{
  "task_id": "358ba94e",
  "model": "gpt-4.1-mini",
  "reasoning_effort": "N/A",
  "api_type": "responses_api_multiturn",
  "program": "def transform(grid):\n    from collections import deque\n    \n    nrows = len(grid)\n    ncols = len(grid[0])\n    grid_array = [list(row) for row in grid]  # copy for safety\n    \n    visited = [[False]*ncols for _ in range(nrows)]\n    \n    directions = [(-1,0),(1,0),(0,-1),(0,1)]\n    \n    def bfs(sr, sc):\n        color = grid_array[sr][sc]\n        queue = deque()\n        queue.append((sr, sc))\n        visited[sr][sc] = True\n        coords = []\n        \n        rmin, rmax = sr, sr\n        cmin, cmax = sc, sc\n        \n        while queue:\n            r,c = queue.popleft()\n            coords.append((r,c))\n            if r < rmin: rmin = r\n            if r > rmax: rmax = r\n            if c < cmin: cmin = c\n            if c > cmax: cmax = c\n            for dr, dc in directions:\n                nr, nc = r+dr, c+dc\n                if 0<=nr<nrows and 0<=nc<ncols and not visited[nr][nc]:\n                    if grid_array[nr][nc]==color:\n                        visited[nr][nc] = True\n                        queue.append((nr,nc))\n        return {\n            \"color\": color,\n            \"coords\": coords,\n            \"rmin\": rmin,\n            \"rmax\": rmax,\n            \"cmin\": cmin,\n            \"cmax\": cmax\n        }\n    \n    blocks = []\n    for r in range(nrows):\n        for c in range(ncols):\n            if grid_array[r][c] != 0 and not visited[r][c]:\n                block = bfs(r,c)\n                blocks.append(block)\n                \n    # Retain only blocks with bounding box at least 5x5 (or bigger)\n    candidate_blocks = []\n    for b in blocks:\n        h = b['rmax'] - b['rmin'] + 1\n        w = b['cmax'] - b['cmin'] + 1\n        if h >= 5 and w >= 5:\n            candidate_blocks.append(b)\n\n    if not candidate_blocks:\n        # Fallback: return 5x5 zeros\n        return [[0]*5 for _ in range(5)]\n    \n    # For each candidate block, calculate number of black pixels inside bounding box\n    def count_black(block):\n        rmin, rmax, cmin, cmax = block['rmin'], block['rmax'], block['cmin'], block['cmax']\n        black_count = 0\n        for rr in range(rmin, rmin+5):\n            for cc in range(cmin, cmin+5):\n                if rr < nrows and cc < ncols:\n                    if grid_array[rr][cc] == 0:\n                        black_count += 1\n        return black_count\n    \n    best_block = None\n    max_black = -1\n    for b in candidate_blocks:\n        black_in_block = count_black(b)\n        if black_in_block > max_black:\n            max_black = black_in_block\n            best_block = b\n        elif black_in_block == max_black:\n            # tie break by top-left coords\n            if b['rmin'] < best_block['rmin'] or (b['rmin'] == best_block['rmin'] and b['cmin'] < best_block['cmin']):\n                best_block = b\n    \n    # Extract 5x5 block from best_block bounding box top-left corner\n    r0, c0 = best_block['rmin'], best_block['cmin']\n    output_block = []\n    for rr in range(r0, r0+5):\n        row = []\n        for cc in range(c0, c0+5):\n            if rr < nrows and cc < ncols:\n                v = grid_array[rr][cc]\n                # Keep color or black 0, replace other colors by block color for uniformity\n                if v == 0:\n                    row.append(0)\n                else:\n                    row.append(best_block['color'])\n            else:\n                # Outside input grid bounds, fill with 0\n                row.append(0)\n        output_block.append(row)\n    \n    return output_block",
  "execution_error": "",
  "timed_out": false,
  "tokens_used": 16541,
  "request_cost": 0.0100484,
  "turns_used": 2,
  "raw_response": {
    "id": "resp_686faaa44c08819d97d0f88c216a86e7078ca6cb5f84be57",
    "model": "gpt-4.1-mini-2025-04-14",
    "usage": {
      "input_tokens": 8172,
      "output_tokens": 1533,
      "total_tokens": 9705
    },
    "output": [
      {
        "type": "message",
        "content": [
          "The biggest issue with the previous attempt was the use of `scipy.ndimage.label` which is not permitted. So I'll avoid external libraries and try a pure Python approach.\n\n---\n\n**Pattern Summary:**\n\n- Inputs have 4 colored 5x5 or 6x6 blocks containing black (0) pixels inside.\n- Outputs are always a **specific 5x5** block extracted from one of those blocks.\n- The output is the 5x5 colored block including the black points inside.\n- The position chosen corresponds to one of the colored blocks, but which one varies.\n- Examining each training output visually:\n  - Example 1 output matches the bottom-right block's 5x5 area from input.\n  - Example 2 output matches the top-left block's 5x5 area.\n  - Example 3 output matches the **middle block** of the top group (from inputs).\n  - Example 4 output matches the top-left block's 5x5 area.\n  \nThe goal: given multiple colored blocks, select **the block with the smallest row and column bounding box coordinate** (top-left most block) in most cases, except Example 1 where it\u2019s bottom right. This can't be perfectly guessed, but looking carefully, Example 1 is the only outlier picking the bottom-right.\n\nA safe heuristic is to:\n\n- Identify the 5x5 colored blocks in the input: a block is a connected region of a single color (non-zero).\n- Find all such blocks and extract their bounding boxes.\n- Crop each to 5x5 (top-left corner) if needed.\n- Return the 5x5 block which contains the **largest number of black pixels inside** (as black pixels inside these blocks define the inner pattern).\n- If multiple blocks are equal, pick the top-left most block.\n  \nThis should reasonably cover all examples except maybe Example 1's odd choice.\n\n---\n\n**Implementation without external libs**\n\n- Use BFS/DFS for connected component labeling of colored pixels.\n- Keep track of bounding boxes and pixels in each color block.\n- For each block, check how many black pixels are inside bounding box.\n- Extract a 5x5 crop from that bounding box (starting from top-left).\n- Return the 5x5 cropped block for the best block.\n\n---\n\nFinal answer:\n\n```python\ndef transform(grid):\n    from collections import deque\n    \n    nrows = len(grid)\n    ncols = len(grid[0])\n    grid_array = [list(row) for row in grid]  # copy for safety\n    \n    visited = [[False]*ncols for _ in range(nrows)]\n    \n    directions = [(-1,0),(1,0),(0,-1),(0,1)]\n    \n    def bfs(sr, sc):\n        color = grid_array[sr][sc]\n        queue = deque()\n        queue.append((sr, sc))\n        visited[sr][sc] = True\n        coords = []\n        \n        rmin, rmax = sr, sr\n        cmin, cmax = sc, sc\n        \n        while queue:\n            r,c = queue.popleft()\n            coords.append((r,c))\n            if r < rmin: rmin = r\n            if r > rmax: rmax = r\n            if c < cmin: cmin = c\n            if c > cmax: cmax = c\n            for dr, dc in directions:\n                nr, nc = r+dr, c+dc\n                if 0<=nr<nrows and 0<=nc<ncols and not visited[nr][nc]:\n                    if grid_array[nr][nc]==color:\n                        visited[nr][nc] = True\n                        queue.append((nr,nc))\n        return {\n            \"color\": color,\n            \"coords\": coords,\n            \"rmin\": rmin,\n            \"rmax\": rmax,\n            \"cmin\": cmin,\n            \"cmax\": cmax\n        }\n    \n    blocks = []\n    for r in range(nrows):\n        for c in range(ncols):\n            if grid_array[r][c] != 0 and not visited[r][c]:\n                block = bfs(r,c)\n                blocks.append(block)\n                \n    # Retain only blocks with bounding box at least 5x5 (or bigger)\n    candidate_blocks = []\n    for b in blocks:\n        h = b['rmax'] - b['rmin'] + 1\n        w = b['cmax'] - b['cmin'] + 1\n        if h >= 5 and w >= 5:\n            candidate_blocks.append(b)\n\n    if not candidate_blocks:\n        # Fallback: return 5x5 zeros\n        return [[0]*5 for _ in range(5)]\n    \n    # For each candidate block, calculate number of black pixels inside bounding box\n    def count_black(block):\n        rmin, rmax, cmin, cmax = block['rmin'], block['rmax'], block['cmin'], block['cmax']\n        black_count = 0\n        for rr in range(rmin, rmin+5):\n            for cc in range(cmin, cmin+5):\n                if rr < nrows and cc < ncols:\n                    if grid_array[rr][cc] == 0:\n                        black_count += 1\n        return black_count\n    \n    best_block = None\n    max_black = -1\n    for b in candidate_blocks:\n        black_in_block = count_black(b)\n        if black_in_block > max_black:\n            max_black = black_in_block\n            best_block = b\n        elif black_in_block == max_black:\n            # tie break by top-left coords\n            if b['rmin'] < best_block['rmin'] or (b['rmin'] == best_block['rmin'] and b['cmin'] < best_block['cmin']):\n                best_block = b\n    \n    # Extract 5x5 block from best_block bounding box top-left corner\n    r0, c0 = best_block['rmin'], best_block['cmin']\n    output_block = []\n    for rr in range(r0, r0+5):\n        row = []\n        for cc in range(c0, c0+5):\n            if rr < nrows and cc < ncols:\n                v = grid_array[rr][cc]\n                # Keep color or black 0, replace other colors by block color for uniformity\n                if v == 0:\n                    row.append(0)\n                else:\n                    row.append(best_block['color'])\n            else:\n                # Outside input grid bounds, fill with 0\n                row.append(0)\n        output_block.append(row)\n    \n    return output_block\n```\nThis code:\n\n- Finds connected colored blocks (without extra libraries).\n- Filters blocks with bounding boxes 5x5 or larger.\n- Selects the block with the most black pixels inside its 5x5 bounding box (since black holes are key).\n- If tie, picks top-left block.\n- Extracts a 5x5 crop from that block with consistent coloring, black pixels preserved.\n\nThis approach will solve most training examples and likely generalize better than previous attempts while avoiding external dependencies.\n\n---\n\nIf needed, the heuristic can adjust to prioritize the \"bottom-right\" block only if the maximum black pixels argument fails, but this is a reasonable best-effort interpretation."
        ]
      }
    ]
  },
  "score": {
    "correct": true,
    "pixel_accuracy": 1.0,
    "total_pixels": 25,
    "correct_pixels": 25,
    "error": null,
    "predicted_output": [
      [
        1,
        1,
        1,
        1,
        1
      ],
      [
        1,
        0,
        1,
        0,
        1
      ],
      [
        1,
        1,
        1,
        1,
        1
      ],
      [
        1,
        0,
        1,
        0,
        1
      ],
      [
        1,
        1,
        1,
        1,
        1
      ]
    ],
    "actual_output": [
      [
        1,
        1,
        1,
        1,
        1
      ],
      [
        1,
        0,
        1,
        0,
        1
      ],
      [
        1,
        1,
        1,
        1,
        1
      ],
      [
        1,
        0,
        1,
        0,
        1
      ],
      [
        1,
        1,
        1,
        1,
        1
      ]
    ]
  },
  "predicted_output": [
    [
      1,
      1,
      1,
      1,
      1
    ],
    [
      1,
      0,
      1,
      0,
      1
    ],
    [
      1,
      1,
      1,
      1,
      1
    ],
    [
      1,
      0,
      1,
      0,
      1
    ],
    [
      1,
      1,
      1,
      1,
      1
    ]
  ],
  "actual_output": [
    [
      1,
      1,
      1,
      1,
      1
    ],
    [
      1,
      0,
      1,
      0,
      1
    ],
    [
      1,
      1,
      1,
      1,
      1
    ],
    [
      1,
      0,
      1,
      0,
      1
    ],
    [
      1,
      1,
      1,
      1,
      1
    ]
  ],
  "api_success": true,
  "multiturn_data": {
    "turn_details": [
      {
        "turn_number": 1,
        "timestamp": "2025-07-10T12:56:59.026476",
        "input_tokens": 5509,
        "output_tokens": 1327,
        "turn_cost": 0.0043268000000000004,
        "program_extracted": true,
        "program": "def transform(grid):\n    import numpy as np\n    grid = np.array(grid)\n    rows, cols = grid.shape\n    \n    # We want to find connected colored blocks:\n    # 1) Find all colored pixels (non-zero)\n    colored_pixels = (grid != 0)\n    \n    # Label connected components of colored pixels using 4-connectivity\n    from scipy.ndimage import label\n    \n    labeled, num = label(colored_pixels)\n    \n    def get_bbox(coords):\n        rmin = coords[:,0].min()\n        rmax = coords[:,0].max()\n        cmin = coords[:,1].min()\n        cmax = coords[:,1].max()\n        return rmin, rmax, cmin, cmax\n    \n    # For each connected component, analyze\n    for component_id in range(1, num+1):\n        coords = np.argwhere(labeled == component_id)\n        if len(coords) < 5*5:\n            # too small to contain 5x5 block\n            continue\n        \n        rmin, rmax, cmin, cmax = get_bbox(coords)\n        height = rmax - rmin + 1\n        width = cmax - cmin + 1\n        \n        # Skip if bounding box smaller than 5x5 (can't extract 5x5 inside)\n        if height < 5 or width < 5:\n            continue\n        \n        # Extract subgrid of bounding box\n        subgrid = grid[rmin:rmax+1, cmin:cmax+1]\n        \n        # The color is the mode of subgrid ignoring zeros\n        colors, counts = np.unique(subgrid[subgrid != 0], return_counts=True)\n        if len(colors) == 0:\n            # no color? skip\n            continue\n        block_color = colors[np.argmax(counts)]\n        \n        # Check for black holes inside (zeros) inside subgrid\n        # Only consider pixels inside the bounding box that are 0 but surrounded by color pixels\n        # Easier: check if subgrid contains zeros other than background outside this block\n        # We want zero pixels inside the bounding box surrounded by the block color.\n        # Let's define holes as zeros entirely surrounded inside subgrid by color pixels.\n        \n        # For each possible 5x5 window inside subgrid, check if it contains black holes inside\n        for r0 in range(height - 5 + 1):\n            for c0 in range(width - 5 + 1):\n                window = subgrid[r0:r0+5, c0:c0+5]\n                # Check if window is mostly block_color or zero, and zero pixels present\n                zero_count = np.sum(window == 0)\n                color_count = np.sum(window == block_color)\n                # We require some zeros inside block and mostly block_color pixels in the window\n                # To separate from mixed or background\n                if zero_count > 0 and color_count >= 10:\n                    # Form output block:\n                    output_block = window.copy()\n                    # Replace all other color values with block_color except zeros remain zero\n                    # Actually, window already is such\n                    return output_block.tolist()\n        \n        # If no 5x5 window inside bounding box satisfies, fallback to top-left 5x5 of bounding box\n        # but only if it contains zeros inside\n        top5x5 = subgrid[0:5,0:5]\n        if np.any(top5x5 == 0):\n            return top5x5.tolist()\n    \n    # If none found, return a 5x5 array of zeros\n    return [[0]*5 for _ in range(5)]",
        "training_feedback": {
          "feedback_messages": [
            {
              "type": "input_text",
              "text": "Training results: 0/4 examples solved, 0.0% pixel accuracy - Keep experimenting! Try a different approach to the transformation.\n\nTraining Example 1 \u2717:\nExpected: [[7, 7, 7, 7, 7], [7, 0, 7, 7, 7], [7, 7, 7, 0, 7], [7, 0, 7, 7, 7], [7, 7, 7, 7, 7]]\nError: Traceback (most recent call last):\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmpy_y9gsxi.py\", line 110, in <module>\n    output = transform(test_input)\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmpy_y9gsxi.py\", line 39, in transform\n    from scipy.ndimage import label\nModuleNotFoundError: No module named 'scipy'\n\n\nTraining Example 2 \u2717:\nExpected: [[8, 8, 8, 8, 8], [8, 0, 8, 0, 8], [8, 8, 8, 8, 8], [8, 0, 8, 0, 8], [8, 8, 8, 8, 8]]\nError: Traceback (most recent call last):\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmpyublrkp5.py\", line 110, in <module>\n    output = transform(test_input)\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmpyublrkp5.py\", line 39, in transform\n    from scipy.ndimage import label\nModuleNotFoundError: No module named 'scipy'\n\n\nTraining Example 3 \u2717:\nExpected: [[6, 6, 6, 6, 6], [6, 0, 6, 0, 6], [6, 6, 6, 6, 6], [6, 0, 6, 6, 6], [6, 6, 6, 6, 6]]\nError: Traceback (most recent call last):\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmphs5439kf.py\", line 110, in <module>\n    output = transform(test_input)\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmphs5439kf.py\", line 39, in transform\n    from scipy.ndimage import label\nModuleNotFoundError: No module named 'scipy'\n\n\nTraining Example 4 \u2717:\nExpected: [[2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 0, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]]\nError: Traceback (most recent call last):\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmpjf09rht3.py\", line 110, in <module>\n    output = transform(test_input)\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmpjf09rht3.py\", line 39, in transform\n    from scipy.ndimage import label\nModuleNotFoundError: No module named 'scipy'\n\n\n"
            },
            {
              "type": "input_image",
              "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAP8AAAKUCAIAAABExnktAAAxLUlEQVR4nO3de1hTZ4LH8TfcQSAItSi3qiBgn3hBFAWjFeEPhKIg6Nh6GRBHpohF4lq1Zey4jxR3cHFq+9R1VaAMdXB0y0VHXfQRUWtRW5mK4oUBqkCRwWiISLjm3ceep3lYIGnQkNv7+zz+gYdzyTl8z+HkJIfwKKUEgEkmun4AADqD+oFdqB/YhfqBXagf2IX6gV2oH9iF+oFdqB/YhfqBXagf2IX6gV2oH9j1SvUnJyfzlFu1atWQ41hYWIwdO3bx4sU3btwYPM+zZ8/yeDxHR8fOzs4B3zp+/DiPxzt06BD337i4OB6Pl5mZOWC0xsZGHo+Xlpb2KlNxOjs7Dxw4EBwc7OLiYmlp6eLismzZskuXLqnYJmlpaco2yK1bt1RvtNDQ0F/dsIpx1q1b13849/BiYmK+/fbb/o8nKipqwGgTJkx4//33nz59OqyNz3n8+PGuXbv8/Pz4fP6oUaMCAgIOHTrU/23C3OIGTP7999+PGTPGzs6urKyMMH7s7+npaWlpOXHiRHBwcF1d3YDvZmdnE0KePn169OhRdea2Y8eOu3fvDvcxqDPVjz/+GBgY+Pvf//7ChQvNzc3d3d3Nzc3Hjx+fP39+VlYW0TPcw/v666+FQuFXX32lYrQff/zxs88+CwsLk8vlw9r433777bRp0/7whz/84x//kEqlHR0d169f/93vfpeQkKDigZ0/fz44OLivr+/cuXPBwcHEaOr//PPP6S+OHTtGCMnJyVEMyc/PV4xZX1+vGN7Z2Xnnzp13331XKpXu37+//wwlEklRUdGyZcscHR3/67/+S53H0N3dHRcX19fXN6xH/qtT9fT0xMbG/uMf/wgKCiopKXn8+HFPT8/Dhw+/+OILR0fHDz74gDuQK1NZWUkHEQgEQ24QhXPnzvWfiTrjNDc3c8NlMtk///nPbdu2UUrXrl374MGD/qPJZLL+Gz80NPTatWtnz55Vf+P/61//io6O/umnn955552KigqpVPrkyZOioqKJEyfm5OQcOHBgyO1QWFgYHh5uY2Nz4cKF2bNnEz2jg2O/paWlr6/vf/zHfxBCBhz7jxw50tnZmZiYGB8fX1FRcfPmzV+d28aNG69evfqf//mfw3oMvzrVl19++f3334eGhl68eDEyMtLJycnMzMzd3f299977+uuv+/r6/vrXvxJ9YmVl5enpmZGRsWPHju7u7j//+c8qNv6mTZu4PUf9jZ+VldXS0pKamnrkyJHZs2fb2dmNHj16yZIl5eXlo0aNysrKGnyb1OHDh5ctW/b6669funRp6tSpiuG5ubk8Hu/zzz8nDNbf1dV1+/ZtkUhECPH29u7/rZycnMmTJy9cuPC9994zNTVV5/D/ySefeHl57dix486dO+o/hl+d6siRIzwe77//+79NTU0HfOutt96qrq7etWsX0UubN2+2sbH53//93yG/29PTc//+/X379pmZmb311lvqb/y//e1v1tbW//7v/z5ghm5ubpcvX75w4QKPx+s//E9/+tO6desmTpx4+fLlSZMmEb2kpfonTJigeOJlZWUlEAiOHTv22muvpaSkKMa5devWd999t2XLFh6P5+npuWzZsq+++qq9vV31nG1sbHJycnp6eoZ1/vOrU1VWVk6ePHnChAlDTj558uQBP+wB/Pz8BjxbvXz5srINonDhwoXhjjOYnZ3dpEmTBvxStba25ia3sLDw8fH55ptvvvzyy/5rp3rj9/T0/PjjjwEBAba2toOXOH369HHjxvUf8sEHH2zdupUQMm/ePA8PjwHjx8XFUUqTk5MJm1c8XV1d165d+8MPP4wdO1YxMDs729XVdeXKldx/t2/f/uzZM3VOMIRC4fvvv3/t2rU9e/ao/xhUTNXT0yORSJydnfsPHHAdZvz48URfOTk5df1M2Qh9fX0VFRU9PT1qbnyJREIpdXJyUvMBfPbZZ4GBgaGhodnZ2V9//TXRV1qqn3sC193dXVBQwB2cdu/e7eLiohihp6cnPz+/qanJ0tKSy2vatGmUUjWf+37yySeTJk36+OOPq6ur1X9UyqYyNze3s7NrbW0lL2vws16hUPirz2gXLFgw3HGG9PTpU3Nzc0tLy8HPeru7u+vq6jZs2PDZZ5/927/9m5ob39HR0cTERP0NEh8ff+HChby8PEdHx9/97ndNTU1EL2n12G9ubv6b3/zm6NGj5eXlYWFh/a8Knzx5csiNe+PGjevXr//qnK2trV/i/EfFVFOmTKmurn748OGQF7j8/f2Jvmpvb79169bkyZOH/K65ufmECRP27NkjEAhyc3PV3PimpqaTJ0/+7rvvOjo6Bo+WkZGxZs2an376STHkiy++sLCw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"
            },
            {
              "type": "input_text",
              "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
            }
          ],
          "solved_count": 0,
          "total_training_examples": 4,
          "pixel_accuracy": 0.0
        },
        "test_result": {
          "execution_error": "Traceback (most recent call last):\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmpitqoqi7f.py\", line 110, in <module>\n    output = transform(test_input)\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmpitqoqi7f.py\", line 39, in transform\n    from scipy.ndimage import label\nModuleNotFoundError: No module named 'scipy'\n",
          "timed_out": false,
          "predicted_output": null
        },
        "status": "failed_test",
        "feedback_sent": true
      },
      {
        "turn_number": 2,
        "timestamp": "2025-07-10T12:57:24.153157",
        "input_tokens": 8172,
        "output_tokens": 1533,
        "turn_cost": 0.0057216,
        "program_extracted": true,
        "program": "def transform(grid):\n    from collections import deque\n    \n    nrows = len(grid)\n    ncols = len(grid[0])\n    grid_array = [list(row) for row in grid]  # copy for safety\n    \n    visited = [[False]*ncols for _ in range(nrows)]\n    \n    directions = [(-1,0),(1,0),(0,-1),(0,1)]\n    \n    def bfs(sr, sc):\n        color = grid_array[sr][sc]\n        queue = deque()\n        queue.append((sr, sc))\n        visited[sr][sc] = True\n        coords = []\n        \n        rmin, rmax = sr, sr\n        cmin, cmax = sc, sc\n        \n        while queue:\n            r,c = queue.popleft()\n            coords.append((r,c))\n            if r < rmin: rmin = r\n            if r > rmax: rmax = r\n            if c < cmin: cmin = c\n            if c > cmax: cmax = c\n            for dr, dc in directions:\n                nr, nc = r+dr, c+dc\n                if 0<=nr<nrows and 0<=nc<ncols and not visited[nr][nc]:\n                    if grid_array[nr][nc]==color:\n                        visited[nr][nc] = True\n                        queue.append((nr,nc))\n        return {\n            \"color\": color,\n            \"coords\": coords,\n            \"rmin\": rmin,\n            \"rmax\": rmax,\n            \"cmin\": cmin,\n            \"cmax\": cmax\n        }\n    \n    blocks = []\n    for r in range(nrows):\n        for c in range(ncols):\n            if grid_array[r][c] != 0 and not visited[r][c]:\n                block = bfs(r,c)\n                blocks.append(block)\n                \n    # Retain only blocks with bounding box at least 5x5 (or bigger)\n    candidate_blocks = []\n    for b in blocks:\n        h = b['rmax'] - b['rmin'] + 1\n        w = b['cmax'] - b['cmin'] + 1\n        if h >= 5 and w >= 5:\n            candidate_blocks.append(b)\n\n    if not candidate_blocks:\n        # Fallback: return 5x5 zeros\n        return [[0]*5 for _ in range(5)]\n    \n    # For each candidate block, calculate number of black pixels inside bounding box\n    def count_black(block):\n        rmin, rmax, cmin, cmax = block['rmin'], block['rmax'], block['cmin'], block['cmax']\n        black_count = 0\n        for rr in range(rmin, rmin+5):\n            for cc in range(cmin, cmin+5):\n                if rr < nrows and cc < ncols:\n                    if grid_array[rr][cc] == 0:\n                        black_count += 1\n        return black_count\n    \n    best_block = None\n    max_black = -1\n    for b in candidate_blocks:\n        black_in_block = count_black(b)\n        if black_in_block > max_black:\n            max_black = black_in_block\n            best_block = b\n        elif black_in_block == max_black:\n            # tie break by top-left coords\n            if b['rmin'] < best_block['rmin'] or (b['rmin'] == best_block['rmin'] and b['cmin'] < best_block['cmin']):\n                best_block = b\n    \n    # Extract 5x5 block from best_block bounding box top-left corner\n    r0, c0 = best_block['rmin'], best_block['cmin']\n    output_block = []\n    for rr in range(r0, r0+5):\n        row = []\n        for cc in range(c0, c0+5):\n            if rr < nrows and cc < ncols:\n                v = grid_array[rr][cc]\n                # Keep color or black 0, replace other colors by block color for uniformity\n                if v == 0:\n                    row.append(0)\n                else:\n                    row.append(best_block['color'])\n            else:\n                # Outside input grid bounds, fill with 0\n                row.append(0)\n        output_block.append(row)\n    \n    return output_block",
        "training_feedback": {
          "feedback_messages": [
            {
              "type": "input_text",
              "text": "Training results: 3/4 examples solved, 99.0% pixel accuracy - Great progress! You're on the right track. Next, try to identify a transformation that solves more than 3 of the training examples.\n\nTraining Example 1 \u2713:\nExpected: [[7, 7, 7, 7, 7], [7, 0, 7, 7, 7], [7, 7, 7, 0, 7], [7, 0, 7, 7, 7], [7, 7, 7, 7, 7]]\nYour output: [[7, 7, 7, 7, 7], [7, 0, 7, 7, 7], [7, 7, 7, 0, 7], [7, 0, 7, 7, 7], [7, 7, 7, 7, 7]]\n\nTraining Example 2 \u2713:\nExpected: [[8, 8, 8, 8, 8], [8, 0, 8, 0, 8], [8, 8, 8, 8, 8], [8, 0, 8, 0, 8], [8, 8, 8, 8, 8]]\nYour output: [[8, 8, 8, 8, 8], [8, 0, 8, 0, 8], [8, 8, 8, 8, 8], [8, 0, 8, 0, 8], [8, 8, 8, 8, 8]]\n\nTraining Example 3 \u2713:\nExpected: [[6, 6, 6, 6, 6], [6, 0, 6, 0, 6], [6, 6, 6, 6, 6], [6, 0, 6, 6, 6], [6, 6, 6, 6, 6]]\nYour output: [[6, 6, 6, 6, 6], [6, 0, 6, 0, 6], [6, 6, 6, 6, 6], [6, 0, 6, 6, 6], [6, 6, 6, 6, 6]]\n\nTraining Example 4 \u2717:\nExpected: [[2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 0, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]]\nYour output: [[2, 2, 2, 2, 2], [2, 2, 2, 0, 2], [2, 0, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]]\nPixel accuracy: 96.0%\n\n"
            },
            {
              "type": "input_image",
              "image_url": "data:image/png;base64,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"
            },
            {
              "type": "input_text",
              "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
            }
          ],
          "solved_count": 3,
          "total_training_examples": 4,
          "pixel_accuracy": 0.99
        },
        "test_result": {
          "correct": true,
          "pixel_accuracy": 1.0,
          "total_pixels": 25,
          "correct_pixels": 25,
          "error": null,
          "predicted_output": [
            [
              1,
              1,
              1,
              1,
              1
            ],
            [
              1,
              0,
              1,
              0,
              1
            ],
            [
              1,
              1,
              1,
              1,
              1
            ],
            [
              1,
              0,
              1,
              0,
              1
            ],
            [
              1,
              1,
              1,
              1,
              1
            ]
          ],
          "actual_output": [
            [
              1,
              1,
              1,
              1,
              1
            ],
            [
              1,
              0,
              1,
              0,
              1
            ],
            [
              1,
              1,
              1,
              1,
              1
            ],
            [
              1,
              0,
              1,
              0,
              1
            ],
            [
              1,
              1,
              1,
              1,
              1
            ]
          ]
        },
        "status": "success"
      }
    ],
    "total_turns": 2,
    "conversation_history": [
      {
        "role": "system",
        "content": "You are an expert at solving abstract reasoning puzzles. Write clean, efficient Python code."
      },
      {
        "role": "user",
        "content": [
          {
            "type": "input_text",
            "text": "You are solving an ARC (Abstraction and Reasoning Corpus) task. \nI will show you training examples with input and output grids, plus a test input grid. Your task is to:\n\n1. **Analyze the training examples** to discover patterns that map input grids to output grids\n2. **Write a Python program** that implements your best understanding of the transformation  \n3. **DO NOT predict or generate the test output** - your job is only to write the transformation program\n4. **Attempt a solution** - even if the pattern isn't completely clear, provide your best hypothesis\n5. **Do not repeat the same transformation** - if you have already tried a transformation, do not repeat it.\n\n**IMPORTANT: Your transformation must always produce a 5\u00d75 output grid.**\n\nThe test input is shown for context so you understand what type of grid your program will eventually process. Focus on learning patterns from training examples and writing code that captures your understanding.\n\nTraining Examples:\n\nExample 1:\nInput:\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 7 7 7 7 7 0 0 0 0 0 0 0 0 0 0 0\n0 0 7 7 7 0 7 0 0 7 7 7 7 7 0 0 0 0\n0 0 7 0 7 7 7 0 0 7 7 7 7 7 0 0 0 0\n0 0 7 7 7 7 7 0 0 7 0 7 7 7 0 0 0 0\n0 0 7 7 7 7 7 0 0 7 7 7 0 7 0 0 0 0\n0 0 0 0 0 0 0 0 0 7 7 7 7 7 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 7 7 7 7 7 0 0 0 0 7 7 7 7 7 0\n0 0 0 7 7 7 0 7 0 0 0 0 7 0 7 7 7 0\n0 0 0 7 0 7 7 7 0 0 0 0 7 7 7 0 7 0\n0 0 0 7 7 7 7 7 0 0 0 0 7 0 7 7 7 0\n0 0 0 7 7 7 7 7 0 0 0 0 7 7 7 7 7 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\nOutput:\n7 7 7 7 7\n7 0 7 7 7\n7 7 7 0 7\n7 0 7 7 7\n7 7 7 7 7\n\nExample 2:\nInput:\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8 8 8\n0 8 8 8 8 8 0 0 0 0 0 0 0 0 8 0 8 8 8\n0 8 0 8 0 8 0 0 8 8 8 8 8 0 8 8 8 0 8\n0 8 8 8 8 8 0 0 8 0 8 0 8 0 8 0 8 8 8\n0 8 0 8 8 8 0 0 8 8 8 8 8 0 8 8 8 8 8\n0 8 8 8 8 8 0 0 8 8 8 0 8 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 8 8 8 8 8 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 8 8 8 8 8 0 0\n0 0 0 8 8 8 8 8 0 0 0 0 8 8 8 0 8 0 0\n0 0 0 8 0 8 0 8 0 0 0 0 8 0 8 8 8 0 0\n0 0 0 8 8 8 8 8 0 0 0 0 8 8 8 0 8 0 0\n0 0 0 8 0 8 0 8 0 0 0 0 8 8 8 8 8 0 0\n0 0 0 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\nOutput:\n8 8 8 8 8\n8 0 8 0 8\n8 8 8 8 8\n8 0 8 0 8\n8 8 8 8 8\n\nExample 3:\nInput:\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 6 6 6 6 6 0 0 0 0 0 0 6 6 6 6 6 0 0\n0 6 6 6 6 6 0 0 0 0 0 0 6 0 6 0 6 0 0\n0 6 0 6 0 6 0 0 0 0 0 0 6 6 6 6 6 0 0\n0 6 6 6 6 6 0 0 0 0 0 0 6 0 6 6 6 0 0\n0 6 6 6 6 6 0 0 0 0 0 0 6 6 6 6 6 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 6 6 6 6 6 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 6 0 6 6 6 0 0 0 0 0 0 0\n0 6 6 6 6 6 0 6 6 6 6 6 0 0 0 0 0 0 0\n0 6 6 0 6 6 0 6 6 6 0 6 0 0 0 0 0 0 0\n0 6 6 6 6 6 0 6 6 6 6 6 0 0 6 6 6 6 6\n0 6 0 6 6 6 0 0 0 0 0 0 0 0 6 6 6 6 6\n0 6 6 6 6 6 0 0 0 0 0 0 0 0 6 0 6 6 6\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 6 6 0 6\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 6 6 6 6\nOutput:\n6 6 6 6 6\n6 0 6 0 6\n6 6 6 6 6\n6 0 6 6 6\n6 6 6 6 6\n\nExample 4:\nInput:\n0 0 0 0 0 0 0 0 2 2 2 2 2 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 2 2 2 0 2 0 0 0 0 0 0\n0 2 2 2 2 2 0 0 2 0 2 2 2 0 0 0 0 0 0\n0 2 0 2 0 2 0 0 2 2 2 2 2 0 0 0 0 0 0\n0 2 2 2 2 2 0 0 2 2 2 2 2 0 2 2 2 2 2\n0 2 2 2 2 2 0 0 0 0 0 0 0 0 2 2 2 0 2\n0 2 2 2 2 2 0 0 0 0 0 0 0 0 2 0 2 2 2\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2 2 2 2\n0 0 2 2 2 2 2 0 0 0 0 0 0 0 2 2 2 2 2\n0 0 2 2 0 2 2 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 2 2 2 2 2 0 0 2 2 2 2 2 0 0 0 0 0\n0 0 2 2 2 0 2 0 0 2 2 2 2 2 0 0 0 0 0\n0 0 2 2 2 2 2 0 0 2 0 2 2 2 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 2 2 2 2 2 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 2 2 2 2 2 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\nOutput:\n2 2 2 2 2\n2 2 2 2 2\n2 0 2 2 2\n2 2 2 2 2\n2 2 2 2 2\n\nTest Input:\n0 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 1 1 1 0 1 0 0 0 1 1 1 1 1 0 0 0 0 0\n0 1 1 1 1 1 0 0 0 1 0 1 0 1 0 0 0 0 0\n0 1 0 1 1 1 0 0 0 1 1 1 1 1 0 0 0 0 0\n0 1 1 1 1 1 0 0 0 1 1 1 1 1 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 1 1 1 1 1 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n1 1 1 1 1 0 0 0 0 0 0 0 0 0 1 1 1 1 1\n1 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 1 1 1\n1 1 1 1 1 0 0 1 1 1 1 1 0 0 1 1 1 0 1\n1 0 1 0 1 0 0 1 1 1 0 1 0 0 1 1 1 1 1\n1 1 1 1 1 0 0 1 0 1 1 1 0 0 1 1 1 1 1\n0 0 0 0 0 0 0 1 1 1 1 1 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 1 1 1 1 1 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\nAnalyze the patterns in the training examples and write a Python function that performs this transformation.\n\n**Approach Guidelines:**\n- Look for patterns in shapes, colors, positions, sizes, rotations, reflections, etc.\n- Even if you can't solve all training examples perfectly, implement what patterns you do observe\n- A partial solution that captures some aspects is better than returning the input unchanged\n- If the pattern is unclear, make your best educated guess based on what you can see\n\nRequirements:\n- The function takes a 2D list (grid) where grid[row][col] gives the value at that position\n- Values are integers from 0-9\n- Return a new grid (2D list) with the transformation applied\n- You can use numpy if needed - just add 'import numpy as np' at the start of your function\n- Aim to handle the training examples as well as possible, even if not perfectly\n- Your function should attempt some meaningful transformation based on the patterns you observe\n\nYou MUST end your response with the following exact format:\n\nFinal answer:\n```python\ndef transform(grid):\n    # Your transformation logic here (implement your best understanding)\n    return transformed_grid\n```\n"
          },
          {
            "type": "input_image",
            "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAkQAAAddCAIAAAAOY9D5AABPkklEQVR4nO3df7xVdZ3o/71180MQUbNJwfTwo1GKQiP8lfkjsGasbK0Js9J7OySpM5FxTaF69OPeyh9AM938ORoJFmWp17Ue08TDO8E8TLt3LFLCFFFwMFEoBZH8hecA6/v4zvne8+WinA57n8M677Ofz7+O++z3Wp+911n7xV5nI9WiKCoAENk+ZS8AABolZgCEJ2YAhCdmAIQnZgCEJ2YAhCdmAIQnZgCEJ2YAhCdmAIQnZgCEJ2YAhCdmADR3zGbMmFHdvfPOO+917zNw4MBDDz30rLPOeuCBB167zZ///OfVavXggw/eunXrLt+64447qtXq/PnzO/6ztbW1Wq3Omzdvl7s99dRT1Wr1y1/+ciNTHbZu3XrjjTeefvrpI0aMGDRo0IgRI84+++x77723vudkypQplUpl06ZNI0aMOOigg5566qldZv/mb/5m4MCBv/nNb7r5hHzsYx+rVqu1Wu3ZZ5997UrGjx9frVZbW1s7/nP69Ok7L2bfffc94IADjj/++O9973udI0mSVKvV1+6omw+tw8aNG2fNmnX00Ufvt99+Bx544EknnXTDDTds3769iycNIN47s/b29j/+8Y8//elPTz/99H//93/f5bs333xzpVLZvHnzT37yk+5s7atf/eqqVav2dA3dmXriiSdOPPHEiy666O67796wYUNbW9uGDRvuuOOOU0455R/+4R8q9XrDG95w8803P//889OmTdv539+57rrrsiy74oor3vWud+3RE7J9+/Y777xzlxt/97vfPfzww10sY8eOHS+88MKvf/3r6dOnz507t9JDnn322UmTJs2bN+/RRx/dunXrli1b/u3f/u3v/u7vzj77bP/YENBHY3bttdcW/8ftt99eqVQWLFjQecuiRYs677l27drO27du3frII4984hOf+NOf/nTDDTfsvMHnn38+z/Ozzz774IMP/sd//MfurKGtra21tXVP/+D/Z6fa29unTp3629/+9qSTTvqnf/qnjRs3tre3P/nkk9dff/3BBx88a9ashx56qIvt7/x4Oy1ZsqTju3/1V3/1mc98ZsmSJddee23HLStWrPj85z//vve97/Of//wePSH77rvvUUcdddttt+1y+49//OO3ve1tr73/hg0bOhazY8eOF1988Uc/+tHgwYMvv/zyV199tcsnrLsP7eqrr37iiSemTp26YsWKl1566fnnn//Xf/3XY489Nsuyn/70p93cBUCAd2aDBg06+uij58yZU6lUdnln9qMf/Wjr1q0XXnjhtGnT7rvvvgcffPDPbu2zn/3sr371q7//+7/fozX82albbrnl/vvvnzJlyj333POhD33oDW94Q61We/Ob3/y3f/u3d9555/bt22+99dZKA+bNm3f00UfPnj370UcfffHFFz/60Y8OHz78+9//frVa3dMn5KMf/egvfvGLZ555Zucbf/KTn5xzzjldLKBarQ4dOvTjH//4xz72sT/96U+PPfZYpSesWrWqVqstWrToHe94x5AhQ4YPH3766ad3vHG86667Ou6zcOHCarXaGXKAkDF79dVXH3744UsuuaRSqfzlX/7lzt9asGDBuHHj3vve9/7t3/7tvvvu2503Z1dcccXYsWO/+tWvPvLII91fw5+d+tGPflStVm+66aZ99913l2+deuqpK1eu/OY3v1lpwH777ffDH/5w27Zt55133kUXXbR69ervf//7b3rTm3a5W3eekI9+9KO7XGn89a9//fjjj3/0ox/tzko63pO99mHWZ8KECdu2bcuybOcbW1paiqK4/vrre2QXAKXFbNSoUZ0fFhg8ePD48eNvv/32Qw455HOf+1znfR566KHf/OY3l112WbVaHTNmzNlnn/3DH/7wxRdf7HrLQ4YMWbBgQXt7+x5dbPyzU8uXLx83btyoUaNed3zcuHG7vIXq4vF2uvvuu3e+zzvf+c7/+l//629+85sf/vCHl1xyyfvf//5dNtLNJ2T8+PFvfetbOy7zdvjxj3/8rne9a8yYMV2scPv27evXr//Od75z2223/cVf/MVRRx3VxZ27/9Bmzpx58sknf/zjHx89evT06dNvuumm1/7qrrW1tSiKGTNmdHOPAH30o/kjR4781Kc+tWLFikMPPbTzxptvvnnkyJHnnntux39+8YtffOGFF7pzNe/kk0+++OKLf/3rX3/rW9/q/hq6mGpvb3/++ed3eZ+0y2f5WlpaKg378Ic/3BHFk08++bXf7f4TsvOVxqIobrvttt1dYzzssMM61l+r1UaOHDlz5szt27dfccUVPfXObP/997/77rsXLVo0YcKEPM8vvPDC8ePHjxo16pZbbumR7QOUGbOOTw20tbX9+Mc/HjZs2Fve8parrrpqxIgRnXdob29ftGjR008/PWjQoI5X2wkTJhRF0c2PgVxxxRVvectbvva1r61cubL7q9rd1IABA4YNG/a6n3dv5FMSp5122s732bp16yc+8Ynhw4cPGzbswgsv3OWXXnv0hJxzzjmdVxrvueee9evX/9lrjPvss8/BBx88efLkPM/PP//8Hnxo++6777nnnptl2caNG1evXr1gwYI3velNra2t3/72t7u/F4C++85swIAB55xzzk9+8pNf/OIXf/VXf7Xz32f653/+59eNxwMPPLBs2bI/u+X99tuvjouNXUy9/e1vX7ly5ZNPPvm6H92cOHFipWEzZ8588MEHr/4PzzzzzKc+9amdv7tHT8jRRx/99re/veMzjT/5yU9OOOGEI4444nV32vlpxu3bt2/atGnJkiUf/vCHK71m7Nixra2tv/zlL4899tgGf8sI0LcuM/71X//1Zz/72QceeODSSy/tvPHmm28ePHjwli1bdv7z/v/+3/+7UqnceOON3dnsu9/97s997nPLli177V+IrmPq3HPP3bFjx9/93d+9bhob/ytTt99++4033viJT3ziP/2n/9Ta2vqRj3zkZz/72c5/UWFPn5Bzzjnnnnvu6fibcF1/jrH3PP3009Vqdfr06bvcXqvV3v72tz///PNtbW2lLAzo98r5ndkVV1xxxBFH3HDDDb/61a8qlcof/vCHu+6660Mf+tABBxyw891OPPHEo4466tZbb92yZUt3Nnv55Ze/5S1v2dNPzb3u1PTp0ydOnPizn/3suOOOu+222/7whz+0t7d3pOIDH/jAAw88sM8+9T91a9eu/fSnPz1q1KjOet14442HHXbY5z//+Y6/yl3HE9JxpXHmzJkbN248++yzK2UYOXLkO9/5zptvvnnGjBn/9m//9sc//nHr1q2PP/749ddff/vttx933HEDBw4sZWFAv1dOzIYOHXrNNdfs2LHjwgsv3LZt2/e///1t27Z1ftJhZ5/85CdffvnlH/zgB92/bNj15wy7OTVw4MA8z0888cQHHnjgnHPOOeywwwYOHNjxv7NavHjxUUcd1fX/oOR1P/JXrVZffPHF9vb2c84556WXXvrhD3/Y2ao3vOENCxcu3Lp167nnntve3l7HEzJ27Nhjjz32tttue8973rPzLyPrsN9+++2y7IULF3bnoXW8oTzwwAOvu+66k0466dBDD91vv/3Gjh37mc98plardf7FMn/PDOg//6Phs846K0mSFStW/Pf//t8XLlx40EEH/fVf//Vr7/af//N/3meffbp5pbHjsuHMmTP3dDGvO3X44Yffe++9ixYtOvPMMw8//PCBAwe+6U1vOvPMM2+55ZaHHnpo0qRJlbp84QtfWLZs2de+9rUTTzxx59vf9773zZgx44EHHvjyl79c3xPScXWxm3+9rJdMmDDh4Ycf/vznPz9+/PgDDjhg4MCBLS0tF1xwwe9+97se+UUjwOuq+j/mARCdfwIGgPDEDIDwxAyA8MQMgPDEDIDwxAyA8MQMgPDEDIDwxAyA8MQMgPDEDIDwxAyA8MQMgPDEDIDwxAyA8MQMgPDEDIDwxAyA8MQMgPDEDIDwxAyA8MQMgPDEDIDwxAyA8MQMgPDEDIDwxAyA8MQMgPDEDIDwxAyA8MQMgPDEDIDwxAyA8MQMgPDEDIDwxAyA8MSMvmLTpk2rVq0qexXQRCfOpn500okZ9UiSpLW1tWe3OWXKlPvuu293333++edHjx7dxR0gunXr1n36058eOXLk4MGDR48efemllz733HMNnjjNc9KJGX3FK6+8srtvrVu3bsqUKWvXrt27K4K957HHHps4ceLmzZsXL1783HPP3XnnnY888sjEiRM3bNhQ94nTVCedmNGQjRs3VqvV6667rqWlZfDgwe9///uffvrpztu/973vHX744cOHDz///PM7TpunnnqqWq0+8cQTHePf+ta3TjjhhEqlctpppz366KPTpk2bPn36Lrv42c9+Nn78+IkTJ5bx+GAvmT59+qmnnnrHHXdMmDBhyJAhxxxzzE9/+tNDDz304osv7uaJs7G5TzoxowfccsstS5cuXbVq1fr167/+9a933j537ty77rpr+fLl999//4wZM7rYwt13333UUUctWLBg/vz5u3xr0KBBS5Ysue6663pt+VCy3//+9/fee+8u58g+++wzc+bMPM83b97c/RNnbrOedGJGD/jKV74yZsyYlpaW1tbWZcuWdd4+Z86c8ePHjx49et68eYsWLXrppZfq2PiUKVMmTZrUo+uFvmXlypWVSmXcuHG73D5hwoRt27atWbOm+5ua06wnnZjRA1paWjq+GDp0aHt7e+ftHVczKpXKMccc09bW9vjj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+eWXi6JYt25dpVJZu3Ztx3bmzZt3/PHHF0Vx6qmndvxAnn/++Tvv6H/9r/9Vq9VeffXVjv/8p3/6pyFDhuzYsaOMBw2lec973jN16tSdb9m+ffsJJ5zQceO6bpxW/f6U9M6MHnDLLbcsXbp01apV69ev//rXv955+9y5c++6667ly5fff//9M2bM6GILd99991FHHbVgwYL58+fvfPtJJ53U3t4+cODAjv/csGHDwQcfXK1We+2hQJ/z+9///t57793lDNpnn31mzpyZ5/nmzZu7f1r141NSzOgBX/nKV8aMGdPS0tLa2rps2bLO2+fMmTN+/PjRo0fPmzdv0aJFL730UiN72bJly1VXXXX++ef3xJIhjJUrV1YqlXHjxu1y+4QJE7Zt27ZmzZrub6ofn5JiRg9oaWnp+GLo0KHt7e2dt59wwgkdXxxzzDFtbW2PP/543bt46aWXPvShD40fP/7LX/5yw+uFSDre92zfvn2X21999dU93dQJ/feUFDN6wIABAzq/Loritbd3nIe1Wm2XyxGvPT9f16ZNmyZPnnz44YffcccdtVqt5xYOAXS8J+t4f7azVatW1Wq1sWPHdv+06senpJjRix588MGOL5YvX77//vuPGTOm41J758WNJ598svPOu7vs/tRTT5188smnnHLKD3/4w84r9dA8jjzyyMmTJ1911VU737hjx465c+eeddZZBx10UPdPq358SooZvWjWrFlr165dvXr17NmzL7jggkGDBh1yyCGjRo268cYbX3755SVLltx6662ddx46dOj69etfeOGFnbfw/PPPv/e97z3rrLPmzp3bF37JDKW46aabHn744fPOO++xxx5rb29fuXLl1KlTn3nmmWuuuaZSqXT/tOrPp2TZH6ekP3w0/5FHHum4/YYbbnjb297WefsXvvCFI4888qCDDrrkkkva2to67rN06dJx48YNGjTolFNO6fwccFEU3/3ud/fff/+PfOQjO+/oyiuvfO0P7QsvvLDXHzGUbMOGDZ/5zGeOOOKIQYMGtbS0zJw5c+PGjZ3fXfrnTqt+f0pWd/4Nx55K07TuWfq3tra2xYsXT548ediwYWWvhf4jy7JKNH3kdbItwinZyPFt9Bd3eZ7XN5gkidl+PHvmmWdWKpWlS5fu5f0GnZ0wr85zeMVlaVPNBtUXnueXN29cvPiNR8+69pDR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qR199atf/dCHPnT00Ud38/47dux44YUXfv0fNm3aNGvWrJ5aCQB95Z3ZtddeW/wft99+e6VSWbBgQectixYt6rzn2rVri9dYsmRJx3evvvrqJ554YurUqStWrHjppZeef/75f/3Xfz322GOzLPvpT3+6RzvqWltbW2tra+cbvt3ZsGFDx5Z37Njx4osv/uhHPxo8ePDll1/+6quv9vgzA0A/+Z3ZqlWrarXaokWL3vGOdwwZMmT48OGnn376nXfeWalU7rrrrh7c0Wc/+9lf/epXf//3f9/N+1er1aFDh3784x//2Mc+9qc//emxxx7rwcUsXLiwWq1ee+21PbhNgObUJ2I2YcKEbdu2ZVm2840tLS1FUVx//fU9uKMrrrhi7NixX/3qVx955JE9Gux4T7bvvvv24GIACBazUaNGvfZzEHfffXfHd2fOnHnyySd//OMfHz169PTp02+66aaHH364N5YxZMiQBQsWtLe3d+diY6VS2b59+/r167/zne/cdtttf/EXf3HUUUf14GJaW1uLopgxY0YPbhOgOfWJd2b777//3XffvWjRogkTJuR5fuGFF44fP37UqFG33HJLj+/r5JNPvvjii3/9619/61vf2t19DjvssI7c1mq1kSNHzpw5c/v27VdccYV3ZgBNHbPX/QDIaaed1nmHfffd99xzz82ybOPGjatXr16wYMGb3vSm1tbWb3/72z2+mCuuuOItb3nL1772tZUrV3Z9z3322efggw+ePHlynufnn39+x4212v/7EdD29vZd7txxS8d3AWi6d2a7GDt2bGtr6y9/+ctjjz32m9/8Zo9vf7/99uv6YmPnpxm3b9++adOmJUuWfPjDH+787vDhwyuVyjPPPLPL1B/+8IfO7wLQXDF7+umnq9Xq9OnTd7m9Vqu9/e1vf/7559va2np8p+9+97s/97nPLVu27LV/jfrPGjVq1Ot+zLLjltGjR/fcMgHolvKviY0cOfKd73znzTffPHjw4HPPPXf06NHDhw9/+umn/+f//J+33377cccdN3DgwN7Y7+WXX/7P//zPdXxa8owzzhgwYMDcuXOHDx9+7rnnvvGNb/zjH//44x//+JprrhkyZMh73/ve3lgtAH3004zVavXFF1+sVCo333zzgQceeN1115100kmHHnrofvvtN3bs2M985jO1Wq33/hpWx8XGOv73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"
          },
          {
            "type": "input_text",
            "text": "Above is a visual representation of all the training examples and the test input. Each grid cell is colored according to its value (0-9), with clear labels and arrows showing input\u2192output transformations. Use both the textual and visual information to understand the pattern."
          }
        ]
      },
      {
        "type": "message",
        "role": "assistant",
        "content": [
          "Analysis:\n\n- Each training input has a large grid with multiple (mostly 4) identifiable colored squares, each a 5\u00d75 or 6\u00d76 block.\n- Within these colored blocks, there are several \"black\" (0) smaller squares arranged in a pattern.\n- The output is always a 5\u00d75 grid extracted from the input:\n  - It appears to be one 5\u00d75 colored block taken from the input.\n  - The block contains the color (not black=0) and the relative arrangement of black squares inside that colored block.\n- Which block is extracted differs:\n  - Example 1: block at bottom right (orange 7)\n  - Example 2: block at center bottom with some black squares\n  - Example 3: block at bottom center-left with a specific pattern\n  - Example 4: only one block is extracted, which contains the single black square closest to origin in that cluster? Actually, it seems just the first block (top-left) is extracted.\n- The extracted output block retains the color of the original block (7,8,6,2) and the pattern of 0s inside it.\n- The output block matches exactly one of the input 5\u00d75 blocks, preserving both color and pattern but cropped/scaled to 5\u00d75 if needed.\n\nHypothesis / Strategy for transformation:\n\n- Identify the largest connected colored components (nonzero color).\n- Among these components, select one 5\u00d75 block that contains black squares (zeros) inside.\n- Extract that block and produce it as the 5\u00d75 output grid.\n- The color of the block is uniform (except the black holes).\n- Since the training outputs differ in which block is selected, and no clear absolute rule emerges, a practical approach is to:\n  - Extract all connected components of the dominant color.\n  - Among connected blocks of size at least 5\u00d75, find one that contains black pixels inside.\n  - Extract the top-left 5\u00d75 area of that block as output.\n- Another observation is that in outputs there are black squares inside the colored block, often in a recognizable pattern.\n\nImplementation plan:\n\n1. Identify distinct color blocks (non-zero colors).\n2. For each color block:\n   - find bounding boxes of connected components.\n3. For each bounding box of size >=5x5:\n   - check if inside contains black pixels (0 values)\n   - if yes, extract 5x5 block from that bounding box.\n4. Return the first such block found.\n5. If none found, return a 5x5 block of zeros.\n\nThis keeps to the training pattern that output is a 5\u00d75 colored block containing the black holes within it.\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n    grid = np.array(grid)\n    rows, cols = grid.shape\n    \n    # We want to find connected colored blocks:\n    # 1) Find all colored pixels (non-zero)\n    colored_pixels = (grid != 0)\n    \n    # Label connected components of colored pixels using 4-connectivity\n    from scipy.ndimage import label\n    \n    labeled, num = label(colored_pixels)\n    \n    def get_bbox(coords):\n        rmin = coords[:,0].min()\n        rmax = coords[:,0].max()\n        cmin = coords[:,1].min()\n        cmax = coords[:,1].max()\n        return rmin, rmax, cmin, cmax\n    \n    # For each connected component, analyze\n    for component_id in range(1, num+1):\n        coords = np.argwhere(labeled == component_id)\n        if len(coords) < 5*5:\n            # too small to contain 5x5 block\n            continue\n        \n        rmin, rmax, cmin, cmax = get_bbox(coords)\n        height = rmax - rmin + 1\n        width = cmax - cmin + 1\n        \n        # Skip if bounding box smaller than 5x5 (can't extract 5x5 inside)\n        if height < 5 or width < 5:\n            continue\n        \n        # Extract subgrid of bounding box\n        subgrid = grid[rmin:rmax+1, cmin:cmax+1]\n        \n        # The color is the mode of subgrid ignoring zeros\n        colors, counts = np.unique(subgrid[subgrid != 0], return_counts=True)\n        if len(colors) == 0:\n            # no color? skip\n            continue\n        block_color = colors[np.argmax(counts)]\n        \n        # Check for black holes inside (zeros) inside subgrid\n        # Only consider pixels inside the bounding box that are 0 but surrounded by color pixels\n        # Easier: check if subgrid contains zeros other than background outside this block\n        # We want zero pixels inside the bounding box surrounded by the block color.\n        # Let's define holes as zeros entirely surrounded inside subgrid by color pixels.\n        \n        # For each possible 5x5 window inside subgrid, check if it contains black holes inside\n        for r0 in range(height - 5 + 1):\n            for c0 in range(width - 5 + 1):\n                window = subgrid[r0:r0+5, c0:c0+5]\n                # Check if window is mostly block_color or zero, and zero pixels present\n                zero_count = np.sum(window == 0)\n                color_count = np.sum(window == block_color)\n                # We require some zeros inside block and mostly block_color pixels in the window\n                # To separate from mixed or background\n                if zero_count > 0 and color_count >= 10:\n                    # Form output block:\n                    output_block = window.copy()\n                    # Replace all other color values with block_color except zeros remain zero\n                    # Actually, window already is such\n                    return output_block.tolist()\n        \n        # If no 5x5 window inside bounding box satisfies, fallback to top-left 5x5 of bounding box\n        # but only if it contains zeros inside\n        top5x5 = subgrid[0:5,0:5]\n        if np.any(top5x5 == 0):\n            return top5x5.tolist()\n    \n    # If none found, return a 5x5 array of zeros\n    return [[0]*5 for _ in range(5)]\n```\n"
        ]
      },
      {
        "role": "user",
        "content": [
          {
            "type": "input_text",
            "text": "Please analyze the training feedback and programs from all prior turns, and write an improved transformation.\n\n**Important**:\n1. Always start by attempting to find a complete rule that solves all training examples and should generalize to the test input.\n2. If you cannot find a perfect solution, provide your best attempt at a transformation that solves as many training examples as possible - ideally more than in the best previous turn.\n3. Even if your solution doesn't solve all examples perfectly, ensure it demonstrates meaningful pattern recognition and provides reasonable outputs that minimize pixel-level errors.\n\nFinal answer:\n```python\ndef transform(grid):\n    # Your improved transformation logic here (even if partial)\n    return transformed_grid\n```"
          },
          {
            "type": "input_text",
            "text": "Training results: 0/4 examples solved, 0.0% pixel accuracy - Keep experimenting! Try a different approach to the transformation.\n\nTraining Example 1 \u2717:\nExpected: [[7, 7, 7, 7, 7], [7, 0, 7, 7, 7], [7, 7, 7, 0, 7], [7, 0, 7, 7, 7], [7, 7, 7, 7, 7]]\nError: Traceback (most recent call last):\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmpy_y9gsxi.py\", line 110, in <module>\n    output = transform(test_input)\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmpy_y9gsxi.py\", line 39, in transform\n    from scipy.ndimage import label\nModuleNotFoundError: No module named 'scipy'\n\n\nTraining Example 2 \u2717:\nExpected: [[8, 8, 8, 8, 8], [8, 0, 8, 0, 8], [8, 8, 8, 8, 8], [8, 0, 8, 0, 8], [8, 8, 8, 8, 8]]\nError: Traceback (most recent call last):\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmpyublrkp5.py\", line 110, in <module>\n    output = transform(test_input)\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmpyublrkp5.py\", line 39, in transform\n    from scipy.ndimage import label\nModuleNotFoundError: No module named 'scipy'\n\n\nTraining Example 3 \u2717:\nExpected: [[6, 6, 6, 6, 6], [6, 0, 6, 0, 6], [6, 6, 6, 6, 6], [6, 0, 6, 6, 6], [6, 6, 6, 6, 6]]\nError: Traceback (most recent call last):\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmphs5439kf.py\", line 110, in <module>\n    output = transform(test_input)\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmphs5439kf.py\", line 39, in transform\n    from scipy.ndimage import label\nModuleNotFoundError: No module named 'scipy'\n\n\nTraining Example 4 \u2717:\nExpected: [[2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 0, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]]\nError: Traceback (most recent call last):\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmpjf09rht3.py\", line 110, in <module>\n    output = transform(test_input)\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmpjf09rht3.py\", line 39, in transform\n    from scipy.ndimage import label\nModuleNotFoundError: No module named 'scipy'\n\n\n"
          },
          {
            "type": "input_image",
            "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAP8AAAKUCAIAAABExnktAAAxLUlEQVR4nO3de1hTZ4LH8TfcQSAItSi3qiBgn3hBFAWjFeEPhKIg6Nh6GRBHpohF4lq1Zey4jxR3cHFq+9R1VaAMdXB0y0VHXfQRUWtRW5mK4oUBqkCRwWiISLjm3ceep3lYIGnQkNv7+zz+gYdzyTl8z+HkJIfwKKUEgEkmun4AADqD+oFdqB/YhfqBXagf2IX6gV2oH9iF+oFdqB/YhfqBXagf2IX6gV2oH9j1SvUnJyfzlFu1atWQ41hYWIwdO3bx4sU3btwYPM+zZ8/yeDxHR8fOzs4B3zp+/DiPxzt06BD337i4OB6Pl5mZOWC0xsZGHo+Xlpb2KlNxOjs7Dxw4EBwc7OLiYmlp6eLismzZskuXLqnYJmlpaco2yK1bt1RvtNDQ0F/dsIpx1q1b13849/BiYmK+/fbb/o8nKipqwGgTJkx4//33nz59OqyNz3n8+PGuXbv8/Pz4fP6oUaMCAgIOHTrU/23C3OIGTP7999+PGTPGzs6urKyMMH7s7+npaWlpOXHiRHBwcF1d3YDvZmdnE0KePn169OhRdea2Y8eOu3fvDvcxqDPVjz/+GBgY+Pvf//7ChQvNzc3d3d3Nzc3Hjx+fP39+VlYW0TPcw/v666+FQuFXX32lYrQff/zxs88+CwsLk8vlw9r433777bRp0/7whz/84x//kEqlHR0d169f/93vfpeQkKDigZ0/fz44OLivr+/cuXPBwcHEaOr//PPP6S+OHTtGCMnJyVEMyc/PV4xZX1+vGN7Z2Xnnzp13331XKpXu37+//wwlEklRUdGyZcscHR3/67/+S53H0N3dHRcX19fXN6xH/qtT9fT0xMbG/uMf/wgKCiopKXn8+HFPT8/Dhw+/+OILR0fHDz74gDuQK1NZWUkHEQgEQ24QhXPnzvWfiTrjNDc3c8NlMtk///nPbdu2UUrXrl374MGD/qPJZLL+Gz80NPTatWtnz55Vf+P/61//io6O/umnn955552KigqpVPrkyZOioqKJEyfm5OQcOHBgyO1QWFgYHh5uY2Nz4cKF2bNnEz2jg2O/paWlr6/vf/zHfxBCBhz7jxw50tnZmZiYGB8fX1FRcfPmzV+d28aNG69evfqf//mfw3oMvzrVl19++f3334eGhl68eDEyMtLJycnMzMzd3f299977+uuv+/r6/vrXvxJ9YmVl5enpmZGRsWPHju7u7j//+c8qNv6mTZu4PUf9jZ+VldXS0pKamnrkyJHZs2fb2dmNHj16yZIl5eXlo0aNysrKGnyb1OHDh5ctW/b6669funRp6tSpiuG5ubk8Hu/zzz8nDNbf1dV1+/ZtkUhECPH29u7/rZycnMmTJy9cuPC9994zNTVV5/D/ySefeHl57dix486dO+o/hl+d6siRIzwe77//+79NTU0HfOutt96qrq7etWsX0UubN2+2sbH53//93yG/29PTc//+/X379pmZmb311lvqb/y//e1v1tbW//7v/z5ghm5ubpcvX75w4QKPx+s//E9/+tO6desmTpx4+fLlSZMmEb2kpfonTJigeOJlZWUlEAiOHTv22muvpaSkKMa5devWd999t2XLFh6P5+npuWzZsq+++qq9vV31nG1sbHJycnp6eoZ1/vOrU1VWVk6ePHnChAlDTj558uQBP+wB/Pz8BjxbvXz5srINonDhwoXhjjOYnZ3dpEmTBvxStba25ia3sLDw8fH55ptvvvzyy/5rp3rj9/T0/PjjjwEBAba2toOXOH369HHjxvUf8sEHH2zdupUQMm/ePA8PjwHjx8XFUUqTk5MJm1c8XV1d165d+8MPP4wdO1YxMDs729XVdeXKldx/t2/f/uzZM3VOMIRC4fvvv3/t2rU9e/ao/xhUTNXT0yORSJydnfsPHHAdZvz48URfOTk5df1M2Qh9fX0VFRU9PT1qbnyJREIpdXJyUvMBfPbZZ4GBgaGhodnZ2V9//TXRV1qqn3sC193dXVBQwB2cdu/e7eLiohihp6cnPz+/qanJ0tKSy2vatGmUUjWf+37yySeTJk36+OOPq6ur1X9UyqYyNze3s7NrbW0lL2vws16hUPirz2gXLFgw3HGG9PTpU3Nzc0tLy8HPeru7u+vq6jZs2PDZZ5/927/9m5ob39HR0cTERP0NEh8ff+HChby8PEdHx9/97ndNTU1EL2n12G9ubv6b3/zm6NGj5eXlYWFh/a8Knzx5csiNe+PGjevXr//qnK2trV/i/EfFVFOmTKmurn748OGQF7j8/f2Jvmpvb79169bkyZOH/K65ufmECRP27NkjEAhyc3PV3PimpqaTJ0/+7rvvOjo6Bo+WkZGxZs2an376STHkiy++sLCw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"
          },
          {
            "type": "input_text",
            "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
          }
        ]
      }
    ],
    "all_responses": [
      {
        "id": "resp_686faa8b3470819d9a0f15a7280ce3e8078ca6cb5f84be57",
        "model": "gpt-4.1-mini-2025-04-14",
        "usage": {
          "input_tokens": 5509,
          "output_tokens": 1327,
          "total_tokens": 6836
        },
        "output": [
          {
            "type": "message",
            "content": [
              "Analysis:\n\n- Each training input has a large grid with multiple (mostly 4) identifiable colored squares, each a 5\u00d75 or 6\u00d76 block.\n- Within these colored blocks, there are several \"black\" (0) smaller squares arranged in a pattern.\n- The output is always a 5\u00d75 grid extracted from the input:\n  - It appears to be one 5\u00d75 colored block taken from the input.\n  - The block contains the color (not black=0) and the relative arrangement of black squares inside that colored block.\n- Which block is extracted differs:\n  - Example 1: block at bottom right (orange 7)\n  - Example 2: block at center bottom with some black squares\n  - Example 3: block at bottom center-left with a specific pattern\n  - Example 4: only one block is extracted, which contains the single black square closest to origin in that cluster? Actually, it seems just the first block (top-left) is extracted.\n- The extracted output block retains the color of the original block (7,8,6,2) and the pattern of 0s inside it.\n- The output block matches exactly one of the input 5\u00d75 blocks, preserving both color and pattern but cropped/scaled to 5\u00d75 if needed.\n\nHypothesis / Strategy for transformation:\n\n- Identify the largest connected colored components (nonzero color).\n- Among these components, select one 5\u00d75 block that contains black squares (zeros) inside.\n- Extract that block and produce it as the 5\u00d75 output grid.\n- The color of the block is uniform (except the black holes).\n- Since the training outputs differ in which block is selected, and no clear absolute rule emerges, a practical approach is to:\n  - Extract all connected components of the dominant color.\n  - Among connected blocks of size at least 5\u00d75, find one that contains black pixels inside.\n  - Extract the top-left 5\u00d75 area of that block as output.\n- Another observation is that in outputs there are black squares inside the colored block, often in a recognizable pattern.\n\nImplementation plan:\n\n1. Identify distinct color blocks (non-zero colors).\n2. For each color block:\n   - find bounding boxes of connected components.\n3. For each bounding box of size >=5x5:\n   - check if inside contains black pixels (0 values)\n   - if yes, extract 5x5 block from that bounding box.\n4. Return the first such block found.\n5. If none found, return a 5x5 block of zeros.\n\nThis keeps to the training pattern that output is a 5\u00d75 colored block containing the black holes within it.\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n    grid = np.array(grid)\n    rows, cols = grid.shape\n    \n    # We want to find connected colored blocks:\n    # 1) Find all colored pixels (non-zero)\n    colored_pixels = (grid != 0)\n    \n    # Label connected components of colored pixels using 4-connectivity\n    from scipy.ndimage import label\n    \n    labeled, num = label(colored_pixels)\n    \n    def get_bbox(coords):\n        rmin = coords[:,0].min()\n        rmax = coords[:,0].max()\n        cmin = coords[:,1].min()\n        cmax = coords[:,1].max()\n        return rmin, rmax, cmin, cmax\n    \n    # For each connected component, analyze\n    for component_id in range(1, num+1):\n        coords = np.argwhere(labeled == component_id)\n        if len(coords) < 5*5:\n            # too small to contain 5x5 block\n            continue\n        \n        rmin, rmax, cmin, cmax = get_bbox(coords)\n        height = rmax - rmin + 1\n        width = cmax - cmin + 1\n        \n        # Skip if bounding box smaller than 5x5 (can't extract 5x5 inside)\n        if height < 5 or width < 5:\n            continue\n        \n        # Extract subgrid of bounding box\n        subgrid = grid[rmin:rmax+1, cmin:cmax+1]\n        \n        # The color is the mode of subgrid ignoring zeros\n        colors, counts = np.unique(subgrid[subgrid != 0], return_counts=True)\n        if len(colors) == 0:\n            # no color? skip\n            continue\n        block_color = colors[np.argmax(counts)]\n        \n        # Check for black holes inside (zeros) inside subgrid\n        # Only consider pixels inside the bounding box that are 0 but surrounded by color pixels\n        # Easier: check if subgrid contains zeros other than background outside this block\n        # We want zero pixels inside the bounding box surrounded by the block color.\n        # Let's define holes as zeros entirely surrounded inside subgrid by color pixels.\n        \n        # For each possible 5x5 window inside subgrid, check if it contains black holes inside\n        for r0 in range(height - 5 + 1):\n            for c0 in range(width - 5 + 1):\n                window = subgrid[r0:r0+5, c0:c0+5]\n                # Check if window is mostly block_color or zero, and zero pixels present\n                zero_count = np.sum(window == 0)\n                color_count = np.sum(window == block_color)\n                # We require some zeros inside block and mostly block_color pixels in the window\n                # To separate from mixed or background\n                if zero_count > 0 and color_count >= 10:\n                    # Form output block:\n                    output_block = window.copy()\n                    # Replace all other color values with block_color except zeros remain zero\n                    # Actually, window already is such\n                    return output_block.tolist()\n        \n        # If no 5x5 window inside bounding box satisfies, fallback to top-left 5x5 of bounding box\n        # but only if it contains zeros inside\n        top5x5 = subgrid[0:5,0:5]\n        if np.any(top5x5 == 0):\n            return top5x5.tolist()\n    \n    # If none found, return a 5x5 array of zeros\n    return [[0]*5 for _ in range(5)]\n```\n"
            ]
          }
        ]
      },
      {
        "id": "resp_686faaa44c08819d97d0f88c216a86e7078ca6cb5f84be57",
        "model": "gpt-4.1-mini-2025-04-14",
        "usage": {
          "input_tokens": 8172,
          "output_tokens": 1533,
          "total_tokens": 9705
        },
        "output": [
          {
            "type": "message",
            "content": [
              "The biggest issue with the previous attempt was the use of `scipy.ndimage.label` which is not permitted. So I'll avoid external libraries and try a pure Python approach.\n\n---\n\n**Pattern Summary:**\n\n- Inputs have 4 colored 5x5 or 6x6 blocks containing black (0) pixels inside.\n- Outputs are always a **specific 5x5** block extracted from one of those blocks.\n- The output is the 5x5 colored block including the black points inside.\n- The position chosen corresponds to one of the colored blocks, but which one varies.\n- Examining each training output visually:\n  - Example 1 output matches the bottom-right block's 5x5 area from input.\n  - Example 2 output matches the top-left block's 5x5 area.\n  - Example 3 output matches the **middle block** of the top group (from inputs).\n  - Example 4 output matches the top-left block's 5x5 area.\n  \nThe goal: given multiple colored blocks, select **the block with the smallest row and column bounding box coordinate** (top-left most block) in most cases, except Example 1 where it\u2019s bottom right. This can't be perfectly guessed, but looking carefully, Example 1 is the only outlier picking the bottom-right.\n\nA safe heuristic is to:\n\n- Identify the 5x5 colored blocks in the input: a block is a connected region of a single color (non-zero).\n- Find all such blocks and extract their bounding boxes.\n- Crop each to 5x5 (top-left corner) if needed.\n- Return the 5x5 block which contains the **largest number of black pixels inside** (as black pixels inside these blocks define the inner pattern).\n- If multiple blocks are equal, pick the top-left most block.\n  \nThis should reasonably cover all examples except maybe Example 1's odd choice.\n\n---\n\n**Implementation without external libs**\n\n- Use BFS/DFS for connected component labeling of colored pixels.\n- Keep track of bounding boxes and pixels in each color block.\n- For each block, check how many black pixels are inside bounding box.\n- Extract a 5x5 crop from that bounding box (starting from top-left).\n- Return the 5x5 cropped block for the best block.\n\n---\n\nFinal answer:\n\n```python\ndef transform(grid):\n    from collections import deque\n    \n    nrows = len(grid)\n    ncols = len(grid[0])\n    grid_array = [list(row) for row in grid]  # copy for safety\n    \n    visited = [[False]*ncols for _ in range(nrows)]\n    \n    directions = [(-1,0),(1,0),(0,-1),(0,1)]\n    \n    def bfs(sr, sc):\n        color = grid_array[sr][sc]\n        queue = deque()\n        queue.append((sr, sc))\n        visited[sr][sc] = True\n        coords = []\n        \n        rmin, rmax = sr, sr\n        cmin, cmax = sc, sc\n        \n        while queue:\n            r,c = queue.popleft()\n            coords.append((r,c))\n            if r < rmin: rmin = r\n            if r > rmax: rmax = r\n            if c < cmin: cmin = c\n            if c > cmax: cmax = c\n            for dr, dc in directions:\n                nr, nc = r+dr, c+dc\n                if 0<=nr<nrows and 0<=nc<ncols and not visited[nr][nc]:\n                    if grid_array[nr][nc]==color:\n                        visited[nr][nc] = True\n                        queue.append((nr,nc))\n        return {\n            \"color\": color,\n            \"coords\": coords,\n            \"rmin\": rmin,\n            \"rmax\": rmax,\n            \"cmin\": cmin,\n            \"cmax\": cmax\n        }\n    \n    blocks = []\n    for r in range(nrows):\n        for c in range(ncols):\n            if grid_array[r][c] != 0 and not visited[r][c]:\n                block = bfs(r,c)\n                blocks.append(block)\n                \n    # Retain only blocks with bounding box at least 5x5 (or bigger)\n    candidate_blocks = []\n    for b in blocks:\n        h = b['rmax'] - b['rmin'] + 1\n        w = b['cmax'] - b['cmin'] + 1\n        if h >= 5 and w >= 5:\n            candidate_blocks.append(b)\n\n    if not candidate_blocks:\n        # Fallback: return 5x5 zeros\n        return [[0]*5 for _ in range(5)]\n    \n    # For each candidate block, calculate number of black pixels inside bounding box\n    def count_black(block):\n        rmin, rmax, cmin, cmax = block['rmin'], block['rmax'], block['cmin'], block['cmax']\n        black_count = 0\n        for rr in range(rmin, rmin+5):\n            for cc in range(cmin, cmin+5):\n                if rr < nrows and cc < ncols:\n                    if grid_array[rr][cc] == 0:\n                        black_count += 1\n        return black_count\n    \n    best_block = None\n    max_black = -1\n    for b in candidate_blocks:\n        black_in_block = count_black(b)\n        if black_in_block > max_black:\n            max_black = black_in_block\n            best_block = b\n        elif black_in_block == max_black:\n            # tie break by top-left coords\n            if b['rmin'] < best_block['rmin'] or (b['rmin'] == best_block['rmin'] and b['cmin'] < best_block['cmin']):\n                best_block = b\n    \n    # Extract 5x5 block from best_block bounding box top-left corner\n    r0, c0 = best_block['rmin'], best_block['cmin']\n    output_block = []\n    for rr in range(r0, r0+5):\n        row = []\n        for cc in range(c0, c0+5):\n            if rr < nrows and cc < ncols:\n                v = grid_array[rr][cc]\n                # Keep color or black 0, replace other colors by block color for uniformity\n                if v == 0:\n                    row.append(0)\n                else:\n                    row.append(best_block['color'])\n            else:\n                # Outside input grid bounds, fill with 0\n                row.append(0)\n        output_block.append(row)\n    \n    return output_block\n```\nThis code:\n\n- Finds connected colored blocks (without extra libraries).\n- Filters blocks with bounding boxes 5x5 or larger.\n- Selects the block with the most black pixels inside its 5x5 bounding box (since black holes are key).\n- If tie, picks top-left block.\n- Extracts a 5x5 crop from that block with consistent coloring, black pixels preserved.\n\nThis approach will solve most training examples and likely generalize better than previous attempts while avoiding external dependencies.\n\n---\n\nIf needed, the heuristic can adjust to prioritize the \"bottom-right\" block only if the maximum black pixels argument fails, but this is a reasonable best-effort interpretation."
            ]
          }
        ]
      }
    ]
  }
}