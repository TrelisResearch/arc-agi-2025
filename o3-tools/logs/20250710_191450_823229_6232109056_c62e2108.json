{
  "task_id": "c62e2108",
  "model": "gpt-4.1",
  "reasoning_effort": "N/A",
  "api_type": "responses_api_multiturn",
  "program": "import numpy as np\n\ndef is_hollow_ring(grid, x, y, color):\n    \"\"\"Check if there is a 3x3 hollow square of color anchored at (x, y)\"\"\"\n    # Check bounds\n    h, w = grid.shape\n    if x+2 >= h or y+2 >= w:\n        return False\n    # Ring outline\n    expected = np.array([\n        [color, color, color],\n        [color,   0,   color],\n        [color, color, color],\n    ])\n    block = grid[x:x+3, y:y+3]\n    return np.array_equal(block, expected)\n\ndef find_ring_centers(grid, color):\n    \"\"\"Return list of (x, y) center coordinates of all 3x3 hollow rings of color\"\"\"\n    h, w = grid.shape\n    centers = []\n    for x in range(h-2):\n        for y in range(w-2):\n            if is_hollow_ring(grid, x, y, color):\n                # Center is +1,+1 from topleft\n                centers.append( (x+1, y+1) )\n    return centers\n\ndef mark_row(grid, row, color, block_centers):\n    \"\"\"Fill row with color except through block_centers (if needed)\"\"\"\n    h, w = grid.shape\n    for y in range(w):\n        grid[row, y] = color\n\ndef mark_col(grid, col, color, block_centers):\n    \"\"\"Fill column with color except through block_centers (if needed)\"\"\"\n    h, w = grid.shape\n    for x in range(h):\n        grid[x, col] = color\n\ndef find_bars(grid, color):\n    \"\"\"Find edge bars: returns a list of (orientation, idx, start, end)\"\"\"\n    h, w = grid.shape\n    bars = []\n    # Top edge\n    for y in range(w-2):\n        if np.all(grid[0, y:y+3] == color):\n            bars.append(('horizontal', 0, y, y+2))\n    # Bottom edge\n    for y in range(w-2):\n        if np.all(grid[h-1, y:y+3] == color):\n            bars.append(('horizontal', h-1, y, y+2))\n    # Left edge\n    for x in range(h-2):\n        if np.all(grid[x:x+3, 0] == color):\n            bars.append(('vertical', 0, x, x+2))\n    # Right edge\n    for x in range(h-2):\n        if np.all(grid[x:x+3, w-1] == color):\n            bars.append(('vertical', w-1, x, x+2))\n    return bars\n\ndef transform(grid):\n    import numpy as np\n    grid = np.array(grid)\n    h, w = grid.shape\n    \n    # Always output 18x17\n    out_h, out_w = 18, 17\n    out = np.zeros((out_h, out_w), dtype=\"int\")\n    \n    # If input is not the right shape, crop or pad\n    crop_h = min(h, out_h)\n    crop_w = min(w, out_w)\n    grid = grid[:crop_h, :crop_w]\n    # Pad output for further painting\n    out[:crop_h, :crop_w] = 0\n\n    # Detect color(s) in grid\n    colors = set(np.unique(grid)) - {0}\n    for color in colors:\n        # 1. Find ring centers\n        centers = find_ring_centers(grid, color)\n        # 2. For each center, paint vertical and horizontal\n        for x, y in centers:\n            # Horizontal\n            out[x, :] = np.where(out[x, :]==0, color, out[x, :])\n            # Vertical\n            out[:, y] = np.where(out[:, y]==0, color, out[:, y])\n        # 3. Find and paint edge bars into the grid\n        bars = find_bars(grid, color)\n        for bar in bars:\n            orient, i, start, end = bar\n            if orient == 'horizontal':\n                # row is i, columns start:end+1, fill inward (down) until hitting border or another color\n                row = i\n                for y in range(start, end+1):\n                    # Extend downwards until hitting something painted or border\n                    for x in range(row, out_h):\n                        if out[x, y]!=0:\n                            break\n                        out[x, y]=color\n            else: # vertical\n                # col is i, rows start:end+1, fill rightward (across columns) until hitting border or another color\n                col = i\n                for x in range(start, end+1):\n                    for y in range(col, out_w):\n                        if out[x, y]!=0:\n                            break\n                        out[x, y]=color\n\n    # Ensure shape\n    transformed_grid = out.tolist()\n    return transformed_grid",
  "execution_error": "Max turns reached",
  "timed_out": false,
  "tokens_used": 9634,
  "request_cost": 0.029216,
  "turns_used": 1,
  "raw_response": {
    "id": "resp_687002f64c90819c92896acb4f532a590a934c6a12264a72",
    "model": "gpt-4.1-2025-04-14",
    "usage": {
      "input_tokens": 7976,
      "output_tokens": 1658,
      "total_tokens": 9634
    },
    "output": [
      {
        "type": "message",
        "content": [
          "From the visual training examples, we can make several key observations:\n\n- Each input grid shows:\n  - Colored \"rings\" (2x2, 3x3 donuty blocks with a hollow center) of a color (red, blue, green, yellow) not present in the background (0).\n  - 3-block long bars of the same color(s) on the grid edges.\n- In the output grid:\n  - Each \"ring\" is extended: a horizontal or vertical colored bar emerges from each edge of the ring, and if it reaches another edge of the grid, the bar continues to the border and changes direction at the border (L/T/corner).\n  - Every colored bar in the input is transformed into a colored bar on the output.\n  - All output has the same color (from the ring and bars) as the input for each instance.\n  - All processed shapes are on a blank (0) background, the output grid size stays the same as the input grid size.\n\n## Hypothesis\nFor each color:\n1. Find all the 3x3 hollow squares (\"rings\").\n2. For each ring, extend \"arms\" horizontally and vertically in all four directions from the ring until blocked by a grid edge or another ring/bar, filling with that color.\n3. For colored bars on the edges, extend them inward to cross the grid as far as possible.\n\nBut, crucially, in the output each \"ring\" is replaced with an L-corner or T-structure, depending on their placement.\n\n#### More simply, it looks like:\n- Each \"ring\" gets replaced by a T or L shape that forms a continuous colored path along the rows/columns intersecting the centers of the rings and reaching the grid bounds, respecting the bars.\n\nLet's focus on following the majority principle:\n- For each nonzero color:\n    - Identify the centers of all 3x3 hollow colored rings.\n    - For every row and column involving a center, fill that row and/or column (for that color) as far as possible until blocked by another same-color object or an edge.\n    - Any bar present on the edge of the input also \"launches\" a bar row/column into the grid, connecting to a ring if there is one.\n\n## Implementation Plan\n- Find all unique nonzero colors.\n- For each color:\n    - Find all 3x3 hollow rings; get their centers.\n    - For each center, fill (paint) horizontally and vertically, from the edge of the ring to the nearest grid edge or another same-color \"obstacle\".\n    - For colored bars on the grid border, extend into the grid, as far as possible until hitting something.\n- All other cells: 0.\n\n## Additional Notes\n- **ALWAYS produce an 18x17 output grid.** (`height = 18, width = 17`) You may need to crop or pad input accordingly.\n\nFinal answer:\n```python\nimport numpy as np\n\ndef is_hollow_ring(grid, x, y, color):\n    \"\"\"Check if there is a 3x3 hollow square of color anchored at (x, y)\"\"\"\n    # Check bounds\n    h, w = grid.shape\n    if x+2 >= h or y+2 >= w:\n        return False\n    # Ring outline\n    expected = np.array([\n        [color, color, color],\n        [color,   0,   color],\n        [color, color, color],\n    ])\n    block = grid[x:x+3, y:y+3]\n    return np.array_equal(block, expected)\n\ndef find_ring_centers(grid, color):\n    \"\"\"Return list of (x, y) center coordinates of all 3x3 hollow rings of color\"\"\"\n    h, w = grid.shape\n    centers = []\n    for x in range(h-2):\n        for y in range(w-2):\n            if is_hollow_ring(grid, x, y, color):\n                # Center is +1,+1 from topleft\n                centers.append( (x+1, y+1) )\n    return centers\n\ndef mark_row(grid, row, color, block_centers):\n    \"\"\"Fill row with color except through block_centers (if needed)\"\"\"\n    h, w = grid.shape\n    for y in range(w):\n        grid[row, y] = color\n\ndef mark_col(grid, col, color, block_centers):\n    \"\"\"Fill column with color except through block_centers (if needed)\"\"\"\n    h, w = grid.shape\n    for x in range(h):\n        grid[x, col] = color\n\ndef find_bars(grid, color):\n    \"\"\"Find edge bars: returns a list of (orientation, idx, start, end)\"\"\"\n    h, w = grid.shape\n    bars = []\n    # Top edge\n    for y in range(w-2):\n        if np.all(grid[0, y:y+3] == color):\n            bars.append(('horizontal', 0, y, y+2))\n    # Bottom edge\n    for y in range(w-2):\n        if np.all(grid[h-1, y:y+3] == color):\n            bars.append(('horizontal', h-1, y, y+2))\n    # Left edge\n    for x in range(h-2):\n        if np.all(grid[x:x+3, 0] == color):\n            bars.append(('vertical', 0, x, x+2))\n    # Right edge\n    for x in range(h-2):\n        if np.all(grid[x:x+3, w-1] == color):\n            bars.append(('vertical', w-1, x, x+2))\n    return bars\n\ndef transform(grid):\n    import numpy as np\n    grid = np.array(grid)\n    h, w = grid.shape\n    \n    # Always output 18x17\n    out_h, out_w = 18, 17\n    out = np.zeros((out_h, out_w), dtype=\"int\")\n    \n    # If input is not the right shape, crop or pad\n    crop_h = min(h, out_h)\n    crop_w = min(w, out_w)\n    grid = grid[:crop_h, :crop_w]\n    # Pad output for further painting\n    out[:crop_h, :crop_w] = 0\n\n    # Detect color(s) in grid\n    colors = set(np.unique(grid)) - {0}\n    for color in colors:\n        # 1. Find ring centers\n        centers = find_ring_centers(grid, color)\n        # 2. For each center, paint vertical and horizontal\n        for x, y in centers:\n            # Horizontal\n            out[x, :] = np.where(out[x, :]==0, color, out[x, :])\n            # Vertical\n            out[:, y] = np.where(out[:, y]==0, color, out[:, y])\n        # 3. Find and paint edge bars into the grid\n        bars = find_bars(grid, color)\n        for bar in bars:\n            orient, i, start, end = bar\n            if orient == 'horizontal':\n                # row is i, columns start:end+1, fill inward (down) until hitting border or another color\n                row = i\n                for y in range(start, end+1):\n                    # Extend downwards until hitting something painted or border\n                    for x in range(row, out_h):\n                        if out[x, y]!=0:\n                            break\n                        out[x, y]=color\n            else: # vertical\n                # col is i, rows start:end+1, fill rightward (across columns) until hitting border or another color\n                col = i\n                for x in range(start, end+1):\n                    for y in range(col, out_w):\n                        if out[x, y]!=0:\n                            break\n                        out[x, y]=color\n\n    # Ensure shape\n    transformed_grid = out.tolist()\n    return transformed_grid\n```"
        ]
      }
    ]
  },
  "score": {
    "correct": false,
    "pixel_accuracy": 0.0,
    "total_pixels": 576,
    "correct_pixels": 0,
    "error": "Max turns reached"
  },
  "actual_output": [
    [
      0,
      0,
      0,
      0,
      0,
      0,
      4,
      0,
      0,
      4,
      0,
      0,
      0,
      4,
      4,
      4,
      4,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      4,
      4,
      4,
      4,
      0,
      0,
      0,
      4,
      0,
      0,
      4,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      4,
      4,
      4,
      4,
      0,
      0,
      0,
      4,
      0,
      0,
      4,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      4,
      0,
      0,
      4,
      0,
      0,
      0,
      4,
      4,
      4,
      4,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      4,
      0,
      0,
      4,
      0,
      0,
      0,
      4,
      4,
      4,
      4,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      4,
      4,
      4,
      4,
      0,
      0,
      0,
      4,
      0,
      0,
      4,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      0,
      0,
      0,
      4,
      0,
      0,
      4,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      4,
      4,
      0,
      0,
      4,
      4,
      0,
      0,
      4,
      0,
      0,
      0,
      4,
      4,
      4,
      4,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      4,
      4,
      0,
      0,
      4,
      4,
      0,
      0,
      4,
      0,
      0,
      0,
      4,
      4,
      4,
      4,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      0,
      0,
      0,
      4,
      0,
      0,
      4,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      4,
      4,
      4,
      4,
      0,
      0,
      0,
      4,
      0,
      0,
      4,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      4,
      0,
      0,
      4,
      0,
      0,
      0,
      4,
      4,
      4,
      4,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      4,
      0,
      0,
      4,
      0,
      0,
      0,
      4,
      4,
      4,
      4,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      4,
      4,
      4,
      4,
      0,
      0,
      0,
      4,
      0,
      0,
      4,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      4,
      4,
      4,
      4,
      0,
      0,
      0,
      4,
      0,
      0,
      4,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      4,
      0,
      0,
      4,
      0,
      0,
      0,
      4,
      4,
      4,
      4,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      4,
      0,
      0,
      4,
      0,
      0,
      0,
      4,
      4,
      4,
      4,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      4,
      4,
      4,
      4,
      0,
      0,
      0,
      4,
      0,
      0,
      4,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      4,
      4,
      4,
      4,
      0,
      0,
      0,
      4,
      0,
      0,
      4,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      4,
      0,
      0,
      4,
      0,
      0,
      0,
      4,
      4,
      4,
      4,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      4,
      0,
      0,
      4,
      0,
      0,
      0,
      4,
      4,
      4,
      4,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      4,
      4,
      4,
      4,
      0,
      0,
      0,
      4,
      0,
      0,
      4,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      4,
      4,
      4,
      4,
      0,
      0,
      0,
      4,
      0,
      0,
      4,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      4,
      0,
      0,
      4,
      0,
      0,
      0,
      4,
      4,
      4,
      4,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]
  ],
  "api_success": true,
  "multiturn_data": {
    "turn_details": [
      {
        "turn_number": 1,
        "timestamp": "2025-07-10T19:14:14.173381",
        "input_tokens": 7976,
        "output_tokens": 1658,
        "turn_cost": 0.029216,
        "program_extracted": true,
        "program": "import numpy as np\n\ndef is_hollow_ring(grid, x, y, color):\n    \"\"\"Check if there is a 3x3 hollow square of color anchored at (x, y)\"\"\"\n    # Check bounds\n    h, w = grid.shape\n    if x+2 >= h or y+2 >= w:\n        return False\n    # Ring outline\n    expected = np.array([\n        [color, color, color],\n        [color,   0,   color],\n        [color, color, color],\n    ])\n    block = grid[x:x+3, y:y+3]\n    return np.array_equal(block, expected)\n\ndef find_ring_centers(grid, color):\n    \"\"\"Return list of (x, y) center coordinates of all 3x3 hollow rings of color\"\"\"\n    h, w = grid.shape\n    centers = []\n    for x in range(h-2):\n        for y in range(w-2):\n            if is_hollow_ring(grid, x, y, color):\n                # Center is +1,+1 from topleft\n                centers.append( (x+1, y+1) )\n    return centers\n\ndef mark_row(grid, row, color, block_centers):\n    \"\"\"Fill row with color except through block_centers (if needed)\"\"\"\n    h, w = grid.shape\n    for y in range(w):\n        grid[row, y] = color\n\ndef mark_col(grid, col, color, block_centers):\n    \"\"\"Fill column with color except through block_centers (if needed)\"\"\"\n    h, w = grid.shape\n    for x in range(h):\n        grid[x, col] = color\n\ndef find_bars(grid, color):\n    \"\"\"Find edge bars: returns a list of (orientation, idx, start, end)\"\"\"\n    h, w = grid.shape\n    bars = []\n    # Top edge\n    for y in range(w-2):\n        if np.all(grid[0, y:y+3] == color):\n            bars.append(('horizontal', 0, y, y+2))\n    # Bottom edge\n    for y in range(w-2):\n        if np.all(grid[h-1, y:y+3] == color):\n            bars.append(('horizontal', h-1, y, y+2))\n    # Left edge\n    for x in range(h-2):\n        if np.all(grid[x:x+3, 0] == color):\n            bars.append(('vertical', 0, x, x+2))\n    # Right edge\n    for x in range(h-2):\n        if np.all(grid[x:x+3, w-1] == color):\n            bars.append(('vertical', w-1, x, x+2))\n    return bars\n\ndef transform(grid):\n    import numpy as np\n    grid = np.array(grid)\n    h, w = grid.shape\n    \n    # Always output 18x17\n    out_h, out_w = 18, 17\n    out = np.zeros((out_h, out_w), dtype=\"int\")\n    \n    # If input is not the right shape, crop or pad\n    crop_h = min(h, out_h)\n    crop_w = min(w, out_w)\n    grid = grid[:crop_h, :crop_w]\n    # Pad output for further painting\n    out[:crop_h, :crop_w] = 0\n\n    # Detect color(s) in grid\n    colors = set(np.unique(grid)) - {0}\n    for color in colors:\n        # 1. Find ring centers\n        centers = find_ring_centers(grid, color)\n        # 2. For each center, paint vertical and horizontal\n        for x, y in centers:\n            # Horizontal\n            out[x, :] = np.where(out[x, :]==0, color, out[x, :])\n            # Vertical\n            out[:, y] = np.where(out[:, y]==0, color, out[:, y])\n        # 3. Find and paint edge bars into the grid\n        bars = find_bars(grid, color)\n        for bar in bars:\n            orient, i, start, end = bar\n            if orient == 'horizontal':\n                # row is i, columns start:end+1, fill inward (down) until hitting border or another color\n                row = i\n                for y in range(start, end+1):\n                    # Extend downwards until hitting something painted or border\n                    for x in range(row, out_h):\n                        if out[x, y]!=0:\n                            break\n                        out[x, y]=color\n            else: # vertical\n                # col is i, rows start:end+1, fill rightward (across columns) until hitting border or another color\n                col = i\n                for x in range(start, end+1):\n                    for y in range(col, out_w):\n                        if out[x, y]!=0:\n                            break\n                        out[x, y]=color\n\n    # Ensure shape\n    transformed_grid = out.tolist()\n    return transformed_grid",
        "training_feedback": {
          "feedback_messages": [
            {
              "type": "input_text",
              "text": "Training results: 0/3 examples solved, 48.7% pixel accuracy - Good partial progress! Your approach is capturing some patterns. Next, try to identify a transformation that solves at least one of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [0, 0, 2, 0, 0, 2, 2, 0, 0, 2, 2, 0, 0, 2, 2, 0, 0], [0, 0, 2, 0, 0, 2, 2, 0, 0, 2, 2, 0, 0, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 73.2%\n\nTraining Example 2 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 0, 0, 8, 8, 0, 0, 8, 8, 0, 0, 8, 8, 0, 0, 8, 8, 0, 0], [8, 0, 0, 8, 8, 0, 0, 8, 8, 0, 0, 8, 8, 0, 0, 8, 8, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 8, 8, 8, 8, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0]]\nPixel accuracy: 42.6%\n\nTraining Example 3 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 0, 0, 3, 3, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 0, 0, 3, 3, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 3, 0, 0, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 3, 0, 0, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 38.4%\n\n\u26a0\ufe0f  GRID SIZE ERROR: One or more of your output grids are incorrect in size. They should ALL be 18\u00d717 for this task.\n\n"
            },
            {
              "type": "input_image",
              "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA5MAAAWlCAIAAAAcfhFUAABVoklEQVR4nO3de5RU5Z3o/V3YNKIgKBqjAonYEc1iRGO8Rh1UzooKaFWAOBpjZLzE5OAFBNFZRE8cjCCOmWiM8UTBC3HixKQKNWiIM4q5SGKU8a7hZoKAiaKNINiA7HfFWqcXLwhCNbDrV/X5LP5oq+vX++ld9MPXYleRS9M0AQCAqtcu6wUAAMBmUa4AAMSgXAEAiEG5AgAQg3IFACAG5QoAQAzKFQCAGJQrAAAxKFcAAGJQrgAAxKBcAQCIQbkCABCDcgUAoA7Kdfjw4bmNO+ussz7yPo2NjZ/85CdPPfXUZ555ZsOv+atf/SqXy+22227vv//+ep+6//77c7nc7bffXv7Pc845J5fLTZw4cb27vf7667lcbuzYsW2ZKnv//fdvu+22448/fu+99+7QocPee+89dOjQX//615s4J2PHjt3YCXnhhRc2fdL69+//sSe29T7nnXfeureXlzd48OAnn3xy3fXk8/n17rbvvvtefPHF77zzzhad/LK33npr3LhxhxxySJcuXXbeeefDDz/89ttvT9N0vcOtN/7000/vsccenTt3fuyxxzZx6gAAqu4519WrV//1r3998MEHjz/++Hnz5q332UmTJiVJ8s4779x3332b89WuuuqqV155ZUvXsDlTr7322lFHHXXhhRc+/vjjixcvXrVq1eLFi++///7jjjvuxhtvTKpMeXk///nPjznmmB//+MebuNtrr7128803n3TSSWvXrt2ik//kk0/27dv3W9/61v/8z/+8++67K1aseOqpp84///xzzz13Ewv77//+7+OPP/6DDz549NFHjz/++DZ8iwBAvWtTuX7/+99P/5+f/vSnSZJMnjy59ZYpU6a03nP+/Pmtt7///vsvv/zymWee+e677956663rfsHm5uZSqTR06NDddtvthz/84easYdWqVeecc84HH3ywRSv/2KnVq1cPGTLkf/7nf44++ugHHnjgrbfeWr169V/+8pcf/OAHu+222+WXX15+AnVjZs2alW6gT58+H3lCWj366KPrfpHNuc/ixYvLt69cuXLOnDlXXHFFmqb//M///Oc//3ndu61cuXLdk9+/f/8//OEPv/rVrzb/5P/tb38rFAqLFi0644wzZs6c+e6777799tulUqlXr16TJ0++7bbbPvI8FIvFU045Zaeddnr88cePOOKITZwxAIBqfM61Q4cOBxxwwIQJE5IkWe8513vvvff999//+te/PmzYsJkzZz733HMf+9Uuuuii3//+9//2b/+2RWv42Km77rrr6aef7t+//xNPPDFo0KBu3bo1NDT06NHjG9/4xs9//vMPPvjgP/7jP5JqsuOOO+63337XXXfdVVddtWrVqn//93/fxMm/9NJLy9W7+Sf/xhtv/Otf/zpixIh77733iCOO6Ny586677nraaafNmDFj5513vvHGG9e9ZqDsjjvuGDp06Cc+8Ylf//rXBx10UOvtd955Zy6X+/73v79VTwAAUPsyKNeWlpYXX3xx5MiRSZLsv//+635q8uTJBx544AknnPCNb3xjhx122JynXb/zne80NTVdddVVL7/88uav4WOn7r333lwu93//7//dYYcd1vvUP/7jP7700kvjxo1LqtJll1220047/fKXv/zIz65evfpPf/rTTTfd1NDQ8I//+I+bf/L/8z//s2PHjtdcc816X7B79+6/+c1vHn/88Vwut+7t119//XnnnderV6/f/OY3n/nMZ7be9wcA1K/tVK777rtv64uEdtxxxz59+vz0pz/dfffdL7nkktb7vPDCC3/84x9Hjx6dy+X222+/oUOH/vjHP16+fPmmv/JOO+00efLk1atXb9E1Ax87NWvWrAMPPHDffff9yPEDDzxwvVBbzyGHHLLeK6t+85vfbOyEtHr88ce39D4b6ty582c+85n1nszu2LFjebyxsbF3796//e1v77rrrnW/u02f/NWrV7/22muHH354p06dNjziwQcfvNdee617y+WXXz5mzJgkSY499tiePXuud/9zzjknTdPhw4dv+hsBAKiKd8XaZ599/vmf//nZZ5/95Cc/2XrjpEmT9tlnn6985Svl/7zyyiuXLVu2OX8pf8wxx1x88cV/+MMfbrjhhs1fwyamVq9e3dzcvOeee65743qv9//0pz+dVKtu3bq1fGhjd/jggw9mzpy5evXqzTz5zc3NaZp269ZtMxdw8803H3XUUf379580adLPf/7ztn03AADbt1zLLzZatWrVT37yk/KTguPHj997771b77B69eopU6YsXLiwQ4cO5TTs27dvmqab+Tqt73znO5/5zGeuvvrql156afNXtbGp9u3bd+7c+c0330wqteErtI455piPffVVv379tvQ+H+mdd95p3759hw4dNnyF1qpVq+bNm/e///f/vvnmm0eNGrWZJ3+33XZr167d5p+QYcOGPf7443ffffduu+12/vnnL1y4cDMHAQCq5TnX9u3bn3766ffdd9+MGTNOOumkdd/186GHHvrIMHrmmWeeeuqpj/3KHTt2rOCagU1M/cM//MNLL730l7/85SPfSOHQQw9NqtXy5ctfeOGFAw888CM/2759+3333feGG27o06fPnXfeuZknf4cddjjwwAP/+Mc/rlixYsO7XXfddWefffaiRYtab/nBD37Q2Ni41157ff/733/77bfPPvvsDd+BCwAgwNUCJ5988kUXXfTMM8+0PudX/tvqHXfccenSpes+v/i73/0uSZKNvePSer7whS9ccsklTz311Ib/ykAFU1/5ylfWrl37zW9+8yM7eMPX0VeP7373u6tXrz7ppJM2fbd27dotX758zZo1m3ny8/n8ypUr/8//+T/rfZ3XXnvt+uuvf+ihhz7yWoIzzjhjyJAh//3f/71FF3IAAFTRda7f+c53evbseeutt/7+979PkuSNN9545JFHBg0atMsuu6x7t6OOOqp3797/8R//sXTp0s35stdee+1nPvOZH/zgB1u0mI+cOu+88w499NBf/OIXhx9++H/+53++8cYbq1evLv9LBAMGDHjmmWfatauufzi3paXl1VdfHTt27Le//e2ddtppY69/StP09ddfHz169HPPPXfIIYc0NDRs5skfMWJEt27dJk6cePbZZ//xj39cuXLlX//613vvvbdfv37Nzc2jR49e9+KEdd1666177rnn2LFjn3766W3zrQMA9SKb/Np5551vvvnmtWvXfv3rX1+zZs3dd9+9Zs2a1pcHretrX/vaihUr7rnnns3/2/9Nv+p/M6caGxtLpdJRRx31zDPPnH766XvttVdjY2P5X3+dNm1a7969N/Of+NqYj3zfgFwut+57KWzOffbaa6/Wd2w44IADrr322vI/ddujR4/1vsfy3dq1a9ejR48bbrihXbt25Tf22syT361bt/vuu69z58733HPPYYcdttNOO33yk5/8yle+8uc//7lQKFx++eUb+0533333H/3oR6tXrz7zzDPfe+897+cKAFQssycOTz311Hw+/+yzz/77v//7nXfeueuuu5588skb3u3ss89u167dZl4wUP7b//Lb7G+Rj5zq3r37r3/96ylTppxyyindu3dvbGzcc889TznllLvuuuuFF1447LDDkmrSvn37Hj16/NM//dNvf/vbM844Y2N322GHHT7xiU8MGDDgV7/6VfmKgs0/+SeeeOKsWbMuvvjiAw44oFOnTh07djziiCNuv/32n/3sZxu+6+26Bg0adM455/zpT39a903QAAC2VK6aL9kEAIBW1XWxJgAAbIxyBQAgBuUKAEAMyhUAgBiUKwAAMShXAABiUK4AAMSgXAEAiEG5AgAQg3IFACAG5QoAQAzKFQCAGJQrAAAxKFcAAGJQrgAAxKBcAQCIQbkCABCDcgUAIAblCgBADMoVAIAYlCsAADEoVwAAYlCuAADEoFwBAIhBuQIAEINyBQAgBuUKAEAMyhUAgBiUKwAAMShXAABiUK4AAMSgXAEAiEG5AgAQg3IFACAG5QoAQAzKFQCAGJQrNWvJkiWvvPJK1qsA6ohtB7Y15cr20L1799wGpkyZsk0P2r9//5kzZ27+/W+44YYjjzxyY59tbm7u1avXFn1BICu7775761bT2Nh44IEH3nTTTRV/tdbNobm5OZfLbaJNbTuwrSlXtpPvfve76f/fWWedtU2PuHLlyq31pRYsWNC/f//58+dvrS8IbGu33npreat57733Jk6cOGrUqHvuuaeNX7Nr165pmh5wwAEbu4NtB7Y15UqW7rjjjg4dOixYsCBJkjfffHOXXXaZPHnyW2+9lcvl7rjjju7du3fp0uXcc89t/cNg8eLFQ4YM6dSpU48ePUaOHNl6+8KFCwuFQufOnffYY49vfvObLS0t/fr1e/XVV4cNG3beeedtYvDFF1889thjO3bsePTRR2/sT4hf/OIXffr0OfTQQ7fXWQG2pvbt2w8cOPDEE08sFotvvPFGLpe78soru3Tpcs4552zp5rDuc662HciEciVL55577jHHHDN+/PgkSa699trPf/7zw4YNK3/q+uuvf+SRR2bNmvX0008PHz68fOPgwYM7d+782muvzZgx46mnnhoxYkSSJB988MHJJ5/c2Ng4d+7cJ5988vnnn7/66qsff/zx3r17T548+fbbb9/Y4Pvvv3/KKaf07dt30aJFV1555eTJkz9ykR06dHj00UdvueWW7XhigK1szZo1nTp1Kn/8yiuvvP7669dcc03Fm4NtBzKz3l/gwrawzz77rPcbb4cddih/avbs2V27dr3xxhu7dOkye/bsNE3ffPPNJEmKxWL5DtOnT29sbFy+fPmMGTN22mmnlpaW8u1PPfVUu3btVq5cOWPGjMbGxiVLlqx30PIfIWmabmywVCp16dJlxYoV5dsvuOCCI444YmPfwurVq5MkefLJJ7fB6QG2sm7durVeLdDc3Dx58uR27do99NBDixcvTpJk2rRp5U9t6ebwzjvvJEny8ssv23YgK55zJZvrXNesWVO+vampafTo0SNHjrzsssuamppa79/6qoWDDz541apVc+fOfemll1asWNGhQ4fyqy4OO+ywtWvXzps378UXX+zevftuu+22sUNvbPCll17ab7/9OnbsWL7bIYccso3PAbD9fOMb3yj/yO+555433HDDLbfcMmDAgPKnevbs2cbNwbYDWVGuZO+FF15IkuSZZ55Z98b27duXP/jggw+SJGloaFizZk1TU9N6/+/12c9+tn379rlcbhNff2OD692t9YhADWh9zvX9999/4YUXLrzwwtZPdejQoY2bg20HsqJcydjDDz983333TZw4cerUqaVSqfX25557rvzBrFmzOnXqtN9++x1wwAHz589//fXX1/sK+++//4IFC8p/i7eu1j9XNjbYp0+f2bNnv/fee+X/fP7557f2NwdUtYo3B9sOZEW5kqXly5dfeOGFF1988ahRo84///zhw4cvW7as/KnLL798/vz5s2fPHjNmzAUXXNChQ4cTTjjhoIMOGjZs2IIFCxYuXHjppZf27NmzpaXl2GOP7dOnz0UXXfTWW2+99tprgwcPPuOMM5Ik2XnnnRctWrRs2bKNDX7xi1/ca6+9LrnkkrfffvvRRx+dNGlS1ucD2K4q3hxsO5AV5cp2MmLEiPX+JYILL7zwX/7lX9q1azdu3LgkSSZOnNiuXbt/+Zd/Kd+/f//+xx9//BFHHPG//tf/Kr/5QLt27Uql0s4773zggQd+9rOfffXVV6dPn16+jOxnP/vZ22+/3aNHj89//vO77LLLbbfdliTJhRdeeN111w0bNmxjg42NjQ8//PBrr722zz77jBgx4vzzz8/6JAHbVcWbg20HspJL0zSpLYVCIesl0CarVq2aNm3aiSee2Llz56zXQiTFYjGT49pzoD5ltefUu7Tm5PP5is+GWbNm487a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X0OHDj3ooIMee+yxLl26DBw48Mgjj1y7du23vvWtrNcF1LpydFbcr2mdNmuZcgXqVO/evVtaWsofj/5Q1isC6kkF/ZrWdbOWKVcAgIy0xugmElawrkO5AgBkTZ5uHu8tAABADMoVAIAYlCsAADEoVwAAYlCuAADEoFwBAIghl9bcuzAUCoWslwBkoFgsZnJcew7Up6z2nDpXm+/nWiqVKhvM5/NtmS0uXVTZbKHL3hFnszrPZs1Wm3DnyqxZs22fJROuFgAAIAblCgBADMoVAIAYlCsAADEoVwAAYlCuAADEoFwBALa5f/qnf+r3oaOPPnr33XdPkmTFihWnn356v379Dj300F/84hfr3nnSpEnHHnvswQcfPH369CRJxo8f36dPn4kTJyZJsnbt2gEDBjQ3Nyd1qTbfzxUAoKr85Cc/KX9w++23/+Uvf0mS5Pvf//5hhx02atSoxYsXH3XUUQMGDCjf4c0337zrrrtmzJjxpz/9qVAovPzyy9/73vdeffXV3r17jx49+vbbbx88eHDXrl2TuqRcAQC2kzRNb7nlll/+8pdJkpx//vk777xzkiQvvvhi+/btW++zZMmS4cOHt2vXrkePHkuWLEmSpH379n/7298aGxvffvvtqVOnPvTQQ0m9Uq4AANvJgw8+eNhhh33iE59IkmTXXXdNkuSrX/3qz3/+8wceeKD1Pgd8KEmS+++/f9CgQUmSXHvttWedddZ11103duzYb3/727lcLqlXrnMFANhO/u3f/u2yyy5b95Z77rnn3nvvveuuu9a759y5cydOnDh+/Phy3c6cObN3795JksybN2/AgAH3339/UpeUKwDA9vD73/++a9eu5QBNkuSiiy5as2ZNkiQDBw5c7xVay5cvP/300++444499tijfEuaplddddW//uu/Xn755Xfcccfll1+e1CXlCgCwPVx//fXrPuG6dOnSUqmUJMnvfve7cs4uX768HKlf+9rXLrvssiOOOKL1zpMmTRo0aFC3bt1WrlyZpumKFSuSuuQ6VwCAbW7OnDmLFi067rjjWm8ZN27c1772tZtvvrmxsXHSpElJknzpS1+aPn36nXfe+ctf/nLJkiW33XZbp06dHnrooebm5p/+9KfTpk1LkmTEiBH9+/df75KD+qFcAQC2uaampieffHLdW3r27PnYY4+te0v53VuHfWjd27t2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PUaOHNl6+8KFCwuFQufOnffYY49vfvObLS0t/fr1e/XVV4cNG3beeedtYvDFF1889thjO3bsePTRR8+fP3/DFT711FPz5s278cYbd91116ampquvvnrq1Klpmm7HkwRkpn379gMHDjzxxBOLxeIbb7yRy+WuvPLKLl26nHPOOVu6saz7nKstCyqmXMnSueeee8wxx4wfPz5Jkmuvvfbzn//8sGHDyp+6/vrrH3nkkVmzZj399NPDhw8v3zh48ODOnTu/9tprM2bMeOqpp0aMGJEkyQcffHDyySc3NjbOnTv3ySeffP7556+++urHH3+8d+/ekydPvv322zc2+P77759yyil9+/ZdtGjRlVdeOXny5A1XePTRR69evbqxsbH8n4sXL95tt91yudx2PElAxtasWdOpU6fyx6+88srrr79+zTXXVLyx2LKgTdb7C1zYFvbZZ5/1fuPtsMMO5U/Nnj27a9euN954Y5cuXWbPnp2m6ZtvvpkkSbFYLN9h+vTpjY2Ny5cvnzFjxk477dTS0lK+/amnnmrXrt3KlStnzJjR2Ni4ZMmS9Q5a/mMgTdONDZZKpS5duqxYsaJ8+wUXXHDEEUds4rtobm7ed999r7766q19eoAq0q1bt9arBZqbmydPntyuXbuHHnpo8eLFSZJMmzat/Kkt3VjeeeedJElefvllWxa0hedcyeY61zVr1pRvb2pqGj169MiRIy+77LKmpqbW+7e+8uDggw9etWrV3LlzX3rppRUrVnTo0KH8yonDDjts7dq18+bNe/HFF7t3777bbrtt7NAbG3zppZf222+/jh07lu92yCGHbGL977333qBBg/r06TN27NitdEqAKvWNb3yjvF3sueeeN9xwwy233DJgwIDyp3r27NnGjcWWBW2hXMneCy+8kCTJM888s+6N7du3L3/wwQcfJEnS0NCwZs2apqam9f7f67Of/Wz79u03/XdhGxtc726tR9zQkiVLTjzxxO7du99///0NDQ1t+3aBatf6nOv777//wgsvrPsipw4dOrRxY7FlQVsoVzL28MMP33fffRMnTpw6dWqpVGq9/bnnnit/MGvWrE6dOu23334HHHDA/PnzX3/99fW+wv77779gwYLy38Stq/XPho0N9unTZ/bs2e+99175P59//vmPXOHrr79+zDHHHHfccT/+8Y9brx4D6lzFG4st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063zzxOEzVblClCJoUOHHnTQQY899liXLl0GDhx45JFHrl279lvf+lbW6wJqXfphdFbcr5GbtUy5Amyx3r17t7S0lD8e/aGsVwTUk3TL+zV+s5YpVwCAgNL/F6ObSNhaCdZWyhUAILK01vJ0E7y3AAAAMShXAABiUK4AAMSgXAEAiEG5AgAQg3IFACCGXFqV76RQKBSyXgJQR4rFYibHtddBfcpqz6kB1ft+rn0nVvigPju6YNasWbNRlJomVDaYnzPGrNmqmy2VKpzN5+tqloq5WgAAgBiUKwAAMShXAABiUK4AAMSgXAEAiEG5AgAQg3IFAIhh2rRpHTt2LH88adKkY4899uCDD54+fXrrHdauXXvxxRcfddRRxx133Lx585IkGT9+fJ8+fSZOnFj+7IABA5qbm5OwlCsAQADLli0bN25c+/btkyR5880377rrrhkzZvzkJz+55JJLWu/zwx/+sHPnzk8++eSIESNGjRqVJMn3vve93/3udzfeeGOSJLfffvvgwYO7du2ahKVcAQACuOKKKy699NJ27f4eb0uWLBk+fHi7du169OixZMmS1vv8+Mc/HjZsWJIkAwYMOPLII5Mkad++/d/+9rfGxsa333576tSp5c/GpVwBAKrdb37zm0WLFn35y18u/+cBBxwwdOjQJEnuv//+QYMGtd7tT3/60wMPPNCvX7/TTz+9fOdrr732rLPOuu6668aOHfvtb387l8slkSlXAICq1tLSMmrUqFtuuWW92+fOnTtx4sTx48e33rJq1apPfepTjz/++FlnnXXuuecmSfLVr3515syZvXv3TpJk3rx5AwYMuP/++5OwGrJeAAAAm/Kzn/1s2bJlZ555ZpIky5cvP/vss+++++7ly5effvrpd9xxxx577NF6zz333DOfzydJks/nL7zwwvKNaZpeddVVd99996GHHjpz5syjjz56yJAhSUyecwUAqGpnnnnmiy+++PiHOnXqdPfdd6dp+rWvfe2yyy474ogjyvdZvnx5kiQnnHDCE088kSTJE0880bdv3/KnJk2aNGjQoG7duq1cuTJN0xUrViRhec4VACCYO++885e//OWSJUtuu+22Tp06PfTQQ1/60pemT59+zTXXnHvuuddcc01DQ8Ntt92WJElzc/NPf/rTadOmJUkyYsSI/v37X3bZZUlYyhUAIIzmD9+NddiH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KFcAAGJQrgAAxKBcAQCIQbkCABCDcgUAIAblCgBADMoVAIAYlCsAADEoVwAAYlCuAADEoFwBAIhBuQIAEINyBQAgBuUKAEAMyhUAgBiUKwAAMShXataSJUteeeWVrFcBkDGbIbVEubI9dO/ePbeBKVOmbNOD9u/ff+bMmZt//xtuuOHII4/c8Pa//vWvQ4YM2WWXXXr06DFu3Litukagjuy+++6tG2BjY+OBBx540003VfzVWres5ubmXC63iTa1GVJLGrJeAPXiu9/97qWXXro9j7hy5cqt8nXOPPPMnj17LliwYPbs2SeffPInP/nJ8847b6t8ZaDe3HrrrRdeeGGSJKtXr/7lL3/5pS99adddd/3qV7/alq/ZtWvXNE03cQebIbXEc65k6Y477ujQocOCBQuSJHnzzTd32WWXyZMnv/XWW7lc7o477ujevXuXLl3OPffc1m138eLFQ4YM6dSpU48ePUaOHNl6+8KFCwuFQufOnffYY49vfvObLS0t/fr1e/XVV4cNG1beWDc2+OKLLx577LEdO3Y8+uij58+fv+EK586d+9hjj91www1dunT5/Oc/f/zxx//ud7/bjmcIqE3t27cfOHDgiSeeWCwW33jjjVwud+WVV3bp0uWcc87Z0i1r3edcbYbUPOVKls4999xjjjlm/PjxSZJce+21n//854cNG1b+1PXXX//II4/MmjXr6aefHj58ePnGwYMHd+7c+bXXXpsxY8ZTTz01YsSIJEk++OCDk08+ubGxce7cuU8++eTzzz9/9dVXP/7447179548efLtt9++scH333//lFNO6du376JFi6688srJkydvuML99ttv7dq13bp1W7NmzX99qFAobN+TBNSsNWvWdOrUqfzxK6+88vrrr19zzTUVb1k2Q+pCCtvePvvss95vvB122KH8qdmzZ3ft2vXGG2/s0qXL7Nmz0zR98803kyQpFovlO0yfPr2xsXH58uUzZszYaaedWlpayrc/9dRT7dq1W7ly5YwZMxobG5csWbLeQcubdZqmGxsslUpdunRZsWJF+fYLLrjgiCOO2Ni30Lt37w4dOvTr1+/NN9/cBmcIqH3dunW79dZbyx83NzdPnjy5Xbt2Dz300OLFi5MkmTZtWvlTW7plvfPOO0mSvPzyyzZD6oHnXNlOvvvd7677O2/NmjXl25uamkaPHj1y5MjLLrusqamp9f6trw84+OCDV61aNXfu3JdeemnFihUdOnQov77hsMMOW7t27bx581588cXu3bvvtttuGzv0xgZfeuml/fbbr2PHjuW7HXLIIZtY/yuvvLJkyZKddtpp4MCBW+mUAHXnG9/4Rnkj2nPPPW+44YZbbrllwIAB5U/17NmzjVuWzZB6oFzJ3gsvvJAkyTPPPLPuje3bty9/8MEHH/z9tYQNDWvWrGlqalrv/70++9nPtm/fPpfLbeLrb2xwvbu1HnFjdt5557Fjx/7+979ftGhRpd8rUNdan3N9//33X3jhhfKrtco6dOjQxi3LZkg9UK5k7OGHH77vvvsmTpw4derUUqnUevtzzz1X/mDWrFmdOnXab7/9DjjggPnz57/++uvrfYX9999/wYIF5b8vW1frDr6xwT59+syePfu9994r/+fzzz+/4fIeeeSRLl26tLS0lP/z7bff3mGHHbp27dq2bxpgoyresmyG1APlSpaWL19+4YUXXnzxxaNGjTr//POHDx++bNmy8qcuv/zy+fPnz549e8yYMRdccEGHDh1OOOGEgw46aNiwYQsWLFi4cOGll17as2fPlpaWY489tk+fPhdddNFbb7312muvDR48+Iwzzig/K7Bo0aJly5ZtbPCLX/ziXnvtdckll7z99tuPPvropEmTNlxhv379PvnJT44cOXLp0qXPPffc6NGjhw0bttNOO233UwXUi4q3LJshdWErXS8LW/YKrSRJvv71r1900UWf/vSnly9fnqbp0qVLe/ToMXz48PIrtK644opPfepTu+6668iRI1etWlX+On/+859PO+20nXfeeZdddjnppJNefvnl8u3z588/+eSTd9xxx27dup1zzjlLly5N0/RHP/pRp06dBg8evInBuXPnnnjiiTvuuGOfPn1Gjhz5kS9KmDNnzimnnLLLLrv07NnzyiuvXLly5XY8c0BtvkJrXeVXaJVfolq2RVtW6yu0bIbUg9ym375407wjBtvCqlWrpk2bduKJJ3bu3DnrtUBbFYvFTI5rf4b6VMxozwnzb2ite2HiFsnn82Y3f3be2ObKZnuN6xputvtVf//rp//6r/+qn8fXbA3PZijcuYo62zShwtk5Y0LORnyM6mm25rnOFQCAGJQrVaexsTHrJQAA1Ui5AgAQg3IFACAG5QoAQAzKFQCAGJQrAAAx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DdZ6XC0AAFAf0jT6cZUrAAAxKFcAAGLIpW14/rZQKGzVxQDUmmKxmMlx7c9Qn4qbs+ds50tXt+olCm19hVapVKpsMJ/PmzVr1mzNz2Yo3LmKOts0ocLZOWNCzkZ8jOpptua5WgAAoJ6kadxjKVcAAGJQrgAAdSZNgx5FuQJUi4MPPnjhwoVJkrS0tOy///433XTTIYcc8rnPfW769OlZLw2oOWka8esrV4BqMWTIkAceeCBJkscee+ykk04aN27cE088ce+9906ZMiXrpQG1KE3DfWXlClAthg4dOnXq1CRJHnzwwS9/+cunnHLK2WefvWDBgrvvvjvrpQE1Kk1jPZurXAGqRe/evZcsWfLuu+/OmjXrC1/4wp133jlixIhbb7112LBhWS8NqF1pGugihLa+nysAW9Fpp502fvz4ww8//N133z311FMfffTRQw89tFevXlmvC6hpabp1/nmCbf/CL+UKUEWGDh160EEHPfbYY126dBk4cOCRRx65du3ab33rW1mvC6h16YfRWXG/bq/3iFWuAFWkd+/eLS0t5Y9HfyjrFQH1JN3yft2e/66BcgUA4KNjdBMJu32DtZVyBQCgivJ0E7y3AAAAMShXAABiUK4AAMSgXAEAiEG5AgAQg3IFACCGXNqG9zsoFApbdTEAtaZYLGZyXPsz1KdiRntOmPdzLZVKlQ3m83mzZqttdt7Y5spme43ratZstYn4MxhytmlChbNzxoScjfgY1dNszXO1AAAAMShXAABiUK4AAMSgXAEAiEG5AgAQg3IFACAG5QoAUKdWrFhx+umn9+vX79BDD/3FL36RJMl//dd/HX300ccff/yxxx775JNPbjgybdq0jh07Jkkyfvz4Pn36TJw4MUmStWvXDhgwoLm5udrfzxUAgKC+//3vH3bYYaNGjVq8ePFRRx01YMCAc88997HHHtt3333nzp07aNCgl156ad37L1u2bNy4ce3bt0+S5Hvf+96rr77au3fv0aNH33777YMHD+7ateu2XrDnXAEA6tT5559/8cUXJ0ny4osvlnu0W7duS5YsSZJkyZIl77333nr3v+KKKy699NJ27f4ekO3bt//b3/7W2Nj49ttvT506ddiwYdthwcoVAKBO7brrro2NjV/96ldPO+20H/7wh0mS/PCHPzzmmGP+4R/+4bjjjrvlllvWvfNvfvObRYsWffnLXy7/57XXXnvWWWddd911Y8eO/fa3v53L5bbDgpUrAEBdu+eee+6999677rorSZJRo0b9+Mc/fv755++5556f//znrfdpaWkZNWrUui371a9+debMmb17906SZN68eQMGDLj//vu39VKVKwBAnbrooovWrFmTJMnAgQPLr9B6/vnnC4VCkiRf+tKXHnjggdZ7/uxnP1u2bNmZZ57Zr1+/5cuXn3322UmSpGl61VVX/eu//uvll19+xx13XH755dt6wcoVAKBOLV26tFQqJUnyu9/9rvzsae/evX/7298mSfLkk09++tOfTpJk+fLlSZKceeaZL7744uMf6tSp0913350kyaRJkwYNGtStW7eVK1emabpixYptvWDvLQAAUKfGjRv3ta997eabb25sbJw0aVL5Otfya7Zyudztt99efvJ1+vTpG842Nzf/9Kc/nTZtWpIkI0aM6N+//2WXXbatF6xcAQDqVM+ePR977LF1b+nbt++MGTPWvWXDbC2/b2vXrl0feeSR8i1XfGjbr9fVAgAABKFcAQCIQbkCABBDLk3TiofLb5oAwMYUi8VMjmt/hvpUzGjP2W7a+gqt8jspVCCfz5s1W22z88b+/ZLzCvQa1zXimn2/mz9b8ZozFPFnMORs04QKZ+eMCTkb8TGqp9ma52oBAABiUK4AAMSgXAEAiEG5AgAQg3IFACAG5QoAQAzKFQCAGJQrAAAxKFcAAGJQrgAAxKBcAQCIQbkCABCDcgUAIAblCgBADMoVAIAYlCsAADEoVwAAYlCuAADEkEvTtOLhQqGwVRcDUGuKxWImx7U/Q30qZrTnbDcNbZwvlUqVDebzebNmq2123tjmymZ7jesacc2+382frXjNGYr4MxhytmlChbNzxoScjfgY1dNszXO1AAAAMShXAABiUK4AAMSgXAEAiEG5AgAQg3IFACAG5QoAQAzKFQCAGJQrAAAxKFcAAGJQrgAAxKBcAQCIQbkCABCDcgUAIAblCgBADMoVAIAYlCsAADEoVwAAYsilaVrxcKFQ2KqLAag1xWIxk+Pan6E+FTPac7abhjbOl0qlygbz+bxZs9U2O29sc2WzvcZ1NWu22kT8GQw52zShwtk5Y0LORnyM6mm25rlaAACAGJQrAAAxKFcAAGJQrgAAxKBcAQCIQbkCABCDcgUAIAblCgBADMoVAIAYlCsAADEoVwAAYlCuAADEoFwBAIhBuQIAEINyBQAgBuUKAEAMyhUAgBiUKwAAMeTSNK14uFAobNXFANSaYrGYyXHtz1CfihntOdtNQxvnS6VSZYP5fN6s2WqbnTe2ubLZXuO6RpyN+BiFm81QuHMVdbZpQoWzc8aEnI34GNXTbM1ztQAAADEoVwAAYlCuAADEoFwBAIhBuQIAEINyBQAgBuUKAEAMyhUAgBiUKwAAMShXAABiUK4AAMSgXAEAiEG5AgAQg3IFACAG5QoAQAzKFQCAGJQrAAAxKFcAAGLIpWla8XChUNiqiwGoNcViMZPj2p+hPhUz2nO2m4Y2zpdKpcoG8/m8WbPVNjtvbHNls73GdbVms9Um3LmKOts0ocLZOWNCzkZ8jOpptua5WgAAgBiUKwAAMShXAABiUK4AAMSgXAEAiEG5AgAQg3IFACAG5QoAQAzKFQCAGJQrAAAxKFcAAGJQrgAAxKBcAQCIQbkCABCDcgUAIAblCgBADMoVAIAYlCsAADHk0jSteLhQKGzVxQDUmmKxmMlx7c9Qn4oZ7TnbTUMb50ulUmWD+XzerNlqm503trmy2V7julqz2WoT7lxFnW2aUOHsnDEhZyM+RvU0W/NcLQAAQAzKFQCAGJQrAAAxKFcAAGJQrgAAxKBcAQCIQbkCABCDcgUAIAblCgBADMoVAIAYlCsAADEoVwAAYlCuAADEoFwBAIhBuQIAEINyBQAgBuUKAEAMyhUAgBhyaZpWPFwoFLbqYgBqTbFYzHoJALWjoY3zpVKpssF8Pm/WbLXNzhvbXNlsr3FdI85GfIzCzQKwFblaAACAGJQrAAAxKFcAAGJQrgAAxKBcAQCIQbkCABCDcgUAIAblCgBADMoVAIAYlCsAADEoVwAAYlCuAADEoFwBAIhBuQIAEINyBQAgBuUKAEAMyhUAgBiUKwAAMeTSNK14uFAobNXFANSaYrGY9RIAakdDG+dLpVJlg/l83qzZapudN7a5stle47pGnI34GIWbBWArcrUAAAAxKFcAAGJQrgAAxKBcAQCIQbkCABCDcgUAIAblCgBADMoVAIAYlCsAADEoVwAAYlCuAADEoFwBAIhBuQIAEINyBQAgBuUKAEAMyhUAgBiUKwAAMShXAABiyKVpWvFwoVDYqosBqDXFYjHrJQDUjoY2zpdKpcoG8/m8WbPVNjtvbHNls73GdbVmswBsa64WAAAgBuUKAEAMyhUAgBiUKwAAMShXAABiUK4AAMSgXAEAiEG5AgAQg3IFACAG5QoAQAzKFQCAGJQrAAAxKFcAAGJQrgAAxKBcAQCIQbkCABCDcgUAIAblCgBADLk0TSseLhQKW3UxALWmWCxmvQSA2tHQxvlSqVTZYD6fN2u22mbnjW2ubLbXuK7WbBaAbc3VAgAAxKBcAQCIQbkCABCDcgUAIAblCgBADMoVAIAYlCsAADEoVwAAYlCuAADEoFwBAIhBuQIAEINyBQAgBuUKAEAMyhUAgBiUKwAAMShXAABiUK4AAMSgXAEAiCGXpmnWawAAgI/nOVcAAGJQrgAAxKBcAQCIQbkCABCDcgUAIAblCgBADMoVAIAYlCsAADEoVwAAYlCuAADEoFwBAIhBuQIAEINyBQAgBuUKAEAMyhUAgBiUKwAAMShXAABiUK4AAMSgXAEASEL4/wC9+MVlRNA1dAAAAABJRU5ErkJggg=="
            },
            {
              "type": "input_text",
              "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
            }
          ],
          "solved_count": 0,
          "total_training_examples": 3,
          "pixel_accuracy": 0.4867549668874172
        },
        "test_result": {
          "correct": false,
          "pixel_accuracy": 0.0,
          "total_pixels": 576,
          "correct_pixels": 0,
          "error": "Grid height mismatch"
        },
        "status": "failed_test"
      }
    ],
    "total_turns": 1,
    "conversation_history": [
      {
        "role": "system",
        "content": "You are an expert at solving abstract reasoning puzzles. Write clean, efficient Python code."
      },
      {
        "role": "user",
        "content": [
          {
            "type": "input_text",
            "text": "You are solving an ARC (Abstraction and Reasoning Corpus) task. \nI will show you training examples with input and output grids, plus a test input grid. Your task is to:\n\n1. **Analyze the training examples** to discover patterns that map input grids to output grids\n2. **Write a Python program** that implements your best understanding of the transformation  \n3. **DO NOT predict or generate the test output** - your job is only to write the transformation program\n4. **Attempt a solution** - even if the pattern isn't completely clear, provide your best hypothesis\n5. **Do not repeat the same transformation** - if you have already tried a transformation, do not repeat it.\n\n**IMPORTANT: Your transformation must always produce a 18\u00d717 output grid.**\n\nThe test input is shown for context so you understand what type of grid your program will eventually process. Focus on learning patterns from training examples and writing code that captures your understanding.\n\nTraining Examples:\n\nExample 1:\nInput:\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 2 2 2 2 0 0 0 0 0 0 0 0 0 0 1\n0 0 2 0 0 2 0 0 0 0 0 0 0 0 0 0 1\n0 0 2 0 0 2 0 0 0 0 0 0 0 0 0 0 1\n0 0 2 2 2 2 0 0 0 0 0 0 0 0 0 0 1\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0\nOutput:\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\n0 0 2 0 0 2 2 0 0 2 2 0 0 2 2 0 0\n0 0 2 0 0 2 2 0 0 2 2 0 0 2 2 0 0\n0 0 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\n0 0 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0\n0 0 2 0 0 2 0 0 0 0 0 0 0 0 0 0 0\n0 0 2 0 0 2 0 0 0 0 0 0 0 0 0 0 0\n0 0 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0\n0 0 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0\n0 0 2 0 0 2 0 0 0 0 0 0 0 0 0 0 0\n0 0 2 0 0 2 0 0 0 0 0 0 0 0 0 0 0\n0 0 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0\n0 0 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0\n0 0 2 0 0 2 0 0 0 0 0 0 0 0 0 0 0\n0 0 2 0 0 2 0 0 0 0 0 0 0 0 0 0 0\n0 0 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0\n\nExample 2:\nInput:\n0 0 0 0 0 0 0 0 1 1 1 1 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n1 0 0 0 0 0 0 0 8 8 8 8 0 0 0 0 0 0 1\n1 0 0 0 0 0 0 0 8 0 0 8 0 0 0 0 0 0 1\n1 0 0 0 0 0 0 0 8 0 0 8 0 0 0 0 0 0 1\n1 0 0 0 0 0 0 0 8 8 8 8 0 0 0 0 0 0 1\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 8 0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 8 0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0\nOutput:\n0 0 0 0 0 0 0 0 8 8 8 8 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 8 0 0 8 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 8 0 0 8 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 8 8 8 8 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 8 8 8 8 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 8 0 0 8 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 8 0 0 8 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 8 8 8 8 0 0 0 0 0 0 0\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 0 0 8 8 0 0 8 8 0 0 8 8 0 0 8 8 0 0\n8 0 0 8 8 0 0 8 8 0 0 8 8 0 0 8 8 0 0\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 8 0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 8 0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 8 0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 8 0 0 8 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0\n\nExample 3:\nInput:\n0 0 0 0 0 0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n1 0 0 0 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0\n1 0 0 0 0 0 3 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0\n1 0 0 0 0 0 3 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0\n1 0 0 0 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 0 0 0 0 0 1\n0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 3 0 0 0 0 0 1\n0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 3 0 0 0 0 0 1\n0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 0 0 0 0 0 1\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 0 0 0 0 0 0\nOutput:\n0 0 0 0 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 3 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 3 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0\n3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0\n0 3 3 0 0 3 3 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0\n0 3 3 0 0 3 3 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0\n3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 3\n0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 3 3 0 0 3 3 0\n0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 3 3 0 0 3 3 0\n0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 3 3 3 3 3 3\n0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 3 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 3 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 3 3 3 3 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 3 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 3 0 0 0 0 0 0\n\nTest Input:\n0 0 0 0 0 0 1 1 1 1 0 0 0 1 1 1 1 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n1 0 0 0 0 0 4 4 4 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n1 0 0 0 0 0 4 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n1 0 0 0 0 0 4 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n1 0 0 0 0 0 4 4 4 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 4 4 4 4 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 4 0 0 4 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 4 0 0 4 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 4 4 4 4 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 1 1 1 1 0 0 0 1 1 1 1 0 0 0 0 0 0 0\n\nAnalyze the patterns in the training examples and write a Python function that performs this transformation.\n\n**Approach Guidelines:**\n- Look for patterns in shapes, colors, positions, sizes, rotations, reflections, etc.\n- Even if you can't solve all training examples perfectly, implement what patterns you do observe\n- A partial solution that captures some aspects is better than returning the input unchanged\n- If the pattern is unclear, make your best educated guess based on what you can see\n\nRequirements:\n- The function takes a 2D list (grid) where grid[row][col] gives the value at that position\n- Values are integers from 0-9\n- Return a new grid (2D list) with the transformation applied\n- You can use numpy if needed - just add 'import numpy as np' at the start of your function\n- Aim to handle the training examples as well as possible, even if not perfectly\n- Your function should attempt some meaningful transformation based on the patterns you observe\n\nYou MUST end your response with the following exact format:\n\nFinal answer:\n```python\ndef transform(grid):\n    # Your transformation logic here (implement your best understanding)\n    return transformed_grid\n```\n"
          },
          {
            "type": "input_image",
            "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA9QAAAfGCAIAAAB552FQAABaBUlEQVR4nO3df5iXdZ3v8furIyCIINmqYAnDdNQOiUb+zN0kMHcz7b7PYpZ6TkOSuhsVmz8420V5TpoKuNspf5QeFC3MUo/391o3Ls+Geyw7m2VqWCIKivkDy0Axf4QMcJ/r7JwzF4uIM9+Zed9zz/fxuPiDhnnN957vMJ95Nt1MtaIoEgAAoP/tEvAYAACA+AYAgDjiGwAAgohvAAAIIr4BACCI+AYAgCDiGwAAgohvAAAIIr4BACCI+AYAgCDiGwAAgohvAAAIIr4BAKAK8T179uzamzvjjDN2+DpDhgzZd999Tz755AceeOCNb/OHP/xhrVYbM2bMxo0bt/uj2267rVarLVq0qPM/tre312q1hQsXbvdqzzzzTK1WmzdvXm9WnTZu3HjNNddMnTp17NixQ4cOHTt27CmnnHLPPfc09pxMnz49SZL169ePHTt2r732euaZZ7bb/of/8B+GDBnyi1/8optPyMc//vFardbS0vL73//+jVcyadKkWq3W3t7e+R9nzZq17cXsuuuue+6555FHHnndddd1TdI0rdVqb3ygbr5rndatW3fBBRccdNBBu+++++jRo4855phvfvObW7Zs2cmTBgDQJEr4zndHR8fvfve7O+64Y+rUqU888cR2f3r99dcnSfLiiy9+//vf785b+/KXv7xy5cqeXkN3Vk8++eTRRx99zjnn3H333c8999ymTZuee+6522677c/+7M/+/u//PmnU2972tuuvv37Dhg0zZ84siqLr5VdddVWe55dccsn73ve+Hj0hW7Zsuf3227d74a9+9auHH354J5exdevWl19++ec///msWbMWLFiQ9JHf//73hx9++MKFCx999NGNGze+9NJLP/3pT//6r//6lFNO2fadBQBoTr2K7yuvvLL4/2699dYkSRYvXtz1kiVLlnS95po1a7pevnHjxkceeeS00077wx/+8M1vfnPbN7hhw4Z6vX7KKaeMGTPmW9/6VneuYdOmTe3t7T39xupbrjo6OmbMmPHLX/7ymGOO+Yd/+Id169Z1dHQ89dRTV1999ZgxYy644IJf//rXO3n7276/XZYtW9b5p3/+53/+mc98ZtmyZVdeeWXnS5YvX37uued+6EMfOvfcc3v0hOy6664HHnjgLbfcst3Lv/e97/37f//v3/j6zz33XOfFbN269ZVXXvnud787bNiwr371q6+//vpOn7Duvmvf+MY3nnzyyRkzZixfvvzVV1/dsGHDP//zPx922GF5nt9xxx3dfAgAgMGqhO98Dx069KCDDpo/f36SJNt95/u73/3uxo0bzz777JkzZ957770PPfTQW761z372sz/72c/+7u/+rkfX8JarG2+88f77758+ffqPf/zjk0466W1ve1tLS8s73vGOv/qrv7r99tu3bNly8803J72wcOHCgw46aO7cuY8++ugrr7zysY99bNSoUd/+9rdrtVpPn5CPfexjP/rRj55//vltX/j973//1FNP3ckF1Gq1ESNGfOITn/j4xz/+hz/84bHHHkv6wsqVK1taWpYsWXLIIYcMHz581KhRU6dO7fzG/J133tn5OjfccEOtVuv6Lx4AAM2jhPh+/fXXH3744S984QtJkvy7f/fvtv2jxYsXH3zwwR/84Af/6q/+atddd+3ON78vueSStra2L3/5y4888kj3r+EtV9/97ndrtdq111676667bvdHH/jAB1asWHHxxRcnvbD77rvfdNNNmzdvPuOMM84555xVq1Z9+9vf3meffbZ7te48IR/72Me2u/Pk5z//+eOPP/6xj32sO1fS+T3vN76bjZk8efLmzZvzPN/2hePHjy+K4uqrr+6ThwAAqK6g+J4wYULXP84bNmzYpEmTbr311r333vvzn/981+v8+te//sUvfnH++efXarWJEyeecsopN9100yuvvLLztzx8+PDFixd3dHT06OaTt1w9+OCDBx988IQJE3Y4P/jgg7f7FvVO3t8ud99997av8973vve//Jf/8otf/OKmm276whe+cMIJJ2z3Rrr5hEyaNOnd7353520/nb73ve+9733vmzhx4k6ucMuWLWvXrv36179+yy23/Mmf/MmBBx64k1fu/rs2Z86cY4899hOf+ERra+usWbOuvfbaN9563t7eXhTF7Nmzu/mIAACDRjk/anDcuHGf+tSnli9fvu+++3a98Prrrx83btzpp5/e+R//9m//9uWXX+7O3R3HHnvs5z73uZ///OeXX355969hJ6uOjo4NGzZs933o7X7Wx/jx45Ne++hHP9oZ8ccee+wb/7T7T8i2d54URXHLLbe82T0n++23X+f1t7S0jBs3bs6cOVu2bLnkkkv66jvfe+yxx913371kyZLJkyfX6/Wzzz570qRJEyZMuPHGG/vk7QMAVFpQfHf+K71NmzZ973vfGzly5Lve9a7LLrts7NixXa/Q0dGxZMmSZ599dujQoZ11OHny5KIouvnPLi+55JJ3vetdF1544YoVK7p/VW+22m233UaOHLnDn9/Xm3+VeNxxx237Ohs3bjzttNNGjRo1cuTIs88+e7ubtnv0hJx66qldd578+Mc/Xrt27Vvec7LLLruMGTNm2rRp9Xr9zDPP7MN3bddddz399NPzPF+3bt2qVasWL168zz77tLe3f+1rX+v+owAADEqh3/nebbfdTj311O9///s/+tGP/vzP/3zbnyf9j//4jzuM3QceeOC+++57y7e8++67N3DzyU5W73nPe1asWPHUU0/t8Ee7TJkyJem1OXPmPPTQQ9/4V88///ynPvWpbf+0R0/IQQcd9J73vKfzZ558//vfP+qoo975znfu8EG7ftrJli1b1q9fv2zZso9+9KO9f1/eTFtbW3t7+09+8pPDDjusl3fJAwAMAiXcdvIXf/EXn/3sZx944IHzzjuv64XXX3/9sGHDXnrppW2/n/ov//IvSZJcc8013Xmz73//+z//+c/fd999b/w/0Glgdfrpp2/duvWv//qvd5jyvf+R1bfeeus111xz2mmn/cf/+B/b29v/8i//8gc/+MG2P3ixp0/Iqaee+uMf/7jzJ5Hv/Oec9J9nn322VqvNmjVru5e3tLS85z3v2bBhw6ZNm0q5MACApr7n+5JLLnnnO9/5zW9+82c/+1mSJL/97W/vvPPOk046ac8999z21Y4++ugDDzzw5ptvfumll7rzZr/61a++613v6ulP1djhatasWVOmTPnBD35wxBFH3HLLLb/97W87Ojo60/bEE0984IEHdtml8aduzZo1n/70pydMmNBV29dcc81+++137rnndv5f/zTwhHTeeTJnzpx169adcsopSRnGjRv33ve+9/rrr589e/ZPf/rT3/3udxs3bnz88cevvvrqW2+99YgjjhgyZEgpFwYA0NTxPWLEiCuuuGLr1q1nn3325s2bv/3tb2/evLnrXxZu65Of/ORrr732ne98p/u3kez855B0czVkyJB6vX700Uc/8MADp5566n777TdkyJDO/3v5pUuXHnjggTv/P+Dc4Y8EqdVqr7zySkdHx6mnnvrqq6/edNNNXW39tre97YYbbti4cePpp5/e0dHRwBPS1tZ22GGH3XLLLX/6p3+67c30Ddh99923u+wbbrihO+9a5zfsR48efdVVVx1zzDH77rvv7rvv3tbW9pnPfKalpaXrB3v7Od8AQNMqJ76TJDn55JPTNF2+fPl/+2//7YYbbthrr73+4i/+4o2v9p/+03/aZZddunnnSedtJHPmzOnpxexwtf/++99zzz1Lliz58Ic/vP/++w8ZMmSfffb58Ic/fOONN/76178+/PDDk4b85//8n++7774LL7zw6KOP3vblH/rQh2bPnv3AAw/MmzevsSek826Tbv54734yefLkhx9++Nxzz500adKee+45ZMiQ8ePHn3XWWb/61a/65EZ5AIBKq/X+9mUAAGBAf+cbAACajfgGAIAg4hsAAIKIbwAACCK+AQAgiPgGAIAg4hsAAIKIbwAACCK+AQAgiPgGAIAg4hsAAIKIbwAACCK+AQAgiPgGAIAg4hsAAIKIbwAACCK+AQAgiPgGAIAg4hsAAIKIbwAACCK+AQAgiPgGAIAg4hsAAIKIbwAACCK+AQAgiPgGAIAg4hsAAIKIbwAACCK+AQAgiPgGAIAg4hsAAIKIbwAACCK+AQAgiPgGAIAg4hsAAIKIbwAACCK+oRzr169fuXJl2VcBNKneHEGOL+gN8Q1vLU3T9vb2vn2b06dPv/fee9/sTzds2NDa2rqTVwDo9PTTT3/6058eN27csGHDWltbzzvvvBdeeKGXR1Bvto4v2DnxDeX44x//+GZ/9PTTT0+fPn3NmjWxVwRUz2OPPTZlypQXX3xx6dKlL7zwwu233/7II49MmTLlueeea/gIekuOL+gN8Q09sG7dulqtdtVVV40fP37YsGEnnHDCs88+2/Xy6667bv/99x81atSZZ57Z+cXpmWeeqdVqTz75ZOf88ssvP+qoo5IkOe644x599NGZM2fOmjVru4f4wQ9+MGnSpClTppTx/gEVM2vWrA984AO33Xbb5MmThw8ffuihh95xxx377rvv5z73uW4eQY4vCCa+ocduvPHGu+66a+XKlWvXrv3KV77S9fIFCxbceeedDz744P333z979uydvIW77777wAMPXLx48aJFi7b7o6FDhy5btuyqq67qt8sHBonf/OY399xzz3anzS677DJnzpx6vf7iiy92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zZq17dt//PHH/9f/+l+XX375qFGj3ve+902dOvVf/uVfSnpfAQaVWbNmfeADH7jtttsmT548fPjwQw899I477th3330/97nPdfO4dtQziIlvBrQbb7zxrrvuWrly5dq1a7/yla90vXzBggV33nnngw8+eP/998+ePXsnb+Huu+8+8MADFy9evN13OyZOnLh169a3ve1tmzdvvutfZVnWn+8KQFP4zW9+c88992x3Mu+yyy5z5syp1+svvvhi949rRz2DkvhmQPvSl740ceLE8ePHt7e333fffV0vnz9//qRJk1pbWxcuXLhkyZJXX3214YeYNGnSiSeeeMghhxx99NF9dNUAzWvFihVJkhx88MHbvXzy5MmbN29evXp199+Uo55BSXwzoI0fP77zNyNGjOjo6Oh6eef/zpgkyaGHHrpp06bHH3+84YdYuXLl+vXrhw8f/pGPfKTX1wvQ7Gq1WpIkW7Zs2e7lr7/+ek/flKOeQUl8M6DttttuXb8viuKNL+8831taWjqP+y5vPPd3YsSIEfPmzfvZz362du3avrhqgObV+T3vzu9/b2vlypUtLS1tbW3dP64d9QxK4ptKeuihhzp/8+CDD+6xxx4TJ04cMmRIkiRd/6PkU0891fXK2x3Wne68885Ro0Z1fSfmhRde2HXXXUePHh1y+QCD1gEHHDBt2rTLLrts2xdu3bp1wYIFJ5988l577dX949pRz6AkvqmkCy64YM2aNatWrZo7d+5ZZ501dOjQvffee8KECddcc81rr722bNmym2++ueuVR4wYsXbt2pdffnnbt3Dcccftu+++X/jCF1566aWHHnro/PPPnzlz5vDhw8t4bwAGlWuvvfbhhx8+44wzHnvssY6OjhUrVsyYMeP555+/4oorkiTp/nHtqGdQEt9U0vTp06dOnXrkkUcef/zxnd9fqdVqixYtWrZs2ZgxYy666KIvfvGLXa98zjnnXHrppTNnztz2LQwbNmzp0qVPPvnkO9/5zpNOOilN086vCgD0Umtr6wMPPDB69Ojjjz9+5MiRJ5544gEHHPDLX/5y7NixPTquHfUMSrVt76PtKT+vh3ibNm1aunTptGnTRo4cWfa1wFvL8zypGmc7pXPUM4jP9pZePna9Xm9smKapbQ+2bfMb3K6eW8ntWz1Xd91116D6+NoO3m1FVe55ruj2iXkbGtu2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GwAAgohvAAAIIr4BACCI+AYAgCDiGwAAgohvAAAIIr4BACCI+AYAgCDiGwAAgohvAAAIIr4BACCI+AYAgCDiGwAAgohvAAAIIr4BACCI+AYAgCDiGwAAgohvAAAIIr4BACCI+AYAgCDiGwAAgohvAAAIIr4BACCI+AYAgCDiGwAAgohvAAAIIr4BACCI+AYAgCDiGwAAgohvAAAIIr4BACCI+AYAgCDiGwAAqhDfs2fPrr25M844Y+evM3369K43tW7dugsuuOCggw7afffdR48efcwxx3zzm9/csmVL9x9oO7fddlutVlu0aFHnf2xvb6/VagsXLtzu1Z555plarTZv3rzO/zhr1qxt3/Kuu+665557Hnnkkdddd9127/WTTz653ZtauXJlrVY777zzGrtgAAAGvZZkAPj9739/xBFHdOXsxo0bf/qvfvjDH/6P//E/arVaXz3Ql7/85ZNOOumggw7q5utv3br15Zdf/vm/Wr9+/QUXXNBXVwIAQBPq1Xe+r7zyyuL/u/XWW5MkWbx4cddLlixZ0vWaa9asKd5g2bJlnX/6jW9848knn5wxY8by5ctfffXVDRs2/PM///Nhhx2W5/kdd9zRowfauU2bNrW3t3d9Q/3NPPfcc51veevWra+88sp3v/vdYcOGffWrX3399df7/JkBAKB5DIh7vleuXNnS0rJkyZJDDjlk+PDho0aNmjp16u23354kyZ133tmHD/TZz372Zz/72d/93d918/VrtdqIESM+8YlPfPzjH//DH/7w2GOP9eHF3HDDDbVa7corr+zDtwkAwEA2IOJ78uTJmzdvzvN82xeOHz++KIqrr766Dx/okksuaWtr+/KXv/zII4/0aNj5Pe9dd921Dy8GAIBmExTfEyZMeOO/O7z77rs7/3TOnDnHHnvsJz7xidbW1lmzZl177bUPP/xwf1zG8OHDFy9e3NHR0Z2bT5Ik2bJly9q1a7/+9a/fcsstf/Inf3LggQf24cW0t7cXRTF79uw+fJsAAAxkA+I733vsscfdd9+9ZMmSyZMn1+v1s88+e9KkSRMmTLjxxhv7/LGOPfbYz33ucz//+c8vv/zyN3ud/fbbr/O/HrS0tIwbN27OnDlbtmy55JJLfOcbAIAKxPcO/8Hlcccd1/UKu+666+mnn57n+bp161atWrV48eJ99tmnvb39a1/7Wp9fzCWXXPKud73rwgsvXLFixc5fc5dddhkzZsy0adPq9fqZZ57Z+cKWlv/7I2I6Ojq2e+XOl3T+KQAADNDvfG+nra2tvb39Jz/5yWGHHXbxxRf3+dvffffdd37zSddPO9myZcv69euXLVv20Y9+tOtPR40alSTJ888/v93qt7/9bdefAgDAQIzvZ599tlarzZo1a7uXt7S0vOc979mwYcOmTZv6/EHf//73f/7zn7/vvvve+H+785YmTJiwwx/D0vmS1tbWvrtMAAAGlfLvkRg3btx73/ve66+/ftiwYaeffnpra+uoUaOeffbZ//k//+ett956xBFHDBkypD8e96tf/eo//uM/NvDTVI4//vjddtttwYIFo0aNOv3009/+9rf/7ne/+973vnfFFVcMHz78gx/8YH9cLQAAg0CZP+2kVqu98sorSZJcf/31o0ePvuqqq4455ph999139913b2tr+8xnPtPS0tJ/Pwa78+aTBv7vM8eNG/df/+t/3bRp0/nnnz927Njddttt//33P++88zZv3vz3f//3b3/727v5dvycbwCAZjNQfs73ww8/fO65506aNGnPPfccMmTI+PHjzzrrrF/96ldTpkzpv8d9//vfP2fOnAaGf/u3f1uv10844YR99tlnt91222+//U466aRly5adffbZ/XCZAAAMErWiKMq+BgAAaAoD4jvfAADQDMQ3AAAEEd8AABBEfAMAQBDxDQAAQcQ3AAAEEd8AABBEfAMAQBDxDQAAQcQ3AAAEEd8AABBEfAMAQBDxDQAAQcQ3AAAEEd8AABBEfAMAQBDxDQAAQcQ3AAAEEd8AABBEfAMAQBDxDQAAQcQ3AAAEEd8AABBEfAMAQBDxDQAAQcQ3AAAEEd8AABBEfAMAQBDxDQAAQcQ3AAAEEd8AABBEfAMAQBDxDQAAQcQ3AAAEEd8AABBEfAMAQBDxDTDQrV+/fuXKlYPvsQCakPgG6BczZsyo7ciyZct6+qamT59+7733vvHlaZq2t7f30fW+xWMB0CfEN0C/uO2224p/tXjx4hEjRnT+viiK6dOn9/RN/fGPf+yfayz5sQCakPgGKMFzzz03Y8aMPfbY4x3veMcXvvCFruT91re+1draOnLkyMMPP/z2229PkuS444579NFHZ86cOWvWrDd7a+vWravValddddX48eOHDRt2wgknPPvss10vv+666/bff/9Ro0adeeaZnQ/0zDPP1Gq1J598snN++eWXH3XUUd18LAB6Q3wDlOAv//IvR44c+eSTT/7oRz+67777/uZv/iZJkoceeuiCCy647bbb1q1b9/nPf/6000578cUX77777gMPPHDx4sWLFi3a+du88cYb77rrrpUrV65du/YrX/lK18sXLFhw5513Pvjgg/fff//s2bN38ha6/1gANEZ8A0T78Y9/vHz58muuuWbvvfdubW392te+9t//+3/fuHHjb37zmyRJRowYMXTo0DPOOGPjxo177bVX99/sl770pYkTJ44fP769vf2+++7revn8+fMnTZrU2tq6cOHCJUuWvPrqq/3zbgHw1sQ3QLQVK1a89tprQ4cO7fwnmIcffvjWrVufeOKJ448//ogjjjj44IOPOOKIiy666JlnnunRmx0/fnznb0aMGNHR0dH18s5bSpIkOfTQQzdt2vT444/36XsDQA+Ib4BomzdvbmtrK/6td7/73cOGDfvhD3/4k5/8ZNq0ad/5zncOO+ywVatWdf/N7rbbbl2/L4rijS/fsmVLkiQtLS21Wm3bYefLAQggvgGiHXTQQWvWrNnhN7Zrtdoxxxxz6aWXrlixYvjw4f/0T//U+cLePNxDDz3U+ZsHH3xwjz32mDhx4pAhQ5Ik6br/5Kmnntr2AnrzWADsnPgGiPbBD37wkEMOmTlz5tNPP/3ss8/OmTPnne985+uvv/6d73xn/Pjxv/71rzdt2nTPPfc8//zz733veztvI1m7du3LL7/c2MNdcMEFa9asWbVq1dy5c88666yhQ4fuvffeEyZMuOaaa1577bVly5bdfPPNXa/cy8cCYOfEN0C0XXbZpV6vjxgx4uCDD373u9/96KOP/tM//VPnP7L85Cc/+eEPf3jkyJFnnXXW1VdfffTRRydJcs4551x66aUzZ85s7OGmT58+derUI4888vjjj7/ssss6v729aNGiZcuWjRkz5qKLLvriF7/Y9cq9fCwAdq627X2BMLhlWVb2JUCoTZs2LV26dNq0aSNHjiz7WmBn8jwv+xIgSEvUA8GAUK/XGxumaWrbg23b/Aa3q+dWcjuwP0Z33XXXDrZVfJ4H78fIFpqH204AACCI+AYAgCDiGwAAgohvAAAIIr4BACCI+AYAgCDiGwAAgohvAAAIIr4BACCI+AYAgCDiGwAA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"
          },
          {
            "type": "input_text",
            "text": "Above is a visual representation of all the training examples and the test input. Each grid cell is colored according to its value (0-9), with clear labels and arrows showing input\u2192output transformations. Use both the textual and visual information to understand the pattern."
          }
        ]
      },
      {
        "type": "message",
        "role": "assistant",
        "content": [
          "From the visual training examples, we can make several key observations:\n\n- Each input grid shows:\n  - Colored \"rings\" (2x2, 3x3 donuty blocks with a hollow center) of a color (red, blue, green, yellow) not present in the background (0).\n  - 3-block long bars of the same color(s) on the grid edges.\n- In the output grid:\n  - Each \"ring\" is extended: a horizontal or vertical colored bar emerges from each edge of the ring, and if it reaches another edge of the grid, the bar continues to the border and changes direction at the border (L/T/corner).\n  - Every colored bar in the input is transformed into a colored bar on the output.\n  - All output has the same color (from the ring and bars) as the input for each instance.\n  - All processed shapes are on a blank (0) background, the output grid size stays the same as the input grid size.\n\n## Hypothesis\nFor each color:\n1. Find all the 3x3 hollow squares (\"rings\").\n2. For each ring, extend \"arms\" horizontally and vertically in all four directions from the ring until blocked by a grid edge or another ring/bar, filling with that color.\n3. For colored bars on the edges, extend them inward to cross the grid as far as possible.\n\nBut, crucially, in the output each \"ring\" is replaced with an L-corner or T-structure, depending on their placement.\n\n#### More simply, it looks like:\n- Each \"ring\" gets replaced by a T or L shape that forms a continuous colored path along the rows/columns intersecting the centers of the rings and reaching the grid bounds, respecting the bars.\n\nLet's focus on following the majority principle:\n- For each nonzero color:\n    - Identify the centers of all 3x3 hollow colored rings.\n    - For every row and column involving a center, fill that row and/or column (for that color) as far as possible until blocked by another same-color object or an edge.\n    - Any bar present on the edge of the input also \"launches\" a bar row/column into the grid, connecting to a ring if there is one.\n\n## Implementation Plan\n- Find all unique nonzero colors.\n- For each color:\n    - Find all 3x3 hollow rings; get their centers.\n    - For each center, fill (paint) horizontally and vertically, from the edge of the ring to the nearest grid edge or another same-color \"obstacle\".\n    - For colored bars on the grid border, extend into the grid, as far as possible until hitting something.\n- All other cells: 0.\n\n## Additional Notes\n- **ALWAYS produce an 18x17 output grid.** (`height = 18, width = 17`) You may need to crop or pad input accordingly.\n\nFinal answer:\n```python\nimport numpy as np\n\ndef is_hollow_ring(grid, x, y, color):\n    \"\"\"Check if there is a 3x3 hollow square of color anchored at (x, y)\"\"\"\n    # Check bounds\n    h, w = grid.shape\n    if x+2 >= h or y+2 >= w:\n        return False\n    # Ring outline\n    expected = np.array([\n        [color, color, color],\n        [color,   0,   color],\n        [color, color, color],\n    ])\n    block = grid[x:x+3, y:y+3]\n    return np.array_equal(block, expected)\n\ndef find_ring_centers(grid, color):\n    \"\"\"Return list of (x, y) center coordinates of all 3x3 hollow rings of color\"\"\"\n    h, w = grid.shape\n    centers = []\n    for x in range(h-2):\n        for y in range(w-2):\n            if is_hollow_ring(grid, x, y, color):\n                # Center is +1,+1 from topleft\n                centers.append( (x+1, y+1) )\n    return centers\n\ndef mark_row(grid, row, color, block_centers):\n    \"\"\"Fill row with color except through block_centers (if needed)\"\"\"\n    h, w = grid.shape\n    for y in range(w):\n        grid[row, y] = color\n\ndef mark_col(grid, col, color, block_centers):\n    \"\"\"Fill column with color except through block_centers (if needed)\"\"\"\n    h, w = grid.shape\n    for x in range(h):\n        grid[x, col] = color\n\ndef find_bars(grid, color):\n    \"\"\"Find edge bars: returns a list of (orientation, idx, start, end)\"\"\"\n    h, w = grid.shape\n    bars = []\n    # Top edge\n    for y in range(w-2):\n        if np.all(grid[0, y:y+3] == color):\n            bars.append(('horizontal', 0, y, y+2))\n    # Bottom edge\n    for y in range(w-2):\n        if np.all(grid[h-1, y:y+3] == color):\n            bars.append(('horizontal', h-1, y, y+2))\n    # Left edge\n    for x in range(h-2):\n        if np.all(grid[x:x+3, 0] == color):\n            bars.append(('vertical', 0, x, x+2))\n    # Right edge\n    for x in range(h-2):\n        if np.all(grid[x:x+3, w-1] == color):\n            bars.append(('vertical', w-1, x, x+2))\n    return bars\n\ndef transform(grid):\n    import numpy as np\n    grid = np.array(grid)\n    h, w = grid.shape\n    \n    # Always output 18x17\n    out_h, out_w = 18, 17\n    out = np.zeros((out_h, out_w), dtype=\"int\")\n    \n    # If input is not the right shape, crop or pad\n    crop_h = min(h, out_h)\n    crop_w = min(w, out_w)\n    grid = grid[:crop_h, :crop_w]\n    # Pad output for further painting\n    out[:crop_h, :crop_w] = 0\n\n    # Detect color(s) in grid\n    colors = set(np.unique(grid)) - {0}\n    for color in colors:\n        # 1. Find ring centers\n        centers = find_ring_centers(grid, color)\n        # 2. For each center, paint vertical and horizontal\n        for x, y in centers:\n            # Horizontal\n            out[x, :] = np.where(out[x, :]==0, color, out[x, :])\n            # Vertical\n            out[:, y] = np.where(out[:, y]==0, color, out[:, y])\n        # 3. Find and paint edge bars into the grid\n        bars = find_bars(grid, color)\n        for bar in bars:\n            orient, i, start, end = bar\n            if orient == 'horizontal':\n                # row is i, columns start:end+1, fill inward (down) until hitting border or another color\n                row = i\n                for y in range(start, end+1):\n                    # Extend downwards until hitting something painted or border\n                    for x in range(row, out_h):\n                        if out[x, y]!=0:\n                            break\n                        out[x, y]=color\n            else: # vertical\n                # col is i, rows start:end+1, fill rightward (across columns) until hitting border or another color\n                col = i\n                for x in range(start, end+1):\n                    for y in range(col, out_w):\n                        if out[x, y]!=0:\n                            break\n                        out[x, y]=color\n\n    # Ensure shape\n    transformed_grid = out.tolist()\n    return transformed_grid\n```"
        ]
      }
    ],
    "all_responses": [
      {
        "id": "resp_687002f64c90819c92896acb4f532a590a934c6a12264a72",
        "model": "gpt-4.1-2025-04-14",
        "usage": {
          "input_tokens": 7976,
          "output_tokens": 1658,
          "total_tokens": 9634
        },
        "output": [
          {
            "type": "message",
            "content": [
              "From the visual training examples, we can make several key observations:\n\n- Each input grid shows:\n  - Colored \"rings\" (2x2, 3x3 donuty blocks with a hollow center) of a color (red, blue, green, yellow) not present in the background (0).\n  - 3-block long bars of the same color(s) on the grid edges.\n- In the output grid:\n  - Each \"ring\" is extended: a horizontal or vertical colored bar emerges from each edge of the ring, and if it reaches another edge of the grid, the bar continues to the border and changes direction at the border (L/T/corner).\n  - Every colored bar in the input is transformed into a colored bar on the output.\n  - All output has the same color (from the ring and bars) as the input for each instance.\n  - All processed shapes are on a blank (0) background, the output grid size stays the same as the input grid size.\n\n## Hypothesis\nFor each color:\n1. Find all the 3x3 hollow squares (\"rings\").\n2. For each ring, extend \"arms\" horizontally and vertically in all four directions from the ring until blocked by a grid edge or another ring/bar, filling with that color.\n3. For colored bars on the edges, extend them inward to cross the grid as far as possible.\n\nBut, crucially, in the output each \"ring\" is replaced with an L-corner or T-structure, depending on their placement.\n\n#### More simply, it looks like:\n- Each \"ring\" gets replaced by a T or L shape that forms a continuous colored path along the rows/columns intersecting the centers of the rings and reaching the grid bounds, respecting the bars.\n\nLet's focus on following the majority principle:\n- For each nonzero color:\n    - Identify the centers of all 3x3 hollow colored rings.\n    - For every row and column involving a center, fill that row and/or column (for that color) as far as possible until blocked by another same-color object or an edge.\n    - Any bar present on the edge of the input also \"launches\" a bar row/column into the grid, connecting to a ring if there is one.\n\n## Implementation Plan\n- Find all unique nonzero colors.\n- For each color:\n    - Find all 3x3 hollow rings; get their centers.\n    - For each center, fill (paint) horizontally and vertically, from the edge of the ring to the nearest grid edge or another same-color \"obstacle\".\n    - For colored bars on the grid border, extend into the grid, as far as possible until hitting something.\n- All other cells: 0.\n\n## Additional Notes\n- **ALWAYS produce an 18x17 output grid.** (`height = 18, width = 17`) You may need to crop or pad input accordingly.\n\nFinal answer:\n```python\nimport numpy as np\n\ndef is_hollow_ring(grid, x, y, color):\n    \"\"\"Check if there is a 3x3 hollow square of color anchored at (x, y)\"\"\"\n    # Check bounds\n    h, w = grid.shape\n    if x+2 >= h or y+2 >= w:\n        return False\n    # Ring outline\n    expected = np.array([\n        [color, color, color],\n        [color,   0,   color],\n        [color, color, color],\n    ])\n    block = grid[x:x+3, y:y+3]\n    return np.array_equal(block, expected)\n\ndef find_ring_centers(grid, color):\n    \"\"\"Return list of (x, y) center coordinates of all 3x3 hollow rings of color\"\"\"\n    h, w = grid.shape\n    centers = []\n    for x in range(h-2):\n        for y in range(w-2):\n            if is_hollow_ring(grid, x, y, color):\n                # Center is +1,+1 from topleft\n                centers.append( (x+1, y+1) )\n    return centers\n\ndef mark_row(grid, row, color, block_centers):\n    \"\"\"Fill row with color except through block_centers (if needed)\"\"\"\n    h, w = grid.shape\n    for y in range(w):\n        grid[row, y] = color\n\ndef mark_col(grid, col, color, block_centers):\n    \"\"\"Fill column with color except through block_centers (if needed)\"\"\"\n    h, w = grid.shape\n    for x in range(h):\n        grid[x, col] = color\n\ndef find_bars(grid, color):\n    \"\"\"Find edge bars: returns a list of (orientation, idx, start, end)\"\"\"\n    h, w = grid.shape\n    bars = []\n    # Top edge\n    for y in range(w-2):\n        if np.all(grid[0, y:y+3] == color):\n            bars.append(('horizontal', 0, y, y+2))\n    # Bottom edge\n    for y in range(w-2):\n        if np.all(grid[h-1, y:y+3] == color):\n            bars.append(('horizontal', h-1, y, y+2))\n    # Left edge\n    for x in range(h-2):\n        if np.all(grid[x:x+3, 0] == color):\n            bars.append(('vertical', 0, x, x+2))\n    # Right edge\n    for x in range(h-2):\n        if np.all(grid[x:x+3, w-1] == color):\n            bars.append(('vertical', w-1, x, x+2))\n    return bars\n\ndef transform(grid):\n    import numpy as np\n    grid = np.array(grid)\n    h, w = grid.shape\n    \n    # Always output 18x17\n    out_h, out_w = 18, 17\n    out = np.zeros((out_h, out_w), dtype=\"int\")\n    \n    # If input is not the right shape, crop or pad\n    crop_h = min(h, out_h)\n    crop_w = min(w, out_w)\n    grid = grid[:crop_h, :crop_w]\n    # Pad output for further painting\n    out[:crop_h, :crop_w] = 0\n\n    # Detect color(s) in grid\n    colors = set(np.unique(grid)) - {0}\n    for color in colors:\n        # 1. Find ring centers\n        centers = find_ring_centers(grid, color)\n        # 2. For each center, paint vertical and horizontal\n        for x, y in centers:\n            # Horizontal\n            out[x, :] = np.where(out[x, :]==0, color, out[x, :])\n            # Vertical\n            out[:, y] = np.where(out[:, y]==0, color, out[:, y])\n        # 3. Find and paint edge bars into the grid\n        bars = find_bars(grid, color)\n        for bar in bars:\n            orient, i, start, end = bar\n            if orient == 'horizontal':\n                # row is i, columns start:end+1, fill inward (down) until hitting border or another color\n                row = i\n                for y in range(start, end+1):\n                    # Extend downwards until hitting something painted or border\n                    for x in range(row, out_h):\n                        if out[x, y]!=0:\n                            break\n                        out[x, y]=color\n            else: # vertical\n                # col is i, rows start:end+1, fill rightward (across columns) until hitting border or another color\n                col = i\n                for x in range(start, end+1):\n                    for y in range(col, out_w):\n                        if out[x, y]!=0:\n                            break\n                        out[x, y]=color\n\n    # Ensure shape\n    transformed_grid = out.tolist()\n    return transformed_grid\n```"
            ]
          }
        ]
      }
    ]
  }
}