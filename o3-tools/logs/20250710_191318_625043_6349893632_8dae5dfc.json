{
  "task_id": "8dae5dfc",
  "model": "gpt-4.1",
  "reasoning_effort": "N/A",
  "api_type": "responses_api_multiturn",
  "program": "import numpy as np\nfrom collections import Counter, deque\n\ndef find_connected_components(grid):\n    \"\"\"Return list of mask arrays, one for each connected component of nonzero cells.\"\"\"\n    grid = np.array(grid)\n    h, w = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    masks = []\n    for i in range(h):\n        for j in range(w):\n            if grid[i,j]!=0 and not visited[i,j]:\n                # BFS to get connected component\n                mask = np.zeros_like(grid, dtype=bool)\n                q = deque()\n                q.append((i,j))\n                visited[i,j] = True\n                mask[i,j] = True\n                while q:\n                    ci,cj = q.popleft()\n                    for di,dj in [(-1,0),(1,0),(0,-1),(0,1)]:\n                        ni,nj = ci+di, cj+dj\n                        if 0<=ni<h and 0<=nj<w and not visited[ni,nj] and grid[ni,nj]!=0:\n                            visited[ni,nj] = True\n                            mask[ni,nj] = True\n                            q.append((ni,nj))\n                masks.append(mask)\n    return masks\n\ndef extract_layers(block, block_mask):\n    \"\"\"\n    From block (grid of ints), and block_mask (bool, True where block exists),\n    return a list of (layer_color, layer_mask), ordered from outermost to innermost.\n    Each layer_mask is bool (True for the band).\n    \"\"\"\n    # Get bounding box\n    rows,cols = np.where(block_mask)\n    minr, maxr = rows.min(), rows.max()\n    minc, maxc = cols.min(), cols.max()\n    submask = block_mask[minr:maxr+1, minc:maxc+1]\n    subgrid = block[minr:maxr+1, minc:maxc+1]\n    # The layer structure is such that each \"band\" is a rectangle, each with a solid color\n    layers = []\n    m, n = submask.shape\n    cur = submask.copy()\n    background = (subgrid==0) | ~cur\n    # Find unique nonzero colors in order of pixel count (outermost first)\n    palette = [c for c,cnt in Counter(subgrid[cur].ravel()).most_common()]\n    for color in palette:\n        # Band: those cells with color 'color', that are not yet part of earlier layers (i.e., current mask)\n        band = (subgrid==color) & cur\n        if band.sum()==0:\n            continue\n        layers.append((color, band.copy()))\n        cur[band] = False # remove them from 'cur', move inward\n    return layers, (minr, minc)\n\ndef permute_colors(colors):\n    \"\"\"Rotate the palette left by 1.\"\"\"\n    # Examples use a leftward/circular shift by 1 for each block\n    if len(colors) == 0:\n        return colors\n    return colors[1:] + colors[:1]\n\ndef transform(grid):\n    import numpy as np\n    grid = np.array(grid)\n    h,w = grid.shape\n    transformed = np.zeros_like(grid)\n    # Find blocks (connected components of nonzero cells)\n    masks = find_connected_components(grid)\n    for block_mask in masks:\n        # extract the block\n        layers, (minr, minc) = extract_layers(grid, block_mask)\n        if not layers:\n            continue\n        # Build palette, outermost to innermost\n        in_colors = [c for c,mask in layers]\n        # Output color mapping: rotate palette left by 1\n        out_colors = permute_colors(in_colors)\n        # For each layer, assign the new color\n        # reconstruct the block\n        for (in_color, layer_mask), out_color in zip(layers, out_colors):\n            # layer_mask is submatrix over block\n            rows, cols = np.where(layer_mask)\n            for r0,c0 in zip(rows,cols):\n                r, c = minr + r0, minc + c0\n                transformed[r,c] = out_color\n    return transformed.tolist()",
  "execution_error": "Max turns reached",
  "timed_out": false,
  "tokens_used": 9084,
  "request_cost": 0.026304,
  "turns_used": 1,
  "raw_response": {
    "id": "resp_687002a982c48192825463a5c559bb4e0270edfd8e6c28f5",
    "model": "gpt-4.1-2025-04-14",
    "usage": {
      "input_tokens": 7728,
      "output_tokens": 1356,
      "total_tokens": 9084
    },
    "output": [
      {
        "type": "message",
        "content": [
          "From analyzing the examples, we observe:\n\n- The grids contain \"blocks\"\u2014rectangles or squares of nested color bands (concentric rectangles).\n- In each pair, the nested blocks have their colors changed in a specific systematic way, but the blocks' positions/shapes stay the same.\n- The output grid is always the same size as the input.\n- The color remapping is **consistent within each block** but varies per block (i.e., different regions use different remappings).\n- For each block, **the outermost color in the input becomes the outermost color in the output, the next-to-outermost input color maps to the next-to-outermost output color, etc.** (the set of output colors usually matches one of the input block's colors or a permuted set).\n\n# Hypothesis\n\n- Each block's color layers are mapped to new values, but the *relative* band structure stays the same.\n- The transformation for each block is: \n    - For the *largest* color region: assign it the *outermost* color in the output for that block\n    - For the *next* largest color region (the next \"layer\" inside): assign the *next outermost output color*\n    - And so on, working inwards.\n- The color palette used for an output block is generally a circular permutation (rotation) of the block's input palette (e.g., green becomes outer, orange becomes middle, blue becomes inner, etc), but always preserves the nesting structure.\n\n# Implementation Plan\n\n1. **Segment blocks:** Detect each distinct outer block in the grid (connected components that are not color 0).\n2. **For each block:**\n    - Extract the color band layers from outer to inner (ignore the zeros/background).\n    - Map these bands to a new color sequence (by rotating left, as seen in examples; or by shifting colors so the outermost becomes the block's unique color in output).\n    - Replace the block's colors according to the mapping.\n3. **Place all blocks back in their original positions.**\n\n# Let's proceed with code. We'll use `scipy.ndimage.label` and `skimage.measure.regionprops` if needed for connected components, or just use a BFS if keeping it simple.\n\nFinal answer:\n```python\nimport numpy as np\nfrom collections import Counter, deque\n\ndef find_connected_components(grid):\n    \"\"\"Return list of mask arrays, one for each connected component of nonzero cells.\"\"\"\n    grid = np.array(grid)\n    h, w = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    masks = []\n    for i in range(h):\n        for j in range(w):\n            if grid[i,j]!=0 and not visited[i,j]:\n                # BFS to get connected component\n                mask = np.zeros_like(grid, dtype=bool)\n                q = deque()\n                q.append((i,j))\n                visited[i,j] = True\n                mask[i,j] = True\n                while q:\n                    ci,cj = q.popleft()\n                    for di,dj in [(-1,0),(1,0),(0,-1),(0,1)]:\n                        ni,nj = ci+di, cj+dj\n                        if 0<=ni<h and 0<=nj<w and not visited[ni,nj] and grid[ni,nj]!=0:\n                            visited[ni,nj] = True\n                            mask[ni,nj] = True\n                            q.append((ni,nj))\n                masks.append(mask)\n    return masks\n\ndef extract_layers(block, block_mask):\n    \"\"\"\n    From block (grid of ints), and block_mask (bool, True where block exists),\n    return a list of (layer_color, layer_mask), ordered from outermost to innermost.\n    Each layer_mask is bool (True for the band).\n    \"\"\"\n    # Get bounding box\n    rows,cols = np.where(block_mask)\n    minr, maxr = rows.min(), rows.max()\n    minc, maxc = cols.min(), cols.max()\n    submask = block_mask[minr:maxr+1, minc:maxc+1]\n    subgrid = block[minr:maxr+1, minc:maxc+1]\n    # The layer structure is such that each \"band\" is a rectangle, each with a solid color\n    layers = []\n    m, n = submask.shape\n    cur = submask.copy()\n    background = (subgrid==0) | ~cur\n    # Find unique nonzero colors in order of pixel count (outermost first)\n    palette = [c for c,cnt in Counter(subgrid[cur].ravel()).most_common()]\n    for color in palette:\n        # Band: those cells with color 'color', that are not yet part of earlier layers (i.e., current mask)\n        band = (subgrid==color) & cur\n        if band.sum()==0:\n            continue\n        layers.append((color, band.copy()))\n        cur[band] = False # remove them from 'cur', move inward\n    return layers, (minr, minc)\n\ndef permute_colors(colors):\n    \"\"\"Rotate the palette left by 1.\"\"\"\n    # Examples use a leftward/circular shift by 1 for each block\n    if len(colors) == 0:\n        return colors\n    return colors[1:] + colors[:1]\n\ndef transform(grid):\n    import numpy as np\n    grid = np.array(grid)\n    h,w = grid.shape\n    transformed = np.zeros_like(grid)\n    # Find blocks (connected components of nonzero cells)\n    masks = find_connected_components(grid)\n    for block_mask in masks:\n        # extract the block\n        layers, (minr, minc) = extract_layers(grid, block_mask)\n        if not layers:\n            continue\n        # Build palette, outermost to innermost\n        in_colors = [c for c,mask in layers]\n        # Output color mapping: rotate palette left by 1\n        out_colors = permute_colors(in_colors)\n        # For each layer, assign the new color\n        # reconstruct the block\n        for (in_color, layer_mask), out_color in zip(layers, out_colors):\n            # layer_mask is submatrix over block\n            rows, cols = np.where(layer_mask)\n            for r0,c0 in zip(rows,cols):\n                r, c = minr + r0, minc + c0\n                transformed[r,c] = out_color\n    return transformed.tolist()\n```\n"
        ]
      }
    ]
  },
  "score": {
    "correct": false,
    "pixel_accuracy": 0.0,
    "total_pixels": 380,
    "correct_pixels": 0,
    "error": "Max turns reached"
  },
  "actual_output": [
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      4,
      4,
      1,
      1,
      1,
      1,
      1,
      1,
      4,
      4,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      4,
      4,
      1,
      6,
      6,
      6,
      6,
      1,
      4,
      4,
      0,
      0,
      8,
      8,
      8,
      8,
      8,
      8
    ],
    [
      0,
      4,
      4,
      1,
      6,
      3,
      3,
      6,
      1,
      4,
      4,
      0,
      0,
      8,
      4,
      4,
      4,
      4,
      8
    ],
    [
      0,
      4,
      4,
      1,
      6,
      6,
      6,
      6,
      1,
      4,
      4,
      0,
      0,
      8,
      4,
      5,
      5,
      4,
      8
    ],
    [
      0,
      4,
      4,
      1,
      1,
      1,
      1,
      1,
      1,
      4,
      4,
      0,
      0,
      8,
      4,
      5,
      5,
      4,
      8
    ],
    [
      0,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      0,
      0,
      8,
      4,
      4,
      4,
      4,
      8
    ],
    [
      0,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      0,
      0,
      8,
      8,
      8,
      8,
      8,
      8
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      3,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      3,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      3,
      4,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      4,
      3,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      3,
      4,
      2,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      2,
      4,
      3,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      3,
      4,
      2,
      8,
      6,
      6,
      6,
      6,
      6,
      8,
      2,
      4,
      3,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      3,
      4,
      2,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      2,
      4,
      3,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      3,
      4,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      4,
      3,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      3,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      3,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      0,
      0,
      0
    ]
  ],
  "api_success": true,
  "multiturn_data": {
    "turn_details": [
      {
        "turn_number": 1,
        "timestamp": "2025-07-10T19:12:57.387057",
        "input_tokens": 7728,
        "output_tokens": 1356,
        "turn_cost": 0.026304,
        "program_extracted": true,
        "program": "import numpy as np\nfrom collections import Counter, deque\n\ndef find_connected_components(grid):\n    \"\"\"Return list of mask arrays, one for each connected component of nonzero cells.\"\"\"\n    grid = np.array(grid)\n    h, w = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    masks = []\n    for i in range(h):\n        for j in range(w):\n            if grid[i,j]!=0 and not visited[i,j]:\n                # BFS to get connected component\n                mask = np.zeros_like(grid, dtype=bool)\n                q = deque()\n                q.append((i,j))\n                visited[i,j] = True\n                mask[i,j] = True\n                while q:\n                    ci,cj = q.popleft()\n                    for di,dj in [(-1,0),(1,0),(0,-1),(0,1)]:\n                        ni,nj = ci+di, cj+dj\n                        if 0<=ni<h and 0<=nj<w and not visited[ni,nj] and grid[ni,nj]!=0:\n                            visited[ni,nj] = True\n                            mask[ni,nj] = True\n                            q.append((ni,nj))\n                masks.append(mask)\n    return masks\n\ndef extract_layers(block, block_mask):\n    \"\"\"\n    From block (grid of ints), and block_mask (bool, True where block exists),\n    return a list of (layer_color, layer_mask), ordered from outermost to innermost.\n    Each layer_mask is bool (True for the band).\n    \"\"\"\n    # Get bounding box\n    rows,cols = np.where(block_mask)\n    minr, maxr = rows.min(), rows.max()\n    minc, maxc = cols.min(), cols.max()\n    submask = block_mask[minr:maxr+1, minc:maxc+1]\n    subgrid = block[minr:maxr+1, minc:maxc+1]\n    # The layer structure is such that each \"band\" is a rectangle, each with a solid color\n    layers = []\n    m, n = submask.shape\n    cur = submask.copy()\n    background = (subgrid==0) | ~cur\n    # Find unique nonzero colors in order of pixel count (outermost first)\n    palette = [c for c,cnt in Counter(subgrid[cur].ravel()).most_common()]\n    for color in palette:\n        # Band: those cells with color 'color', that are not yet part of earlier layers (i.e., current mask)\n        band = (subgrid==color) & cur\n        if band.sum()==0:\n            continue\n        layers.append((color, band.copy()))\n        cur[band] = False # remove them from 'cur', move inward\n    return layers, (minr, minc)\n\ndef permute_colors(colors):\n    \"\"\"Rotate the palette left by 1.\"\"\"\n    # Examples use a leftward/circular shift by 1 for each block\n    if len(colors) == 0:\n        return colors\n    return colors[1:] + colors[:1]\n\ndef transform(grid):\n    import numpy as np\n    grid = np.array(grid)\n    h,w = grid.shape\n    transformed = np.zeros_like(grid)\n    # Find blocks (connected components of nonzero cells)\n    masks = find_connected_components(grid)\n    for block_mask in masks:\n        # extract the block\n        layers, (minr, minc) = extract_layers(grid, block_mask)\n        if not layers:\n            continue\n        # Build palette, outermost to innermost\n        in_colors = [c for c,mask in layers]\n        # Output color mapping: rotate palette left by 1\n        out_colors = permute_colors(in_colors)\n        # For each layer, assign the new color\n        # reconstruct the block\n        for (in_color, layer_mask), out_color in zip(layers, out_colors):\n            # layer_mask is submatrix over block\n            rows, cols = np.where(layer_mask)\n            for r0,c0 in zip(rows,cols):\n                r, c = minr + r0, minc + c0\n                transformed[r,c] = out_color\n    return transformed.tolist()",
        "training_feedback": {
          "feedback_messages": [
            {
              "type": "input_text",
              "text": "Training results: 0/4 examples solved, 57.3% pixel accuracy - Good partial progress! Your approach is capturing some patterns. Next, try to identify a transformation that solves at least one of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 4, 4, 4, 4, 4, 4, 4, 4, 3, 0, 3, 3, 3, 3, 3, 3], [0, 0, 3, 4, 4, 4, 4, 4, 4, 4, 4, 3, 0, 3, 1, 1, 1, 1, 3], [0, 0, 3, 4, 4, 7, 7, 7, 7, 4, 4, 3, 0, 3, 1, 2, 2, 1, 3], [0, 0, 3, 4, 4, 7, 8, 8, 7, 4, 4, 3, 0, 3, 1, 2, 2, 1, 3], [0, 0, 3, 4, 4, 7, 8, 8, 7, 4, 4, 3, 0, 3, 1, 1, 1, 1, 3], [0, 0, 3, 4, 4, 7, 8, 8, 7, 4, 4, 3, 0, 3, 3, 3, 3, 3, 3], [0, 0, 3, 4, 4, 7, 8, 8, 7, 4, 4, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 4, 4, 7, 8, 8, 7, 4, 4, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 4, 4, 7, 7, 7, 7, 4, 4, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 4, 4, 4, 4, 4, 4, 4, 4, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 4, 4, 4, 4, 4, 4, 4, 4, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 8, 8, 8, 8, 8, 8, 8, 8, 4, 0, 1, 1, 1, 1, 1, 1], [0, 0, 4, 8, 8, 8, 8, 8, 8, 8, 8, 4, 0, 1, 3, 3, 3, 3, 1], [0, 0, 4, 8, 8, 3, 3, 3, 3, 8, 8, 4, 0, 1, 3, 2, 2, 3, 1], [0, 0, 4, 8, 8, 3, 7, 7, 3, 8, 8, 4, 0, 1, 3, 2, 2, 3, 1], [0, 0, 4, 8, 8, 3, 7, 7, 3, 8, 8, 4, 0, 1, 3, 3, 3, 3, 1], [0, 0, 4, 8, 8, 3, 7, 7, 3, 8, 8, 4, 0, 1, 1, 1, 1, 1, 1], [0, 0, 4, 8, 8, 3, 7, 7, 3, 8, 8, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 8, 8, 3, 7, 7, 3, 8, 8, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 8, 8, 3, 3, 3, 3, 8, 8, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 8, 8, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 8, 8, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 52.6%\n\nTraining Example 2 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 8, 8, 8, 8, 8, 8, 8, 8, 2, 2, 0, 0], [0, 0, 2, 2, 8, 3, 3, 3, 3, 3, 3, 8, 2, 2, 0, 0], [0, 0, 2, 2, 8, 3, 3, 3, 3, 3, 3, 8, 2, 2, 0, 0], [0, 0, 2, 2, 8, 3, 3, 1, 1, 3, 3, 8, 2, 2, 0, 0], [0, 0, 2, 2, 8, 3, 3, 1, 1, 3, 3, 8, 2, 2, 0, 0], [0, 0, 2, 2, 8, 3, 3, 3, 3, 3, 3, 8, 2, 2, 0, 0], [0, 0, 2, 2, 8, 3, 3, 3, 3, 3, 3, 8, 2, 2, 0, 0], [0, 0, 2, 2, 8, 8, 8, 8, 8, 8, 8, 8, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 0, 8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 8, 8, 0, 0], [0, 0, 8, 8, 2, 3, 3, 3, 3, 3, 3, 2, 8, 8, 0, 0], [0, 0, 8, 8, 2, 3, 3, 3, 3, 3, 3, 2, 8, 8, 0, 0], [0, 0, 8, 8, 2, 3, 3, 1, 1, 3, 3, 2, 8, 8, 0, 0], [0, 0, 8, 8, 2, 3, 3, 1, 1, 3, 3, 2, 8, 8, 0, 0], [0, 0, 8, 8, 2, 3, 3, 3, 3, 3, 3, 2, 8, 8, 0, 0], [0, 0, 8, 8, 2, 3, 3, 3, 3, 3, 3, 2, 8, 8, 0, 0], [0, 0, 8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 8, 8, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 62.5%\n\nTraining Example 3 \u2717:\nExpected: [[1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 2, 2, 2, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 2, 8, 8, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 2, 8, 8, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 2, 2, 2, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 0], [0, 0, 0, 0, 1, 2, 4, 4, 4, 4, 4, 4, 4, 4, 2, 1, 0], [0, 0, 0, 0, 1, 2, 4, 3, 3, 3, 3, 3, 3, 4, 2, 1, 0], [0, 0, 0, 0, 1, 2, 4, 3, 6, 6, 6, 6, 3, 4, 2, 1, 0], [0, 0, 0, 0, 1, 2, 4, 3, 6, 6, 6, 6, 3, 4, 2, 1, 0], [0, 0, 0, 0, 1, 2, 4, 3, 3, 3, 3, 3, 3, 4, 2, 1, 0], [0, 0, 0, 0, 1, 2, 4, 4, 4, 4, 4, 4, 4, 4, 2, 1, 0], [0, 0, 0, 0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]]\nYour output: [[2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 1, 8, 8, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 1, 8, 8, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 0], [0, 0, 0, 0, 3, 4, 2, 2, 2, 2, 2, 2, 2, 2, 4, 3, 0], [0, 0, 0, 0, 3, 4, 2, 1, 1, 1, 1, 1, 1, 2, 4, 3, 0], [0, 0, 0, 0, 3, 4, 2, 1, 6, 6, 6, 6, 1, 2, 4, 3, 0], [0, 0, 0, 0, 3, 4, 2, 1, 6, 6, 6, 6, 1, 2, 4, 3, 0], [0, 0, 0, 0, 3, 4, 2, 1, 1, 1, 1, 1, 1, 2, 4, 3, 0], [0, 0, 0, 0, 3, 4, 2, 2, 2, 2, 2, 2, 2, 2, 4, 3, 0], [0, 0, 0, 0, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0]]\nPixel accuracy: 50.2%\n\nTraining Example 4 \u2717:\nExpected: [[0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 6, 6, 6, 6, 6, 8, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 6, 1, 1, 1, 6, 8, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 6, 6, 6, 6, 6, 8, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 0, 0, 0, 0, 0, 0], [0, 8, 1, 4, 4, 4, 4, 4, 4, 4, 4, 1, 8, 0, 0, 0, 0, 0, 0], [0, 8, 1, 4, 2, 2, 2, 2, 2, 2, 4, 1, 8, 0, 0, 0, 0, 0, 0], [0, 8, 1, 4, 2, 2, 2, 2, 2, 2, 4, 1, 8, 0, 0, 0, 0, 0, 0], [0, 8, 1, 4, 4, 4, 4, 4, 4, 4, 4, 1, 8, 0, 0, 0, 0, 0, 0], [0, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 6, 8, 8, 8, 8, 8, 6, 6, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 6, 8, 1, 1, 1, 8, 6, 6, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 6, 8, 8, 8, 8, 8, 6, 6, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0], [0, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 0, 0, 0, 0, 0, 0], [0, 4, 1, 8, 8, 8, 8, 8, 8, 8, 8, 1, 4, 0, 0, 0, 0, 0, 0], [0, 4, 1, 8, 2, 2, 2, 2, 2, 2, 8, 1, 4, 0, 0, 0, 0, 0, 0], [0, 4, 1, 8, 2, 2, 2, 2, 2, 2, 8, 1, 4, 0, 0, 0, 0, 0, 0], [0, 4, 1, 8, 8, 8, 8, 8, 8, 8, 8, 1, 4, 0, 0, 0, 0, 0, 0], [0, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 64.1%\n\n"
            },
            {
              "type": "input_image",
              "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA38AAAZ8CAIAAAA1eavRAABqgUlEQVR4nO3de5gU9Z3o/2rkIgrOKBoVwSRIRHOIaLwbNUbZJwqi3QGTk6wxsHghWSRBQTSH1RMXV3Q4sjEX44kCGuMmG5NuL4uGeKIYN2JYZYn3gGAWARNFB0WQi9Tvib07PxZlxO7hU9PTr9eTP4ae/nTV1FR/552u6TGXpmkCAAAhOsVsBgAA1CcAAKHUJwAAcdQnAABx1CcAAHHUJwAAcdQnAABx1CcAAHHUJwAAcdQnAABx1CcAAHHUJwAAcdQnAAA1Up9jx47NbdvZZ5/9nvfp2rXrPvvsc8YZZzz++OPvfsxf/epXuVxujz32eOutt7b61B133JHL5W666abyP0eOHJnL5Zqamra624svvpjL5SZPnlzNVNlbb7114403fuYzn+ndu3e3bt169+591lln/eY3v2nlmEyePHlbB+TJJ59s/aANHjz4fQ9sy33OPffcLW8v797w4cMfeeSRLfcnn89vdbePfvSj48aNe+211z7QwS975ZVXpkyZcthhhzU0NOy6665HHXXUTTfdlKbpVpvbavyxxx7ba6+9evbs+cADD7Ry6ACAepDBa58bN27805/+dPfdd3/mM59ZsmTJVp+dMWNGkiSvvfbaT3/60+15tMsvv/zZZ5/9oPuwPVMvvPDCscceO2bMmAcffHDlypUbNmxYuXLlHXfcceKJJ1533XVJO1PevV/84hfHH3/8j3/841bu9sILL3znO9859dRTN2/e/IEO/iOPPDJo0KC/+7u/+/d///fXX3997dq18+fPP++880aPHt3Kjv3617/+zGc+8/bbb99///2f+cxnqvgSAYCk3uvzu9/9bvpffvaznyVJMnPmzJZbbrvttpZ7Ll26tOX2t95665lnnvnSl770+uuv33DDDVs+YHNzc6lUOuuss/bYY48f/OAH27MPGzZsGDly5Ntvv/2B9vx9pzZu3DhixIh///d/P+644+66665XXnll48aN//Ef//H9739/jz32uOSSS8ovZG7LggUL0ncZOHDgex6QFvfff/+WD7I991m5cmX59nXr1i1evPjSSy9N0/Rv/uZv/vjHP255t3Xr1m158AcPHvy73/3uV7/61fYf/D//+c+FQmHFihVf/OIX582b9/rrr7/66qulUqlfv34zZ8688cYb3/M4FIvFIUOG7LLLLg8++ODRRx/dyhEDAOpEBq99duvW7aCDDrrmmmuSJNnqtc/bb7/9rbfeuuCCC0aNGjVv3rzf//737/toF1544aOPPvp//s//+UD78L5Tt9xyy2OPPTZ48OCHHnpo2LBhvXr16ty5c9++fb/61a/+4he/ePvtt//pn/4paU923nnnAw444Oqrr7788ss3bNjwj//4j60c/G984xvlct3+g3/dddf96U9/Gj9+/O2333700Uf37Nlz9913P/PMM+fOnbvrrrted911W15/L7v55pvPOuusD33oQ7/5zW8OOeSQlttnzZqVy+W++93vtukBAABqQwb1uX79+qeeeuqiiy5KkuTAAw/c8lMzZ848+OCDTz755K9+9as77bTT9rz8+Q//8A/9+/e//PLLn3nmme3fh/eduv3223O53P/9v/93p5122upTn/70p59++ukpU6Yk7dLFF1+8yy67/PKXv3zPz27cuPEPf/jD9ddf37lz509/+tPbf/D/+Z//uXv37ldeeeVWD9inT5+HH374wQcfzOVyW95+7bXXnnvuuf369Xv44Yc/9rGPtd3XBwDUtqD6/OhHP9ryxpedd9554MCBP/vZz/bcc8+vf/3rLfd58skn/+3f/m3ixIm5XO6AAw4466yzfvzjH69Zs6b1R95ll11mzpy5cePGD3T9/X2nFixYcPDBB3/0ox99z/GDDz54q9jaymGHHbbVu4UefvjhbR2QFg8++OAHvc+79ezZ82Mf+9hWLyp37969PN61a9cBAwb867/+6y233LLlV9f6wd+4ceMLL7xw1FFH9ejR491bPPTQQ/fdd98tb7nkkksmTZqUJMkJJ5yw//77b3X/kSNHpmk6duzY1r8QAKBDyuYvLu23335/8zd/s3Dhwn322aflxhkzZuy3335//dd/Xf7nZZdd9sYbb2zPBe7jjz9+3Lhxv/vd76ZNm7b9+9DK1MaNG5ubm/fee+8tb9zqfegf+chHkvaqV69e69+xrTu8/fbb8+bN27hx43Ye/Obm5jRNe/XqtZ078J3vfOfYY48dPHjwjBkzfvGLX1T31QAAHUpQfZbfQLNhw4af/OQn5Rfnpk6d2rt375Y7bNy48bbbblu+fHm3bt3KeTdo0KA0TbfzvUf/8A//8LGPfeyKK654+umnt3+vtjXVpUuXnj17vvzyy0ml3v2uo+OPP/5931F00kknfdD7vKfXXnutS5cu3bp1e/e7jjZs2LBkyZK//du//c53vjNhwoTtPPh77LFHp06dtv+AjBo16sEHH7z11lv32GOP8847b/ny5ds5CAB0eKGvfXbp0uULX/jCT3/607lz55566qlb/lXIe+655z3j5vHHH58/f/77PnL37t0ruP7eytQnPvGJp59++j/+4z/e8w3+hx9+eNJerVmz5sknnzz44IPf87NdunT56Ec/Om3atIEDB86aNWs7D/5OO+108MEH/9u//dvatWvffberr776nHPOWbFiRcst3//+97t27brvvvt+97vfffXVV88555x3/3UnAKA+ZXDl/bTTTrvwwgsff/zxltfeyld+d95559WrV2/5Ot9vf/vbJEm29dd8tvKpT33q61//+vz589/9l+QrmPrrv/7rzZs3f+1rX3vPln33+7vbj+nTp2/cuPHUU09t/W6dOnVas2bNpk2btvPg5/P5devW/e///b+3epwXXnjh2muvveeee97zuvwXv/jFESNG/PrXv/5AvxQBAHRg2fze5z/8wz/sv//+N9xww6OPPpokyUsvvXTfffcNGzZst9122/Juxx577IABA/7pn/5p9erV2/OwV1111cc+9rHvf//7H2hn3nPq3HPPPfzww//lX/7lqKOO+ud//ueXXnpp48aN5b82P3To0Mcff7xTp/b1Hyldv379c889N3ny5G9961u77LLLtt7Tk6bpiy++OHHixN///veHHXZY586dt/Pgjx8/vlevXk1NTeecc86//du/rVu37k9/+tPtt99+0kknNTc3T5w4ccsL/Vu64YYb9t5778mTJz/22GM75ksHAGpJNgm16667fuc739m8efMFF1ywadOmW2+9ddOmTS1vednSV77ylbVr1/7oRz/a/ivprb8bfTununbtWiqVjj322Mcff/wLX/jCvvvu27Vr1/J/aXP27NkDBgzYzv8U07a85/vZc7nclu/x35777Lvvvi1/SeCggw666qqryv9Z0b59+271NZbv1qlTp759+06bNq1Tp07lPxq1nQe/V69eP/3pT3v27PmjH/3oyCOP3GWXXfbZZ5+//uu//uMf/1goFC655JJtfaV77rnnD3/4w40bN37pS1968803/b1PAKhzmb2Ad8YZZ+Tz+YULF/7jP/7jrFmzdt9999NOO+3ddzvnnHM6deq0nRffy1fSy39K/QN5z6k+ffr85je/ue2224YMGdKnT5+uXbvuvffeQ4YMueWWW5588skjjzwyaU+6dOnSt2/f//k//+e//uu/fvGLX9zW3XbaaacPfehDQ4cO/dWvflW+Or/9B/+UU05ZsGDBuHHjDjrooB49enTv3v3oo4++6aabfv7zn7/7r6JuadiwYSNHjvzDH/6w5R/YAgDqU649/wojAAAdTPv65UUAADo29QkAQBz1CQBAHPUJAEAc9QkAQBz1CQBAHPUJAEAc9QkAQBz1CQBAHPUJAEAc9QkAQBz1CQBAHPUJAEAc9QkAQBz1CQBAHPUJAEAc9QkAQBz1CQBAHPUJAEAc9QkAQBz1CQBAHPUJAEAc9QkAQBz1CQBAHPUJAEAc9QkAQBz1CQBAHPUJAEAc9QkAQBz1CQBAHPUJAEAc9QkAQBz1CQBAHPUJAEAc9QkAQBz1CQBAHPVJxlatWvXss89mvRcAO5zlDsrUJ/+/Pn365N7ltttu26EbHTx48Lx587b//tOmTTvmmGO29dnm5uZ+/fp9oAcE6s2ee+7ZssR17dr14IMPvv766yt+tJZFqbm5OZfLtdKXljsoU5/8N9OnT0//u7PPPnuHbnHdunVt9VDLli0bPHjw0qVL2+oBgY7qhhtuKC9xb775ZlNT04QJE370ox9V+ZiNjY1pmh500EHbuoPlDsrUJ+/v5ptv7tat27Jly5Ikefnll3fbbbeZM2e+8soruVzu5ptv7tOnT0NDw+jRo1sW1pUrV44YMaJHjx59+/a96KKLWm5fvnx5oVDo2bPnXnvt9bWvfW39+vUnnXTSc889N2rUqHPPPbeVwaeeeuqEE07o3r37cccdt63V9l/+5V8GDhx4+OGHRx0VoCPo0qXL6aeffsoppxSLxZdeeimXy1122WUNDQ0jR478oIvSlq99Wu6gFeqT9zd69Ojjjz9+6tSpSZJcddVVRxxxxKhRo8qfuvbaa++7774FCxY89thjY8eOLd84fPjwnj17vvDCC3Pnzp0/f/748eOTJHn77bdPO+20rl27Pv/884888sgTTzxxxRVXPPjggwMGDJg5c+ZNN920rcG33npryJAhgwYNWrFixWWXXTZz5sz33Mlu3brdf//93/ve9wIPDNBBbNq0qUePHuWPn3322RdffPHKK6+seFGy3MH72OoyK/Vsv/322+r02GmnncqfWrRoUWNj43XXXdfQ0LBo0aI0TV9++eUkSYrFYvkOc+bM6dq165o1a+bOnbvLLrusX7++fPv8+fM7deq0bt26uXPndu3addWqVVtttLwcp2m6rcFSqdTQ0LB27dry7eeff/7RRx+9rS9h48aNSZI88sgjO+DwAB1Er169Wq68Nzc3z5w5s1OnTvfcc8/KlSuTJJk9e3b5Ux90UXrttdeSJHnmmWcsd9A6r33S2u99btq0qXx7//79J06ceNFFF1188cX9+/dvuX/Lb8QfeuihGzZseP75559++um1a9d269at/Bv9Rx555ObNm5csWfLUU0/16dNnjz322NamtzX49NNPH3DAAd27dy/f7bDDDtvBxwDo+L761a+Wl5q999572rRp3/ve94YOHVr+1P7771/lomS5g9apT7bXk08+mSTJ448/vuWNXbp0KX/w9ttvJ0nSuXPnTZs29e/ff6v/l/Pxj3+8S5cuuVyulcff1uBWd2vZIkDFWl77fOutt5588skxY8a0fKpbt25VLkqWO2id+mS73HvvvT/96U+bmpruvPPOUqnUcvvvf//78gcLFizo0aPHAQcccNBBBy1duvTFF1/c6hEOPPDAZcuWla9Mballjd7W4MCBAxctWvTmm2+W//nEE0+09RcH8B4qXpQsd9A69cn7W7NmzZgxY8aNGzdhwoTzzjtv7Nixb7zxRvlTl1xyydKlSxctWjRp0qTzzz+/W7duJ5988iGHHDJq1Khly5YtX778G9/4xv77779+/foTTjhh4MCBF1544SuvvPLCCy8MHz78i1/8YpIku+6664oVK954441tDX72s5/dd999v/71r7/66qv333//jBkzsj4eQF2oeFGy3EHr1Cf/zfjx47f6a/Njxoz55je/2alTpylTpiRJ0tTU1KlTp29+85vl+w8ePPgzn/nM0Ucf/Vd/9VflN8V36tSpVCrtuuuuBx988Mc//vHnnntuzpw55V9v+vnPf/7qq6/27dv3iCOO2G233W688cYkScaMGXP11VePGjVqW4Ndu3a99957X3jhhf3222/8+PHnnXde1gcJqAsVL0qWO2hdLk3TpFKFQqHiWWrdhg0bZs+efcopp/Ts2TPrfaFeFIvFTLZrrQPqYa2Lk1Yhn89XvF2z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HPUJAEAc9QkAQBz1CQBAHPUJAEAc9QkAQBz1CQBAHPUJAEAc9QkAQBz1CQBAHPUJAEAc9QkAQBz1CQBAnFyapoGbAwCgrnntEwCAOOoTAIA46hMAgDjqEwCAOOoTAIA46hMAgDjqEwCAOOoTAIA46hMAgDjqEwCAOOoTAIA46hMAgDjqEwCAOOoTAIA46hMAgDjqEwCAOOoTAIA46hMAgDjqEwCAOOoTAIA46hMAgDjqEwCAOOoTAIA46hMAgDjqEwCAOOoTAIA46hMAgDjqEwCAOOoTAIA46hMAgDjqEwCAOOoTAIA46hMAgDjqEwCAOOoTAIA46hMAgDjqEwCAOOoTAIA46hMAgDjqEwCAOOoTAIA46hMAgDjqEwCAOOqTDmvVqlXPPvts1nsB1BhLB+xo6pMIffr0yb3LbbfdtkM3Onjw4Hnz5m3//adNm3bMMce8+/ZFixadfvrpjY2N++677wUXXPD666+36W4C723PPfdsWS66du168MEHX3/99RU/WssTvLm5OZfLtdKXlg7Y0dQnQaZPn57+d2efffYO3eK6deuqf5CNGzeefvrpH/nIR5YuXfqb3/zmscceGzNmTFvsHfD+brjhhvJy8eabbzY1NU2YMOFHP/pRlY/Z2NiYpulBBx20rTtYOmBHU59k6eabb+7WrduyZcuSJHn55Zd32223mTNnvvLKK7lc7uabb+7Tp09DQ8Po0aNbfhisXLlyxIgRPXr06Nu370UXXdRy+/LlywuFQs+ePffaa6+vfe1r69evP+mkk5577rlRo0ade+65rQw+9dRTJ5xwQvfu3Y877rilS5e+ew/nz5+/ZMmS6667bvfdd+/fv/8VV1xx5513pmkaeJCApEuXLqeffvopp5xSLBZfeumlXC532WWXNTQ0jBw58oM+wbd87dPSAZlQn2Rp9OjRxx9//NSpU5Mkueqqq4444ohRo0aVP3Xttdfed999CxYseOyxx8aOHVu+cfjw4T179nzhhRfmzp07f/788ePHJ0ny9ttvn3baaV27dn3++ecfeeSRJ5544oorrnjwwQcHDBgwc+bMm266aVuDb7311pAhQwYNGrRixYrLLrts5syZ797D4447buPGjV27di3/c+XKlXvssUculws8SMB/2rRpU48ePcofP/vssy+++OKVV15Z8RPc0gGZ2epiKOwI++2331Yn3k477VT+1KJFixobG6+77rqGhoZFixalafryyy8nSVIsFst3mDNnTteuXdesWTN37txddtll/fr15dvnz5/fqVOndevWzZ07t2vXrqtWrdpqo+UfIWmabmuwVCo1NDSsXbu2fPv5559/9NFHt/JVNDc3f/SjH73iiiva+vAA76FXr14tV96bm5tnzpzZqVOne+65Z+XKlUmSzJ49u/ypD/oEf+2115IkeeaZZywdkBWvfZLN731u2rSpfHv//v0nTpx40UUXXXzxxf3792+5f8tv8R966KEbNmx4/vnnn3766bVr13br1q38LoQjjzxy8+bNS5Yseeqpp/r06bPHHntsa9PbGnz66acPOOCA7t27l+922GGHtbL/b7755rBhwwYOHDh58uQ2OiTA+/jqV79aftruvffe06ZN+973vjd06NDyp/bff/8qn+CWDsiK+iR7Tz75ZJIkjz/++JY3dunSpfzB22+/nSRJ586dN23a1L9//63+/9PHP/7xLl26tH49a1uDW92tZYvvtmrVqlNOOaVPnz533HFH586dq/tyge3V8trnW2+99eSTT275xp1u3bpV+QS3dEBW1CcZu/fee3/60582NTXdeeedpVKp5fbf//735Q8WLFjQo0ePAw444KCDDlq6dOmLL7641SMceOCBy5YtK19N21LLz5VtDQ4cOHDRokVvvvlm+Z9PPPHEe+7hiy++ePzxx5944ok//vGPW36LC2gnKn6CWzogK+qTLK1Zs2bMmDHjxo2bMGHCeeedN3bs2DfeeKP8qUsuuWTp0qWLFi2aNGnS+eef361bt5NPPvmQQw4ZNWrUsmXLli9f/o1vfGP//fdfv379CSecMHDgwAsvvPCVV1554YUXhg8f/sUvfjFJkl133XXFihVvvPHGtgY/+9nP7rvvvl//+tdfffXV+++/f8aMGe/ew+bm5pNPPvmMM8649tprvWMA2qGKn+CWDshMG/3+KHywdx0lSXLBBRdceOGFH/nIR9asWZOm6erVq/v27Tt27Njyu44uvfTSD3/4w7vvvvtFF120YcOG8uP88Y9/PPPMM3fdddfddtvt1FNPfeaZZ8q3L1269LTTTtt555179eo1cuTI1atXp2n6wx/+sEePHsOHD29l8Pnnnz/llFN23nnngQMHXnTRRe9+68DVV1/97j1/4403Yo8f1Pu7jrZU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i5Fpvb/wqT4BAAilPgGAuhfzkqQXPt+hPoGO6dBDD12+fHmSJOvXrz/wwAOvv/76ww477JOf/OScOXOy3jWgXdrRaSg9/4v6BDqmESNG3HXXXUmSPPDAA6eeeuqUKVMeeuih22+//bbbbst614D2ascFovTcgvoEOqazzjrrzjvvTJLk7rvv/vznPz9kyJBzzjln2bJlt956a9a7BrRjOyITped/pz6BjmnAgAGrVq16/fXXFyxY8KlPfWrWrFnjx4+/4YYbRo0alfWuAe1b28ai9HyXevx7n0CdOPPMM6dOnXrUUUe9/vrrZ5xxxv3333/44Yf369cv6/0C2r00bZs/QS8934v6BDqss84665BDDnnggQcaGhpOP/30Y445ZvPmzX/3d3+X9X4BtaAcjhU3qO7cNvUJdFgDBgxYv359+eOJ78h6j4A6aFDd+X7UJwDA9gVlKxkqOreb+gQA2D4Ssy14zzsAAHHUJwAAcdQnAABx1CcAAHHUJwAAcdQnAABxcmmd/e2AQqGQ9S4AFSoWi5ls17oBtSurdYNW1OPf+yyVSpUN5vP5amaLq1dUNlto6F3N7KCmCp94CycWlkxurmy235RGs9s/W833KKvzKpPnUR2uG9WcG1mdV7X4HKzF2ax+LlQzW2/rBtviyjsAAHHUJwAAcdQnAABx1CcAAHHUJwAAcdQnAABx1CcAwH/avHnzuHHjjj322BNPPHHJkiXlG2fMmHHCCScceuihc+bMabnnr371q379+p30jsmTJydJMnXq1IEDBzY1NZUfZ+jQoc3NFf5RrY6tHv/eJwDAe/rBD37Qs2fPRx55pFgsTpgw4Re/+MXLL798yy23zJ079w9/+EOhUHjmmWfK93zppZcuueSSMWPGtMx++9vffu655wYMGDBx4sSbbrpp+PDhjY2N2X0p7Zf6BAD4Tz/+8Y9vueWWJEmGDh26aNGiJElWrVo1duzYTp069e3bd9WqVS33XLly5YABA7ac7dKly5///OeuXbu++uqrd9555z333JPFV1AD1CcAwH/6wx/+cNc7dt999+nTpydJctA7kiS54447hg0b1nLPlStXLl68uKmpaY899pg+ffoBBxxw1VVXnX322VdfffXkyZO/9a1v5XK5TL+U9svvfQIA/KcNGzZ8+MMffvDBB88+++zRo0e33P788883NTVNnTq1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QBz1CQBAHPUJAEAc9QkAQBz1CQBAHPUJAEAc9QkAQBz1CQBAHPUJAEAc9QkAQBz1CQBAHPUJAEAc9QkAQBz1CQBAHPUJAEAc9QkAQBz1CQBAHPUJAEAc9UkNW7Vq1bPPPpv1XgB1xLID1VOftI0+ffrk3uW2227boRsdPHjwvHnztv/+06ZNO+aYY959+5/+9KcRI0bstttuffv2nTJlSpvuI7BD7Lnnni1LTdeuXQ8++ODrr7++4kdrWRyam5tzuVwrfWnZgep1boPHgHdMnz79G9/4RuQW161b1yaP86UvfWn//fdftmzZokWLTjvttH322efcc89tk0cGdpwbbrhhzJgxSZJs3Ljxl7/85ec+97ndd9/9y1/+cjWP2djYmKZpK3ew7ED1vPbJjnXzzTd369Zt2bJlSZK8/PLLu+2228yZM1955ZVcLnfzzTf36dOnoaFh9OjRLQv6ypUrR4wY0aNHj759+1500UUtty9fvrxQKPTs2XOvvfb62te+tn79+pNOOum5554bNWpUecne1uBTTz11wgkndO/e/bjjjlu6dOm79/D5559/4IEHpk2b1tDQcMQRR3zmM5/57W9/G3iEgGp16dLl9NNPP+WUU4rF4ksvvZTL5S677LKGhoaRI0d+0MVhy9c+LTuwg6hPdqzRo0cff/zxU6dOTZLkqquuOuKII0aNGlX+1LXXXnvfffctWLDgscceGzt2bPnG4cOH9+zZ84UXXpg7d+78+fPHjx+fJMnbb7992mmnde3a9fnnn3/kkUeeeOKJK6644sEHHxwwYMDMmTNvuummbQ2+9dZbQ4YMGTRo0IoVKy677LKZM2e+ew8POOCAzZs39+rVa9OmTf/vHYVCIfYgAW1g06ZNPXr0KH/87LPPvvjii1deeWXFi4NlB3agFNrCfvvtt9WptdNOO5U/tWjRosbGxuuuu66hoWHRokVpmr788stJkhSLxfId5syZ07Vr1zVr1sydO3eXXXZZv359+fb58+d36tRp3bp1c+fO7dq166pVq7baaPnHQJqm2xoslUoNDQ1r164t337++ecfffTR2/oSBgwY0K1bt5NOOunll1/eAUcIaEu9evW64YYbyh83NzfPnDmzU6dO99xzz8qVK5MkmT17dvlTH3RxeO2115IkeeaZZyw7sON47ZM2M3369C3PrU2bNpVv79+//8SJEy+66KKLL764f//+Lfdv+U38Qw89dMOGDc8///zTTz+9du3abt26ld9JcOSRR27evHnJkiVPPfVUnz599thjj21teluDTz/99AEHHNC9e/fy3Q477LBW9v/ZZ59dtWrVLrvscvrpp7fRIQF2oK9+9avlp/zee+89bdq0733ve0OHDi1/av/9969ycbDswI6jPonw5JNPJkny+OOPb3ljly5dyh+8/fbbf3kHXOfOmzZt6t+//1b/D+njH/94ly5dcrlcK4+/rcGt7tayxW3ZddddJ0+e/Oijj65YsaLSrxUI0vLa51tvvfXkk0+W34FU1q1btyoXB8sO7Djqkx3u3nvv/elPf9rU1HTnnXeWSqWW23//+9+XP1iwYEGPHj0OOOCAgw46aOnSpS+++OJWj3DggQcuW7asfEVsSy0/G7Y1OHDgwEWLFr355pvlfz7xxBPv3r377ruvoaFh/fr15X+++uqrO+20U2NjY3VfNNAuVLw4WHZgx1Gf7Fhr1qwZM2bMuHHjJkyYcN55540dO/aNN94of+qSSy5ZunTpokWLJk2adP7553fr1u3kk08+5JBDRo0atWzZsuXLl3/jG9/Yf//9169ff8IJJwwcOPDCCy985ZVXXnjhheHDh3/xi18sv2awYsWKN954Y1uDn/3sZ/fdd9+vf/3rr7766v333z9jxox37+FJJ520zz77XHTRRatXr/79738/ceLEUaNG7bLLLuGHCmh7FS8Olh3Ygdro90epd+9+11GSJBdccMGFF174kY98ZM2aNWmarl69um/fvmPHji2/6+jSSy/98Ic/vPvuu1900UUbNmwoP84f//jHM888c9ddd91tt91OPfXUZ555pnz70qVLTzvttJ133rlXr14jR45cvXp1mqY//OEPe/ToMXz48FYGn3/++VNOOWXnnXceOHDgRRdd9J6//r948eIhQ4bstttu+++//2WXXbZu3brAIwdU+66jLZXfdVR+g2PZB1ocWt51ZNmBHSfX+p/VbZ/8ZYpat2HDhtmzZ59yyik9e/bMel+oJcViMZPtWnOgPmW15nR4tfrfOir1v6aywfziSWY/wOwWv6b5wWbz+fed/X//7/9VPFvNds3W7myGiqsrfEdIoaG32e2frblz0mzHnmUH8XufAADEUZ8AAMRRnwAAxFGfAADEUZ8AAMRRnwAAxFGfAADE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3bZDNzp48OB58+Zt//2nTZt2zDHHtHKHsWPHnnTSSW2xa0DHtOeee7YscV27dj344IOvv/76ih+tZVFqbm7O5XKt9KXlDsrUJ//N9OnT0//u7LPP3qFbXLduXRs+2sMPP/z973+/DR8Q6JBuuOGG8hL35ptvNjU1TZgw4Uc/+lGVj9nY2Jim6UEHHbStO1juoEx98v5uvvnmbt26LVu2LEmSl19+ebfddps5c+Yrr7ySy+VuvvnmPn36NDQ0jB49umVhXbly5YgRI3r06NG3b9+LLrqo5fbly5cXCoWePXvutddeX/va19avX3/SSSc999xzo0aNOvfcc1sZfOqpp0444YTu3bsfd9xxS5cu3dZ+vvXWW6NHjz7iiCNCjgrQEXTp0uX0008/5ZRTisXiSy+9lMvlLrvssoaGhpEjR37QRWnL1z4td9AK9cn7Gz169PHHHz916tQkSa666qojjjhi1KhR5U9de+21991334IFCx577LGxY8eWbxw+fHjPnj1feOGFuXPnzp8/f/z48UmSvP3226eddlrXrl2ff/75Rx555IknnrjiiisefPDBAQMGzJw586abbtrW4FtvvTVkyJBBgwatWLHisssumzlz5rb28/LLL/8f/+N/fO5zn4s6MEAHsWnTph49epQ/fvbZZ1988cUrr7yy4kXJcgfvY6vLrNSz/fbbb6vTY6eddip/atGiRY2Njdddd11DQ8OiRYvSNH355ZeTJCkWi+U7zJkzp2vXrmvWrJk7d+4uu+yyfv368u3z58/v1KnTunXr5s6d27Vr11WrVm210fJynKbptgZLpVJDQ8PatWvLt59//vlHH330u3f+d7/73V577bVy5cqrr77605/+9A47SEDN69WrV8uV9+bm5pkzZ3bq1Omee+5ZuXJlkiSzZ88uf+qDLkqvvfZakiTPPPOM5Q5a57VPWvu9z02bNpVv79+//8SJEy+66KKLL764f//+Lfdv+Y34Qw89dMOGDc8///zTTz+9du3abt26lX+j/8gjj9y8efOSJUueeuqpPn367LHHHtva9LYGn3766QMOOKB79+7lux122GHvnt24cePf/M3fNDU17bPPPm19SIAO6Ktf/Wp5qdl7772nTZv2ve99b+jQoeVP7b///lUuSpY7aJ36ZHs9+eSTSZI8/vjjW97YpUuX8gdvv/12kiSdO3fetGlT//79t/p/OR//+Me7dOmSy+VaefxtDW51t5Ytbumqq67q06fPV77ylbb4QoGOr+W1z7feeuvJJ58cM2ZMy6e6detW5aJkuYPWqU+2y7333vvTn/60qanpzjvvLJVKLbf//ve/L3+wYMGCHj16HHDAAQcddNDSpUtffPHFrR7hwAMPXLZsWfnK1JZa1uhtDQ4cOHDRokVvvvlm+Z9PPPHEu3fvjjvuuO+++8qvIlx22WVz587N5XLvfiiA7VfxomS5g9apT97fmjVrxowZM27cuAkTJpx33nljx4594403yp+65JJLli5dumjRokmTJp1//vndunU7+eSTDznkkFGjRi1btmz58uXf+MY39t9///Xr159wwgkDBw688MILX3nllRdeeGH48OFf/OIXkyTZddddV6xY8cYbb2xr8LOf/ey+++779a9//dVXX73//vtnzJjx7j188sknW14/aPlFqD59+oQfKqDjqHhRstxB69Qn/8348eO3+mvzY8aM+eY3v9mpU6cpU6YkSdLU1NSpU6dvfvOb5fsPHjz4M5/5zNFHH/1Xf/VX5TfFd+rUqVQq7brrrgcffPDHP/7x5557bs6cOeVfb/r5z3/+6quv9u3b94gjjthtt91uvPHGJEnGjBlz9dVXjxo1aluDXbt2vffee1944YX99ttv/Pjx5513XtYHCagLFS9KljtoXS5N06RShUKh4llq3YYNG2bPnn3KKaf07Nkz632hXhSLxUy2a60D6mGtC9O5yvktfwXwA8nn81nNDmqq8Ju6cGLBbIu1r70ye/ZeB13y3T37HVQr+/y+s7V4PtfVbIZq7ljl8/lZD42rbHbkideb7diztXg+19Vsh+fKOwAAtfPaJ3Vrl933vGJR5b+2AQDUJ699AgAQR30CABBHfQIAEEd9AgAQR30CABBHfQIAEEd9AgAQR30CABBHfQIAEEd9AgAQR30CABBHfQIAEEd9AgAQR30CABBHfQIAEEd9AgAQJ5emacXDhUKhTXcGoDXFYjGT7VrrgHpY68J0rnK+VCpVNpjP57OaHdRU4Td14cSC2Y49W4vnc13NZqjmjlU+n5/10LjKZkeeeL3Zjj1bi+dzXc12eK68AwAQR30CABBHfQIAEEd9AgAQR30CABBHfQIAEEd9AgAQR30CABBHfQIAEEd9AgAQR30CABBHfQIAEEd9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"
            },
            {
              "type": "input_text",
              "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
            }
          ],
          "solved_count": 0,
          "total_training_examples": 4,
          "pixel_accuracy": 0.573268921095008
        },
        "test_result": {
          "correct": false,
          "pixel_accuracy": 0.4368421052631579,
          "total_pixels": 380,
          "correct_pixels": 166,
          "error": null
        },
        "status": "failed_test"
      }
    ],
    "total_turns": 1,
    "conversation_history": [
      {
        "role": "system",
        "content": "You are an expert at solving abstract reasoning puzzles. Write clean, efficient Python code."
      },
      {
        "role": "user",
        "content": [
          {
            "type": "input_text",
            "text": "You are solving an ARC (Abstraction and Reasoning Corpus) task. \nI will show you training examples with input and output grids, plus a test input grid. Your task is to:\n\n1. **Analyze the training examples** to discover patterns that map input grids to output grids\n2. **Write a Python program** that implements your best understanding of the transformation  \n3. **DO NOT predict or generate the test output** - your job is only to write the transformation program\n4. **Attempt a solution** - even if the pattern isn't completely clear, provide your best hypothesis\n5. **Do not repeat the same transformation** - if you have already tried a transformation, do not repeat it.\n\n**IMPORTANT: Your transformation must always produce a 18\u00d719 output grid.**\n\nThe test input is shown for context so you understand what type of grid your program will eventually process. Focus on learning patterns from training examples and writing code that captures your understanding.\n\nTraining Examples:\n\nExample 1:\nInput:\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0\n0 0 8 7 7 7 7 7 7 7 7 8 0 2 2 2 2 2 2\n0 0 8 7 7 7 7 7 7 7 7 8 0 2 1 1 1 1 2\n0 0 8 7 7 4 4 4 4 7 7 8 0 2 1 3 3 1 2\n0 0 8 7 7 4 3 3 4 7 7 8 0 2 1 3 3 1 2\n0 0 8 7 7 4 3 3 4 7 7 8 0 2 1 1 1 1 2\n0 0 8 7 7 4 3 3 4 7 7 8 0 2 2 2 2 2 2\n0 0 8 7 7 4 3 3 4 7 7 8 0 0 0 0 0 0 0\n0 0 8 7 7 4 3 3 4 7 7 8 0 0 0 0 0 0 0\n0 0 8 7 7 4 4 4 4 7 7 8 0 0 0 0 0 0 0\n0 0 8 7 7 7 7 7 7 7 7 8 0 0 0 0 0 0 0\n0 0 8 7 7 7 7 7 7 7 7 8 0 0 0 0 0 0 0\n0 0 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\nOutput:\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0\n0 0 3 4 4 4 4 4 4 4 4 3 0 3 3 3 3 3 3\n0 0 3 4 4 4 4 4 4 4 4 3 0 3 1 1 1 1 3\n0 0 3 4 4 7 7 7 7 4 4 3 0 3 1 2 2 1 3\n0 0 3 4 4 7 8 8 7 4 4 3 0 3 1 2 2 1 3\n0 0 3 4 4 7 8 8 7 4 4 3 0 3 1 1 1 1 3\n0 0 3 4 4 7 8 8 7 4 4 3 0 3 3 3 3 3 3\n0 0 3 4 4 7 8 8 7 4 4 3 0 0 0 0 0 0 0\n0 0 3 4 4 7 8 8 7 4 4 3 0 0 0 0 0 0 0\n0 0 3 4 4 7 7 7 7 4 4 3 0 0 0 0 0 0 0\n0 0 3 4 4 4 4 4 4 4 4 3 0 0 0 0 0 0 0\n0 0 3 4 4 4 4 4 4 4 4 3 0 0 0 0 0 0 0\n0 0 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\nExample 2:\nInput:\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 1 1 1 1 1 1 1 1 1 1 1 1 0 0\n0 0 1 1 1 1 1 1 1 1 1 1 1 1 0 0\n0 0 1 1 3 3 3 3 3 3 3 3 1 1 0 0\n0 0 1 1 3 8 8 8 8 8 8 3 1 1 0 0\n0 0 1 1 3 8 8 8 8 8 8 3 1 1 0 0\n0 0 1 1 3 8 8 2 2 8 8 3 1 1 0 0\n0 0 1 1 3 8 8 2 2 8 8 3 1 1 0 0\n0 0 1 1 3 8 8 8 8 8 8 3 1 1 0 0\n0 0 1 1 3 8 8 8 8 8 8 3 1 1 0 0\n0 0 1 1 3 3 3 3 3 3 3 3 1 1 0 0\n0 0 1 1 1 1 1 1 1 1 1 1 1 1 0 0\n0 0 1 1 1 1 1 1 1 1 1 1 1 1 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\nOutput:\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 2 2 2 2 2 2 2 2 2 2 2 2 0 0\n0 0 2 2 2 2 2 2 2 2 2 2 2 2 0 0\n0 0 2 2 8 8 8 8 8 8 8 8 2 2 0 0\n0 0 2 2 8 3 3 3 3 3 3 8 2 2 0 0\n0 0 2 2 8 3 3 3 3 3 3 8 2 2 0 0\n0 0 2 2 8 3 3 1 1 3 3 8 2 2 0 0\n0 0 2 2 8 3 3 1 1 3 3 8 2 2 0 0\n0 0 2 2 8 3 3 3 3 3 3 8 2 2 0 0\n0 0 2 2 8 3 3 3 3 3 3 8 2 2 0 0\n0 0 2 2 8 8 8 8 8 8 8 8 2 2 0 0\n0 0 2 2 2 2 2 2 2 2 2 2 2 2 0 0\n0 0 2 2 2 2 2 2 2 2 2 2 2 2 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\nExample 3:\nInput:\n8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0\n8 2 2 2 2 8 0 0 0 0 0 0 0 0 0 0 0\n8 2 1 1 2 8 0 0 0 0 0 0 0 0 0 0 0\n8 2 1 1 2 8 0 0 0 0 0 0 0 0 0 0 0\n8 2 2 2 2 8 0 0 0 0 0 0 0 0 0 0 0\n8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 6 6 6 6 6 6 6 6 6 6 6 6 0\n0 0 0 0 6 3 3 3 3 3 3 3 3 3 3 6 0\n0 0 0 0 6 3 4 4 4 4 4 4 4 4 3 6 0\n0 0 0 0 6 3 4 2 2 2 2 2 2 4 3 6 0\n0 0 0 0 6 3 4 2 1 1 1 1 2 4 3 6 0\n0 0 0 0 6 3 4 2 1 1 1 1 2 4 3 6 0\n0 0 0 0 6 3 4 2 2 2 2 2 2 4 3 6 0\n0 0 0 0 6 3 4 4 4 4 4 4 4 4 3 6 0\n0 0 0 0 6 3 3 3 3 3 3 3 3 3 3 6 0\n0 0 0 0 6 6 6 6 6 6 6 6 6 6 6 6 0\nOutput:\n1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0\n1 2 2 2 2 1 0 0 0 0 0 0 0 0 0 0 0\n1 2 8 8 2 1 0 0 0 0 0 0 0 0 0 0 0\n1 2 8 8 2 1 0 0 0 0 0 0 0 0 0 0 0\n1 2 2 2 2 1 0 0 0 0 0 0 0 0 0 0 0\n1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 0\n0 0 0 0 1 2 2 2 2 2 2 2 2 2 2 1 0\n0 0 0 0 1 2 4 4 4 4 4 4 4 4 2 1 0\n0 0 0 0 1 2 4 3 3 3 3 3 3 4 2 1 0\n0 0 0 0 1 2 4 3 6 6 6 6 3 4 2 1 0\n0 0 0 0 1 2 4 3 6 6 6 6 3 4 2 1 0\n0 0 0 0 1 2 4 3 3 3 3 3 3 4 2 1 0\n0 0 0 0 1 2 4 4 4 4 4 4 4 4 2 1 0\n0 0 0 0 1 2 2 2 2 2 2 2 2 2 2 1 0\n0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 0\n\nExample 4:\nInput:\n0 0 0 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0\n0 0 0 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0\n0 0 0 1 1 6 6 6 6 6 1 1 0 0 0 0 0 0 0\n0 0 0 1 1 6 8 8 8 6 1 1 0 0 0 0 0 0 0\n0 0 0 1 1 6 6 6 6 6 1 1 0 0 0 0 0 0 0\n0 0 0 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0\n0 0 0 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 2 2 2 2 2 2 2 2 2 2 2 2 0 0 0 0 0 0\n0 2 4 4 4 4 4 4 4 4 4 4 2 0 0 0 0 0 0\n0 2 4 1 1 1 1 1 1 1 1 4 2 0 0 0 0 0 0\n0 2 4 1 8 8 8 8 8 8 1 4 2 0 0 0 0 0 0\n0 2 4 1 8 8 8 8 8 8 1 4 2 0 0 0 0 0 0\n0 2 4 1 1 1 1 1 1 1 1 4 2 0 0 0 0 0 0\n0 2 4 4 4 4 4 4 4 4 4 4 2 0 0 0 0 0 0\n0 2 2 2 2 2 2 2 2 2 2 2 2 0 0 0 0 0 0\nOutput:\n0 0 0 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0\n0 0 0 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0\n0 0 0 8 8 6 6 6 6 6 8 8 0 0 0 0 0 0 0\n0 0 0 8 8 6 1 1 1 6 8 8 0 0 0 0 0 0 0\n0 0 0 8 8 6 6 6 6 6 8 8 0 0 0 0 0 0 0\n0 0 0 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0\n0 0 0 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0\n0 8 1 1 1 1 1 1 1 1 1 1 8 0 0 0 0 0 0\n0 8 1 4 4 4 4 4 4 4 4 1 8 0 0 0 0 0 0\n0 8 1 4 2 2 2 2 2 2 4 1 8 0 0 0 0 0 0\n0 8 1 4 2 2 2 2 2 2 4 1 8 0 0 0 0 0 0\n0 8 1 4 4 4 4 4 4 4 4 1 8 0 0 0 0 0 0\n0 8 1 1 1 1 1 1 1 1 1 1 8 0 0 0 0 0 0\n0 8 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0 0 0\n\nTest Input:\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0 0\n0 3 3 3 3 3 3 3 3 3 3 0 0 0 0 0 0 0 0\n0 3 3 6 6 6 6 6 6 3 3 0 0 0 0 0 0 0 0\n0 3 3 6 1 1 1 1 6 3 3 0 0 5 5 5 5 5 5\n0 3 3 6 1 4 4 1 6 3 3 0 0 5 4 4 4 4 5\n0 3 3 6 1 1 1 1 6 3 3 0 0 5 4 8 8 4 5\n0 3 3 6 6 6 6 6 6 3 3 0 0 5 4 8 8 4 5\n0 3 3 3 3 3 3 3 3 3 3 0 0 5 4 4 4 4 5\n0 3 3 3 3 3 3 3 3 3 3 0 0 5 5 5 5 5 5\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 6 6 6 6 6 6 6 6 6 6 6 6 6 0 0 0\n0 0 0 6 8 8 8 8 8 8 8 8 8 8 8 6 0 0 0\n0 0 0 6 8 2 2 2 2 2 2 2 2 2 8 6 0 0 0\n0 0 0 6 8 2 4 4 4 4 4 4 4 2 8 6 0 0 0\n0 0 0 6 8 2 4 3 3 3 3 3 4 2 8 6 0 0 0\n0 0 0 6 8 2 4 4 4 4 4 4 4 2 8 6 0 0 0\n0 0 0 6 8 2 2 2 2 2 2 2 2 2 8 6 0 0 0\n0 0 0 6 8 8 8 8 8 8 8 8 8 8 8 6 0 0 0\n0 0 0 6 6 6 6 6 6 6 6 6 6 6 6 6 0 0 0\n\nAnalyze the patterns in the training examples and write a Python function that performs this transformation.\n\n**Approach Guidelines:**\n- Look for patterns in shapes, colors, positions, sizes, rotations, reflections, etc.\n- Even if you can't solve all training examples perfectly, implement what patterns you do observe\n- A partial solution that captures some aspects is better than returning the input unchanged\n- If the pattern is unclear, make your best educated guess based on what you can see\n\nRequirements:\n- The function takes a 2D list (grid) where grid[row][col] gives the value at that position\n- Values are integers from 0-9\n- Return a new grid (2D list) with the transformation applied\n- You can use numpy if needed - just add 'import numpy as np' at the start of your function\n- Aim to handle the training examples as well as possible, even if not perfectly\n- Your function should attempt some meaningful transformation based on the patterns you observe\n\nYou MUST end your response with the following exact format:\n\nFinal answer:\n```python\ndef transform(grid):\n    # Your transformation logic here (implement your best understanding)\n    return transformed_grid\n```\n"
          },
          {
            "type": "input_image",
            "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA1wAAAhNCAIAAAAOCrxXAABhIElEQVR4nO3dfZQddZ3g/7pwSQIhdEBmhA5K0mkXcKINxvAkBjBBZ0SwaiaIArt2JAIzxpjRhOx4ou5KBJLOjGt4UNhIgkZQYKk645jDjmEOBncHjYCNEgKEBHloFHlI5MGQp/qdmj7bJ79AYqfqkurq+3r9FW/6c+vb1XW//eZWd6ylaRoAANDc9il7AQAAlE8UAgAgCgEAEIUAAIhCAAAyohAAAFEIAIAoBABAFAIAkBGFAACIQgAARCEAAKIQAIDCUTh9+vTarl1wwQVv+DFDhgw57LDDzj777Pvuu+/1z/njH/+4VqsdcsghmzZt2umvbrvttlqttnjx4t7/2dnZWavVurq6dvqwp556qlarzZ07t8hUr02bNl133XWnn356a2vr0KFDW1tbzznnnLvvvjvfOZk8eXIQBM8//3xra+vBBx/81FNP7TT713/910OGDPnFL37RzxPy8Y9/vFar1ev13//+969fybhx42q1WmdnZ+//nDZt2o6L2XfffQ866KATTjjh29/+dt9IGIa1Wu31B+rnp9brueeeu/TSS48++uj9999/5MiRJ5988je/+c1t27bt5qQBAM34TuGWLVt+97vf/fCHPzz99NPXrVu309/ecMMNQRC8+OKLP/jBD/rzbF/+8pfXrFmzp2voz9Tjjz9+0kknXXLJJXfdddczzzyzefPmZ5555rbbbps4ceI//dM/BXm95S1vueGGGzZs2DB16tQ0Tfsev+aaa+I4vvzyy9/73vfu0QnZtm3b7bffvtODv/rVrx588MHdLGP79u0vvfTSz3/+82nTpi1YsCBokN///vcTJkzo6up6+OGHN23atHHjxn//93//u7/7u3POOWfHTxYAGFRRePXVV6f/z6233hoEwZIlS/oeWbZsWd9Hrl+/vu/xTZs2PfTQQ+edd94f/vCHb37zmzs+4YYNG5IkOeeccw455JBvfetb/VnD5s2bOzs79/SNqD85tWXLlilTpvzyl788+eST//mf//m5557bsmXLE088ce211x5yyCGXXnrpr3/96908/46fb58VK1b0/u1f/uVffuYzn1mxYsXVV1/d+0h3d/cXvvCFD37wg1/4whf26ITsu+++Rx111C233LLT49///vf/4i/+4vUf/8wzz/QuZvv27S+//PJNN900bNiwr33ta6+99tpuT1h/P7VFixY9/vjjU6ZM6e7ufuWVVzZs2PBv//Zvxx13XBzHP/zhD/t5CACgKd4pHDp06NFHHz1//vwgCHZ6p/Cmm27atGnTxRdfPHXq1HvuueeBBx74k8/22c9+9mc/+9k//uM/7tEa/uTUjTfeeO+9906ePHnlypVnnXXWW97ylnq9/ra3ve1v//Zvb7/99m3btt18881BAV1dXUcfffScOXMefvjhl19++WMf+1hLS8t3vvOdWq22pyfkYx/72E9+8pNnn312xwd/8IMfnHvuubtZQK1WGz58+Cc+8YmPf/zjf/jDHx555JGgEdasWVOv15ctW/bud7/7gAMOaGlpOf3003vfyLzjjjt6P2bp0qW1Wq0viAGAJo3C11577cEHH/z85z8fBMF/+k//ace/WrJkyTHHHPOBD3zgb//2b/fdd9/+vFl4+eWXt7e3f/nLX37ooYf6v4Y/OXXTTTfVarXrr79+33333emvTj311NWrV8+bNy8oYP/99//e9763devWCy644JJLLnn00Ue/853vvPWtb93pw/pzQj72sY/tdAf55z//+WOPPfaxj32sPyvpfY/w9Z9mPh0dHVu3bo3jeMcHR48enabptdde25BDAAAVjsIxY8b0/VLCsGHDxo0bd+uttx566KGf+9zn+j7m17/+9S9+8YvZs2fXarWxY8eec8453/ve915++eXdP/MBBxywZMmSLVu27NFN5D85df/99x9zzDFjxox5w/Fjjjlmp7f0dvP59rnrrrt2/Jj3vOc9/+2//bdf/OIX3/ve9z7/+c9/6EMf2ulJ+nlCxo0b9853vrP39n2v73//++9973vHjh27mxVu27atp6fnG9/4xi233PLnf/7nRx111G4+uP+f2syZM0855ZRPfOITbW1t06ZNu/7661//o42dnZ1pmk6fPr2fRwQABu0/STNq1KhPfepT3d3dhx12WN+DN9xww6hRo84///ze//kP//APL730Un/u0p5yyikzZsz4+c9/vnDhwv6vYTdTW7Zs2bBhw07v2+30u7ejR48OCvvoRz/aG5ennHLK6/+2/ydkxzvIaZrecsstu7p3fPjhh/euv16vjxo1aubMmdu2bbv88ssb9U7hgQceeNdddy1btqyjoyNJkosvvnjcuHFjxoy58cYbG/L8AEC1o7D3txM2b978/e9/f8SIEe94xzuuvPLK1tbWvg/YsmXLsmXLnn766aFDh/ZWS0dHR5qm/fx1k8svv/wd73jHV77yldWrV/d/Vbua2m+//UaMGPGG/85Lkd/GOO2003b8mE2bNp133nktLS0jRoy4+OKLd/qhwD06Ieeee27fHeSVK1f29PT8yXvH++yzzyGHHDJp0qQkSS688MIGfmr77rvv+eefH8fxc8899+ijjy5ZsuStb31rZ2fn17/+9f4fBQAYzO8U7rfffueee+4PfvCDn/zkJ3/5l3+547+H9y//8i9vGGH33XffqlWr/uQz77///jluIu9m6l3vetfq1aufeOKJN/xV6/HjxweFzZw584EHHlj0H5599tlPfepTO/7tHp2Qo48++l3velfv7yD/4Ac/OPHEE9/+9re/4UH7fvt427Ztzz///IoVKz760Y8Gb5r29vbOzs6f/vSnxx13XMGfwgQABtvt47/6q7/67Gc/e999982aNavvwRtuuGHYsGEbN27c8f2n//t//28QBNddd11/nvZ973vf5z73uVWrVr3+H6bOMXX++edv37797/7u794wMYv/k3u33nrrddddd9555/3n//yfOzs7/+Zv/uZHP/rRjv9Az56ekHPPPXflypW9/5Li7n/v+M3z9NNP12q1adOm7fR4vV5/17vetWHDhs2bN5eyMABggP5M4eWXX/72t7/9m9/85s9+9rMgCH7729/ecccdZ5111kEHHbTjh5100klHHXXUzTffvHHjxv487de+9rV3vOMde/pbrm84NW3atPHjx//oRz86/vjjb7nllt/+9rdbtmzpTa4zzzzzvvvu22ef/Kdu/fr1n/70p8eMGdNXgdddd93hhx/+hS98ofef1M5xQnrvIM+cOfO5554755xzgjKMGjXqPe95zw033DB9+vR///d//93vfrdp06bHHnvs2muvvfXWW48//vghQ4aUsjAAYIBG4fDhw6+66qrt27dffPHFW7du/c53vrN169a+36jY0Sc/+clXX331u9/9bv9vB+/+94L7OTVkyJAkSU466aT77rvv3HPPPfzww4cMGdL7f3O3fPnyo446avf/hytv+Cu6tVrt5Zdf3rJly7nnnvvKK69873vf62u+t7zlLUuXLt20adP555+/ZcuWHCekvb39uOOOu+WWW97//vfv+MOaOey///47LXvp0qX9+dR63+AcOXLkNddcc/LJJx922GH7779/e3v7Zz7zmXq93vcPE/p3CgFgAConCoMgOPvss8Mw7O7u/h//438sXbr04IMP/qu/+qvXf9h/+S//ZZ999unnHeTe28EzZ87c08W84dQRRxxx9913L1u27MMf/vARRxwxZMiQt771rR/+8IdvvPHGX//61xMmTAhy+a//9b+uWrXqK1/5ykknnbTj4x/84AenT59+3333zZ07N98J6b1r3M9/nvBN0tHR8eCDD37hC18YN27cQQcdNGTIkNGjR1900UW/+tWvGvKDmADAm6Tm/5EWAIDS3ikEAGDgEIUAAIhCAABEIQAAohAAgIwoBABAFAIAIAoBABCFAABkRCEAAKIQAABRCACAKAQAICMKAQAQhQAAiEIAAEQhAAAZUQgAgCgEAEAUAgAgCgEAyIhCAABEIQAAohAAAFEIAEBGFAIAIAoBABCFAACIQgAAMqIQAABRCACAKAQAQBQCAJARhQAAiEIAAEQhAACikAHk+eefX7NmTdmrAKjM1mfbpLFEIXmEYdjZ2dnY55w8efI999yzq7/dsGFDW1vbbj4AoFxPPvnkpz/96VGjRg0bNqytrW3WrFkvvPBCwa2vyKxtkz0lChko/vjHP+7qr5588snJkyevX79+764IoL8eeeSR8ePHv/jii8uXL3/hhRduv/32hx56aPz48c8880zure9Psm3SWKKQQp577rlarXbNNdeMHj162LBhH/rQh55++um+x7/97W8fccQRLS0tF154Ye/m9dRTT9Vqtccff7x3fOHChSeeeGIQBKeddtrDDz88derUadOm7XSIH/3oR+PGjRs/fnwZnx9Av0ybNu3UU0+97bbbOjo6DjjggGOPPfaHP/zhYYcdNmPGjH5ufbZNSicKaYAbb7zxzjvvXLNmTU9Pz1e/+tW+xxcsWHDHHXfcf//999577/Tp03fzDHfddddRRx21ZMmSxYsX7/RXQ4cOXbFixTXXXPOmLR+gkN/85jd33333TrvcPvvsM3PmzCRJXnzxxf5vfbZNSiQKaYAvfelLY8eOHT16dGdn56pVq/oenz9//rhx49ra2rq6upYtW/bKK6/kePLJkydPmDChoesFaKTVq1cHQXDMMcfs9HhHR8fWrVvXrl3b/6eybVIiUUgD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Xnjhjgdau3ZtrVZ77rnnev/nOeecM3Xq1DI+Y6Aa3v/+90+ZMmXHR7Zt23biiSf2PtifLcj2RaV5p5CS3XjjjXfeeeeaNWt6enq++tWv9j2+YMGCO+644/7777/33nunT5++m2e46667jjrqqCVLluz0X9Jjx47dvn37W97ylq1bt975H6IoejM/FaDCfvOb39x999077Tb77LPPzJkzkyR58cUX+78F2b6oKFFIyb70pS+NHTt29OjRnZ2dq1at6nt8/vz548aNa2tr6+rqWrZs2SuvvJL7EOPGjTvzzDPf/e53n3TSSQ1aNTDYrF69OgiCY445ZqfHOzo6tm7dunbt2v4/le2LihKFlGz06NG9fxg+fPiWLVv6Hj/xxBN7/3Dsscdu3rz5sccey32INWvWPP/88wcccMBHPvKRwusFBqdarRYEwbZt23Z6/LXXXtvTp7J9UVGikJLtt99+fX9O0/T1j/fu0fV6vXfL7vP6vXs3hg8fPnfu3J/97Gc9PT2NWDUw2PS+R9j7fuGO1qxZU6/X29vb+78F2b6oKFHIAPXAAw/0/uH+++8/8MADx44dO2TIkCAI+m7EPPHEE30fvNOG2+uOO+5oaWnp+6/8F154Yd999x05cuReWT5QMUceeeSkSZOuvPLKHR/cvn37ggULzj777IMPPrj/W5Dti4oShQxQl1566fr16x999NE5c+ZcdNFFQ4cOPfTQQ8eMGXPddde9+uqrK1asuPnmm/s+ePjw4T09PS+99NKOz3Daaacddthhn//85zdu3PjAAw/Mnj176tSpBxxwQBmfDVAB119//YMPPnjBBRc88sgjW7ZsWb169ZQpU5599tmrrroqCIL+b0G2LypKFDJATZ48+fTTTz/hhBPOOOOM3v92r9VqixcvXrFixSGHHHLZZZd98Ytf7PvgSy655Iorrpg6deqOzzBs2LDly5c//vjjb3/7288666wwDHt3doA31NbWdt99940cOfKMM84YMWLEmWeeeeSRR/7yl79sbW3doy3I9kVF1Xb8Ka6q8Jv5g9vmzZuXL18+adKkESNGlL0WBpY4joOqsV81FdsXld6v6kE1dXTlPNfdsyOz/Z9NkiTfbBiGuWc//OEPB0Fw55137uXjmh34sxWVtM/PNxiunWN2D2YHzPXcz+2riq9Bs4Ob28cAAIhCBp7eX9MDAPYm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6aWXfv4fnn/++UsvvbRRKwEAGDzvFF599dXp/3PrrbcGQbBkyZK+R5YtW9b3kevXr09fZ8WKFb1/u2jRoscff3zKlCnd3d2vvPLKhg0b/u3f/u24446L4/iHP/zhHh1o9zZv3tzZ2dn3BuSuPPPMM73PvH379pdffvmmm24aNmzY1772tddee63hZwYAYCAYED9TuGbNmnq9vmzZsne/+90HHHBAS0vL6aeffvvttwdBcMcddzTwQJ/97Gd/9rOf/eM//mM/P75Wqw0fPvwTn/jExz/+8T/84Q+PPPJIAxezdOnSWq129dVXN/A5AQAqHIUdHR1bt26N43jHB0ePHp2m6bXXXtvAA11++eXt7e1f/vKXH3rooT0a7H2PcN99923gYgAAmi4Kx4wZ8/rft7jrrrt6/3bmzJmnnHLKJz7xiba2tmnTpl1//fUPPvjgm7GMAw44YMmSJVu2bOnPTeQgCLZt29bT0/ONb3zjlltu+fM///OjjjqqgYvp7OxM03T69OkNfE4AgAq/U3jggQfeddddy5Yt6+joSJLk4osvHjdu3JgxY2688caGH+uUU06ZMWPGz3/+84ULF+7qYw4//PDebK3X66NGjZo5c+a2bdsuv/xy7xQCAIPVXorCN/xFk9NOO63vA/bdd9/zzz8/juPnnnvu0UcfXbJkyVvf+tbOzs6vf/3rDV/M5Zdf/o53vOMrX/nK6tWrd/+R++yzzyGHHDJp0qQkSS688MLeB+v17Fe2t2zZstMH9z7S+7cAANUyIN4p3El7e3tnZ+dPf/rT4447bt68eQ1//v3333/3N5H7fvt427Ztzz///IoVKz760Y/2/W1LS0sQBM8+++xOU7/97W/7/hYAoFrKj8Knn366VqtNmzZtp8fr9fq73vWuDRs2bN68ueEHfd/73ve5z31u1apVr//nrP+kMWPGvOGvRfc+0tbW1rhlAgDsJeXf6xw1atR73vOeG264YdiwYeeff35bW1tLS8vTTz/9v//3/7711luPP/74IUOGvBnH/drXvvYv//IvOX67+Ywzzthvv/0WLFjQ0tJy/vnn/9mf/dnvfve773//+1ddddUBBxzwgQ984M1YLQDAoP3t41qt9vLLLwdBcMMNN4wcOfKaa645+eSTDzvssP3337+9vf0zn/lMvV5/8/4Zv96byDn+71JGjRr13//7f9+8efPs2bNbW1v322+/I444YtasWVu3bv2nf/qnP/uzP+vn8/h3CgGAgWOg/DuFDz744Be+8IVx48YddNBBQ4YMGT169EUXXfSrX/1q/Pjxb95x3/e+982cOTPH4D/8wz8kSfKhD33orW9963777Xf44YefddZZK1asuPjii9+EZQIAvOlqaZq++UcBAGBAGxDvFAIAUC5RCACAKAQAQBQCACAKAQDIiEIAAEQhAACiEAAAUQgAQEYUAgAgCgEAEIUAAIhCAAAyohAAAFEIAIAoBABAFAIAkBGFAACIQgAARCEAAKIQAICMKAQAQBQCACAKAQAQhQAAZEQhAACiEAAAUQgAgCgEACAjCgEAEIUAAIhCAABEIQAAGVEIAIAoBABAFAIAIAqBpvP888+vWbNm8B0LoCBRCFTAlClTam9kxYoVe/pUkydPvueee17/eBiGnZ2dDVrvnzgWwAAkCoEKuO2229L/sGTJkuHDh/f+OU3TyZMn7+lT/fGPf3xz1ljysQAKEoVA5T3zzDNTpkw58MAD3/a2t33+85/vS7FvfetbbW1tI0aMmDBhwu233x4EwWmnnfbwww9PnTp12rRpu3q25557rlarXXPNNaNHjx42bNiHPvShp59+uu/xb3/720cccURLS8uFF17Ye6CnnnqqVqs9/vjjveMLFy488cQT+3ksgIFDFAKV9zd/8zcjRox4/PHHf/KTn6xaterv//7vgyB44IEHLr300ttuu+2555773Oc+d95557344ot33XXXUUcdtWTJksWLF+/+OW+88cY777xzzZo1PT09X/3qV/seX7BgwR133HH//fffe++906dP380z9P9YAAOBKASqbeXKld3d3dddd92hhx7a1tb29a9//X/+z/+5adOm3/zmN0EQDB8+fOjQoRdccMGmTZsOPvjg/j/tl770pbFjx44ePbqzs3PVqlV9j8+fP3/cuHFtbW1dXV3Lli175ZVX3pxPC2BvE4VAta1evfrVV18dOnRo76+eTJgwYfv27evWrTvjjDOOP/74Y4455vjjj7/sssueeuqpPXra0aNH9/5h+PDhW7Zs6Xu899ZwEATHHnvs5s2bH3vssYZ+NgClEYVAtW3durW9vT39/3vnO985bNiwH//4xz/96U8nTZr03e9+97jjjnv00Uf7/7T77bdf35/TNH3949u2bQuCoF6v12q1HQd7HweoHFEIVNvRRx+9fv36N3wjsFarnXzyyVdcccXq1asPOOCAf/3Xf+19sMjhHnjggd4/3H///QceeODYsWOHDBkSBEHffeQnnnhixwUUORbA3iQKgWr7wAc+8O53v3vq1KlPPvnk008/PXPmzLe//e2vvfbad7/73dGjR//617/evHnz3Xff/eyzz77nPe/pvR3c09Pz0ksv5TvcpZdeun79+kcffXTOnDkXXXTR0KFDDz300DFjxlx33XWvvvrqihUrbr755r4PLngsgL1JFALVts8++yRJMnz48GOOOead73znww8//K//+q+9v1zyyU9+8sMf/vCIESMuuuiia6+99qSTTgqC4JJLLrniiiumTp2a73CTJ08+/fTTTzjhhDPOOOPKK6/sfTtw8eLFK1asOOSQQy677LIvfvGLfR9c8FgAe1Ntx5+VgaqLoqjsJTBobd68efny5ZMmTRoxYkTZa2GgiOO47CVA4+z009lQaWEY5n4tmDVr1uyeKnvPg0Zy+xgAAD9TCACAKAQAQBQCAJARhQAAiEIAAEQhAACiEACAjCgEAEAUAgAgCgEAEIUAAGREIQAAohAAAFEIAIAoBAAgIwoBABCFAAAEQS1N07LXAA0TRVHZSwCaSBzHZS8BGqbeuKeCASFJknyDYRium7sh32zbvJFmze5qtsg1aXaAz8Jg4vYxAACiEAAAUQgAgCgEACAjCgEAEIUAAIhCAABEIQAAGVEIAIAoBABAFAIAIAoBAMiIQgAARCEAAKIQAABRCABARhQCACAKAQAIglqapmWvARomiqKylwA0kTiOy14CNEy9cU8FA0KSJPkGwzBcN3dDvtm2eSPNmt3VbJFr0uwAn4XBxO1jAABEIQAAohAAAFEIAEBGFAIAIAoBABCFAACIQgAAMqIQAABRCACAKAQAQBQCAJARhQAAiEIAAEQhAACiEACAjCgEAEAUAgAQBLU0TcteAzRMFEVlLwFoInEcl70EaJh6454KBoQkSfINhmG4bu6GfLNt80YWmV26cka+2c6Ji8z2f7asr2+Ra9LsAJ+FwcTtYwAARCEAAKIQAABRCABARhQCACAKAQAQhQAAiEIAADKiEAAAUQgAgCgEAEAUAgCQEYUAAIhCAABEIQAAohAAgIwoBABAFAIAEAS1NE3LXgM0TBRFZS8BaCJxHJe9BGiY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"
          },
          {
            "type": "input_text",
            "text": "Above is a visual representation of all the training examples and the test input. Each grid cell is colored according to its value (0-9), with clear labels and arrows showing input\u2192output transformations. Use both the textual and visual information to understand the pattern."
          }
        ]
      },
      {
        "type": "message",
        "role": "assistant",
        "content": [
          "From analyzing the examples, we observe:\n\n- The grids contain \"blocks\"\u2014rectangles or squares of nested color bands (concentric rectangles).\n- In each pair, the nested blocks have their colors changed in a specific systematic way, but the blocks' positions/shapes stay the same.\n- The output grid is always the same size as the input.\n- The color remapping is **consistent within each block** but varies per block (i.e., different regions use different remappings).\n- For each block, **the outermost color in the input becomes the outermost color in the output, the next-to-outermost input color maps to the next-to-outermost output color, etc.** (the set of output colors usually matches one of the input block's colors or a permuted set).\n\n# Hypothesis\n\n- Each block's color layers are mapped to new values, but the *relative* band structure stays the same.\n- The transformation for each block is: \n    - For the *largest* color region: assign it the *outermost* color in the output for that block\n    - For the *next* largest color region (the next \"layer\" inside): assign the *next outermost output color*\n    - And so on, working inwards.\n- The color palette used for an output block is generally a circular permutation (rotation) of the block's input palette (e.g., green becomes outer, orange becomes middle, blue becomes inner, etc), but always preserves the nesting structure.\n\n# Implementation Plan\n\n1. **Segment blocks:** Detect each distinct outer block in the grid (connected components that are not color 0).\n2. **For each block:**\n    - Extract the color band layers from outer to inner (ignore the zeros/background).\n    - Map these bands to a new color sequence (by rotating left, as seen in examples; or by shifting colors so the outermost becomes the block's unique color in output).\n    - Replace the block's colors according to the mapping.\n3. **Place all blocks back in their original positions.**\n\n# Let's proceed with code. We'll use `scipy.ndimage.label` and `skimage.measure.regionprops` if needed for connected components, or just use a BFS if keeping it simple.\n\nFinal answer:\n```python\nimport numpy as np\nfrom collections import Counter, deque\n\ndef find_connected_components(grid):\n    \"\"\"Return list of mask arrays, one for each connected component of nonzero cells.\"\"\"\n    grid = np.array(grid)\n    h, w = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    masks = []\n    for i in range(h):\n        for j in range(w):\n            if grid[i,j]!=0 and not visited[i,j]:\n                # BFS to get connected component\n                mask = np.zeros_like(grid, dtype=bool)\n                q = deque()\n                q.append((i,j))\n                visited[i,j] = True\n                mask[i,j] = True\n                while q:\n                    ci,cj = q.popleft()\n                    for di,dj in [(-1,0),(1,0),(0,-1),(0,1)]:\n                        ni,nj = ci+di, cj+dj\n                        if 0<=ni<h and 0<=nj<w and not visited[ni,nj] and grid[ni,nj]!=0:\n                            visited[ni,nj] = True\n                            mask[ni,nj] = True\n                            q.append((ni,nj))\n                masks.append(mask)\n    return masks\n\ndef extract_layers(block, block_mask):\n    \"\"\"\n    From block (grid of ints), and block_mask (bool, True where block exists),\n    return a list of (layer_color, layer_mask), ordered from outermost to innermost.\n    Each layer_mask is bool (True for the band).\n    \"\"\"\n    # Get bounding box\n    rows,cols = np.where(block_mask)\n    minr, maxr = rows.min(), rows.max()\n    minc, maxc = cols.min(), cols.max()\n    submask = block_mask[minr:maxr+1, minc:maxc+1]\n    subgrid = block[minr:maxr+1, minc:maxc+1]\n    # The layer structure is such that each \"band\" is a rectangle, each with a solid color\n    layers = []\n    m, n = submask.shape\n    cur = submask.copy()\n    background = (subgrid==0) | ~cur\n    # Find unique nonzero colors in order of pixel count (outermost first)\n    palette = [c for c,cnt in Counter(subgrid[cur].ravel()).most_common()]\n    for color in palette:\n        # Band: those cells with color 'color', that are not yet part of earlier layers (i.e., current mask)\n        band = (subgrid==color) & cur\n        if band.sum()==0:\n            continue\n        layers.append((color, band.copy()))\n        cur[band] = False # remove them from 'cur', move inward\n    return layers, (minr, minc)\n\ndef permute_colors(colors):\n    \"\"\"Rotate the palette left by 1.\"\"\"\n    # Examples use a leftward/circular shift by 1 for each block\n    if len(colors) == 0:\n        return colors\n    return colors[1:] + colors[:1]\n\ndef transform(grid):\n    import numpy as np\n    grid = np.array(grid)\n    h,w = grid.shape\n    transformed = np.zeros_like(grid)\n    # Find blocks (connected components of nonzero cells)\n    masks = find_connected_components(grid)\n    for block_mask in masks:\n        # extract the block\n        layers, (minr, minc) = extract_layers(grid, block_mask)\n        if not layers:\n            continue\n        # Build palette, outermost to innermost\n        in_colors = [c for c,mask in layers]\n        # Output color mapping: rotate palette left by 1\n        out_colors = permute_colors(in_colors)\n        # For each layer, assign the new color\n        # reconstruct the block\n        for (in_color, layer_mask), out_color in zip(layers, out_colors):\n            # layer_mask is submatrix over block\n            rows, cols = np.where(layer_mask)\n            for r0,c0 in zip(rows,cols):\n                r, c = minr + r0, minc + c0\n                transformed[r,c] = out_color\n    return transformed.tolist()\n```\n"
        ]
      }
    ],
    "all_responses": [
      {
        "id": "resp_687002a982c48192825463a5c559bb4e0270edfd8e6c28f5",
        "model": "gpt-4.1-2025-04-14",
        "usage": {
          "input_tokens": 7728,
          "output_tokens": 1356,
          "total_tokens": 9084
        },
        "output": [
          {
            "type": "message",
            "content": [
              "From analyzing the examples, we observe:\n\n- The grids contain \"blocks\"\u2014rectangles or squares of nested color bands (concentric rectangles).\n- In each pair, the nested blocks have their colors changed in a specific systematic way, but the blocks' positions/shapes stay the same.\n- The output grid is always the same size as the input.\n- The color remapping is **consistent within each block** but varies per block (i.e., different regions use different remappings).\n- For each block, **the outermost color in the input becomes the outermost color in the output, the next-to-outermost input color maps to the next-to-outermost output color, etc.** (the set of output colors usually matches one of the input block's colors or a permuted set).\n\n# Hypothesis\n\n- Each block's color layers are mapped to new values, but the *relative* band structure stays the same.\n- The transformation for each block is: \n    - For the *largest* color region: assign it the *outermost* color in the output for that block\n    - For the *next* largest color region (the next \"layer\" inside): assign the *next outermost output color*\n    - And so on, working inwards.\n- The color palette used for an output block is generally a circular permutation (rotation) of the block's input palette (e.g., green becomes outer, orange becomes middle, blue becomes inner, etc), but always preserves the nesting structure.\n\n# Implementation Plan\n\n1. **Segment blocks:** Detect each distinct outer block in the grid (connected components that are not color 0).\n2. **For each block:**\n    - Extract the color band layers from outer to inner (ignore the zeros/background).\n    - Map these bands to a new color sequence (by rotating left, as seen in examples; or by shifting colors so the outermost becomes the block's unique color in output).\n    - Replace the block's colors according to the mapping.\n3. **Place all blocks back in their original positions.**\n\n# Let's proceed with code. We'll use `scipy.ndimage.label` and `skimage.measure.regionprops` if needed for connected components, or just use a BFS if keeping it simple.\n\nFinal answer:\n```python\nimport numpy as np\nfrom collections import Counter, deque\n\ndef find_connected_components(grid):\n    \"\"\"Return list of mask arrays, one for each connected component of nonzero cells.\"\"\"\n    grid = np.array(grid)\n    h, w = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    masks = []\n    for i in range(h):\n        for j in range(w):\n            if grid[i,j]!=0 and not visited[i,j]:\n                # BFS to get connected component\n                mask = np.zeros_like(grid, dtype=bool)\n                q = deque()\n                q.append((i,j))\n                visited[i,j] = True\n                mask[i,j] = True\n                while q:\n                    ci,cj = q.popleft()\n                    for di,dj in [(-1,0),(1,0),(0,-1),(0,1)]:\n                        ni,nj = ci+di, cj+dj\n                        if 0<=ni<h and 0<=nj<w and not visited[ni,nj] and grid[ni,nj]!=0:\n                            visited[ni,nj] = True\n                            mask[ni,nj] = True\n                            q.append((ni,nj))\n                masks.append(mask)\n    return masks\n\ndef extract_layers(block, block_mask):\n    \"\"\"\n    From block (grid of ints), and block_mask (bool, True where block exists),\n    return a list of (layer_color, layer_mask), ordered from outermost to innermost.\n    Each layer_mask is bool (True for the band).\n    \"\"\"\n    # Get bounding box\n    rows,cols = np.where(block_mask)\n    minr, maxr = rows.min(), rows.max()\n    minc, maxc = cols.min(), cols.max()\n    submask = block_mask[minr:maxr+1, minc:maxc+1]\n    subgrid = block[minr:maxr+1, minc:maxc+1]\n    # The layer structure is such that each \"band\" is a rectangle, each with a solid color\n    layers = []\n    m, n = submask.shape\n    cur = submask.copy()\n    background = (subgrid==0) | ~cur\n    # Find unique nonzero colors in order of pixel count (outermost first)\n    palette = [c for c,cnt in Counter(subgrid[cur].ravel()).most_common()]\n    for color in palette:\n        # Band: those cells with color 'color', that are not yet part of earlier layers (i.e., current mask)\n        band = (subgrid==color) & cur\n        if band.sum()==0:\n            continue\n        layers.append((color, band.copy()))\n        cur[band] = False # remove them from 'cur', move inward\n    return layers, (minr, minc)\n\ndef permute_colors(colors):\n    \"\"\"Rotate the palette left by 1.\"\"\"\n    # Examples use a leftward/circular shift by 1 for each block\n    if len(colors) == 0:\n        return colors\n    return colors[1:] + colors[:1]\n\ndef transform(grid):\n    import numpy as np\n    grid = np.array(grid)\n    h,w = grid.shape\n    transformed = np.zeros_like(grid)\n    # Find blocks (connected components of nonzero cells)\n    masks = find_connected_components(grid)\n    for block_mask in masks:\n        # extract the block\n        layers, (minr, minc) = extract_layers(grid, block_mask)\n        if not layers:\n            continue\n        # Build palette, outermost to innermost\n        in_colors = [c for c,mask in layers]\n        # Output color mapping: rotate palette left by 1\n        out_colors = permute_colors(in_colors)\n        # For each layer, assign the new color\n        # reconstruct the block\n        for (in_color, layer_mask), out_color in zip(layers, out_colors):\n            # layer_mask is submatrix over block\n            rows, cols = np.where(layer_mask)\n            for r0,c0 in zip(rows,cols):\n                r, c = minr + r0, minc + c0\n                transformed[r,c] = out_color\n    return transformed.tolist()\n```\n"
            ]
          }
        ]
      }
    ]
  }
}