{
  "task_id": "e48d4e1a",
  "model": "gpt-4.1-mini",
  "use_tools": true,
  "api_type": "responses_api",
  "program": "",
  "execution_error": "No code generated",
  "timed_out": false,
  "tokens_used": 100962,
  "tool_calls_count": 10,
  "request_cost": 0.05004,
  "raw_response": {
    "id": "resp_6866bd7942ac81a2aa4e84dcb92abed8045bbeee5efbc8ae",
    "object": "response",
    "created_at": 1751563641,
    "status": "completed",
    "background": false,
    "error": null,
    "incomplete_details": null,
    "instructions": null,
    "max_output_tokens": null,
    "max_tool_calls": null,
    "model": "gpt-4.1-mini-2025-04-14",
    "output": [
      {
        "id": "msg_6866bd7b2f4881a28eaac80d6226e9b4045bbeee5efbc8ae",
        "type": "message",
        "status": "completed",
        "content": [
          {
            "type": "output_text",
            "annotations": [],
            "logprobs": [],
            "text": "Let's start by parsing the input and output grids for each example and analyze the pattern carefully using Python. We'll convert the inputs and outputs into numpy arrays for easier manipulation and pattern recognition."
          }
        ],
        "role": "assistant"
      },
      {
        "id": "ci_6866bd7c463481a2a8f202b4be9e40c1045bbeee5efbc8ae",
        "type": "code_interpreter_call",
        "status": "completed",
        "code": "import numpy as np\n\n# Training examples as numpy arrays for easier analysis\n\ntrain_examples = [\n    {\n        \"input\": np.array([\n            [0,0,0,2,0,0,0,0,0,5],\n            [0,0,0,2,0,0,0,0,0,5],\n            [0,0,0,2,0,0,0,0,0,0],\n            [0,0,0,2,0,0,0,0,0,0],\n            [0,0,0,2,0,0,0,0,0,0],\n            [0,0,0,2,0,0,0,0,0,0],\n            [2,2,2,2,2,2,2,2,2,2],\n            [0,0,0,2,0,0,0,0,0,0],\n            [0,0,0,2,0,0,0,0,0,0],\n            [0,0,0,2,0,0,0,0,0,0]\n        ]),\n        \"output\": np.array([\n            [0,2,0,0,0,0,0,0,0,0],\n            [0,2,0,0,0,0,0,0,0,0],\n            [0,2,0,0,0,0,0,0,0,0],\n            [0,2,0,0,0,0,0,0,0,0],\n            [0,2,0,0,0,0,0,0,0,0],\n            [0,2,0,0,0,0,0,0,0,0],\n            [0,2,0,0,0,0,0,0,0,0],\n            [0,2,0,0,0,0,0,0,0,0],\n            [2,2,2,2,2,2,2,2,2,2],\n            [0,2,0,0,0,0,0,0,0,0]\n        ])\n    },\n    {\n        \"input\": np.array([\n            [0,0,0,4,0,0,0,0,0,5],\n            [0,0,0,4,0,0,0,0,0,5],\n            [0,0,0,4,0,0,0,0,0,5],\n            [4,4,4,4,4,4,4,4,4,4],\n            [0,0,0,4,0,0,0,0,0,0],\n            [0,0,0,4,0,0,0,0,0,0],\n            [0,0,0,4,0,0,0,0,0,0],\n            [0,0,0,4,0,0,0,0,0,0],\n            [0,0,0,4,0,0,0,0,0,0],\n            [0,0,0,4,0,0,0,0,0,0]\n        ]),\n        \"output\": np.array([\n            [4,0,0,0,0,0,0,0,0,0],\n            [4,0,0,0,0,0,0,0,0,0],\n            [4,0,0,0,0,0,0,0,0,0],\n            [4,0,0,0,0,0,0,0,0,0],\n            [4,0,0,0,0,0,0,0,0,0],\n            [4,0,0,0,0,0,0,0,0,0],\n            [4,4,4,4,4,4,4,4,4,4],\n            [4,0,0,0,0,0,0,0,0,0],\n            [4,0,0,0,0,0,0,0,0,0],\n            [4,0,0,0,0,0,0,0,0,0]\n        ])\n    },\n    {\n        \"input\": np.array([\n            [0,0,0,0,0,0,6,0,0,5],\n            [0,0,0,0,0,0,6,0,0,5],\n            [0,0,0,0,0,0,6,0,0,5],\n            [0,0,0,0,0,0,6,0,0,0],\n            [6,6,6,6,6,6,6,6,6,6],\n            [0,0,0,0,0,0,6,0,0,0],\n            [0,0,0,0,0,0,6,0,0,0],\n            [0,0,0,0,0,0,6,0,0,0],\n            [0,0,0,0,0,0,6,0,0,0],\n            [0,0,0,0,0,0,6,0,0,0]\n        ]),\n        \"output\": np.array([\n            [0,0,0,6,0,0,0,0,0,0],\n            [0,0,0,6,0,0,0,0,0,0],\n            [0,0,0,6,0,0,0,0,0,0],\n            [0,0,0,6,0,0,0,0,0,0],\n            [0,0,0,6,0,0,0,0,0,0],\n            [0,0,0,6,0,0,0,0,0,0],\n            [0,0,0,6,0,0,0,0,0,0],\n            [6,6,6,6,6,6,6,6,6,6],\n            [0,0,0,6,0,0,0,0,0,0],\n            [0,0,0,6,0,0,0,0,0,0]\n        ])\n    },\n    {\n        \"input\": np.array([\n            [0,0,0,0,3,0,0,0,0,5],\n            [0,0,0,0,3,0,0,0,0,0],\n            [3,3,3,3,3,3,3,3,3,3],\n            [0,0,0,0,3,0,0,0,0,0],\n            [0,0,0,0,3,0,0,0,0,0],\n            [0,0,0,0,3,0,0,0,0,0],\n            [0,0,0,0,3,0,0,0,0,0],\n            [0,0,0,0,3,0,0,0,0,0],\n            [0,0,0,0,3,0,0,0,0,0],\n            [0,0,0,0,3,0,0,0,0,0]\n        ]),\n        \"output\": np.array([\n            [0,0,0,3,0,0,0,0,0,0],\n            [0,0,0,3,0,0,0,0,0,0],\n            [3,3,3,3,3,3,3,3,3,3],\n            [0,0,0,3,0,0,0,0,0,0],\n            [0,0,0,3,0,0,0,0,0,0],\n            [0,0,0,3,0,0,0,0,0,0],\n            [0,0,0,3,0,0,0,0,0,0],\n            [0,0,0,3,0,0,0,0,0,0],\n            [0,0,0,3,0,0,0,0,0,0],\n            [0,0,0,3,0,0,0,0,0,0]\n        ])\n    }\n]\n\n# Let's visualize the difference for the first example to see the movement of nonzero blocks\nimport matplotlib.pyplot as plt\n\ndef visualize_example(ex):\n    fig, axs = plt.subplots(1,2, figsize=(10,5))\n    axs[0].imshow(ex[\"input\"] != 0, cmap='gray_r')\n    axs[0].set_title(\"Input Nonzero Positions\")\n    axs[1].imshow(ex[\"output\"] != 0, cmap='gray_r')\n    axs[1].set_title(\"Output Nonzero Positions\")\n    plt.show()\n\nprint(\"Visualizing example 1:\")\nvisualize_example(train_examples[0])",
        "container_id": "cntr_6866bd7ac4348191aa4380959eb286cd0e6585decbda08c8",
        "outputs": [
          {
            "type": "logs",
            "logs": "Visualizing example 1:\n"
          },
          {
            "type": "image",
            "url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABlUAAANFCAYAAADifnofAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjYuMywgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/P9b71AAAACXBIWXMAAB7CAAAewgFu0HU+AAC7b0lEQVR4nOzdeXQT9f7/8VdobcveIksEtAhiRUSQwlVAEa64gKgIsqioiAoKuON6XcAvcOXndhUXEEVwF1xxwX0DFZECRVCKopTNFFnCnkJLfn9wiEzTlPmUTiZpno9zPMeELO+0r34yn3nPfMYTDAaDAgAAAAAAAAAAQJmquF0AAAAAAAAAAABAPKCpAgAAAAAAAAAAYANNFQAAAAAAAAAAABtoqgAAAAAAAAAAANhAUwUAAAAAAAAAAMAGmioAAAAAAAAAAAA20FQBAAAAAAAAAACwgaYKAAAAAAAAAACADTRVAAAAAAAAAAAAbKCpAgAAAAAAAAAAYANNFQAAAAAAAAAAABtoqgAAAAAAAAAAANhAUwUAAAAAAAAAAMAGmioAAAAAAAAAAAA20FQBAAAAAAAAAACwgaYKAAAAAAAAAACADTRVAAAAAAAAAAAAbKCpAgAAAAAAAAAAYANNFQAAAAAAAAAAABuS3S4AAABgyJAhWrBgQej2xIkT1a5du0r7vgCAymHXrl3Ky8vT6tWr5ff7VVhYqNTUVNWuXVtHHnmkjjvuOFWtWtXtMgEACDN//nxde+21odtt27bVs88+W2nfF6hINFVwyEaNGqUPPvggdJvBMPGU/ELcr1GjRnrrrbeUnGw+1HTs2FG7d+8O3WZHJ+JNpL+L0lSrVk01a9ZUvXr11LJlS5100kk6/fTTddhhhzlcJQAAMLVnzx7NmjVLH330kRYuXKji4uKIj01KSlLr1q3Vo0cP9ejRQykpKVGsFJVdyYND9rv33nt1wQUXGL/e1KlT9eSTT4ZuM7dHPIr0d1FScnKyatSooVq1aqlZs2Zq2bKlunbtqszMzChUCSDe0VQBKoFt27bp1VdfDd2uWbOmLrnkEhcr2mft2rV69913ddFFF7ldChDTdu7cqZ07d6qgoEBLlizRG2+8oTp16ujSSy/VwIEDlZSU5HaJMScvL09ff/116HZWVpa6dOniWj0AgMTw6aef6vHHH1dBQYGtxxcXF2vBggVasGCBJk2apBtvvFHnnHOOw1Ueuq+//lp5eXmh2126dFFWVpaLFcWmWP05TZ48WT169OAAHaAMRUVF8vv98vv9WrVqlb766is99dRTOvnkk3XLLbeoadOmbpcYk1599VVt27YtdPuSSy5RzZo1XawIcAdNFaAS2LZtmyZPnhy6fcQRR8REU0WSpkyZovPOO0+pqalulwLElU2bNmnChAmaPXu2Hn30UdWqVcvtkmLK8uXLLeNez549aaoAABxTWFioMWPGaNasWREfU6VKFdWoUUPbt2/X3r17w/7977//1j333KNvv/1W9913n9LS0pws+ZB8/fXXltUIGjZsGBPNglgTqz8nn8+nt956SwMGDHC7FCCuBINBzZ07V5dddpnuvvtunXvuuW6XFHNee+01/fXXX6Hb5513Hk0VJCSaKgActX79es2YMUMDBw50uxTAddddd51q164ddv/27du1evVqzZ07N+zI10WLFum2227Tk08+ydGGAAC4IBAI6IYbbih1OZn27dvrrLPOUocOHVS3bl0lJyerqKhIGzZs0Lx58/TJJ5/oxx9/tDzn008/1d9//60nnniC663AMS+88IJ69eoV0807IBpatWpVanOkqKhImzZt0pIlS5STk2NZyrGwsFAPPPCA0tPT1alTp2iWCyBO0FQB4LipU6fqwgsvVPXq1d0uBXBV9+7d1bBhw4j/XlRUpHfffVePPfaYCgsLQ/fn5OTojTfeqNTNSbfW62adcABAWYLBoO66666whkqDBg1055136rTTTgt7TnJysrxer84//3ydf/75+uGHHzRu3DjLkb0LFy7UnXfeqccee0xVqlRx/HMg8WzcuFGvv/66Bg0a5HYpgKsyMzMPuiT5mjVr9MADD1jG+uLiYj3wwAN67733Km1zsl27dpo/f37CvC9Qkdh6A1DhkpKSLEfj+/1+yzVfAJQuOTlZF110kR566KGwHSwvvviipdECAACcN23aNM2ePdty31FHHaVp06aV2lApTYcOHTRt2rSwix9/9913mjZtWoXVChx++OGW2y+++KK2b9/uUjVA/GjcuLGefvpptW3b1nL/xo0b9eabb7pUFYBYRlMFQIVLSkoKOyLq5Zdf1pYtW9wpCIgzHTt2DDtFfdOmTcrNzXWpIgAAEs+aNWss1++SpDp16ujpp59W3bp1jV5r//NK7vSePHmyVq9efci1ApLUq1cv1alTJ3R769atevHFF12sCIgfycnJuu+++5SUlGS5/+uvv3anIAAxjaYKAEf07dtX9erVC93esWMHR+IBBnr16hV2H6dIAwAQPZMmTQo7S/Tmm2+W1+st1+s1aNBAN998s+W+3bt3sxQlKkzVqlV15ZVXWu57/fXXtXnzZpcqAuJL48aN1a5dO8t9S5YsUSAQcKkiALGKa6ogJgWDQeXl5SkvL0+bNm1SUlKSMjIydOyxx+rYY4+Vx+Op8PdbtmyZli9frs2bNyspKUn16tVT8+bN1axZswp9r0SRlpamq666Sg8++GDovunTp+uSSy4xPrLvUOzP0sqVK+X3+7Vr1y6lp6crIyNDJ554ouVIroq0Z88e5ebm6s8//9TWrVtVrVo1ZWRkqE2bNuWeiLth3bp1ob/DLVu2qFq1aqpTp46OPfZYNWnSxJH33LZtmxYvXqw1a9Zo+/btSk5O1pFHHql///vfB33uhg0btGTJklC9VatWVUZGhpo0aeLI2OGkli1bKikpyXLBRJ/PZ+u50cj93r17tWrVKv3222/auHGjdu7cqSpVqigtLU116tRRw4YN1bRpU1WrVu2Q3yse7N69W4sXL5bP55Pf79fevXuVkZGhevXqqU2bNo6tw7x161YtWrRIq1evViAQUK1atVS/fn21bdtWNWvWPKTXLioq0p9//qkVK1bI7/drx44dSkpKUtWqVVW3bl01atRIRx99tFJTUyvo0wBA7NiwYYM+/fRTy31t2rRR9+7dD+l1zznnHL399tuWdfs//fRT3XjjjVHdRo4Vfr8/tN23f3vF6/Wqbdu2qlq1qtvlxaU+ffrolVdeCW037ty5U1OmTNGtt94a1Tq2bNmin3/+WRs2bJDf71dKSooyMjJ05JFHqkWLFmFnA1SUdevW6eeff1ZBQYGKi4uVnp6uI488Uq1bt9Zhhx3myHtWtN27d4c+w+bNm7Vnzx5lZGSoQYMGjm1XBoNB/f777/rtt9+0YcMG7d69W7Vq1dKpp55a5jUhpX3bjEuXLtW6deu0adMm7dmzR+np6apbt65at259yNuk0XbiiSfqxx9/DN0uKirShg0b1Lhx44M+Nxq537Ztm/Ly8rR69Wpt375dhYWFSktLU/Xq1eX1enXkkUfaqrWyWLt2rZYtW6bNmzdr69atqlGjhurUqaNjjjnGsX0WTu+z3LRpk5YvX661a9dq+/bt2rNnj9LS0lSjRg01bNhQRx11VFztV6qsaKrAFeedd57lQo0zZ85Uw4YNtXfvXr311lt66aWXtG7dulKfW79+fV155ZW68MILlZxsL8JDhgyxTFwmTpyodu3aqaioSNOnT9crr7yigoKCUp979NFH6/LLL9d5551n+/NFej+73n//fY0ePTp0u2fPnho1apTlMevWrdP5559f6vP/+uuvg77f/p+5k3r16qWXXnpJa9eulSQFAgE9//zzuuOOOxx9X2nfRPj555/XF198oU2bNpX6GI/Ho+OOO079+/dXjx49bF8ktOTP/ogjjtD7778vSdq+fbuef/55vf3229qxY0epz2/RooWGDx+uU0455aDvNWrUKH3wwQe26jqY+++/31aOt2/frldffVUff/yxVq1aFfFxjRo10oUXXqgBAwbY3rAvK9u//PKLJk+erO+//97SSJD2/YwjNVWKi4s1c+ZMzZgxQ8uXL4/43nXr1tWZZ56pwYMHKyMjw1a9bkpOTlZ6ero2btwYus/v95f5HCdzf2AN06ZN06xZs7Rhw4YyH1ulShU1a9ZMp556qnr27Bm2lvyB7IybJfNzoA8++KDMv5UD/05N37csv/76q55//nnNnTs34hFsKSkpateunQYPHqw2bdrYfu2y/l7y8/P1zDPP6Kuvvgr7e5H2LcPYuXNnDR8+3Hgy8ddff+mFF17Q559/rq1bt5b52OTkZGVlZalz584677zzVL9+faP3AoBYNWvWrLDx9WAXOrarT58+YRdDnjVrli677LJSHz9//nxde+21odtt27Y1Prsl0vzrQGVtd44ePTrid7BU+nylrLpXrFihp59+WnPmzCn1eywtLU1du3bViBEj1KBBg4N+voO9n11u/JwqWkpKiq6++mqNGTMmdN9bb72lgQMH2v5ZHorPP/9cr776qpYsWaK9e/eW+pjatWurc+fOuuaaa4zmpCV/9gfOb+bOnatnn31WixcvLvW5VatWVe/evXXVVVepVq1aZb5PWXNtU5G2QUuzYMECvfTSS/rpp5/K3K48+eSTNWTIELVo0cJ2HZGyXVhYqNdee00zZswodZ9I1apVI/6OVq1apcmTJ2v27NkRr92TlJSkE088UQMHDtTpp59uu143lVymUdo3ByqrUeFk7vf75ptv9MYbb2j+/PkR3+PA9zrppJN0xhln6Oyzz44457M7bpbMz4EO9rdS2n6IQx2vA4GA3njjDc2cOVP5+fkRH9eoUSP16NFDAwcOVPXq1W2/frT3WUr7GjUffvih3nrrLf38888HfXzdunWVnZ2ts846K27+tioblv9CzPD7/br22ms1fvz4iIOTJK1fv17jx4/XrbfeekinYPr9fg0ZMkSPPvpoxIaKJP35558aPXq0hg0bxkX+DCUnJ+uaa66x3Pfuu++W+futCK+//rp69eqlGTNmRNyxLO370vr11181atQoXXrppWU2EOxYtmyZ+vfvr5deeiliQ0XatxN2xIgRMbnUw4cffqgLLrhAzz777EF/HmvXrtWTTz6pPn366Ndffz2k933uuec0aNAgzZ49u9SJdSQrVqxQ//79NXbs2DIbKtK+hsNrr72mXr166d133z2keqOl5MZyWUe8RCP3c+bMUe/evfXSSy8dtKGyv/7ffvtNL7zwQqW7wOOePXv0wAMP6PLLL9fXX39d5vfR7t279f333+vqq6/WHXfcoV27dh3Se3/44Ye65JJL9Pnnn0f8eykuLtZXX32lgQMH6rvvvrP92u+++64uuugivf322wdtqEj/HJn4zDPP6PPPP7f9PgAQ60penL5GjRrq2rVrhbx2ly5dwo7cnjNnToW8djyYOXOmBg4cqG+++Sbi91ggENCsWbPUr18/ffLJJ1GuMP717NlTRx11VOj27t279dxzzzn6ngUFBbryyit15513avHixWXu9N2yZYvef/999enT55DrKi4u1sMPP6wRI0ZEbKhI0q5du/TKK6/o8ssv15o1aw7pPSva5s2bdeONN2rIkCGaPXv2QbcrZ8+ercsvv1zjx483mjuVtHr1al166aV68skny9wnUlIwGNRTTz2lvn37atasWWXuJykuLtbChQt16623aujQoWXOU2JFMBgMuy/SPCwauQ8EAho5cqRuvfVWzZs376ANlf3v9fXXX+vee+8tc99EPMrJyVGfPn00YcKEMhsq0r59FpMnT1avXr3CvtdNObnP0u/366qrrtKoUaNsNVSkffs3PvnkE91///22Ho+KR1MFMWHHjh0aNmyY5YgtSaFTGEvz3XffaezYseV6v8LCQt1www1hG12pqakRl6qZN2+ehg8fTmPFUI8ePdS0adPQ7T179oRd8LMi/e9//9PDDz9c6pdXcnJyxFOPf/vtN1111VVaunRpud73t99+03XXXRe2MVqjRo2IS+M8++yzMbNzPxgM6umnn9b999+vLVu2hP17UlKSateuXeop8wUFBRoyZIjmzZtXrvd+9tlnNXHiRMvGocfjUa1atco8PXrRokW6+uqrtXLlylL/vWbNmqU+f8eOHRozZowmTZpUrnqjpaioKGyndu3atUt9bDRyv2DBAo0cObLUHe0ej0fVq1ePmJHKZseOHbr++us1c+bMUiddZX2XfPHFFxo6dOhBzzqK5IMPPtCoUaMsa/xXqVJFtWrVKvVIqP2TsBUrVhz0tT/++GONGTMm7PoB0r4xoGbNmqpdu7bREVcAEI+KiorCdmq0adOmwpY7TE1NVevWrS33/fzzzyoqKqqQ149ln3/+uf7v//5Pe/bsCd23f7uvtCOpd+zYofvuu0+zZs2KZplxLzk5WUOHDrXcN3PmTMeaCX/++acGDx4ccWdg9erVS91G3LNnjyZOnKgHHnjA1o7i0owdO1avv/665b7DDjtMtWrVKnVH+Jo1a3TDDTfEzDUyVq5cqUGDBkU8CKZq1aqlbssHg0HNmDFDI0eOLNfYsX79el177bVhc6nU1NQyj+gvKirSf/7zH73wwgulNnRSUlIiPj8nJ0eDBw+OuaZWSaU1fkqbh0Ur97fddpu+/vrrUv8tNTVV6enpql69elwtdV1eX3zxha6//vpSm4BlfZds3rxZI0eOLPf+Fyf3We7evVvXXnttxKZwWlqa0tPTWRIzBjErRkz473//GzrK/Pjjj9fAgQN18sknh764tm7dqq+++krPPPOM5ejoWbNm6bzzztO//vUvo/ebPHmyfvnlF0lSnTp1NHjwYJ1xxhmhC6v7/X59++23ev7550NLV0nS0qVLNW7cOI0bN+6QPm9FqF27tu68805J+45CeOaZZyz/dt111x30+dFQpUoVDR061LLk10cffaQrrriiwte3fPvtt/Xyyy9b7ktNTdUll1yiHj16qEmTJvJ4PCosLNRPP/2kV1991dII2P9F+9prryk9Pd32+xYWFuq2227Ttm3b5PF41K1bN/Xq1csy+V67dq0++OADvfjii5Ydlo899pi6du0a8ffRs2dPnXDCCQY/hX1yc3PDJp9lLfP00ksvacqUKZb7jjrqKPXr10+nnHKKMjMzQxtpa9as0ddff62XXnoptDTVrl27dNddd+m1114zWv5n6dKl+uijjyTt2wC/6KKLdPbZZ+u4444LXU9k9erVmjt3ruV5f//9t2699VZt27bNcn/Hjh01YMAAtWvXTikpKdq7d69WrlypDz/8UK+++qplAj958mRlZmbqnHPOsV1vNC1dujRsolLauqnRyH0wGNS4ceMsE7YaNWpowIAB6tKli5o2baqUlJTQv23btk0rVqzQ4sWLNWfOHC1cuLA8P4IwrVq1Co17P//8sz788EPLv5177rkRn2tyuvfBjBs3TvPnz7fcV79+fQ0ePFhdunQJrYnv9/s1e/ZsTZkyRatXrw499pdfftG9996rJ554wmjy8/vvv+vTTz9VMBhUWlqa+vbtq7PPPlvHHnusqlSpEro+2CuvvKKPP/449Lw9e/bov//9b5lHxO3cuVMPPfSQ5b7DDz9cl156qU499VQdddRRlmbK5s2btWLFCi1cuFCzZ88OfacCQGXwxx9/WLYZJBkts2NHixYtLGen7N69WytXrtQxxxxToe9j4sDtzg8//NCyo/Dcc89Vq1atIj7Xznb9xo0bNWbMmNABCWeccYb69u2rNm3aKDk5WcXFxVq2bJneeecdvffee6HHFRcX64EHHlDz5s1d/fns5/TPqaKcddZZmjp1qn777TdJ+36OEydOtCwLVhF27dqlW2+9NWwn5wknnKDLLrtMHTp0ULVq1RQMBrV27Vp99tlnmjp1quXo+ZkzZ6px48YaPHiw0Xu/8847oR2R9evX1+WXX67TTjtNjRo1krTv72r+/PmaOHGiZVtl1apVeuGFFyLOmQ+ca5vYu3evnn32WcvBM2XNwfx+v4YPH2752SUlJemss84KZWn/NmxhYaEWLVqk6dOn65tvvgk9fvbs2XrmmWd0/fXXG9U6bty40Psee+yxod/V/vnAjh07NHfu3LC53aRJk8KuN1WzZk0NGjRIZ555ZmhZqx07duiHH37QtGnTLKsarFmzRiNHjtSLL75omT/EkpI7t5OTk8OueRWt3H/88cf64YcfLPdlZ2erb9++OumkkyxLlRUXF2vNmjX67bffNHfuXM2ePduylPShGDZsWKj2Z555xnIg5nXXXVfm/qWyxkQTv//+u+69917t3r3bcv8555yj3r1768QTTwx9l+Tl5endd9/Vu+++G2pcFRcX67///a+aNGlitCSz5Ow+y1deeUW///675b6uXbvqggsuUKtWrSw/26KiIuXn52v58uX6/vvvNWfOnFIP8kN00FRBTNj/pXXNNdeEHVEjSbVq1dIFF1ygk08+WVdddZXli2v69OnGTZUlS5ZI2jcYTpgwIewLID09Xeeff77OOuss3XHHHZajRj799FOdddZZ6tKli9F7VrTq1auH1nVet26dpalSrVq1ClvzuSKcccYZatGiRWhjqri4WM8884zGjx9fYe+xZs0aPfroo5b76tevr6effjps8pKamqpTTz1Vp556qqZOnaonn3wy9G9///23xo4dG7ZzsSybNm3Spk2bVLVqVY0bN06nnXZa2GMaNWqkoUOHqk2bNrrhhhtCO8t37Nihjz76SBdffHGpr92uXTuj6ztI+5bEeuqppyz3tW3bVmeeeWapj1+8eHHY4y+55BJdf/31pR5Z07hxYw0cOFA9e/bUrbfeqtzcXEn7mnvjxo3T//73P9u1/vnnn5KkevXqacKECWET5aSkJDVp0iTsd/jAAw+EnVEzcuRIDRgwwHJflSpV1LRpU11//fXq3r27hg0bZjny6L///a/atm0bk9eBKO0ompJZiFbuly5dajmKrVatWpo6daplWYkD1axZU23atFGbNm1CSyxEWoPXxIFZSE1NtTRVMjMzozLuffLJJ2HLkLRv314PPfSQatSoYbk/PT1d5513ns4880zde++9+uqrr0L/9sMPP+iNN94Iy2xZli1bJkk68sgj9fjjj4f9/D0ej1q0aKExY8boyCOPtJwVuGjRIi1fvlzHHntsqa89Z84cy99Uo0aNNHXq1IjXH8rIyAiNT9dcc42WL18eNsEBgHhV2lHUzZs3r9D3KO311qxZ42rT4MDtziVLlliaBe3atTO6xmRp9i/TUqVKFd13333q2bOn5d+TkpLUsmVLtWzZUv/+9781cuTI0HfLnj17NHr0aE2bNs34enAVzemfU0XxeDy67rrrdMstt4Tu+/TTTzVo0KAKzdljjz0WtpzsZZddpuuvv97yu/J4PGrcuLGuvPLK0Hb5gc+bNGmSOnbsqOOOO872e+/fj9CpUyf997//DTtTOCUlRR07dlT79u118803Ww7Ueuedd3TNNdeUegbugXNtE2PHjrU0VJKSknTrrbdGfPyoUaMs+zaOOOIIjR8/Xscff3zYY1NTU3XyySfr5JNP1ocffqgHHnggNKd88cUX1bVrV6OD8f744w9J0sUXX6ybb7457O+qevXqOuOMMyz3LVq0SNOmTbPc16xZMz311FNhTYfq1aurW7du6tq1qx555BFNnz499G+///67nnrqKd188822642WNWvWhB08dcIJJ4RdQzRaud9/AOJ+/fv312233VbqY5OSkpSZmanMzEx169ZNRUVF+uKLLypkJYHu3buH/n/atGmWeUP37t0dv15vUVGR7r77bst8Izk5WePGjQu79mpSUpKOP/54HX/88TrzzDN18803h85MKy4u1j333KMZM2YYnfnh5D7LA+e0knTTTTdp4MCBpT42OTlZzZo1U7NmzdS9e3cFAgHLHBPRxfJfiBl9+/YtdXA6kNfrDfvinT17dqlLlRzM4YcfrieeeKLMjnpaWprGjx9vWb5KkuPr0VZGw4YNs9z+8ssvQzsIK8LLL79sOYU7JSVFEyZMOOjRYIMGDQpraHz11Ve2lsop6f777y+1oXKgk08+Wb1797bcV5HXISgoKNANN9xgOYOjWbNmeuSRRyIeCfT4449bzoi4+OKLdcsttxx04ys9PV2PPvqojjjiiNB9c+bMCTvK4mCSkpL0v//9z/bkbsmSJWFH61x11VUH3Tl9zDHH6PHHH7csCbZjxw699tprRvVGw9y5c8M2rjIyMsKWColW7kv+rfbu3TtiQ6U0jRs3Vvv27W0/PpY9//zzltuZmZl69NFHwxoqB0pLS9O4cePUsmVLy/3Tpk0zXq6hevXqmjBhwkF//tdcc03YDruyxpqSv+PLL788YkOlNMcee2y5zqoDgFhU2nXDTMZEO0o7O/Tvv/+u0PeIVddee21YQ6Wkjh076u6777bc9+uvvybUtWcqQufOnS1Hie/du9dyMN6hWr9+vd577z3Lfd27d9eNN95YZvPL6/Xq6aeftpxJXFxcrBdeeMG4hqysLD300EMRl16V9i0Hdt9991nmQ5s2bVJOTo7x+0UyadIkvfPOO5b77rrrLnXu3LnUx//444+WPNeuXVvPPPNMqQ2Vks4991zLmSnBYFAvvviicc1nnHGGbr31VtuNyilTpliWq0pPTy+1oXKgpKQk3XbbbWHXpHrzzTfLvRyuU4qKijRmzJiw1QJKHlAbzdwfuI2enJwctl+lLMnJyTr77LPDGkLx6Kuvvgo1Ave78847wxoqJbVv3z7s7Dyfz6f333/fuAYn9lkGAgHLwYv16tXTJZdcYrumtLQ0S8ML0UVTBTGhdu3auuGGG2w9tmvXrqpTp07odnFxceiUZhMjRoywtcRTWlqaRo4cablv2bJlobNdYE+HDh100kknhW7vv4ZHRdi+fXvYDujLLrtMzZo1s/X8YcOGhZ2pUHJd3oM55ZRT1K1bN1uP7dOnj+X28uXLy72G8IG2bdsWtr6o1+vVhAkTIl5TIzc3N3SmiSQ1bNhQI0aMsP2etWvX1pAhQyz3lZxMHEyfPn2UlZVl+/FvvPGG5Xbjxo111VVX2XpuixYt1K9fP8t97777bsysqVxcXKx33nlHt956a1gmrrjiCsta7tHMfcnrqDh9JFKsmjdvXtjG/B133GHrKKfDDjtMd911l2W5r7///tu4qTpo0CA1btz4oI+rUqWKLrjgAst9ZTWySy6lt3/ZDABIRDt37gy7r6zmeXmU9nqlvW9lc9RRR+nyyy+39diePXuGLdHy5ptvOlBV5VZyJ+w333xTYXPZt956y7IDumbNmmWemXEgr9era6+91nLf119/LZ/PZ1TDHXfcYWsZqfr166tTp06W+w5clupQvPPOO2HXDb322mvVq1eviM8p2QQZNmyYrW28/QYMGGDZXvv666+1efNm289PTk6OeMZDaVavXh12YNuIESPKbKjs5/F4dPvtt1t27hcWFhrPG520du1aXX/99WFnqRx++OFhZy1FM/cHzsP2XzslEZXcB3DSSSeV+fd1oC5duoQ1xkz39zi1z7LkHOyII45w/WxM2MdvCjGhR48etk+9239a+IEiXag6klq1aunss8+2/fh//etfyszMtNz37bffGr0npOHDh1tuf//991q0aNEhv+6CBQu0a9eu0O2kpCT17dvX9vOrVq0atvPx+++/N6rB5PTwZs2aWTaGdu3aVeqF1kwUFhbqlltusezwrV27tiZMmFDm0lYllzG68MILjS/C+u9//9ty9kfJi7cdTMkzdw6m5O+md+/eRuvxDhgwwLJje9u2bREvClfRZs2apTfffDPsv6lTp2rs2LG64IILNHbs2LAjWdq2bav+/ftb7otm7ks25SpqAhpvSl5AtGnTpkbLTx533HGW5nJpr1mWKlWq6MILL7T9+JI7osr6riy5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Vq1aKTs7W+3bt+f6lzGCpgpiQrQbE+W5uFfJL8q9e/dqx44dFX7RykRw3XXX6Ztvvgl9sfzyyy/68ssvy7WUjhT+JVve30nJ59ndwHOrsfb++++HLZ82ZMgQ29dccHID1u5a16ZHZJY8bba8F+or+buO1uR85syZFXaR92jnvmnTpnrxxRc1ZsyYUpeL2L17t37++Wf9/PPPeumll5SWlqbTTz9dl19+ubKysspVWywp7edSEd8l+1/bzllxTo817dq10/PPP68xY8YoLy8v7N937dqlBQsWaMGCBZoyZYpq1qypbt266YorrijXGWMAEKtKG9OWL1+url27Vth7lHbWe2XfSVJR221uHwwTr5o3b66zzjrLck3FZ555Rqeeemq5tjFK/h7c+P26MQ/bvn27brjhBv3111+h+xo0aKAJEybY3vHqVIZNrjfk5jzswKZKNOZhPXv21KhRoyrktdzI/X/+8x81adJEkydPLvUsx4KCAhUUFISW7m3atKl69+5druulxiK39/dIzo41SUlJeuSRRzRp0iS9+uqrYddXlaQ1a9ZozZo1mjVrlqR9y8L17dtX3bt3L3VVC0QH11QBEHVHH320unfvbrlv4sSJCXd9hkPx3XffacyYMZb7evfurSFDhth+DSfXry15Bgwqh8aNG2vixIl6/vnn1bt37zIbAYFAQJ988okGDhyo//f//l9CXHy3MmjRooVefvllTZgwQd27dy/zVPNt27bpnXfeUZ8+ffTcc8/xdw+g0mjatGnYcocVfR2Pkq932GGHHfRaeMChuvbaay074JYvX67PPvvMxYriy549ezRy5EhLU7RWrVqaMGGCGjRoYPQ6TmBbrPK69NJL9f777+v2229X27Zty1x2+Y8//tDDDz+siy66KGrXDsWhSU5O1vDhw/Xee+9pxIgRatmyZZnNkqVLl2rUqFEaOHBg2DKAiB7OVEFCKs/aqSWPCKhSpUq5j0o4mERoLlxzzTX6+OOPVVRUJGnfF/+sWbN07rnnGr9WrVq1LLfLu+Z1yeeVfN1YsXTpUt15552WU0hPP/30g14QsaTSPt+cOXOUlpZ2yDU6peTRX+VdB7nk79r09PdY4GbuW7duHbpmz7p167Rw4UItWrRIixYtsizPIe2b3E2fPl3btm3T//3f/5WrxlhQ2s+lIr5LIr22mzwejzp06BC6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+te/LI2Um2++WaeddpqOO+441axZ0zLpq169urp3737I73v22Wfr22+/tSx38P3336tv374aPHiwunTpEmqqb9myRbNnz9aUKVPCLrLboUOHsGtKuWnbtm166aWX9PLLL+v444/X6aefrpYtWyorK8sy4S0sLNRvv/2mzz77TG+++ablGlj169fXv//9bxeqBwDnVKlSRePHj9eIESMs29oFBQW66aab1L59e5199tk65ZRTVLduXSUnJ6u4uFgbNmzQvHnz9Mknn4R970r7tvfHjx9v+a4qS48ePTRp0qTQMitFRUW64YYbNGjQIPXs2TO0JOzu3buVm5urd955R5999pmCwaAaN26snTt3Gl17rU2bNqpZs2bou3zLli3q37+/unTpoiZNmoQt/9KkSZODNtYzMzO1ceNGbd++XaNGjdKcOXPUr18/nXjiiUpOTtbevXu1bNkyvfPOO3r33XctOyeTk5N1//33H3SHdmX4OUXTgAED9Prrrxs3Uw508803a/78+ZZtneeee04//fSTLrvsMp1yyimhg4DWrl2rzz77TFOnTg1bMujaa6+NeL2caHv++ectP5OkpCSdeuqpB20GlqasbdCxY8dq0KBBobMKCgsL9eCDD2rGjBnq3bu3srOzwy6MvnnzZv3+++/69ddfNWfOHOXm5qq4uDgqBwW2bt1aV1xxhV544YXQfXl5ebrooot05ZVXqlu3bqG/sZ07d+qHH37QtGnTSr0o+7Bhwxyv10nRyv3y5cs1atQojR8/XqeeeqpOPvlkHXfccTr66KOVmpoaepzf79fChQs1Y8YMzZs3z/IavXr1siwbfag6d+5sycCCBQvUt29fnXrqqTriiCOUkpJieXyk/RAmkpOTNXbsWF1xxRWhOf3u3bt1880369xzz9WFF16oli1bhr6Dly9frvfee09vv/225ZovSUlJGjNmTIX+PA7VokWLtGjRItWuXVudO3dW+/btlZWVpaOOOsqyBOnff/+t+fPn69VXXw07GLt///6W5fkQHTRVkJCGDBmiiRMn6pdfftHGjRv10EMP6aGHHlJaWpqSkpIsR6QcqEWLFvrPf/5j6z2uvPJKffbZZ5aleBYvXqwRI0aoSpUqqlmzpnbu3Bm2zNL555+vk046ybip0qtXL7322muWjb/c3NyI13Pp2LFjzDRVpH1Hqrz66quH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ZwIAAABiX1SaKlu3blXfvn1Dk4OOHTtq9OjROv7448Meu3v3bn333Xfavn17NEpzRHZ2tiRx5BdsIzMwRWZgiszAFJkBoivR5kyS5PP5JEler9flShAvyAxMkRmYIjMwQV4SV1SaKv/3f/+n/Px8SdL555+vJ598UklJSaU+NiUlRV27do1GWY5p166dJHZCwD4yA1NkBqbIDEyRGSC6Em3OJCm0bDM7ImAXmYEpMgNTZAb/v717D5KrLPMH/nQSyIAYZgIkQ0ASCQgiC5IJK4JIWQYKohjwMsDKJeUWRsHSXRcF1HXZ2l8Kt9hFwcISd0sRRSECmrhcBFwUxGuG7HAxDJcsIyT0CElmcyHDZdK/P6g0uee8cc6cPtOfT5VVfSZvp5+jX9/0M0/3OSnkpXmNyvsFHnnkkfjBD34QERGTJk2KK664YpvNAQAAQLPRMwEAQHnkPlT53ve+V388e/bs2GOPPfJ+SQAAgNLQMwEAQHnkOlQZHByM+fPn149nzpyZ58sBAACUip4JAADKJdd7qjz22GOxevXqiIgYN25cTJkyJV599dW45ZZb4pZbbonHH388/u///i/Gjx8fb33rW+PEE0+MM888M8aOHZtnWQAAAA1BzwQAAOWS61Clu7u7/njSpEmxbNmymDNnTixatGiTddVqNarVatx7771xzTXXxLe+9a14+9vfvtOvO2rU9r+As379+p3+u7N46qmncv37GXlkhlQyQyqZIZXMwPAoqmdav359LFu2bLtrJk2atNN/fxatra25/v2MPDJDKpkhlcyQQl6aV6VWq9Xy+sv/7d/+Lb761a9GRMShhx4atVotenp6IiLioIMOiiOPPDJGjx4dixcvjocffrj+vN122y1uvfXWOOKIIzK/VkdHR1Sr1UxrTz311C1+du2110ZExIEHHhgnnnjiFn++cuXKmDdvXv21pk+fvsWap556Ku65556IiJgxY0ZMnTp1izULFy6Mrq6uiIjo7OyMtra2LdbcfffdsWTJkoiImDNnzlbPYd68ebFy5cpoa2uLzs7Ora5xTs7JOTkn5+ScnJNzck4j/5xyfDvPMBjOnikirW+6/fbbt/jZkUceGRER/f390dvbu8Wft7S0xCGHHBIRrw2C+vr6tljT2toakydPjoiI3t7e6O/v32LNxIkTo729PSIienp6YmBgYIs1kydP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hIbMDI1NZkglM+UzYcKEuOOOO4ougxLQN22b98Db5j0wZSQzpJIZUshL+QxlzzRihipvetObYv369UWXAQAAw669vT26urqKLoMS0DcBANCMhrJnGjMkf0sDGDt2bLz00ksxevTo2GuvvYouBwAAhk2R3zigXPRNAAA0o6HsmUbMN1UAAAAAAADy5GJvAAAAAAAAGRiqAAAAAAAAZGCoAgAAAAAAkIGhCgAAAAAAQAaGKgAAAAAAABkYqgAAAAAAAGRgqAIAAAAAAJCBoQoAAAAAAEAGhioAAAAAAAAZjCm6gJHi5ZdfjgULFsT8+fOjp6cnXnjhhdhzzz3jTW96U8ycOTM6Oztj/PjxRZdJA3jmmWfivvvui9/+9rexePHiWLZsWaxduzb22GOP2HfffWPatGlx+umnxzvf+c6iS6UELrvssviP//iP+vH+++8fv/vd7wqsiEb08MMPx09/+tO4//77o1qtRn9/f7S1tcU+++wTb3vb2+LYY4+Nd7/73TFhwoSiS6VgCxcujFtuuSUefPDBePbZZ2PNmjXR0tISe++9dxx++OFx8sknx8yZM2Ps2LFFlwqUkJ6JFPomhpK+iR3RM5GVnomIiEqtVqsVXUTZPfnkk3HBBRfEo48+us01e++9d1x55ZXx3ve+dxgro5E88sgjcckll8SiRYsyrX/nO98ZV111Vey33345V0ZZLVq0KD7wgQ/E+vXr6z/THLCxF154If75n/85br311h2unT17dsydO3cYqqIRrVixIi666KL42c9+tsO1U6ZMia997Wtx9NFHD0NlwEihZyIrfRNDTd/E9uiZyErPxMZ8U+UvtGzZsjjjjDOiWq1GRESlUoljjjkmJk+eHMuXL4/7778/BgYG4oUXXoi//du/je9///vxrne9q+CqKcJTTz21RWNw4IEHxqGHHhptbW2xatWqWLhwYTz33HMREfGb3/wmPvCBD8Stt94akydPLqJkGtgrr7wSn/vc5zZpDGBjS5cujQ9/+MPxpz/9qf6zqVOn1vecdevWRW9vbzz66KOxbt26AiulaOvWrYszzzxzk1907rXXXnH44YfHvvvuG8uXL4/HH388ent7IyLi6aefjrPOOivmzZsX06ZNK6psoET0TKTQNzGU9E1sj56JrPRMbM5Q5S/0qU99qt4c7L///vHtb3873va2t9X/fMWKFfHJT34yfvWrX8Urr7wSc+bMiV//+tex5557FlUyBZsyZUr8zd/8TXzwgx+Mfffdd5M/W79+fcybNy++9KUvxbp166JarcanPvWpWLBgQVQqlYIqphFdc801sXjx4oiIOP300+PHP/5xwRXRSFatWhUf+chH6s3BscceG//8z/8chx122BZrX3755XjggQdizZo1w10mDeIb3/hGvTmoVCrxuc99Lj7+8Y/HbrvtVl9Tq9ViwYIFcckll8SqVati3bp18fnPfz7uueeeosoGSkTPxM7QNzEU9E1si56JFHomNudG9X+Bn//85/Wvi+66665x3XXXbdIcRESMHz8+vvOd79Q/MdPf3x/f+MY3hr1WijdhwoS48sor47777osLL7xwi8YgImLUqFFx5plnxte//vX6zx588MH45S9/OZyl0uCefPLJuPrqqyMi4oMf/GAcf/zxBVdEo/mXf/mX+idkPvCBD8SNN9641eYg4rV/v97znvfEqaeeOpwl0kDmzZtXf/yxj30sPvOZz2zSHES81jjMmjUrrrjiivrPFi9eXP8lBcC26JlIpW9iqOib2B49Eyn0TGzOUOUvcN1119Uff+QjH4m3vvWtW123++67x0UXXVQ//v73vx+vvvpq3uXRYN75znfGGWecEaNHj97h2lNOOSWOOuqo+vHPf/7zPEujRGq1Wlx00UXx0ksvRWtra/zTP/1T0SXRYB555JH4wQ9+EBERkyZNiiuuuCLTvkNzWr16dTz77LP149NOO227608++eRNmoclS5bkVRowQuiZSKVvYijom9gePRMp9ExsjaHKTlq7dm088MAD9ePOzs7trp85c2a84Q1viIjXPnn129/+Ntf6KL/p06fXHz/zzDMFVkIj+e53vxt/+MMfIiLiS1/6Uuy9994FV0Sj+d73vld/PHv27Nhjjz0KrIZGt3bt2k2Od3SpnTFjxsQb3/jG+rHrkwPbo2diOOib2Bp9E9ujZyKFnomtMVTZSQsXLoyXXnopIl77VNXb3/727a5vaWmJjo6O+vHGzQVszcbXAh4cHCywEhrF0qVL4/LLL4+IiHe84x1x5plnFlwRjWZwcDDmz59fP545c2aB1VAGe+21V7S0tNSPH3/88e2uX758ebzwwgv1421dIgEgQs/E8NA3sTl9E9ujZyKVnomtMVTZSU888UT98aGHHhpjxozZ4XP+6q/+qv74ySefzKUuRo7HHnus/njSpEkFVkKj+MIXvhBr1qyJXXfdNf71X//VTTjZwmOPPRarV6+OiIhx48bFlClT4tVXX42bbropOjs74+1vf3u8+c1vjo6Ojjj77LPju9/9bv2XXTSnXXbZJd7znvfUj6+66qpYt27dNtfPnTu3/kmrd73rXTF16tTcawTKS8/EcNA3sTl9E9ujZyKVnomtMVTZSU899VT98f7775/pORu/wdMgsD1Lly7d5JN5bqjH/Pnz45577omIiAsuuCAOPvjggiuiEXV3d9cfT5o0KZYtWxannXZafPazn40HHnggnn/++Xj55ZejWq3GvffeG1/4whfi+OOPj//5n/8prmgKd8kll9Qvt/Pwww/HjBkzYt68efG///u/MTAwEEuXLo177rknTj/99LjpppsiIuItb3lLXHnllUWWDZSAnom86ZvYnL6JHdEzsTP0TGxuxx8VYqtWrlxZf7zPPvtkes6ECRPqj/v7+4e6JEaQyy67rP7V9f322y9OPPHEgiuiSCtWrIh//Md/jIiIAw88MD796U8XXBGNatmyZZscn3POOdHT0xMREQcddFAceeSRMXr06Fi8eHE8/PDDEfHaLyM+/OEPx6233hpHHHHEsNdM8Q466KD4yU9+ErNnz46lS5fG008/HX//93+/1bV77rlnfOhDH4qLL77YtaeBHdIzkTd9ExvTN5GFnomdoWdic4YqO2njmxRtfF297dl43eY3OYIN5s2bF7fffnv9+NJLL42xY8cWWBFFu+yyy2L58uUREfGVr3xFHtimVatW1R9vuBTGbrvtFl/96lfj1FNP3WTtAw88EJ/4xCdixYoVsW7duvjkJz8Z9957b+y6667DWjON4bDDDov7778/fvjDH8bcuXPjxRdf3Oq6E044IWbNmqU5ADLRM5EnfROb0zeRhZ6JnaVnYmMu/7WTNr6e4i677JLpORtvugMDA0NeE+XX3d0dl156af34tNNOi9NPP73AiijaL3/5y7jlllsiIuIjH/lIHHfccQVXRCPb2pu6r3/961s0BxERxx13XHznO9+JUaNeeyvw9NNPx49//OPca6QxrVixIi699NK47LLL4sUXX4wJEybEzJkz46Mf/Wiceuqp9cv2LFiwIGbNmhWf//zn3QwY2CE9E3nRN7E5fRNZ6ZnYWXomNuabKjtp4088vPLKK5me8/LLL9cfZ/2kFs3jT3/6U8yePbvePL71rW+Nr3zlKwVXRZFefPHFuPjiiyMioq2tLb785S8XXBGNbvNP43V0dMQpp5yyzfXTp0+PU045JW677baIeO3N3xlnnJFrjTSeJUuWRGdnZzz33HMxduzYmDt3bpx99tmb3FC6VqvF/Pnz45JLLonVq1fHDTfcEKNHj47LL7+8wMqBRqdnIg/6JjanbyKFnomdoWdic76pspM23JwoIvsnqDZet/Hzoa+vL84666z485//HBERkydPjhtuuCHe+MY3FlwZRfrKV74SzzzzTEREfPnLX47x48cXXBGNbvN/W7bXHGxtzcKFC4e8Jhrbq6++Gueff34899xzERFx+eWXx+zZszdpDiIiKpVKnHbaafGtb32r/rPrr78+Fi1aNKz1AuWiZ2Ko6ZvYGn0TKfRMpNIzsTWGKjupra2t/vj555/P9JwNb/wiIlpbW4e6JEpqxYoVcdZZZ8XTTz8dERETJ06MG2+8MSZOnFhsYRTq4Ycfju985zsREXHsscdGZ2dnwRVRBhv/2xQRcfDBB+/wORuvWbNmTaxZs2bI66Jx3XbbbfVrSU+dOnWHe8273/3uOP744+vHN910U671AeWmZ2Io6ZvYGn0TqfRMpNIzsTUu/7WTpk6dWn/87LPPZnrOsmXL6o8POuigIa+J8lm9enV89KMfjZ6enoiIGD9+fNx4441xwAEHFFwZRfvjH/8Y69evj4jX9o73v//921y7YsWK+uM///nPm6z9u7/7u5gxY0Z+hdJQNv63KSLbJ3w3X7NmzRo31Gsiv/jFL+qPjz322KhUKjt8znHHHRf3339/REQ89NBDeZUGjAB6JoaKvolt0TeRSs9EKj0TW2OospM2nlI/9thj8eqrr27xta/NPfzww/XHGgRefPHFOOecc+qb67hx4+KGG26It7zlLQVXRqN5+umn65/I25GXX355k6+WLl++PKeqaESHHnroJsdr167d4XM2XzNu3LghrYnGVq1W6483/9Tetmx8SY1Vq1YNeU3AyKFnYijom8hK30QWeiZS6ZnYGpf/2knTp0+v39zqxRdfjO7u7u2uf+mll+LBBx+sHx933HG51kdjGxgYiNmzZ8cf/vCHiIjYbbfd4vrrr48jjjii4MqAMjvggAM2+cTmE088scPnbLymtbU1dt9991xqozFtfBPo/v7+TM9ZuXJl/fGee+451CUBI4ieib+UvgkYanomUumZ2BpDlZ30hje8YZM3+fPmzdvu+jvuuKN+zcXW1tY45phjcq2PxvXKK6/E+eefHw888EBERIwdOza+/e1vx9FHH11wZTSSM844I5YuXZrpP1deeWX9efvvv/8mf3bGGWcUeBYUYeObKN555507XL/xGv82NZ/99tuv/vjXv/51puds+PcrImLKlClDXRIwguiZ+Evom8hC38TO0DORQs/E1hiq/AXOO++8+uMf/ehH9eu7bm7dunVxxRVX1I/PPvvsHX7tnZFpcHAwLrzwwvjv//7viIgYM2ZMfPOb34x3v/vdBVcGjBTnnntu7LLLLhERsXDhwrjrrru2uXbRokVxxx131I/d2LP5bHwDxSeffDJuvvnm7a7/1a9+Fffdd1/9+IQTTsitNmBk0DOxM/RNQJ70TKTQM7E1hip/gRkzZsQ73vGOiHjtq+rnnXde/PGPf9xkzYoVK+JjH/tY/bqera2tccEFFwx3qTSAWq0W//AP/xC33XZbRESMGjUqrr766jjppJMKrgwYSaZMmRLnnntu/fjCCy+M22+/fYt1v/nNb+K8886LwcHBiIiYNm2a/agJvfe9740DDzywfnzxxRfH9ddfX8/FBrVaLRYsWBDnn39+/WeTJk2KWbNmDVutQDnpmUilbwLypmcihZ6JranUarVa0UWU2bJly+L9739/9PX1RUREpVKJY445JqZMmRLLly+P+++/P9atWxcRr3265vvf//4mE06ax3XXXRdf/OIX68dvfvObk6bVc+fOzaMsRoCbbropPvvZz0bEa19j/93vfldwRRTtpZdeirPOOmuTLBx88MFx5JFHxujRo2Px4sX1m71GREycODF++tOfbvK1ZprHgw8+GJ2dnfX3KxGvZaKjoyPGjx8fq1evjgcffDCeeeaZ+p+PHTs2brzxxvjrv/7rIkoGSkbPRAp9E3nRN7ExPRMp9ExszlBlCDz55JNxwQUXxKOPPrrNNXvttVdceeWVMWPGjGGsjEby7//+75tcwzXV0qVLh7AaRhLNAVuzatWquPTSS+MnP/nJdtcdddRRce2112oOmtyiRYvi05/+dCxZsmSHaw844IC4+uqrXdMeSKJnIit9E3nRN7E5PRMp9ExszEVqh8BBBx0U//Vf/xXz58+P+fPnR09PT7zwwgsxbty4OOCAA2LmzJlxxhlnxPjx44suFYAmMW7cuLjmmmvinHPOiZtvvjl+//vfR7VajcHBwdhnn31i2rRpceqpp8bJJ58clUql6HIp2FFHHRX33ntv3HXXXXHnnXfGQw89FH19fbF27drYfffdY++9944jjjgiTjrppHjf+95XvwY1QFZ6JgAajZ6JFHomNuabKgAAAAAAABm4UT0AAAAAAEAGhioAAAAAAAAZGKoAAAAAAABkYKgCAAAAAACQgaEKAAAAAABABoYqAAAAAAAAGRiqAAAAAAAAZGCoAgAAAAAAkIGhCgAAAAAAQAaGKgAAAAAAABkYqgAAAAAAAGRgqAIAAAAAAJCBoQoAAAAAAEAGhioAAAAAAAAZGKoAAAAAAABkYKgCAAAAAACQgaEKAAAAAABABoYqAAAAAAAAGRiqAAAAAAAAZGCoAgAAAAAAkIGhCgAAAAAAQAaGKgAAAAAAABkYqgAAAAAAAGRgqAIAAAAAAJCBoQoAAAAAAEAG/x99KevVIzGc2AAAAABJRU5ErkJggg=="
          }
        ]
      },
      {
        "id": "msg_6866bdb0409881a2a90dd036e4979c4f045bbeee5efbc8ae",
        "type": "message",
        "status": "completed",
        "content": [
          {
            "type": "output_text",
            "annotations": [
              {
                "type": "container_file_citation",
                "container_id": "cntr_6866bd7ac4348191aa4380959eb286cd0e6585decbda08c8",
                "end_index": 0,
                "file_id": "cfile_6866bdaeedcc8191a6de6fc27ead96fb",
                "filename": "cfile_6866bdaeedcc8191a6de6fc27ead96fb.png",
                "start_index": 0
              }
            ],
            "logprobs": [],
            "text": "From the visualization of example 1:\n\n- In the input, there is a vertical line of '2's at column 3 and a horizontal line of '2's at row 6.\n- In the output, the vertical line moves to column 1.\n- The horizontal line stays at row 8.\n- The number '5' and the few disjoint pixels disappear.\n\nLooking at other examples similarly, it looks like a consistent pattern:\n\n- A vertical line of the target number moves horizontally to column 1 (or the nearest possible column).\n- A horizontal line of the target number moves vertically to row 6 or 7 (somewhere towards the center near bottom).\n- The colors remain the same, other elements disappear.\n\nWe need to better understand the positional transformation logic. Let's examine the positions of the two main lines in input and output for all examples quantitatively."
          }
        ],
        "role": "assistant"
      },
      {
        "id": "ci_6866bdb54c4c81a2a4c13d9b48fa0fa6045bbeee5efbc8ae",
        "type": "code_interpreter_call",
        "status": "completed",
        "code": "def analyze_lines(grid_in, grid_out):\n    values = set(np.unique(grid_in)) - {0}\n    analysis = {}\n    for val in values:\n        # positions of val pixels in input and output\n        inp_positions = np.argwhere(grid_in == val)\n        out_positions = np.argwhere(grid_out == val)\n        \n        # Check if line is vertical or horizontal by inspecting variance or range\n        inp_rows = set(inp_positions[:,0])\n        inp_cols = set(inp_positions[:,1])\n        out_rows = set(out_positions[:,0])\n        out_cols = set(out_positions[:,1])\n\n        analysis[val] = {\n            \"input\": {\"rows\": sorted(inp_rows), \"cols\": sorted(inp_cols)},\n            \"output\": {\"rows\": sorted(out_rows), \"cols\": sorted(out_cols)}\n        }\n    return analysis\n\nfor i, ex in enumerate(train_examples):\n    print(f\"Example {i+1} line positions analysis:\")\n    line_analysis = analyze_lines(ex[\"input\"], ex[\"output\"])\n    for val, pos in line_analysis.items():\n        print(f\"  Value {val}:\")\n        print(f\"    Input rows: {pos['input']['rows']}\")\n        print(f\"    Input cols: {pos['input']['cols']}\")\n        print(f\"    Output rows: {pos['output']['rows']}\")\n        print(f\"    Output cols: {pos['output']['cols']}\")\n    print()",
        "container_id": "cntr_6866bd7ac4348191aa4380959eb286cd0e6585decbda08c8",
        "outputs": [
          {
            "type": "logs",
            "logs": "Example 1 line positions analysis:\n  Value 2:\n    Input rows: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    Input cols: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    Output rows: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    Output cols: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n  Value 5:\n    Input rows: [0, 1]\n    Input cols: [9]\n    Output rows: []\n    Output cols: []\n\nExample 2 line positions analysis:\n  Value 4:\n    Input rows: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    Input cols: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    Output rows: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    Output cols: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n  Value 5:\n    Input rows: [0, 1, 2]\n    Input cols: [9]\n    Output rows: []\n    Output cols: []\n\nExample 3 line positions analysis:\n  Value 5:\n    Input rows: [0, 1, 2]\n    Input cols: [9]\n    Output rows: []\n    Output cols: []\n  Value 6:\n    Input rows: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    Input cols: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    Output rows: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    Output cols: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nExample 4 line positions analysis:\n  Value 3:\n    Input rows: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    Input cols: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    Output rows: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    Output cols: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n  Value 5:\n    Input rows: [0]\n    Input cols: [9]\n    Output rows: []\n    Output cols: []\n\n"
          }
        ]
      },
      {
        "id": "msg_6866bdbca21481a2887957bc670974aa045bbeee5efbc8ae",
        "type": "message",
        "status": "completed",
        "content": [
          {
            "type": "output_text",
            "annotations": [],
            "logprobs": [],
            "text": "It looks like values like 2, 3, 4 and 6 each form a cross shape covering complete rows and columns in their range, but the columns or rows differ in input vs output.\n\nWe also see the '5' disappears in all cases.\n\nLet's summarize the observations:\n\n- The main nonzero color forms a cross. \n- The cross's vertical line in input is always shifted leftwards to column 1 in output.\n- The cross's horizontal line in input is shifted down around row 7 or 8 in output.\n- Any other nonzero elements vanish.\n\nOur task is to extract the main color that forms the cross and reposition its vertical and horizontal lines accordingly.\n\nLet's now attempt to implement this transformation function. We'll:\n\n1. Identify the main color (the one forming the cross) - appears as the color on the largest cross.\n2. Find vertical and horizontal cross lines position in input.\n3. Move vertical line to column 1 and horizontal line to row 7.\n4. Remove other pixels.\n\nWe'll test this on all training examples."
          }
        ],
        "role": "assistant"
      },
      {
        "id": "ci_6866bdc1a1c081a2bd98770eaf876a6f045bbeee5efbc8ae",
        "type": "code_interpreter_call",
        "status": "completed",
        "code": "def transform(grid):\n    import numpy as np\n    \n    grid = np.array(grid)\n    output = np.zeros_like(grid)\n    \n    # Identify colors except zero\n    colors, counts = np.unique(grid[grid != 0], return_counts=True)\n    \n    # The main color is the one with the max pixels (largest connected area)\n    main_color = colors[np.argmax(counts)]\n    \n    # Find positions of main_color pixels\n    positions = np.argwhere(grid == main_color)\n    rows = positions[:,0]\n    cols = positions[:,1]\n    \n    # Determine if cross shape: look for rows and columns with continuous positions\n    \n    # Determine the vertical line column (the one that appears in many rows with main_color)\n    column_counts = {c: np.sum(cols == c) for c in set(cols)}\n    vline_col = max(column_counts, key=column_counts.get)\n    \n    # Determine the horizontal line row (the one that appears in many columns with main_color)\n    row_counts = {r: np.sum(rows == r) for r in set(rows)}\n    hline_row = max(row_counts, key=row_counts.get)\n    \n    # Vertical line target column is 1\n    target_vcol = 1\n    # Horizontal line target row is 7 (index 6), but in examples it's either 6 or 7 or 8,\n    # we choose 7 (index 6) as a middle point (0-based index).\n    target_hrow = 7\n    \n    # Place vertical line pixels at target_vcol for all rows where main_color appears vertically\n    for r in rows:\n        output[r, target_vcol] = main_color\n    \n    # Place horizontal line pixels at target_hrow for all columns where main_color appears horizontally\n    for c in cols:\n        output[target_hrow, c] = main_color\n    \n    return output.tolist()\n\n# Test on all training examples\nfor i, ex in enumerate(train_examples):\n    out_pred = np.array(transform(ex[\"input\"]))\n    correct = np.array_equal(out_pred, ex[\"output\"])\n    print(f\"Example {i+1} correct: {correct}\")",
        "container_id": "cntr_6866bd7ac4348191aa4380959eb286cd0e6585decbda08c8",
        "outputs": [
          {
            "type": "logs",
            "logs": "Example 1 correct: False\nExample 2 correct: False\nExample 3 correct: False\nExample 4 correct: False\n"
          }
        ]
      },
      {
        "id": "msg_6866bdcc67bc81a2a490dea9b30c4c9e045bbeee5efbc8ae",
        "type": "message",
        "status": "completed",
        "content": [
          {
            "type": "output_text",
            "annotations": [],
            "logprobs": [],
            "text": "Our first implementation did not produce the correct output for any example.\n\nReason:\n- We set the horizontal line at fixed row 7 but in outputs the horizontal line sometimes is row 8 or 6\n- The input horizontal line was at row 6 or 3 or 4 and output line is at row 8 or 6 or 3\n- There seems to be a swap in vertical and horizontal lines positions between input and output\n\nLet's analyze the vertical and horizontal line positions (row/column) between input and output for all examples more closely.\n\nAlso, in outputs, the vertical line is always at column 1, but the horizontal line is moved to row 8 or 6 or 3 depending on example.\n\nWe suspect the main transformation could be a swap of y and x lines shifted.\n\nLet's print the difference of input/output positions for vertical and horizontal lines."
          }
        ],
        "role": "assistant"
      },
      {
        "id": "ci_6866bdd07df081a2bbbeb1d4dd3d9460045bbeee5efbc8ae",
        "type": "code_interpreter_call",
        "status": "completed",
        "code": "def analyze_shift(ex):\n    grid_in = ex[\"input\"]\n    grid_out = ex[\"output\"]\n    main_color = list(set(np.unique(grid_in)) - {0})[0]\n    \n    inp_pos = np.argwhere(grid_in == main_color)\n    out_pos = np.argwhere(grid_out == main_color)\n    \n    inp_rows = set(inp_pos[:,0])\n    inp_cols = set(inp_pos[:,1])\n    out_rows = set(out_pos[:,0])\n    out_cols = set(out_pos[:,1])\n    \n    print(f\"Main color: {main_color}\")\n    \n    # Input vertical line is where many rows share the same col:\n    cols_hist = {c: sum(pos[1]==c for pos in inp_pos) for c in inp_cols}\n    max_inp_vcol = max(cols_hist, key=cols_hist.get)\n    print(f\"Input vertical line at col {max_inp_vcol}\")\n    \n    # Input horizontal line:\n    rows_hist = {r: sum(pos[0]==r for pos in inp_pos) for r in inp_rows}\n    max_inp_hrow = max(rows_hist, key=rows_hist.get)\n    print(f\"Input horizontal line at row {max_inp_hrow}\")\n    \n    # Output vertical line:\n    cols_hist_out = {c: sum(pos[1]==c for pos in out_pos) for c in out_cols}\n    max_out_vcol = max(cols_hist_out, key=cols_hist_out.get)\n    print(f\"Output vertical line at col {max_out_vcol}\")\n    \n    # Output horizontal line:\n    rows_hist_out = {r: sum(pos[0]==r for pos in out_pos) for r in out_rows}\n    max_out_hrow = max(rows_hist_out, key=rows_hist_out.get)\n    print(f\"Output horizontal line at row {max_out_hrow}\")\n    print()\n\nfor i, ex in enumerate(train_examples):\n    print(f\"Example {i+1}:\")\n    analyze_shift(ex)",
        "container_id": "cntr_6866bd7ac4348191aa4380959eb286cd0e6585decbda08c8",
        "outputs": [
          {
            "type": "logs",
            "logs": "Example 1:\nMain color: 2\nInput vertical line at col 3\nInput horizontal line at row 6\nOutput vertical line at col 1\nOutput horizontal line at row 8\n\nExample 2:\nMain color: 4\nInput vertical line at col 3\nInput horizontal line at row 3\nOutput vertical line at col 0\nOutput horizontal line at row 6\n\nExample 3:\nMain color: 5\nInput vertical line at col 9\nInput horizontal line at row 0\n"
          }
        ]
      },
      {
        "id": "msg_6866bdd913dc81a2bc46aa05e4d22d40045bbeee5efbc8ae",
        "type": "message",
        "status": "completed",
        "content": [
          {
            "type": "output_text",
            "annotations": [],
            "logprobs": [],
            "text": "In example 3, the output has no '5' color pixels, so the function crashes.\n\nLet's fix that and skip cases where color is missing.\n\nBut before that, note that in example 3 the main color appears to be 6, not 5. So picking the first nonzero color was incorrect.\n\nLet's update our approach:\n\n- The main color is the one forming cross lines, so it should appear both in a full row and a full column.\n- We find the main color by checking which color appears in at least one full row and at least one full column.\n\nWe will implement this main color detection and repeat the shift analysis."
          }
        ],
        "role": "assistant"
      },
      {
        "id": "ci_6866bddcd81081a295828544d3baee19045bbeee5efbc8ae",
        "type": "code_interpreter_call",
        "status": "completed",
        "code": "def find_main_color_cross(grid):\n    colors = set(np.unique(grid)) - {0}\n    for c in colors:\n        rows_with_c = [i for i in range(grid.shape[0]) if np.count_nonzero(grid[i,:] == c) > 0]\n        cols_with_c = [j for j in range(grid.shape[1]) if np.count_nonzero(grid[:,j] == c) > 0]\n\n        # For cross: check if at least one row is fully c and one column fully c\n        full_row = any(np.all(grid[r,:] == c) for r in rows_with_c)\n        full_col = any(np.all(grid[:,col] == c) for col in cols_with_c)\n        if full_row and full_col:\n            return c\n    return None\n\ndef analyze_shift_fixed(ex):\n    grid_in = ex[\"input\"]\n    grid_out = ex[\"output\"]\n    main_color = find_main_color_cross(grid_in)\n    \n    print(f\"Main color: {main_color}\")\n    \n    if main_color is None:\n        print(\"No main color cross found\")\n        return\n    \n    inp_pos = np.argwhere(grid_in == main_color)\n    out_pos = np.argwhere(grid_out == main_color)\n    \n    inp_rows = set(inp_pos[:,0])\n    inp_cols = set(inp_pos[:,1])\n    out_rows = set(out_pos[:,0])\n    out_cols = set(out_pos[:,1])\n    \n    # Input vertical line is where many rows share the same col:\n    cols_hist = {c: sum(pos[1]==c for pos in inp_pos) for c in inp_cols}\n    max_inp_vcol = max(cols_hist, key=cols_hist.get)\n    print(f\"Input vertical line at col {max_inp_vcol}\")\n    \n    # Input horizontal line:\n    rows_hist = {r: sum(pos[0]==r for pos in inp_pos) for r in inp_rows}\n    max_inp_hrow = max(rows_hist, key=rows_hist.get)\n    print(f\"Input horizontal line at row {max_inp_hrow}\")\n    \n    # Output vertical line:\n    if len(out_cols) > 0:\n        cols_hist_out = {c: sum(pos[1]==c for pos in out_pos) for c in out_cols}\n        max_out_vcol = max(cols_hist_out, key=cols_hist_out.get)\n        print(f\"Output vertical line at col {max_out_vcol}\")\n    else:\n        max_out_vcol = None\n        print(f\"Output vertical line missing\")\n    \n    # Output horizontal line:\n    if len(out_rows) > 0:\n        rows_hist_out = {r: sum(pos[0]==r for pos in out_pos) for r in out_rows}\n        max_out_hrow = max(rows_hist_out, key=rows_hist_out.get)\n        print(f\"Output horizontal line at row {max_out_hrow}\")\n    else:\n        max_out_hrow = None\n        print(f\"Output horizontal line missing\")\n    \n    print()\n\nfor i, ex in enumerate(train_examples):\n    print(f\"Example {i+1}:\")\n    analyze_shift_fixed(ex)",
        "container_id": "cntr_6866bd7ac4348191aa4380959eb286cd0e6585decbda08c8",
        "outputs": [
          {
            "type": "logs",
            "logs": "Example 1:\nMain color: 2\nInput vertical line at col 3\nInput horizontal line at row 6\nOutput vertical line at col 1\nOutput horizontal line at row 8\n\nExample 2:\nMain color: 4\nInput vertical line at col 3\nInput horizontal line at row 3\nOutput vertical line at col 0\nOutput horizontal line at row 6\n\nExample 3:\nMain color: 6\nInput vertical line at col 6\nInput horizontal line at row 4\nOutput vertical line at col 3\nOutput horizontal line at row 7\n\nExample 4:\nMain color: 3\nInput vertical line at col 4\nInput horizontal line at row 2\nOutput vertical line at col 3\nOutput horizontal line at row 2\n\n"
          }
        ]
      },
      {
        "id": "msg_6866bdeb403c81a2a5595c18bfce4ffb045bbeee5efbc8ae",
        "type": "message",
        "status": "completed",
        "content": [
          {
            "type": "output_text",
            "annotations": [],
            "logprobs": [],
            "text": "Now we see the main color is the one forming the cross lines in each example.\n\nNotably, the transformation shifts the vertical line usually to the left (column 1 or 0 or 3) and the horizontal line down a few rows.\n\nIn example 4, the horizontal line stays the same row but vertical line shifts left by 1 column.\n\nLet's calculate the differences in vertical line columns and horizontal line rows:\n\n- Column shift = output vertical line column - input vertical line column\n- Row shift = output horizontal line row - input horizontal line row\n\nLet's print shifts for all examples."
          }
        ],
        "role": "assistant"
      },
      {
        "id": "ci_6866bdee5a1c81a2bc01c76973183f22045bbeee5efbc8ae",
        "type": "code_interpreter_call",
        "status": "completed",
        "code": "def print_line_shifts(ex):\n    grid_in = ex[\"input\"]\n    grid_out = ex[\"output\"]\n    main_color = find_main_color_cross(grid_in)\n    inp_pos = np.argwhere(grid_in == main_color)\n    out_pos = np.argwhere(grid_out == main_color)\n    inp_cols = set(inp_pos[:,1])\n    inp_rows = set(inp_pos[:,0])\n    out_cols = set(out_pos[:,1])\n    out_rows = set(out_pos[:,0])\n    \n    cols_hist_inp = {c: sum(pos[1]==c for pos in inp_pos) for c in inp_cols}\n    rows_hist_inp = {r: sum(pos[0]==r for pos in inp_pos) for r in inp_rows}\n    max_inp_vcol = max(cols_hist_inp, key=cols_hist_inp.get)\n    max_inp_hrow = max(rows_hist_inp, key=rows_hist_inp.get)\n    \n    cols_hist_out = {c: sum(pos[1]==c for pos in out_pos) for c in out_cols}\n    rows_hist_out = {r: sum(pos[0]==r for pos in out_pos) for r in out_rows}\n    max_out_vcol = max(cols_hist_out, key=cols_hist_out.get) if out_cols else None\n    max_out_hrow = max(rows_hist_out, key=rows_hist_out.get) if out_rows else None\n    \n    col_shift = max_out_vcol - max_inp_vcol if max_out_vcol is not None else None\n    row_shift = max_out_hrow - max_inp_hrow if max_out_hrow is not None else None\n    \n    print(f\"Main color: {main_color}, Vertical line shift: {col_shift}, Horizontal line shift: {row_shift}\")\n\nfor ex in train_examples:\n    print_line_shifts(ex)",
        "container_id": "cntr_6866bd7ac4348191aa4380959eb286cd0e6585decbda08c8",
        "outputs": [
          {
            "type": "logs",
            "logs": "Main color: 2, Vertical line shift: -2, Horizontal line shift: 2\nMain color: 4, Vertical line shift: -3, Horizontal line shift: 3\nMain color: 6, Vertical line shift: -3, Horizontal line shift: 3\nMain color: 3, Vertical line shift: -1, Horizontal line shift: 0\n"
          }
        ]
      },
      {
        "id": "msg_6866bdf7b25881a2882c81534807bb56045bbeee5efbc8ae",
        "type": "message",
        "status": "completed",
        "content": [
          {
            "type": "output_text",
            "annotations": [],
            "logprobs": [],
            "text": "We observe:\n\n- Vertical line shifts left by 1 to 3 columns.\n- Horizontal line shifts down by 0 to 3 rows.\n\nSo the pattern is shifting the vertical line left by a fixed offset (varies by example) and the horizontal line down similarly.\n\nBut these shifts are relative to the input positions of the lines.\n\nIf we try to encode these shifts dynamically as:\n\n- New vertical column = Old vertical column + shift (negative means shift left)\n- New horizontal row = Old horizontal row + shift\n\nThe shifts differ between examples, so are they related to the difference between the line positions?\n\nIf so, the transformation could be:\n\n- Vertical line moves to column 1 or 0 or 3 depending on the difference from original column\n- Horizontal line moves to near bottom rows (6 to 8).\n\nAlternatively, the output cross lines have fixed columns and rows irrespective of input.\n\nLooking back at outputs:\n\n- The vertical line is mostly at column 1 or 0 or 3.\n- The horizontal line is mostly around row 6 to 8.\n\nOur earlier guess was the vertical line is aligned to column 1 (index 1) and horizontal line mostly aligned near row 7 (index 6), but example 4 shows horizontal line at row 2.\n\nIs there a simpler pattern?\n\nCould the output cross location be the original cross shifted towards top left by one or two?\n\nLet's check if the input vertical line column in output is always column 1\n\nExample 1 output vertical line col = 1  \nExample 2 output vertical line col = 0  \nExample 3 output vertical line col = 3  \nExample 4 output vertical line col = 3  \n\nIt's not fixed column 1. The vertical line shifts left but to different absolute positions.\n\nSimilarly horizontal line row varies.\n\nHence our function should:\n\n- Detect the main color cross lines\n- Shift the vertical line to the leftmost column of vertical lines seen in output\n- Shift the horizontal line to the topmost row of horizontal lines seen in output\n\nBut we cannot access the output in real test cases, only input.\n\nWe need a general rule from inputs.\n\nLooking at inputs, the vertical lines in columns: 3,3,6,4  \nOutputs vertical lines columns: 1,0,3,3  \n\nInput to output vertical line column shifts: -2,-3,-3,-1  \nWe can approximate: vertical line column in output = input vertical column - 2 (min capped at 0)\n\nSimilarly for horizontal line rows: input rows - output rows are 6->8(+2),3->6(+3),4->7(+3),2->2(+0)\n\nApproximate horizontal line row in output = input horizontal row + 2 (max capped at 9)\n\nLet's implement this last idea and test."
          }
        ],
        "role": "assistant"
      },
      {
        "id": "ci_6866be04a03081a2b743dfd176c02131045bbeee5efbc8ae",
        "type": "code_interpreter_call",
        "status": "completed",
        "code": "def transform(grid):\n    import numpy as np\n    grid = np.array(grid)\n    output = np.zeros_like(grid)\n    \n    colors = set(np.unique(grid)) - {0}\n\n    # Find the main color forming cross lines\n    def find_main_color(g):\n        for c in colors:\n            rows_with_c = [i for i in range(g.shape[0]) if np.count_nonzero(g[i,:] == c) > 0]\n            cols_with_c = [j for j in range(g.shape[1]) if np.count_nonzero(g[:,j] == c) > 0]\n            full_row = any(np.all(g[r,:] == c) for r in rows_with_c)\n            full_col = any(np.all(g[:,col] == c) for col in cols_with_c)\n            if full_row and full_col:\n                return c\n        return None\n    \n    c = find_main_color(grid)\n    if c is None:\n        return grid.tolist()\n    \n    positions = np.argwhere(grid == c)\n    rows = positions[:,0]\n    cols = positions[:,1]\n\n    # Find input vertical line column (column with most pixels of color c)\n    col_counts = {col: np.sum(cols == col) for col in set(cols)}\n    input_vcol = max(col_counts, key=col_counts.get)\n\n    # Find input horizontal line row (row with most pixels of color c)\n    row_counts = {row: np.sum(rows == row) for row in set(rows)}\n    input_hrow = max(row_counts, key=row_counts.get)\n\n    # Output vertical line column = max(0, input_vcol - 2)\n    output_vcol = max(0, input_vcol - 2)\n\n    # Output horizontal line row = min(grid.shape[0]-1, input_hrow + 2)\n    output_hrow = min(grid.shape[0]-1, input_hrow + 2)\n\n    # Draw vertical line at output_vcol for all rows in grid where input vertical line existed\n    for r in range(grid.shape[0]):\n        # If same row has color c in input vertical column, keep vertical line pixel else set zero\n        if grid[r, input_vcol] == c:\n            output[r, output_vcol] = c\n\n    # Draw horizontal line at output_hrow for all columns in grid where input horizontal line existed\n    for col in range(grid.shape[1]):\n        # If same column has color c in input horizontal row, keep horizontal line pixel else set zero\n        if grid[input_hrow, col] == c:\n            output[output_hrow, col] = c\n\n    return output.tolist()\n\n# Check correctness on all examples:\nresults = [np.array_equal(np.array(transform(e[\"input\"])), e[\"output\"]) for e in train_examples]\nresults",
        "container_id": "cntr_6866bd7ac4348191aa4380959eb286cd0e6585decbda08c8",
        "outputs": [
          {
            "type": "logs",
            "logs": "[True, False, False, False]"
          }
        ]
      },
      {
        "id": "msg_6866be12b60481a28c90c06698fc4acc045bbeee5efbc8ae",
        "type": "message",
        "status": "completed",
        "content": [
          {
            "type": "output_text",
            "annotations": [],
            "logprobs": [],
            "text": "The latest function corrected example 1 but still fails 2, 3, and 4.\n\nThe vertical line shift of 2 and horizontal line shift of 2 worked in example 1 but not in others.\n\nTrying a fixed shift won't generalize.\n\nLet's examine examples 2, 3, 4 unique pattern:\n\n- Example 2 input_vcol=3, output_vcol=0 => shift -3\n- Example 3 input_vcol=6, output_vcol=3 => shift -3\n- Example 4 input_vcol=4, output_vcol=3 => shift -1\n\nHorizontal line shifts:\n\n- 2 -> 6 (+4)\n- 4 -> 7 (+3)\n- 2 -> 2 (+0)\n\nShifts vary but the horizontal output line seems to be moved close to row 6 or 7 usually.\n\nIs the output vertical column always the minimum vertical column with color c in input?\n\nCheck input vertical lines: example 1 input vertical col=3 but columns with c in example 1 include col 0 (per input data).\n\nVery possibly vertical line in output is at minimum input column with color c.\n\nSimilarly, horizontal line in output possibly at minimum row with color c in input shifted by some offset or at median of horizontal rows with color c.\n\nLet's test using min column of color c in input for vertical line in output and min row of color c in input shifted down by 4 or 5 for horizontal line in output."
          }
        ],
        "role": "assistant"
      },
      {
        "id": "ci_6866be1a105081a28dfcb43bf9b802ab045bbeee5efbc8ae",
        "type": "code_interpreter_call",
        "status": "completed",
        "code": "def transform(grid):\n    import numpy as np\n    grid = np.array(grid)\n    output = np.zeros_like(grid)\n    \n    colors = set(np.unique(grid)) - {0}\n\n    def find_main_color(g):\n        for c in colors:\n            rows_with_c = [i for i in range(g.shape[0]) if np.count_nonzero(g[i,:] == c) > 0]\n            cols_with_c = [j for j in range(g.shape[1]) if np.count_nonzero(g[:,j] == c) > 0]\n            full_row = any(np.all(g[r,:] == c) for r in rows_with_c)\n            full_col = any(np.all(g[:,col] == c) for col in cols_with_c)\n            if full_row and full_col:\n                return c\n        return None\n    \n    c = find_main_color(grid)\n    if c is None:\n        return grid.tolist()\n    \n    positions = np.argwhere(grid == c)\n    rows = positions[:,0]\n    cols = positions[:,1]\n\n    # Calculate min vertical line column of color c in input\n    min_col = np.min(cols)\n    # Calculate min horizontal line row of color c in input\n    min_row = np.min(rows)\n    \n    # Output vertical line column is the min column of color c in input\n    output_vcol = min_col\n    \n    # Output horizontal line row is min_row + 5 capped at max row index\n    output_hrow = min(min_row + 5, grid.shape[0] - 1)\n\n    # Draw vertical line pixels at output_vcol for rows with color c in input vertical line column (min_col)\n    vertical_rows = np.where(grid[:,min_col] == c)[0]\n    for r in vertical_rows:\n        output[r, output_vcol] = c\n    \n    # Draw horizontal line pixels at output_hrow for columns with color c in input horizontal line row (min_row)\n    horizontal_cols = np.where(grid[min_row,:] == c)[0]\n    for col in horizontal_cols:\n        output[output_hrow, col] = c\n\n    return output.tolist()\n\n# Check all training examples\nresults = [np.array_equal(np.array(transform(e[\"input\"])), e[\"output\"]) for e in train_examples]\nresults",
        "container_id": "cntr_6866bd7ac4348191aa4380959eb286cd0e6585decbda08c8",
        "outputs": [
          {
            "type": "logs",
            "logs": "[False, False, False, False]"
          }
        ]
      },
      {
        "id": "msg_6866be26734081a2993e37078bd8ff27045bbeee5efbc8ae",
        "type": "message",
        "status": "completed",
        "content": [
          {
            "type": "output_text",
            "annotations": [],
            "logprobs": [],
            "text": "Not correct yet; let's print the predicted vs actual output for example 1 to debug."
          }
        ],
        "role": "assistant"
      },
      {
        "id": "ci_6866be279c1081a2be5a37e8f991f07f045bbeee5efbc8ae",
        "type": "code_interpreter_call",
        "status": "completed",
        "code": "def print_grids_side_by_side(inp, pred, expected, example_num):\n    print(f\"Example {example_num}\")\n    print(\"Input:\")\n    print(np.array(inp))\n    print(\"\\nPredicted Output:\")\n    print(np.array(pred))\n    print(\"\\nExpected Output:\")\n    print(np.array(expected))\n\nexample_num = 1\nex = train_examples[example_num-1]\npred = transform(ex[\"input\"])\nprint_grids_side_by_side(ex[\"input\"], pred, ex[\"output\"], example_num)",
        "container_id": "cntr_6866bd7ac4348191aa4380959eb286cd0e6585decbda08c8",
        "outputs": [
          {
            "type": "logs",
            "logs": "Example 1\nInput:\n[[0 0 0 2 0 0 0 0 0 5]\n [0 0 0 2 0 0 0 0 0 5]\n [0 0 0 2 0 0 0 0 0 0]\n [0 0 0 2 0 0 0 0 0 0]\n [0 0 0 2 0 0 0 0 0 0]\n [0 0 0 2 0 0 0 0 0 0]\n [2 2 2 2 2 2 2 2 2 2]\n [0 0 0 2 0 0 0 0 0 0]\n [0 0 0 2 0 0 0 0 0 0]\n [0 0 0 2 0 0 0 0 0 0]]\n\nPredicted Output:\n[[0 0 0 0 0 0 0 0 0 0]\n [0 0 0 0 0 0 0 0 0 0]\n [0 0 0 0 0 0 0 0 0 0]\n [0 0 0 0 0 0 0 0 0 0]\n [0 0 0 0 0 0 0 0 0 0]\n [0 0 0 2 0 0 0 0 0 0]\n [2 0 0 0 0 0 0 0 0 0]\n [0 0 0 0 0 0 0 0 0 0]\n [0 0 0 0 0 0 0 0 0 0]\n [0 0 0 0 0 0 0 0 0 0]]\n\nExpected Output:\n[[0 2 0 0 0 0 0 0 0 0]\n [0 2 0 0 0 0 0 0 0 0]\n [0 2 0 0 0 0 0 0 0 0]\n [0 2 0 0 0 0 0 0 0 0]\n [0 2 0 0 0 0 0 0 0 0]\n [0 2 0 0 0 0 0 0 0 0]\n [0 2 0 0 0 0 0 0 0 0]\n [0 2 0 0 0 0 0 0 0 0]\n [2 2 2 2 2 2 2 2 2 2]\n [0 2 0 0 0 0 0 0 0 0]]\n"
          }
        ]
      },
      {
        "id": "msg_6866be2ad17481a2b0e11a066103448e045bbeee5efbc8ae",
        "type": "message",
        "status": "completed",
        "content": [
          {
            "type": "output_text",
            "annotations": [],
            "logprobs": [],
            "text": "The predicted output places the vertical line in input column 3 unchanged (index 3) and horizontal line at row 7 shifted; however, the output vertical line should be at column 1, not 3.\n\nThe error comes from us using min_col as output vertical line column, but in example 1 min_col is 0 (color 2 in col 0 at row 6), but vertical line in output is shifted to 1.\n\nIf we check original input, vertical line at column 3, but there is a horizontal line at row 6 with the color also at col 0,1,2,3,...,9.\n\nThe output keeps vertical line pixels at column 1, not column 0.\n\nChecking the vertical line 1 in output, it matches the pixels originally at column 3 in input.\n\nHence, the output vertical line pixel column (1) is 3 - 2 (i.e., input vertical line column - 2).\n\nSimilarly, output horizontal line row is 6+2=8.\n\nThis matches initial idea of shifting vertical line left by 2 and shifting horizontal line down by 2.\n\nThe discrepancy is our function filtered vertical line rows incorrectly.\n\nWe used rows with color pixels at min_col (0), but vertical line pixels were originally at input_vcol 3.\n\nHence the vertical line pixels correspond to input_vcol 3 rows, not min_col 0 rows.\n\nWe need to find input vertical line column (with max pixels) and base vertical line rows on that column (not min_col).\n\nLet's revise the function accordingly and test."
          }
        ],
        "role": "assistant"
      },
      {
        "id": "ci_6866be36b5dc81a2bb5c2566c2fc59e5045bbeee5efbc8ae",
        "type": "code_interpreter_call",
        "status": "completed",
        "code": "def transform(grid):\n    import numpy as np\n    grid = np.array(grid)\n    output = np.zeros_like(grid)\n    \n    colors = set(np.unique(grid)) - {0}\n\n    def find_main_color(g):\n        for c in colors:\n            rows_with_c = [i for i in range(g.shape[0]) if np.count_nonzero(g[i,:] == c) > 0]\n            cols_with_c = [j for j in range(g.shape[1]) if np.count_nonzero(g[:,j] == c) > 0]\n            full_row = any(np.all(g[r,:] == c) for r in rows_with_c)\n            full_col = any(np.all(g[:,col] == c) for col in cols_with_c)\n            if full_row and full_col:\n                return c\n        return None\n    \n    c = find_main_color(grid)\n    if c is None:\n        return grid.tolist()\n    \n    positions = np.argwhere(grid == c)\n    rows = positions[:,0]\n    cols = positions[:,1]\n\n    # Input vertical line column: column with max pixels\n    unique_cols, counts_cols = np.unique(cols, return_counts=True)\n    input_vcol = unique_cols[np.argmax(counts_cols)]\n\n    # Input horizontal line row: row with max pixels\n    unique_rows, counts_rows = np.unique(rows, return_counts=True)\n    input_hrow = unique_rows[np.argmax(counts_rows)]\n\n    # Output vertical line column = input_vcol - 2 capped at 0\n    output_vcol = max(0, input_vcol - 2)\n\n    # Output horizontal line row = input_hrow + 2 capped at rows-1\n    output_hrow = min(grid.shape[0] - 1, input_hrow + 2)\n\n    # Rows where input vertical line appeared (at input_vcol)\n    vertical_rows = np.where(grid[:, input_vcol] == c)[0]\n    for r in vertical_rows:\n        output[r, output_vcol] = c\n\n    # Columns where input horizontal line appeared (at input_hrow)\n    horizontal_cols = np.where(grid[input_hrow, :] == c)[0]\n    for col in horizontal_cols:\n        output[output_hrow, col] = c\n\n    return output.tolist()\n\n# Check correctness on all examples\nresults = [np.array_equal(np.array(transform(e[\"input\"])), e[\"output\"]) for e in train_examples]\nresults",
        "container_id": "cntr_6866bd7ac4348191aa4380959eb286cd0e6585decbda08c8",
        "outputs": [
          {
            "type": "logs",
            "logs": "[True, False, False, False]"
          }
        ]
      }
    ],
    "parallel_tool_calls": true,
    "previous_response_id": null,
    "reasoning": {
      "effort": null,
      "summary": null
    },
    "service_tier": "default",
    "store": true,
    "temperature": 1.0,
    "text": {
      "format": {
        "type": "text"
      }
    },
    "tool_choice": "auto",
    "tools": [
      {
        "type": "code_interpreter",
        "container": {
          "type": "auto"
        }
      }
    ],
    "top_logprobs": 0,
    "top_p": 1.0,
    "truncation": "disabled",
    "usage": {
      "input_tokens": 92916,
      "input_tokens_details": {
        "cached_tokens": 137824
      },
      "output_tokens": 8046,
      "output_tokens_details": {
        "reasoning_tokens": 0
      },
      "total_tokens": 100962
    },
    "user": null,
    "metadata": {}
  },
  "score": {
    "correct": false,
    "pixel_accuracy": 0.0,
    "total_pixels": 100,
    "correct_pixels": 0,
    "error": "No code generated"
  },
  "mdl": null,
  "actual_output": [
    [
      0,
      0,
      0,
      8,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      8,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      8,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      8,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      8,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8
    ],
    [
      0,
      0,
      0,
      8,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      8,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      8,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      8,
      0,
      0,
      0,
      0,
      0,
      0
    ]
  ]
}