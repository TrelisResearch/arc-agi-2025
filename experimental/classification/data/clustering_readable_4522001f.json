{
  "task_id": "4522001f",
  "summary": {
    "total_programs": 9,
    "optimal_clusters": 4,
    "clustering_method": "silhouette"
  },
  "cluster_analysis": {
    "method": "silhouette",
    "elbow_k": 5,
    "silhouette_k": 4,
    "chosen_k": 4,
    "k_range": [
      2,
      3,
      4,
      5,
      6,
      7,
      8
    ],
    "inertias": [
      1.3490789235363065,
      0.8747843295086379,
      0.5645704438935719,
      0.4148983594717577,
      0.2718976072265144,
      0.1387511012799954,
      0.0641642183576159
    ],
    "silhouette_scores": [
      0.18137829554744475,
      0.25099029029367675,
      0.27748663097139703,
      0.22915345060377673,
      0.18455221898833277,
      0.13267702061563555,
      0.061207613149173966
    ],
    "silhouette_optimal": 0.27748663097139703
  },
  "clusters": {
    "cluster_2": {
      "stats": {
        "size": 2,
        "avg_distance_to_center": 0.2580179314955833,
        "max_distance_to_center": 0.2580179314955833,
        "models": [
          "Qwen2.5-Coder-32B-Instruct"
        ],
        "avg_code_length": 1099.0
      },
      "programs": [
        {
          "index": 0,
          "model": "Qwen2.5-Coder-32B-Instruct",
          "code_length": 997,
          "code_preview": "def transform(grid):\n    color_to_expand = 3\n    new_grid = [[0] * 9 for _ in range(9)]\n    positions = [(i, j) for i in range(3) for j in range(3) if grid[i][j] == color_to_expand]\n    if positions:\n...",
          "full_code": "def transform(grid):\n    color_to_expand = 3\n    new_grid = [[0] * 9 for _ in range(9)]\n    positions = [(i, j) for i in range(3) for j in range(3) if grid[i][j] == color_to_expand]\n    if positions:\n        center_i = round(sum((p[0] for p in positions)) / len(positions))\n        center_j = round(sum((p[1] for p in positions)) / len(positions))\n        base_i = max(0, center_i * 3 - 1)\n        base_j = max(0, center_j * 3 - 1)\n        for i in range(base_i, min(9, base_i + 4)):\n            for j in range(base_j, min(9, base_j + 4)):\n                new_grid[i][j] = color_to_expand\n        if grid[1][1] == 2:\n            additional_base_i = base_i - 4 if base_i >= 4 else base_i + 4\n            additional_base_j = base_j - 4 if base_j >= 4 else base_j + 4\n            for i in range(additional_base_i, min(9, additional_base_i + 4)):\n                for j in range(additional_base_j, min(9, additional_base_j + 4)):\n                    new_grid[i][j] = color_to_expand\n    return new_grid"
        },
        {
          "index": 1,
          "model": "Qwen2.5-Coder-32B-Instruct",
          "code_length": 1201,
          "code_preview": "def transform(grid):\n    output_size = 9\n    output_grid = [[0] * output_size for _ in range(output_size)]\n    positions_of_3 = [(i, j) for i in range(3) for j in range(3) if grid[i][j] == 3]\n    if p...",
          "full_code": "def transform(grid):\n    output_size = 9\n    output_grid = [[0] * output_size for _ in range(output_size)]\n    positions_of_3 = [(i, j) for i in range(3) for j in range(3) if grid[i][j] == 3]\n    if positions_of_3:\n        center_i = round(sum((p[0] for p in positions_of_3)) / len(positions_of_3))\n        center_j = round(sum((p[1] for p in positions_of_3)) / len(positions_of_3))\n        base_i = max(0, center_i * 3 - 1)\n        base_j = max(0, center_j * 3 - 1)\n        base_i = min(base_i, output_size - 4)\n        base_j = min(base_j, output_size - 4)\n        for i in range(base_i, base_i + 4):\n            for j in range(base_j, base_j + 4):\n                output_grid[i][j] = 3\n    if grid[1][1] == 2:\n        additional_base_i = base_i - 4 if base_i >= 4 else base_i + 4\n        additional_base_j = base_j - 4 if base_j >= 4 else base_j + 4\n        additional_base_i = max(0, min(additional_base_i, output_size - 4))\n        additional_base_j = max(0, min(additional_base_j, output_size - 4))\n        for i in range(additional_base_i, additional_base_i + 4):\n            for j in range(additional_base_j, additional_base_j + 4):\n                output_grid[i][j] = 3\n    return output_grid"
        }
      ]
    },
    "cluster_3": {
      "stats": {
        "size": 2,
        "avg_distance_to_center": 0.27356177037537055,
        "max_distance_to_center": 0.27356177037537055,
        "models": [
          "Mistral-Large-Instruct-2407"
        ],
        "avg_code_length": 1160.0
      },
      "programs": [
        {
          "index": 0,
          "model": "Mistral-Large-Instruct-2407",
          "code_length": 1055,
          "code_preview": "import numpy as np\n\ndef transform(grid):\n    input_size = len(grid)\n    output_size = input_size * 3\n    output_grid = np.zeros((output_size, output_size), dtype=int)\n    positions_of_3 = np.argwhere(...",
          "full_code": "import numpy as np\n\ndef transform(grid):\n    input_size = len(grid)\n    output_size = input_size * 3\n    output_grid = np.zeros((output_size, output_size), dtype=int)\n    positions_of_3 = np.argwhere(np.array(grid) == 3)\n    if len(positions_of_3) == 0:\n        return output_grid.tolist()\n    center_x = np.mean(positions_of_3[:, 0]).round().astype(int)\n    center_y = np.mean(positions_of_3[:, 1]).round().astype(int)\n    base_x = max(0, center_x * 3 - 1)\n    base_y = max(0, center_y * 3 - 1)\n    for i in range(base_x, min(output_size, base_x + 4)):\n        for j in range(base_y, min(output_size, base_y + 4)):\n            output_grid[i, j] = 3\n    if grid[1][1] == 2:\n        additional_base_x = base_x - 4 if base_x >= 4 else base_x + 4\n        additional_base_y = base_y - 4 if base_y >= 4 else base_y + 4\n        for i in range(additional_base_x, min(output_size, additional_base_x + 4)):\n            for j in range(additional_base_y, min(output_size, additional_base_y + 4)):\n                output_grid[i, j] = 3\n    return output_grid.tolist()"
        },
        {
          "index": 1,
          "model": "Mistral-Large-Instruct-2407",
          "code_length": 1265,
          "code_preview": "import numpy as np\n\ndef transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = np.array(grid_lst)\n    output_size = 9\n    output_shape = (output_size, output_size)\n    output_grid = np.ze...",
          "full_code": "import numpy as np\n\ndef transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = np.array(grid_lst)\n    output_size = 9\n    output_shape = (output_size, output_size)\n    output_grid = np.zeros(output_shape, dtype=int)\n    non_zero_elements = grid[grid != 0]\n    if len(non_zero_elements) == 0:\n        return output_grid.tolist()\n    unique_elements, counts = np.unique(non_zero_elements, return_counts=True)\n    most_frequent_element = unique_elements[np.argmax(counts)]\n    positions = np.argwhere(grid == most_frequent_element)\n    if len(positions) == 0:\n        return output_grid.tolist()\n    center_row = round(np.mean(positions[:, 0]))\n    center_col = round(np.mean(positions[:, 1]))\n    base_row = max(0, center_row * 3 - 1)\n    base_col = max(0, center_col * 3 - 1)\n    for i in range(4):\n        for j in range(4):\n            output_grid[base_row + i, base_col + j] = most_frequent_element\n    if grid[1, 1] == 2:\n        additional_base_row = base_row - 4 if base_row >= 4 else base_row + 4\n        additional_base_col = base_col - 4 if base_col >= 4 else base_col + 4\n        for i in range(4):\n            for j in range(4):\n                output_grid[additional_base_row + i, additional_base_col + j] = 3\n    return output_grid.tolist()"
        }
      ]
    },
    "cluster_0": {
      "stats": {
        "size": 3,
        "avg_distance_to_center": 0.26006669200281324,
        "max_distance_to_center": 0.3087617768282892,
        "models": [
          "Qwen2.5-Coder-32B-Instruct",
          "Mistral-Large-Instruct-2407"
        ],
        "avg_code_length": 1722.6666666666667
      },
      "programs": [
        {
          "index": 0,
          "model": "Qwen2.5-Coder-32B-Instruct",
          "code_length": 1246,
          "code_preview": "def transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    output_grid = [[0] * 9 for _ in range(9)]\n    positions_of_3 = [(i, j) for i in range(3) for j in range(3) if grid_lst[i][j] == 3]\n    ...",
          "full_code": "def transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    output_grid = [[0] * 9 for _ in range(9)]\n    positions_of_3 = [(i, j) for i in range(3) for j in range(3) if grid_lst[i][j] == 3]\n    if not positions_of_3:\n        return output_grid\n    center_i = round(sum((p[0] for p in positions_of_3)) / len(positions_of_3))\n    center_j = round(sum((p[1] for p in positions_of_3)) / len(positions_of_3))\n    base_i = max(0, center_i * 3 - 1)\n    base_j = max(0, center_j * 3 - 1)\n    for i in range(base_i, min(9, base_i + 4)):\n        for j in range(base_j, min(9, base_j + 4)):\n            output_grid[i][j] = 3\n    if grid_lst[1][1] == 2:\n        if center_i == 0:\n            additional_base_i = base_i + 4\n        elif center_i == 2:\n            additional_base_i = base_i - 4\n        else:\n            additional_base_i = base_i\n        if center_j == 0:\n            additional_base_j = base_j + 4\n        elif center_j == 2:\n            additional_base_j = base_j - 4\n        else:\n            additional_base_j = base_j\n        for i in range(additional_base_i, min(9, additional_base_i + 4)):\n            for j in range(additional_base_j, min(9, additional_base_j + 4)):\n                output_grid[i][j] = 3\n    return output_grid"
        },
        {
          "index": 1,
          "model": "Mistral-Large-Instruct-2407",
          "code_length": 1363,
          "code_preview": "def transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    green_color = 3\n    output_size = 9\n    output_grid = [[0] * output_size for _ in range(output_size)]\n    green_cells = [(i, j) for i i...",
          "full_code": "def transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    green_color = 3\n    output_size = 9\n    output_grid = [[0] * output_size for _ in range(output_size)]\n    green_cells = [(i, j) for i in range(3) for j in range(3) if grid_lst[i][j] == green_color]\n    if green_cells:\n        center_i = round(sum((i for i, _ in green_cells)) / len(green_cells))\n        center_j = round(sum((j for _, j in green_cells)) / len(green_cells))\n        base_i = max(0, center_i * 3 - 1)\n        base_j = max(0, center_j * 3 - 1)\n        for i in range(base_i, min(output_size, base_i + 4)):\n            for j in range(base_j, min(output_size, base_j + 4)):\n                output_grid[i][j] = green_color\n    if grid_lst[1][1] == 2:\n        if green_cells:\n            additional_base_i = base_i - 4 if base_i >= 4 else base_i + 4\n            additional_base_j = base_j - 4 if base_j >= 4 else base_j + 4\n            if additional_base_i == base_i:\n                additional_base_i += 4 if base_i < 3 else -4\n            if additional_base_j == base_j:\n                additional_base_j += 4 if base_j < 3 else -4\n            for i in range(additional_base_i, min(output_size, additional_base_i + 4)):\n                for j in range(additional_base_j, min(output_size, additional_base_j + 4)):\n                    output_grid[i][j] = green_color\n    return output_grid"
        },
        {
          "index": 2,
          "model": "Qwen2.5-Coder-32B-Instruct",
          "code_length": 2559,
          "code_preview": "def transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    output_grid = [[0] * 9 for _ in range(9)]\n    pos_2 = None\n    for i in range(3):\n        for j in range(3):\n            if grid_lst[i]...",
          "full_code": "def transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    output_grid = [[0] * 9 for _ in range(9)]\n    pos_2 = None\n    for i in range(3):\n        for j in range(3):\n            if grid_lst[i][j] == 2:\n                pos_2 = (i, j)\n                break\n        if pos_2:\n            break\n    if pos_2 == (1, 1):\n        if grid_lst[0][1] == 3 and grid_lst[1][0] == 3:\n            for i in range(4):\n                for j in range(4):\n                    output_grid[i][j] = 3\n            for i in range(4, 8):\n                for j in range(4, 8):\n                    output_grid[i][j] = 3\n        elif grid_lst[0][1] == 3 and grid_lst[1][2] == 3:\n            for i in range(4):\n                for j in range(5, 9):\n                    output_grid[i][j] = 3\n            for i in range(4, 8):\n                for j in range(1, 5):\n                    output_grid[i][j] = 3\n        elif grid_lst[2][1] == 3 and grid_lst[1][0] == 3:\n            for i in range(5, 9):\n                for j in range(4):\n                    output_grid[i][j] = 3\n            for i in range(1, 5):\n                for j in range(4, 8):\n                    output_grid[i][j] = 3\n        elif grid_lst[2][1] == 3 and grid_lst[1][2] == 3:\n            for i in range(5, 9):\n                for j in range(5, 9):\n                    output_grid[i][j] = 3\n            for i in range(1, 5):\n                for j in range(1, 5):\n                    output_grid[i][j] = 3\n    elif pos_2 == (0, 1):\n        for i in range(4):\n            for j in range(4, 8):\n                output_grid[i][j] = 3\n        if grid_lst[2][1] == 3:\n            for i in range(5, 9):\n                for j in range(4, 8):\n                    output_grid[i][j] = 3\n    elif pos_2 == (1, 0):\n        for i in range(4, 8):\n            for j in range(4):\n                output_grid[i][j] = 3\n        if grid_lst[1][2] == 3:\n            for i in range(4, 8):\n                for j in range(5, 9):\n                    output_grid[i][j] = 3\n    elif pos_2 == (1, 2):\n        for i in range(4, 8):\n            for j in range(5, 9):\n                output_grid[i][j] = 3\n        if grid_lst[1][0] == 3:\n            for i in range(4, 8):\n                for j in range(4):\n                    output_grid[i][j] = 3\n    elif pos_2 == (2, 1):\n        for i in range(5, 9):\n            for j in range(4, 8):\n                output_grid[i][j] = 3\n        if grid_lst[0][1] == 3:\n            for i in range(4):\n                for j in range(4, 8):\n                    output_grid[i][j] = 3\n    return output_grid"
        }
      ]
    },
    "cluster_1": {
      "stats": {
        "size": 2,
        "avg_distance_to_center": 0.1931150989984722,
        "max_distance_to_center": 0.1931150989984722,
        "models": [
          "Qwen2.5-Coder-32B-Instruct",
          "Mistral-Large-Instruct-2407"
        ],
        "avg_code_length": 1363.5
      },
      "programs": [
        {
          "index": 0,
          "model": "Qwen2.5-Coder-32B-Instruct",
          "code_length": 1287,
          "code_preview": "def transform(grid):\n    from collections import Counter\n    flat_grid = [item for sublist in grid for item in sublist if item != 0]\n    if not flat_grid:\n        return [[0] * 9 for _ in range(9)]\n  ...",
          "full_code": "def transform(grid):\n    from collections import Counter\n    flat_grid = [item for sublist in grid for item in sublist if item != 0]\n    if not flat_grid:\n        return [[0] * 9 for _ in range(9)]\n    frequency = Counter(flat_grid)\n    most_frequent_number = frequency.most_common(1)[0][0]\n    output_grid = [[0] * 9 for _ in range(9)]\n    positions_of_3 = [(i, j) for i in range(3) for j in range(3) if grid[i][j] == most_frequent_number]\n    if not positions_of_3:\n        return output_grid\n    center_i = round(sum((p[0] for p in positions_of_3)) / len(positions_of_3))\n    center_j = round(sum((p[1] for p in positions_of_3)) / len(positions_of_3))\n    base_i = max(0, center_i * 3 - 1)\n    base_j = max(0, center_j * 3 - 1)\n    for i in range(base_i, min(9, base_i + 4)):\n        for j in range(base_j, min(9, base_j + 4)):\n            output_grid[i][j] = most_frequent_number\n    if len(positions_of_3) > 1:\n        additional_base_i = base_i - 4 if base_i >= 4 else base_i + 4\n        additional_base_j = base_j - 4 if base_j >= 4 else base_j + 4\n        for i in range(additional_base_i, min(9, additional_base_i + 4)):\n            for j in range(additional_base_j, min(9, additional_base_j + 4)):\n                output_grid[i][j] = most_frequent_number\n    return output_grid"
        },
        {
          "index": 1,
          "model": "Mistral-Large-Instruct-2407",
          "code_length": 1440,
          "code_preview": "def transform(grid):\n    from collections import Counter\n    elements = [cell for row in grid for cell in row if cell != 0]\n    if not elements:\n        return [[0] * 9 for _ in range(9)]\n    most_com...",
          "full_code": "def transform(grid):\n    from collections import Counter\n    elements = [cell for row in grid for cell in row if cell != 0]\n    if not elements:\n        return [[0] * 9 for _ in range(9)]\n    most_common_element, _ = Counter(elements).most_common(1)[0]\n    output_grid = [[0] * 9 for _ in range(9)]\n    positions_of_3 = [(i, j) for i in range(3) for j in range(3) if grid[i][j] == most_common_element]\n    if not positions_of_3:\n        return output_grid\n    center_i = round(sum((p[0] for p in positions_of_3)) / len(positions_of_3))\n    center_j = round(sum((p[1] for p in positions_of_3)) / len(positions_of_3))\n    base_i = max(0, center_i * 3 - 1)\n    base_j = max(0, center_j * 3 - 1)\n    for i in range(base_i, min(9, base_i + 4)):\n        for j in range(base_j, min(9, base_j + 4)):\n            output_grid[i][j] = most_common_element\n    if len(positions_of_3) > 1:\n        additional_base_i = base_i - 4 if base_i >= 4 else base_i + 4\n        additional_base_j = base_j - 4 if base_j >= 4 else base_j + 4\n        if additional_base_i == base_i:\n            additional_base_i += 4 if base_i < 3 else -4\n        if additional_base_j == base_j:\n            additional_base_j += 4 if base_j < 3 else -4\n        for i in range(additional_base_i, min(9, additional_base_i + 4)):\n            for j in range(additional_base_j, min(9, additional_base_j + 4)):\n                output_grid[i][j] = most_common_element\n    return output_grid"
        }
      ]
    }
  }
}