{
  "task_id": "a48eeaf7",
  "summary": {
    "total_programs": 32,
    "optimal_clusters": 6,
    "clustering_method": "silhouette"
  },
  "cluster_analysis": {
    "method": "silhouette",
    "elbow_k": 7,
    "silhouette_k": 6,
    "chosen_k": 6,
    "k_range": [
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10
    ],
    "inertias": [
      5.002923503569847,
      4.174271971119907,
      3.760948127589778,
      3.359646952242625,
      3.044935649127521,
      2.781306405470926,
      2.4633090838152514,
      2.2590107962221673,
      2.0272467451855087
    ],
    "silhouette_scores": [
      0.241603419384838,
      0.24812959560705217,
      0.24088635712526443,
      0.2519860255333026,
      0.2683734442997001,
      0.2604779192281551,
      0.20389642260281543,
      0.19544176275899158,
      0.2037427145524906
    ],
    "silhouette_optimal": 0.2683734442997001
  },
  "clusters": {
    "cluster_1": {
      "stats": {
        "size": 12,
        "avg_distance_to_center": 0.2783461416824442,
        "max_distance_to_center": 0.4227186228770288,
        "models": [
          "Qwen2.5-Coder-7B-Instruct",
          "Qwen2.5-Coder-32B-Instruct",
          "Qwen2.5-72B-Instruct",
          "Mistral-Large-Instruct-2407"
        ],
        "avg_code_length": 1762.9166666666667
      },
      "programs": [
        {
          "index": 0,
          "model": "Qwen2.5-72B-Instruct",
          "code_length": 705,
          "code_preview": "import numpy as np\n\ndef transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = np.array(grid_lst)\n    number_to_move = 5\n    shape_to_find = 2\n    number_positions = np.argwhere(grid == n...",
          "full_code": "import numpy as np\n\ndef transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = np.array(grid_lst)\n    number_to_move = 5\n    shape_to_find = 2\n    number_positions = np.argwhere(grid == number_to_move)\n    shape_positions = np.argwhere(grid == shape_to_find)\n    for r, c in number_positions:\n        min_row, min_col = (np.min(shape_positions, axis=0)[0], np.min(shape_positions, axis=0)[1])\n        max_row, max_col = (np.max(shape_positions, axis=0)[0], np.max(shape_positions, axis=0)[1])\n        new_r = min(max(min_row - 1, r), max_row + 1)\n        new_c = min(max(min_col - 1, c), max_col + 1)\n        grid[r, c] = 0\n        grid[new_r, new_c] = number_to_move\n    return grid.tolist()"
        },
        {
          "index": 1,
          "model": "Qwen2.5-72B-Instruct",
          "code_length": 870,
          "code_preview": "import numpy as np\n\ndef transform(grid: list[list[int]]) -> list[list[int]]:\n    grid_array = np.array(grid)\n    positions_5 = np.argwhere(grid_array == 5)\n    positions_2 = np.argwhere(grid_array == ...",
          "full_code": "import numpy as np\n\ndef transform(grid: list[list[int]]) -> list[list[int]]:\n    grid_array = np.array(grid)\n    positions_5 = np.argwhere(grid_array == 5)\n    positions_2 = np.argwhere(grid_array == 2)\n    if positions_2.size == 0:\n        return grid\n    top_2, left_2 = positions_2.min(axis=0)\n    bottom_2, right_2 = positions_2.max(axis=0)\n    new_grid = np.zeros_like(grid_array)\n    for row, col in positions_5:\n        if row < top_2:\n            new_row = top_2 - 1\n        elif row > bottom_2:\n            new_row = bottom_2 + 1\n        else:\n            new_row = row\n        if col < left_2:\n            new_col = left_2 - 1\n        elif col > right_2:\n            new_col = right_2 + 1\n        else:\n            new_col = col\n        new_grid[new_row, new_col] = 5\n    for row, col in positions_2:\n        new_grid[row, col] = 2\n    return new_grid.tolist()"
        },
        {
          "index": 2,
          "model": "Qwen2.5-Coder-7B-Instruct",
          "code_length": 1073,
          "code_preview": "import numpy as np\n\ndef transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = np.array(grid_lst)\n    blue_color = 5\n    green_color = 2\n    blue_cells = np.argwhere(grid == blue_color)\n ...",
          "full_code": "import numpy as np\n\ndef transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = np.array(grid_lst)\n    blue_color = 5\n    green_color = 2\n    blue_cells = np.argwhere(grid == blue_color)\n    green_cells = np.argwhere(grid == green_color)\n    for blue_cell in blue_cells:\n        min_distance = float('inf')\n        nearest_green_cell = None\n        for green_cell in green_cells:\n            distance = np.sum(np.abs(blue_cell - green_cell))\n            if distance < min_distance:\n                min_distance = distance\n                nearest_green_cell = green_cell\n        if nearest_green_cell is not None:\n            offset = blue_cell - nearest_green_cell\n            if np.any(offset != 0):\n                offset = offset // np.abs(offset)\n                new_position = nearest_green_cell + offset\n                if 0 <= new_position[0] < grid.shape[0] and 0 <= new_position[1] < grid.shape[1]:\n                    grid[blue_cell[0], blue_cell[1]] = 0\n                    grid[new_position[0], new_position[1]] = blue_color\n    return grid.tolist()"
        },
        {
          "index": 3,
          "model": "Mistral-Large-Instruct-2407",
          "code_length": 1082,
          "code_preview": "import numpy as np\n\ndef transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = np.array(grid_lst)\n    grey_color = 5\n    grey_positions = np.argwhere(grid == grey_color)\n    two_positions...",
          "full_code": "import numpy as np\n\ndef transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = np.array(grid_lst)\n    grey_color = 5\n    grey_positions = np.argwhere(grid == grey_color)\n    two_positions = np.argwhere(grid == 2)\n    if two_positions.size == 0:\n        return grid_lst\n    for grey_pos in grey_positions:\n        min_distance = float('inf')\n        nearest_two_pos = None\n        for two_pos in two_positions:\n            distance = np.sum(np.abs(grey_pos - two_pos))\n            if distance < min_distance:\n                min_distance = distance\n                nearest_two_pos = two_pos\n        if nearest_two_pos is not None:\n            offset = grey_pos - nearest_two_pos\n            if np.any(offset != 0):\n                offset = offset // np.abs(offset)\n                new_position = nearest_two_pos + offset\n                if 0 <= new_position[0] < grid.shape[0] and 0 <= new_position[1] < grid.shape[1]:\n                    grid[grey_pos[0], grey_pos[1]] = 0\n                    grid[new_position[0], new_position[1]] = grey_color\n    return grid.tolist()"
        },
        {
          "index": 4,
          "model": "Qwen2.5-72B-Instruct",
          "code_length": 1130,
          "code_preview": "import numpy as np\n\ndef transform(grid: list[list[int]]) -> list[list[int]]:\n    grid = np.array(grid)\n    twos_positions = np.argwhere(grid == 2)\n    fives_positions = np.argwhere(grid == 5)\n\n    def...",
          "full_code": "import numpy as np\n\ndef transform(grid: list[list[int]]) -> list[list[int]]:\n    grid = np.array(grid)\n    twos_positions = np.argwhere(grid == 2)\n    fives_positions = np.argwhere(grid == 5)\n\n    def find_closest_two_to_five(twos, fives):\n        closest_two = {}\n        for five_pos in fives:\n            min_distance = float('inf')\n            closest_pos = None\n            for two_pos in twos:\n                distance = np.linalg.norm(five_pos - two_pos)\n                if distance < min_distance:\n                    min_distance = distance\n                    closest_pos = two_pos\n            closest_two[tuple(five_pos)] = tuple(closest_pos)\n        return closest_two\n    closest_two_to_five = find_closest_two_to_five(twos_positions, fives_positions)\n    for five_pos, two_pos in closest_two_to_five.items():\n        new_five_pos = (two_pos[0] + np.sign(five_pos[0] - two_pos[0]), two_pos[1] + np.sign(five_pos[1] - two_pos[1]))\n        if 0 <= new_five_pos[0] < grid.shape[0] and 0 <= new_five_pos[1] < grid.shape[1]:\n            grid[tuple(new_five_pos)] = 5\n            grid[five_pos] = 0\n    return grid.tolist()"
        },
        {
          "index": 5,
          "model": "Qwen2.5-Coder-32B-Instruct",
          "code_length": 1187,
          "code_preview": "import numpy as np\n\ndef transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = np.array(grid_lst)\n    rows, cols = grid.shape\n    new_grid = np.zeros_like(grid)\n\n    def move_towards_2s(r...",
          "full_code": "import numpy as np\n\ndef transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = np.array(grid_lst)\n    rows, cols = grid.shape\n    new_grid = np.zeros_like(grid)\n\n    def move_towards_2s(row, col):\n        if grid[row, col] == 5:\n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                r, c = (row + dr, col + dc)\n                while 0 <= r < rows and 0 <= c < cols:\n                    if grid[r, c] == 2:\n                        new_grid[r - dr, c - dc] = 5\n                        return\n                    r += dr\n                    c += dc\n            for dr, dc in [(-1, -1), (-1, 1), (1, -1), (1, 1)]:\n                r, c = (row + dr, col + dc)\n                while 0 <= r < rows and 0 <= c < cols:\n                    if grid[r, c] == 2:\n                        new_grid[r - dr, c - dc] = 5\n                        return\n                    r += dr\n                    c += dc\n    for row in range(rows):\n        for col in range(cols):\n            if grid[row, col] == 2:\n                new_grid[row, col] = 2\n    for row in range(rows):\n        for col in range(cols):\n            move_towards_2s(row, col)\n    return new_grid.tolist()"
        },
        {
          "index": 6,
          "model": "Qwen2.5-72B-Instruct",
          "code_length": 1346,
          "code_preview": "import numpy as np\ndef transform(grid: list[list[int]]) -> list[list[int]]:\n    grid = np.array(grid)\n    grey_color = 5\n    red_color = 2\n    grey_positions = np.argwhere(grid == grey_color)\n    red_...",
          "full_code": "import numpy as np\ndef transform(grid: list[list[int]]) -> list[list[int]]:\n    grid = np.array(grid)\n    grey_color = 5\n    red_color = 2\n    grey_positions = np.argwhere(grid == grey_color)\n    red_positions = np.argwhere(grid == red_color)\n\n    def is_valid_position(pos):\n        return 0 <= pos[0] < grid.shape[0] and 0 <= pos[1] < grid.shape[1]\n\n    def move_grey_towards_red(grey_pos, red_pos):\n        direction = np.sign(red_pos - grey_pos)\n        next_pos = grey_pos + direction\n        if is_valid_position(next_pos) and grid[next_pos[0], next_pos[1]] == 0:\n            grid[grey_pos[0], grey_pos[1]] = 0\n            grid[next_pos[0], next_pos[1]] = grey_color\n            return next_pos\n        return grey_pos\n    for grey_pos in grey_positions:\n        min_distance = float('inf')\n        nearest_red_pos = None\n        for red_pos in red_positions:\n            distance = np.linalg.norm(grey_pos - red_pos, ord=1)\n            if distance < min_distance:\n                min_distance = distance\n                nearest_red_pos = red_pos\n        if nearest_red_pos is not None:\n            while True:\n                new_grey_pos = move_grey_towards_red(grey_pos, nearest_red_pos)\n                if np.array_equal(new_grey_pos, grey_pos):\n                    break\n                grey_pos = new_grey_pos\n    return grid.tolist()"
        },
        {
          "index": 7,
          "model": "Qwen2.5-Coder-7B-Instruct",
          "code_length": 1466,
          "code_preview": "import numpy as np\n\ndef transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = np.array(grid_lst)\n    purple_color = 2\n    grey_color = 5\n    black_color = 0\n    purple_positions = np.arg...",
          "full_code": "import numpy as np\n\ndef transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = np.array(grid_lst)\n    purple_color = 2\n    grey_color = 5\n    black_color = 0\n    purple_positions = np.argwhere(grid == purple_color)\n    grey_positions = np.argwhere(grid == grey_color)\n    new_grid = np.copy(grid)\n\n    def find_closest_purple(grey_pos):\n        min_distance = float('inf')\n        closest_purple = None\n        for purple_pos in purple_positions:\n            distance = np.sum(np.abs(grey_pos - purple_pos))\n            if distance < min_distance:\n                min_distance = distance\n                closest_purple = purple_pos\n        return closest_purple\n    for grey_pos in grey_positions:\n        closest_purple = find_closest_purple(grey_pos)\n        if closest_purple is not None:\n            offset = grey_pos - closest_purple\n            if np.any(offset != 0):\n                offset = offset // np.abs(offset)\n                new_position = closest_purple + offset\n                if 0 <= new_position[0] < grid.shape[0] and 0 <= new_position[1] < grid.shape[1]:\n                    if new_grid[new_position[0], new_position[1]] != grey_color:\n                        new_grid[new_position[0], new_position[1]] = grey_color\n                        new_grid[grey_pos[0], grey_pos[1]] = black_color\n                    else:\n                        print(f'Warning: Grey color already exists at {new_position}')\n    return new_grid.tolist()"
        },
        {
          "index": 8,
          "model": "Qwen2.5-Coder-32B-Instruct",
          "code_length": 1890,
          "code_preview": "import numpy as np\n\ndef transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = np.array(grid_lst)\n    rows, cols = grid.shape\n    new_grid = np.zeros_like(grid)\n    for row in range(rows)...",
          "full_code": "import numpy as np\n\ndef transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = np.array(grid_lst)\n    rows, cols = grid.shape\n    new_grid = np.zeros_like(grid)\n    for row in range(rows):\n        for col in range(cols):\n            color = grid[row, col]\n            if color == 2:\n                new_grid[row, col] = color\n    for row in range(rows):\n        for col in range(cols):\n            color = grid[row, col]\n            if color == 5:\n                nearest_2_row, nearest_2_col = (None, None)\n                min_distance = float('inf')\n                for r in range(rows):\n                    for c in range(cols):\n                        if new_grid[r, c] == 2:\n                            distance = abs(r - row) + abs(c - col)\n                            if distance < min_distance:\n                                min_distance = distance\n                                nearest_2_row, nearest_2_col = (r, c)\n                if nearest_2_row is not None and nearest_2_col is not None:\n                    if row < nearest_2_row:\n                        new_row = nearest_2_row - 1\n                    elif row > nearest_2_row:\n                        new_row = nearest_2_row + 1\n                    else:\n                        new_row = row\n                    if col < nearest_2_col:\n                        new_col = nearest_2_col - 1\n                    elif col > nearest_2_col:\n                        new_col = nearest_2_col + 1\n                    else:\n                        new_col = col\n                else:\n                    new_row, new_col = (row, col)\n                if 0 <= new_row < rows and 0 <= new_col < cols:\n                    if new_grid[new_row, new_col] == 0:\n                        new_grid[new_row, new_col] = color\n                    else:\n                        new_grid[row, col] = color\n    return new_grid.tolist()"
        },
        {
          "index": 9,
          "model": "Qwen2.5-Coder-7B-Instruct",
          "code_length": 1940,
          "code_preview": "import numpy as np\n\ndef transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = np.array(grid_lst)\n    purple_color = 5\n    red_color = 2\n    yellow_color = 4\n    purple_positions = np.arg...",
          "full_code": "import numpy as np\n\ndef transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = np.array(grid_lst)\n    purple_color = 5\n    red_color = 2\n    yellow_color = 4\n    purple_positions = np.argwhere(grid == purple_color)\n    red_positions = np.argwhere(grid == red_color)\n    yellow_positions = np.argwhere(grid == yellow_color)\n    for purple_pos in purple_positions:\n        min_distance = float('inf')\n        nearest_red_pos = None\n        for red_pos in red_positions:\n            distance = np.sum(np.abs(purple_pos - red_pos))\n            if distance < min_distance:\n                min_distance = distance\n                nearest_red_pos = red_pos\n        if nearest_red_pos is not None:\n            offset = purple_pos - nearest_red_pos\n            if np.any(offset != 0):\n                offset = offset // np.abs(offset)\n                new_position = nearest_red_pos + offset\n                if 0 <= new_position[0] < grid.shape[0] and 0 <= new_position[1] < grid.shape[1]:\n                    grid[purple_pos[0], purple_pos[1]] = 0\n                    grid[new_position[0], new_position[1]] = purple_color\n    for yellow_pos in yellow_positions:\n        min_distance = float('inf')\n        nearest_red_pos = None\n        for red_pos in red_positions:\n            distance = np.sum(np.abs(yellow_pos - red_pos))\n            if distance < min_distance:\n                min_distance = distance\n                nearest_red_pos = red_pos\n        if nearest_red_pos is not None:\n            offset = yellow_pos - nearest_red_pos\n            if np.any(offset != 0):\n                offset = offset // np.abs(offset)\n                new_position = nearest_red_pos + offset\n                if 0 <= new_position[0] < grid.shape[0] and 0 <= new_position[1] < grid.shape[1]:\n                    grid[yellow_pos[0], yellow_pos[1]] = 0\n                    grid[new_position[0], new_position[1]] = yellow_color\n    return grid.tolist()"
        },
        {
          "index": 10,
          "model": "Qwen2.5-72B-Instruct",
          "code_length": 1989,
          "code_preview": "import numpy as np\n\ndef transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = np.array(grid_lst)\n    rows, cols = grid.shape\n    new_grid = np.zeros_like(grid)\n\n    def is_within_bounds(...",
          "full_code": "import numpy as np\n\ndef transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = np.array(grid_lst)\n    rows, cols = grid.shape\n    new_grid = np.zeros_like(grid)\n\n    def is_within_bounds(r, c):\n        return 0 <= r < rows and 0 <= c < cols\n\n    def move_towards(r, c, target_r, target_c):\n        if r == target_r:\n            step_c = 1 if c < target_c else -1\n            new_c = c + step_c\n            while is_within_bounds(r, new_c) and grid[r, new_c] == 0:\n                new_c += step_c\n            return (r, new_c - step_c)\n        elif c == target_c:\n            step_r = 1 if r < target_r else -1\n            new_r = r + step_r\n            while is_within_bounds(new_r, c) and grid[new_r, c] == 0:\n                new_r += step_r\n            return (new_r - step_r, c)\n        else:\n            step_r = 1 if r < target_r else -1\n            step_c = 1 if c < target_c else -1\n            new_r, new_c = (r + step_r, c + step_c)\n            while is_within_bounds(new_r, new_c) and grid[new_r, new_c] == 0:\n                new_r += step_r\n                new_c += step_c\n            return (new_r - step_r, new_c - step_c)\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] == 5:\n                nearest_2 = None\n                min_distance = float('inf')\n                for r2 in range(rows):\n                    for c2 in range(cols):\n                        if grid[r2, c2] == 2:\n                            distance = abs(r - r2) + abs(c - c2)\n                            if distance < min_distance:\n                                min_distance = distance\n                                nearest_2 = (r2, c2)\n                if nearest_2:\n                    new_r, new_c = move_towards(r, c, nearest_2[0], nearest_2[1])\n                    new_grid[new_r, new_c] = 5\n                else:\n                    new_grid[r, c] = 5\n            elif grid[r, c] == 2:\n                new_grid[r, c] = 2\n    return new_grid.tolist()"
        },
        {
          "index": 11,
          "model": "Qwen2.5-Coder-7B-Instruct",
          "code_length": 6477,
          "code_preview": "import numpy as np\n\ndef transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = np.array(grid_lst)\n    purple_color = 5\n    blue_color = 1\n    red_color = 2\n    green_color = 3\n    yellow_...",
          "full_code": "import numpy as np\n\ndef transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = np.array(grid_lst)\n    purple_color = 5\n    blue_color = 1\n    red_color = 2\n    green_color = 3\n    yellow_color = 4\n    grey_color = 5\n    pink_color = 6\n    orange_color = 7\n    purple_color = 8\n    brown_color = 9\n    purple_cells = np.argwhere(grid == purple_color)\n    blue_cells = np.argwhere(grid == blue_color)\n    red_cells = np.argwhere(grid == red_color)\n    green_cells = np.argwhere(grid == green_color)\n    yellow_cells = np.argwhere(grid == yellow_color)\n    grey_cells = np.argwhere(grid == grey_color)\n    pink_cells = np.argwhere(grid == pink_color)\n    orange_cells = np.argwhere(grid == orange_color)\n    purple_cells = np.argwhere(grid == purple_color)\n    brown_cells = np.argwhere(grid == brown_color)\n    for purple_cell in purple_cells:\n        nearest_blue_cell = None\n        min_distance = float('inf')\n        for blue_cell in blue_cells:\n            distance = np.sum(np.abs(purple_cell - blue_cell))\n            if distance < min_distance:\n                min_distance = distance\n                nearest_blue_cell = blue_cell\n        if nearest_blue_cell is not None:\n            offset = purple_cell - nearest_blue_cell\n            if np.any(offset != 0):\n                offset = offset // np.abs(offset)\n                new_position = nearest_blue_cell + offset\n                if 0 <= new_position[0] < grid.shape[0] and 0 <= new_position[1] < grid.shape[1]:\n                    grid[purple_cell[0], purple_cell[1]] = 0\n                    grid[new_position[0], new_position[1]] = purple_color\n    for red_cell in red_cells:\n        nearest_green_cell = None\n        min_distance = float('inf')\n        for green_cell in green_cells:\n            distance = np.sum(np.abs(red_cell - green_cell))\n            if distance < min_distance:\n                min_distance = distance\n                nearest_green_cell = green_cell\n        if nearest_green_cell is not None:\n            offset = red_cell - nearest_green_cell\n            if np.any(offset != 0):\n                offset = offset // np.abs(offset)\n                new_position = nearest_green_cell + offset\n                if 0 <= new_position[0] < grid.shape[0] and 0 <= new_position[1] < grid.shape[1]:\n                    grid[red_cell[0], red_cell[1]] = 0\n                    grid[new_position[0], new_position[1]] = red_color\n    for yellow_cell in yellow_cells:\n        nearest_purple_cell = None\n        min_distance = float('inf')\n        for purple_cell in purple_cells:\n            distance = np.sum(np.abs(yellow_cell - purple_cell))\n            if distance < min_distance:\n                min_distance = distance\n                nearest_purple_cell = purple_cell\n        if nearest_purple_cell is not None:\n            offset = yellow_cell - nearest_purple_cell\n            if np.any(offset != 0):\n                offset = offset // np.abs(offset)\n                new_position = nearest_purple_cell + offset\n                if 0 <= new_position[0] < grid.shape[0] and 0 <= new_position[1] < grid.shape[1]:\n                    grid[yellow_cell[0], yellow_cell[1]] = 0\n                    grid[new_position[0], new_position[1]] = yellow_color\n    for grey_cell in grey_cells:\n        nearest_red_cell = None\n        min_distance = float('inf')\n        for red_cell in red_cells:\n            distance = np.sum(np.abs(grey_cell - red_cell))\n            if distance < min_distance:\n                min_distance = distance\n                nearest_red_cell = red_cell\n        if nearest_red_cell is not None:\n            offset = grey_cell - nearest_red_cell\n            if np.any(offset != 0):\n                offset = offset // np.abs(offset)\n                new_position = nearest_red_cell + offset\n                if 0 <= new_position[0] < grid.shape[0] and 0 <= new_position[1] < grid.shape[1]:\n                    grid[grey_cell[0], grey_cell[1]] = 0\n                    grid[new_position[0], new_position[1]] = grey_color\n    for pink_cell in pink_cells:\n        nearest_yellow_cell = None\n        min_distance = float('inf')\n        for yellow_cell in yellow_cells:\n            distance = np.sum(np.abs(pink_cell - yellow_cell))\n            if distance < min_distance:\n                min_distance = distance\n                nearest_yellow_cell = yellow_cell\n        if nearest_yellow_cell is not None:\n            offset = pink_cell - nearest_yellow_cell\n            if np.any(offset != 0):\n                offset = offset // np.abs(offset)\n                new_position = nearest_yellow_cell + offset\n                if 0 <= new_position[0] < grid.shape[0] and 0 <= new_position[1] < grid.shape[1]:\n                    grid[pink_cell[0], pink_cell[1]] = 0\n                    grid[new_position[0], new_position[1]] = pink_color\n    for orange_cell in orange_cells:\n        nearest_purple_cell = None\n        min_distance = float('inf')\n        for purple_cell in purple_cells:\n            distance = np.sum(np.abs(orange_cell - purple_cell))\n            if distance < min_distance:\n                min_distance = distance\n                nearest_purple_cell = purple_cell\n        if nearest_purple_cell is not None:\n            offset = orange_cell - nearest_purple_cell\n            if np.any(offset != 0):\n                offset = offset // np.abs(offset)\n                new_position = nearest_purple_cell + offset\n                if 0 <= new_position[0] < grid.shape[0] and 0 <= new_position[1] < grid.shape[1]:\n                    grid[orange_cell[0], orange_cell[1]] = 0\n                    grid[new_position[0], new_position[1]] = orange_color\n    for brown_cell in brown_cells:\n        nearest_green_cell = None\n        min_distance = float('inf')\n        for green_cell in green_cells:\n            distance = np.sum(np.abs(brown_cell - green_cell))\n            if distance < min_distance:\n                min_distance = distance\n                nearest_green_cell = green_cell\n        if nearest_green_cell is not None:\n            offset = brown_cell - nearest_green_cell\n            if np.any(offset != 0):\n                offset = offset // np.abs(offset)\n                new_position = nearest_green_cell + offset\n                if 0 <= new_position[0] < grid.shape[0] and 0 <= new_position[1] < grid.shape[1]:\n                    grid[brown_cell[0], brown_cell[1]] = 0\n                    grid[new_position[0], new_position[1]] = brown_color\n    return grid.tolist()"
        }
      ]
    },
    "cluster_0": {
      "stats": {
        "size": 8,
        "avg_distance_to_center": 0.3496113130379673,
        "max_distance_to_center": 0.480286985248945,
        "models": [
          "Qwen2.5-Coder-32B-Instruct",
          "Qwen2.5-Coder-14B-Instruct",
          "Qwen2.5-72B-Instruct",
          "Mistral-Large-Instruct-2407"
        ],
        "avg_code_length": 1187.625
      },
      "programs": [
        {
          "index": 0,
          "model": "Mistral-Large-Instruct-2407",
          "code_length": 896,
          "code_preview": "def transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = [row[:] for row in grid_lst]\n    red_color = 2\n    grey_color = 5\n    red_cells = [(i, j) for i, row in enumerate(grid) for j, c...",
          "full_code": "def transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = [row[:] for row in grid_lst]\n    red_color = 2\n    grey_color = 5\n    red_cells = [(i, j) for i, row in enumerate(grid) for j, cell in enumerate(row) if cell == red_color]\n    grey_cells = [(i, j) for i, row in enumerate(grid) for j, cell in enumerate(row) if cell == grey_color]\n    for i, j in grey_cells:\n        closest_red = min(red_cells, key=lambda x: abs(x[0] - i) + abs(x[1] - j))\n        if i < closest_red[0]:\n            new_i = closest_red[0] - 1\n        elif i > closest_red[0]:\n            new_i = closest_red[0] + 1\n        else:\n            new_i = i\n        if j < closest_red[1]:\n            new_j = closest_red[1] - 1\n        elif j > closest_red[1]:\n            new_j = closest_red[1] + 1\n        else:\n            new_j = j\n        grid[i][j] = 0\n        grid[new_i][new_j] = grey_color\n    return grid"
        },
        {
          "index": 1,
          "model": "Qwen2.5-Coder-14B-Instruct",
          "code_length": 945,
          "code_preview": "def transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = [row[:] for row in grid_lst]\n    grey_color = 5\n    blue_color = 2\n    grey_shape = [(i, j) for i, row in enumerate(grid) for j,...",
          "full_code": "def transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = [row[:] for row in grid_lst]\n    grey_color = 5\n    blue_color = 2\n    grey_shape = [(i, j) for i, row in enumerate(grid) for j, cell in enumerate(row) if cell == grey_color]\n    blue_shape = [(i, j) for i, row in enumerate(grid) for j, cell in enumerate(row) if cell == blue_color]\n    new_grid = [[0] * len(grid[0]) for _ in range(len(grid))]\n    for i, j in blue_shape:\n        new_grid[i][j] = blue_color\n    for i, j in grey_shape:\n        closest_blue = min(blue_shape, key=lambda x: abs(x[0] - i) + abs(x[1] - j))\n        new_i, new_j = closest_blue\n        if new_i < i:\n            new_i += 1\n        elif new_i > i:\n            new_i -= 1\n        if new_j < j:\n            new_j += 1\n        elif new_j > j:\n            new_j -= 1\n        if 0 <= new_i < len(grid) and 0 <= new_j < len(grid[0]):\n            new_grid[new_i][new_j] = grey_color\n    return new_grid"
        },
        {
          "index": 2,
          "model": "Mistral-Large-Instruct-2407",
          "code_length": 947,
          "code_preview": "def transform(grid: list[list[int]]) -> list[list[int]]:\n    grey_color = 5\n    purple_color = 2\n    new_grid = [row[:] for row in grid]\n    grey_shapes = [(i, j) for i, row in enumerate(grid) for j, ...",
          "full_code": "def transform(grid: list[list[int]]) -> list[list[int]]:\n    grey_color = 5\n    purple_color = 2\n    new_grid = [row[:] for row in grid]\n    grey_shapes = [(i, j) for i, row in enumerate(grid) for j, cell in enumerate(row) if cell == grey_color]\n    purple_shapes = [(i, j) for i, row in enumerate(grid) for j, cell in enumerate(row) if cell == purple_color]\n    for i, j in grey_shapes:\n        closest_purple = min(purple_shapes, key=lambda x: abs(x[0] - i) + abs(x[1] - j))\n        if i < closest_purple[0]:\n            new_i = closest_purple[0] - 1\n        elif i > closest_purple[0]:\n            new_i = closest_purple[0] + 1\n        else:\n            new_i = i\n        if j < closest_purple[1]:\n            new_j = closest_purple[1] - 1\n        elif j > closest_purple[1]:\n            new_j = closest_purple[1] + 1\n        else:\n            new_j = j\n        new_grid[i][j] = 0\n        new_grid[new_i][new_j] = grey_color\n    return new_grid"
        },
        {
          "index": 3,
          "model": "Mistral-Large-Instruct-2407",
          "code_length": 1043,
          "code_preview": "def transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = [row[:] for row in grid_lst]\n    yellow_color = 5\n    red_color = 2\n    yellow_shapes = [(i, j) for i, row in enumerate(grid) fo...",
          "full_code": "def transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = [row[:] for row in grid_lst]\n    yellow_color = 5\n    red_color = 2\n    yellow_shapes = [(i, j) for i, row in enumerate(grid) for j, cell in enumerate(row) if cell == yellow_color]\n    red_shapes = [(i, j) for i, row in enumerate(grid) for j, cell in enumerate(row) if cell == red_color]\n\n    def move_yellow(yellow, red):\n        y_i, y_j = yellow\n        r_i, r_j = red\n        if y_i < r_i:\n            new_i = r_i - 1\n        elif y_i > r_i:\n            new_i = r_i + 1\n        else:\n            new_i = y_i\n        if y_j < r_j:\n            new_j = r_j - 1\n        elif y_j > r_j:\n            new_j = r_j + 1\n        else:\n            new_j = y_j\n        return (new_i, new_j)\n    for yellow in yellow_shapes:\n        closest_red = min(red_shapes, key=lambda x: abs(x[0] - yellow[0]) + abs(x[1] - yellow[1]))\n        new_pos = move_yellow(yellow, closest_red)\n        grid[yellow[0]][yellow[1]] = 0\n        grid[new_pos[0]][new_pos[1]] = yellow_color\n    return grid"
        },
        {
          "index": 4,
          "model": "Mistral-Large-Instruct-2407",
          "code_length": 1150,
          "code_preview": "def transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = [row[:] for row in grid_lst]\n    red_color = 5\n    blue_color = 2\n    red_shapes = [(i, j) for i, row in enumerate(grid) for j, ...",
          "full_code": "def transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = [row[:] for row in grid_lst]\n    red_color = 5\n    blue_color = 2\n    red_shapes = [(i, j) for i, row in enumerate(grid) for j, cell in enumerate(row) if cell == red_color]\n    blue_shapes = [(i, j) for i, row in enumerate(grid) for j, cell in enumerate(row) if cell == blue_color]\n\n    def manhattan_distance(point1, point2):\n        return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])\n    for red in red_shapes:\n        if blue_shapes:\n            closest_blue = min(blue_shapes, key=lambda blue: manhattan_distance(red, blue))\n            if red[0] < closest_blue[0]:\n                new_i = closest_blue[0] - 1\n            elif red[0] > closest_blue[0]:\n                new_i = closest_blue[0] + 1\n            else:\n                new_i = red[0]\n            if red[1] < closest_blue[1]:\n                new_j = closest_blue[1] - 1\n            elif red[1] > closest_blue[1]:\n                new_j = closest_blue[1] + 1\n            else:\n                new_j = red[1]\n            grid[red[0]][red[1]] = 0\n            grid[new_i][new_j] = red_color\n    return grid"
        },
        {
          "index": 5,
          "model": "Mistral-Large-Instruct-2407",
          "code_length": 1162,
          "code_preview": "def transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = [row[:] for row in grid_lst]\n    purple_color = 5\n    blue_color = 2\n    purple_shapes = [(i, j) for i, row in enumerate(grid) f...",
          "full_code": "def transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = [row[:] for row in grid_lst]\n    purple_color = 5\n    blue_color = 2\n    purple_shapes = [(i, j) for i, row in enumerate(grid) for j, cell in enumerate(row) if cell == purple_color]\n    blue_shapes = [(i, j) for i, row in enumerate(grid) for j, cell in enumerate(row) if cell == blue_color]\n\n    def move_shape(shape, target_shape):\n        for i, j in shape:\n            closest_target = min(target_shape, key=lambda x: abs(x[0] - i) + abs(x[1] - j))\n            if i < closest_target[0]:\n                new_i = closest_target[0] - 1\n            elif i > closest_target[0]:\n                new_i = closest_target[0] + 1\n            else:\n                new_i = i\n            if j < closest_target[1]:\n                new_j = closest_target[1] - 1\n            elif j > closest_target[1]:\n                new_j = closest_target[1] + 1\n            else:\n                new_j = j\n            grid[i][j] = 0\n            grid[new_i][new_j] = purple_color if (i, j) in purple_shapes else blue_color\n    for shape in purple_shapes:\n        move_shape(purple_shapes, blue_shapes)\n    return grid"
        },
        {
          "index": 6,
          "model": "Qwen2.5-72B-Instruct",
          "code_length": 1554,
          "code_preview": "def transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = [row[:] for row in grid_lst]\n    purple_color = 5\n    red_color = 2\n    purple_positions = [(i, j) for i, row in enumerate(grid)...",
          "full_code": "def transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = [row[:] for row in grid_lst]\n    purple_color = 5\n    red_color = 2\n    purple_positions = [(i, j) for i, row in enumerate(grid) for j, cell in enumerate(row) if cell == purple_color]\n    red_positions = [(i, j) for i, row in enumerate(grid) for j, cell in enumerate(row) if cell == red_color]\n\n    def move_purple(pi, pj):\n        if not red_positions:\n            return\n        closest_red = min(red_positions, key=lambda x: abs(x[0] - pi) + abs(x[1] - pj))\n        red_i, red_j = closest_red\n        new_i = pi\n        new_j = pj\n        if pi < red_i:\n            new_i = red_i - 1\n        elif pi > red_i:\n            new_i = red_i + 1\n        if pj < red_j:\n            new_j = red_j - 1\n        elif pj > red_j:\n            new_j = red_j + 1\n        if 0 <= new_i < len(grid) and 0 <= new_j < len(grid[0]) and (grid[new_i][new_j] != red_color):\n            grid[new_i][new_j] = purple_color\n            grid[pi][pj] = 0\n            red_positions.remove(closest_red)\n        else:\n            for direction in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                alt_i, alt_j = (new_i + direction[0], new_j + direction[1])\n                if 0 <= alt_i < len(grid) and 0 <= alt_j < len(grid[0]) and (grid[alt_i][alt_j] == 0):\n                    grid[alt_i][alt_j] = purple_color\n                    grid[pi][pj] = 0\n                    red_positions.remove(closest_red)\n                    break\n    for pi, pj in purple_positions:\n        move_purple(pi, pj)\n    return grid"
        },
        {
          "index": 7,
          "model": "Qwen2.5-Coder-32B-Instruct",
          "code_length": 1804,
          "code_preview": "def transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = [row[:] for row in grid_lst]\n    rows, cols = (len(grid), len(grid[0]))\n\n    def find_shape_positions(grid, color):\n        retu...",
          "full_code": "def transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = [row[:] for row in grid_lst]\n    rows, cols = (len(grid), len(grid[0]))\n\n    def find_shape_positions(grid, color):\n        return [(r, c) for r in range(rows) for c in range(cols) if grid[r][c] == color]\n\n    def move_positions_closest_to_target(source_positions, target_positions, grid, source_color, target_color):\n        if not target_positions:\n            return\n        source_positions.sort(key=lambda x: min([abs(x[0] - y[0]) + abs(x[1] - y[1]) for y in target_positions]))\n        for r, c in source_positions:\n            if not grid[r][c] == source_color:\n                continue\n            min_distance = float('inf')\n            closest_target = None\n            for tr, tc in target_positions:\n                distance = abs(r - tr) + abs(c - tc)\n                if distance < min_distance:\n                    min_distance = distance\n                    closest_target = (tr, tc)\n            if closest_target:\n                cr, cc = closest_target\n                if cr < r:\n                    cr += 1\n                elif cr > r:\n                    cr -= 1\n                if cc < c:\n                    cc += 1\n                elif cc > c:\n                    cc -= 1\n                if 0 <= cr < rows and 0 <= cc < cols and (grid[cr][cc] == 0):\n                    grid[cr][cc] = source_color\n                    grid[r][c] = 0\n    red_positions = find_shape_positions(grid, 2)\n    grey_positions = find_shape_positions(grid, 5)\n    move_positions_closest_to_target(grey_positions, red_positions, grid, 5, 2)\n    red_positions = find_shape_positions(grid, 2)\n    grey_positions = find_shape_positions(grid, 5)\n    move_positions_closest_to_target(red_positions, grey_positions, grid, 2, 5)\n    return grid"
        }
      ]
    },
    "cluster_2": {
      "stats": {
        "size": 6,
        "avg_distance_to_center": 0.3273526725611493,
        "max_distance_to_center": 0.3622157037730007,
        "models": [
          "Qwen2.5-Coder-32B-Instruct",
          "Mistral-Large-Instruct-2407"
        ],
        "avg_code_length": 1313.8333333333333
      },
      "programs": [
        {
          "index": 0,
          "model": "Mistral-Large-Instruct-2407",
          "code_length": 964,
          "code_preview": "def transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = [row[:] for row in grid_lst]\n    rows, cols = (len(grid), len(grid[0]))\n    fives = [(r, c) for r in range(rows) for c in range(...",
          "full_code": "def transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = [row[:] for row in grid_lst]\n    rows, cols = (len(grid), len(grid[0]))\n    fives = [(r, c) for r in range(rows) for c in range(cols) if grid[r][c] == 5]\n    for r, c in fives:\n        closest_two = None\n        min_distance = float('inf')\n        for i in range(rows):\n            for j in range(cols):\n                if grid[i][j] == 2:\n                    distance = abs(i - r) + abs(j - c)\n                    if distance < min_distance:\n                        min_distance = distance\n                        closest_two = (i, j)\n        if closest_two:\n            new_r, new_c = closest_two\n            if new_r < r:\n                new_r += 1\n            elif new_r > r:\n                new_r -= 1\n            if new_c < c:\n                new_c += 1\n            elif new_c > c:\n                new_c -= 1\n            grid[r][c] = 0\n            grid[new_r][new_c] = 5\n    return grid"
        },
        {
          "index": 1,
          "model": "Qwen2.5-Coder-32B-Instruct",
          "code_length": 1171,
          "code_preview": "def transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = [list(row) for row in grid_lst]\n    n = len(grid)\n    m = len(grid[0])\n    new_grid = [[0] * m for _ in range(n)]\n    for i in r...",
          "full_code": "def transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = [list(row) for row in grid_lst]\n    n = len(grid)\n    m = len(grid[0])\n    new_grid = [[0] * m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] != 0:\n                nearest_2_distance = float('inf')\n                nearest_2 = None\n                for x in range(n):\n                    for y in range(m):\n                        if grid[x][y] == 2:\n                            distance = abs(x - i) + abs(y - j)\n                            if distance < nearest_2_distance:\n                                nearest_2_distance = distance\n                                nearest_2 = (x, y)\n                if nearest_2:\n                    x, y = nearest_2\n                    dx = x - i\n                    dy = y - j\n                    new_i = x - dx // abs(dx) if dx != 0 else x\n                    new_j = y - dy // abs(dy) if dy != 0 else y\n                    if 0 <= new_i < n and 0 <= new_j < m:\n                        new_grid[new_i][new_j] = grid[i][j]\n                else:\n                    new_grid[i][j] = grid[i][j]\n    return new_grid"
        },
        {
          "index": 2,
          "model": "Mistral-Large-Instruct-2407",
          "code_length": 1236,
          "code_preview": "def transform(grid: list[list[int]]) -> list[list[int]]:\n    rows, cols = (len(grid), len(grid[0]))\n    new_grid = [[0] * cols for _ in range(rows)]\n    for i in range(rows):\n        for j in range(co...",
          "full_code": "def transform(grid: list[list[int]]) -> list[list[int]]:\n    rows, cols = (len(grid), len(grid[0]))\n    new_grid = [[0] * cols for _ in range(rows)]\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 2:\n                new_grid[i][j] = 2\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 5:\n                closest_2 = None\n                min_distance = float('inf')\n                for x in range(rows):\n                    for y in range(cols):\n                        if grid[x][y] == 2:\n                            distance = abs(x - i) + abs(y - j)\n                            if distance < min_distance:\n                                min_distance = distance\n                                closest_2 = (x, y)\n                if closest_2:\n                    new_i, new_j = closest_2\n                    if i < new_i:\n                        new_i = new_i - 1\n                    elif i > new_i:\n                        new_i = new_i + 1\n                    if j < new_j:\n                        new_j = new_j - 1\n                    elif j > new_j:\n                        new_j = new_j + 1\n                    new_grid[new_i][new_j] = 5\n    return new_grid"
        },
        {
          "index": 3,
          "model": "Qwen2.5-Coder-32B-Instruct",
          "code_length": 1257,
          "code_preview": "def transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = [list(row) for row in grid_lst]\n    rows, cols = (len(grid), len(grid[0]))\n    new_grid = [[0] * cols for _ in range(rows)]\n    ...",
          "full_code": "def transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = [list(row) for row in grid_lst]\n    rows, cols = (len(grid), len(grid[0]))\n    new_grid = [[0] * cols for _ in range(rows)]\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == 2:\n                new_grid[r][c] = 2\n\n    def move_towards_2s(r, c):\n        target_row, target_col = (r, c)\n        min_distance = float('inf')\n        for i in range(rows):\n            for j in range(cols):\n                if new_grid[i][j] == 2:\n                    distance = abs(r - i) + abs(c - j)\n                    if distance < min_distance:\n                        min_distance = distance\n                        target_row, target_col = (i, j)\n        if target_row > r:\n            target_row -= 1\n        elif target_row < r:\n            target_row += 1\n        if target_col > c:\n            target_col -= 1\n        elif target_col < c:\n            target_col += 1\n        return (target_row, target_col)\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == 5:\n                new_r, new_c = move_towards_2s(r, c)\n                if new_grid[new_r][new_c] == 0:\n                    new_grid[new_r][new_c] = 5\n    return new_grid"
        },
        {
          "index": 4,
          "model": "Qwen2.5-Coder-32B-Instruct",
          "code_length": 1565,
          "code_preview": "def transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = [row[:] for row in grid_lst]\n    rows, cols = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n...",
          "full_code": "def transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = [row[:] for row in grid_lst]\n    rows, cols = (len(grid), len(grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 5:\n                found = False\n                for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                    ni, nj = (i + di, j + dj)\n                    while 0 <= ni < rows and 0 <= nj < cols:\n                        if grid[ni][nj] == 2:\n                            found = True\n                            grid[i][j] = 0\n                            grid[ni - di][nj - dj] = 5\n                            break\n                        elif grid[ni][nj] != 0:\n                            break\n                        ni += di\n                        nj += dj\n                    if found:\n                        break\n                if not found:\n                    for di, dj in [(1, 1), (1, -1), (-1, 1), (-1, -1)]:\n                        ni, nj = (i + di, j + dj)\n                        while 0 <= ni < rows and 0 <= nj < cols:\n                            if grid[ni][nj] == 2:\n                                found = True\n                                grid[i][j] = 0\n                                grid[ni - di][nj - dj] = 5\n                                break\n                            elif grid[ni][nj] != 0:\n                                break\n                            ni += di\n                            nj += dj\n                        if found:\n                            break\n    return grid"
        },
        {
          "index": 5,
          "model": "Qwen2.5-Coder-32B-Instruct",
          "code_length": 1690,
          "code_preview": "def transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = [row[:] for row in grid_lst]\n    rows, cols = (len(grid), len(grid[0]))\n\n    def is_valid(x, y):\n        return 0 <= x < rows an...",
          "full_code": "def transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = [row[:] for row in grid_lst]\n    rows, cols = (len(grid), len(grid[0]))\n\n    def is_valid(x, y):\n        return 0 <= x < rows and 0 <= y < cols\n\n    def dfs(x, y, visited, component):\n        if not is_valid(x, y) or grid[x][y] != 2 or (x, y) in visited:\n            return\n        visited.add((x, y))\n        component.append((x, y))\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            dfs(x + dx, y + dy, visited, component)\n    visited = set()\n    components = []\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 2 and (i, j) not in visited:\n                component = []\n                dfs(i, j, visited, component)\n                components.append(component)\n    for component in components:\n        min_x = min((x for x, y in component))\n        max_x = max((x for x, y in component))\n        min_y = min((y for x, y in component))\n        max_y = max((y for x, y in component))\n        for i in range(rows):\n            for j in range(cols):\n                if grid[i][j] == 5:\n                    if i < min_x:\n                        new_i = min_x - 1\n                    elif i > max_x:\n                        new_i = max_x + 1\n                    else:\n                        new_i = i\n                    if j < min_y:\n                        new_j = min_y - 1\n                    elif j > max_y:\n                        new_j = max_y + 1\n                    else:\n                        new_j = j\n                    if is_valid(new_i, new_j):\n                        grid[i][j] = 0\n                        grid[new_i][new_j] = 5\n    return grid"
        }
      ]
    },
    "cluster_3": {
      "stats": {
        "size": 2,
        "avg_distance_to_center": 0.31353347031149054,
        "max_distance_to_center": 0.31353347031149054,
        "models": [
          "Qwen2.5-Coder-32B-Instruct",
          "Qwen2.5-72B-Instruct"
        ],
        "avg_code_length": 1346.5
      },
      "programs": [
        {
          "index": 0,
          "model": "Qwen2.5-Coder-32B-Instruct",
          "code_length": 1313,
          "code_preview": "def transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = [row[:] for row in grid_lst]\n    rows, cols = (len(grid), len(grid[0]))\n\n    def is_valid(x, y):\n        return 0 <= x < rows an...",
          "full_code": "def transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = [row[:] for row in grid_lst]\n    rows, cols = (len(grid), len(grid[0]))\n\n    def is_valid(x, y):\n        return 0 <= x < rows and 0 <= y < cols\n\n    def move_towards_blockers(fx, fy, bx, by):\n        dx = 0 if fx == bx else 1 if fx < bx else -1\n        dy = 0 if fy == by else 1 if fy < by else -1\n        new_x, new_y = (fx + dx, fy + dy)\n        while is_valid(new_x, new_y) and grid[new_x][new_y] == 0:\n            new_x += dx\n            new_y += dy\n        if is_valid(new_x - dx, new_y - dy):\n            grid[fx][fy] = 0\n            grid[new_x - dx][new_y - dy] = 5\n    for f in range(rows):\n        for c in range(cols):\n            if grid[f][c] == 5:\n                nearest_blocker = None\n                min_distance = float('inf')\n                for b in range(rows):\n                    for d in range(cols):\n                        if grid[b][d] in [2]:\n                            distance = abs(f - b) + abs(c - d)\n                            if distance < min_distance:\n                                nearest_blocker = (b, d)\n                                min_distance = distance\n                if nearest_blocker:\n                    move_towards_blockers(f, c, nearest_blocker[0], nearest_blocker[1])\n    return grid"
        },
        {
          "index": 1,
          "model": "Qwen2.5-72B-Instruct",
          "code_length": 1380,
          "code_preview": "def transform(grid: list[list[int]]) -> list[list[int]]:\n    new_grid = [[0 for _ in row] for row in grid]\n\n    def find_2x2_blocks(grid):\n        blocks = []\n        for i in range(len(grid) - 1):\n  ...",
          "full_code": "def transform(grid: list[list[int]]) -> list[list[int]]:\n    new_grid = [[0 for _ in row] for row in grid]\n\n    def find_2x2_blocks(grid):\n        blocks = []\n        for i in range(len(grid) - 1):\n            for j in range(len(grid[0]) - 1):\n                if grid[i][j] == 2 and grid[i][j + 1] == 2 and (grid[i + 1][j] == 2) and (grid[i + 1][j + 1] == 2):\n                    blocks.append((i, j))\n        return blocks\n\n    def move_5_to_block(grid, block, new_grid):\n        block_i, block_j = block\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 5:\n                    if i < block_i:\n                        new_i = block_i - 1\n                    elif i > block_i + 1:\n                        new_i = block_i + 2\n                    else:\n                        new_i = i\n                    if j < block_j:\n                        new_j = block_j - 1\n                    elif j > block_j + 1:\n                        new_j = block_j + 2\n                    else:\n                        new_j = j\n                    new_grid[new_i][new_j] = 5\n    blocks = find_2x2_blocks(grid)\n    for block in blocks:\n        move_5_to_block(grid, block, new_grid)\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 2:\n                new_grid[i][j] = 2\n    return new_grid"
        }
      ]
    },
    "cluster_5": {
      "stats": {
        "size": 2,
        "avg_distance_to_center": 0.2049885737836078,
        "max_distance_to_center": 0.2049885737836078,
        "models": [
          "Qwen2.5-72B-Instruct"
        ],
        "avg_code_length": 2692.5
      },
      "programs": [
        {
          "index": 0,
          "model": "Qwen2.5-72B-Instruct",
          "code_length": 1370,
          "code_preview": "def transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = grid_lst.copy()\n    positions_5 = [(i, j) for i in range(len(grid)) for j in range(len(grid[0])) if grid[i][j] == 5]\n    positio...",
          "full_code": "def transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = grid_lst.copy()\n    positions_5 = [(i, j) for i in range(len(grid)) for j in range(len(grid[0])) if grid[i][j] == 5]\n    positions_2 = [(i, j) for i in range(len(grid)) for j in range(len(grid[0])) if grid[i][j] == 2]\n\n    def is_within_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def move_5_to_2(pos_5, pos_2):\n        dx = 1 if pos_5[0] < pos_2[0] else -1 if pos_5[0] > pos_2[0] else 0\n        dy = 1 if pos_5[1] < pos_2[1] else -1 if pos_5[1] > pos_2[1] else 0\n        new_pos_5 = (pos_5[0] + dx, pos_5[1] + dy)\n        if is_within_bounds(new_pos_5[0], new_pos_5[1]) and grid[new_pos_5[0]][new_pos_5[1]] == 0:\n            grid[pos_5[0]][pos_5[1]] = 0\n            grid[new_pos_5[0]][new_pos_5[1]] = 5\n            return new_pos_5\n        return pos_5\n\n    def find_nearest_2(pos_5):\n        distances = [(abs(pos_5[0] - pos_2[0]) + abs(pos_5[1] - pos_2[1]), pos_2) for pos_2 in positions_2]\n        distances.sort()\n        return distances[0][1] if distances else None\n    for pos_5 in positions_5:\n        nearest_2 = find_nearest_2(pos_5)\n        if nearest_2:\n            while True:\n                new_pos_5 = move_5_to_2(pos_5, nearest_2)\n                if new_pos_5 == pos_5:\n                    break\n                pos_5 = new_pos_5\n    return grid"
        },
        {
          "index": 1,
          "model": "Qwen2.5-72B-Instruct",
          "code_length": 4015,
          "code_preview": "def transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = [row[:] for row in grid_lst]\n    positions_5 = [(i, j) for i in range(len(grid)) for j in range(len(grid[0])) if grid[i][j] == 5...",
          "full_code": "def transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = [row[:] for row in grid_lst]\n    positions_5 = [(i, j) for i in range(len(grid)) for j in range(len(grid[0])) if grid[i][j] == 5]\n    positions_2 = [(i, j) for i in range(len(grid)) for j in range(len(grid[0])) if grid[i][j] == 2]\n\n    def is_within_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def move_5_to_2(pos_5, pos_2):\n        dx = 1 if pos_5[0] < pos_2[0] else -1 if pos_5[0] > pos_2[0] else 0\n        dy = 1 if pos_5[1] < pos_2[1] else -1 if pos_5[1] > pos_2[1] else 0\n        new_pos_5 = (pos_5[0] + dx, pos_5[1] + dy)\n        if is_within_bounds(new_pos_5[0], new_pos_5[1]) and grid[new_pos_5[0]][new_pos_5[1]] == 0:\n            grid[pos_5[0]][pos_5[1]] = 0\n            grid[new_pos_5[0]][new_pos_5[1]] = 5\n            return new_pos_5\n        return pos_5\n\n    def find_nearest_2(pos_5):\n        distances = [(abs(pos_5[0] - pos_2[0]) + abs(pos_5[1] - pos_2[1]), pos_2) for pos_2 in positions_2]\n        distances.sort()\n        return distances[0][1] if distances else None\n\n    def move_all_5s():\n        moved_positions = set()\n        for pos_5 in positions_5:\n            if pos_5 not in moved_positions:\n                nearest_2 = find_nearest_2(pos_5)\n                if nearest_2:\n                    while True:\n                        new_pos_5 = move_5_to_2(pos_5, nearest_2)\n                        if new_pos_5 == pos_5 or new_pos_5 == nearest_2:\n                            break\n                        moved_positions.add(new_pos_5)\n                        pos_5 = new_pos_5\n\n    def resolve_conflicts():\n        for pos_5 in positions_5:\n            if grid[pos_5[0]][pos_5[1]] == 5:\n                nearest_2 = find_nearest_2(pos_5)\n                if nearest_2:\n                    path = []\n                    current_pos = pos_5\n                    while current_pos != nearest_2:\n                        dx = 1 if current_pos[0] < nearest_2[0] else -1 if current_pos[0] > nearest_2[0] else 0\n                        dy = 1 if current_pos[1] < nearest_2[1] else -1 if current_pos[1] > nearest_2[1] else 0\n                        next_pos = (current_pos[0] + dx, current_pos[1] + dy)\n                        if is_within_bounds(next_pos[0], next_pos[1]) and grid[next_pos[0]][next_pos[1]] == 0:\n                            path.append(next_pos)\n                            current_pos = next_pos\n                        else:\n                            break\n                    for i in range(len(path)):\n                        if grid[path[i][0]][path[i][1]] == 0:\n                            grid[path[i][0]][path[i][1]] = 5\n                            grid[pos_5[0]][pos_5[1]] = 0\n                            pos_5 = path[i]\n\n    def ensure_no_overlaps():\n        for pos_5 in positions_5:\n            if grid[pos_5[0]][pos_5[1]] == 5:\n                nearest_2 = find_nearest_2(pos_5)\n                if nearest_2:\n                    path = []\n                    current_pos = pos_5\n                    while current_pos != nearest_2:\n                        dx = 1 if current_pos[0] < nearest_2[0] else -1 if current_pos[0] > nearest_2[0] else 0\n                        dy = 1 if current_pos[1] < nearest_2[1] else -1 if current_pos[1] > nearest_2[1] else 0\n                        next_pos = (current_pos[0] + dx, current_pos[1] + dy)\n                        if is_within_bounds(next_pos[0], next_pos[1]) and grid[next_pos[0]][next_pos[1]] == 0:\n                            path.append(next_pos)\n                            current_pos = next_pos\n                        else:\n                            break\n                    for i in range(len(path)):\n                        if grid[path[i][0]][path[i][1]] == 0:\n                            grid[path[i][0]][path[i][1]] = 5\n                            grid[pos_5[0]][pos_5[1]] = 0\n                            pos_5 = path[i]\n    move_all_5s()\n    resolve_conflicts()\n    ensure_no_overlaps()\n    return grid"
        }
      ]
    },
    "cluster_4": {
      "stats": {
        "size": 2,
        "avg_distance_to_center": 0.23632487778115183,
        "max_distance_to_center": 0.23632487778115183,
        "models": [
          "Qwen2.5-72B-Instruct",
          "Mistral-Large-Instruct-2407"
        ],
        "avg_code_length": 2021.0
      },
      "programs": [
        {
          "index": 0,
          "model": "Mistral-Large-Instruct-2407",
          "code_length": 1916,
          "code_preview": "from collections import deque\n\ndef transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = [row[:] for row in grid_lst]\n    grey_color = 5\n    red_color = 2\n    new_grey_positions = []\n   ...",
          "full_code": "from collections import deque\n\ndef transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = [row[:] for row in grid_lst]\n    grey_color = 5\n    red_color = 2\n    new_grey_positions = []\n    grey_positions = [(i, j) for i, row in enumerate(grid) for j, cell in enumerate(row) if cell == grey_color]\n    red_positions = [(i, j) for i, row in enumerate(grid) for j, cell in enumerate(row) if cell == red_color]\n\n    def bfs_find_closest_red(start):\n        queue = deque([start])\n        visited = set([start])\n        closest_red = None\n        min_distance = float('inf')\n        while queue:\n            x, y = queue.popleft()\n            if grid[x][y] == red_color:\n                if min_distance > abs(x - start[0]) + abs(y - start[1]):\n                    min_distance = abs(x - start[0]) + abs(y - start[1])\n                    closest_red = (x, y)\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = (x + dx, y + dy)\n                if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and ((nx, ny) not in visited):\n                    visited.add((nx, ny))\n                    queue.append((nx, ny))\n        return closest_red\n    for i, j in grey_positions:\n        closest_red = bfs_find_closest_red((i, j))\n        if closest_red:\n            x, y = closest_red\n            if i < x:\n                new_i = x - 1\n            elif i > x:\n                new_i = x + 1\n            else:\n                new_i = i\n            if j < y:\n                new_j = y - 1\n            elif j > y:\n                new_j = y + 1\n            else:\n                new_j = j\n            if 0 <= new_i < len(grid) and 0 <= new_j < len(grid[0]) and (grid[new_i][new_j] != grey_color):\n                new_grey_positions.append((i, j, new_i, new_j))\n    for i, j, new_i, new_j in new_grey_positions:\n        grid[i][j] = 0\n        grid[new_i][new_j] = grey_color\n    return grid"
        },
        {
          "index": 1,
          "model": "Qwen2.5-72B-Instruct",
          "code_length": 2126,
          "code_preview": "from collections import deque\n\ndef transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = [row.copy() for row in grid_lst]\n    positions_5 = [(i, j) for i in range(len(grid)) for j in ran...",
          "full_code": "from collections import deque\n\ndef transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    grid = [row.copy() for row in grid_lst]\n    positions_5 = [(i, j) for i in range(len(grid)) for j in range(len(grid[0])) if grid[i][j] == 5]\n    positions_2 = [(i, j) for i in range(len(grid)) for j in range(len(grid[0])) if grid[i][j] == 2]\n\n    def is_within_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0])\n\n    def bfs_find_nearest_2(start):\n        queue = deque([start])\n        visited = set([start])\n        while queue:\n            x, y = queue.popleft()\n            if grid[x][y] == 2:\n                return (x, y)\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = (x + dx, y + dy)\n                if is_within_bounds(nx, ny) and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny))\n        return None\n\n    def move_5_to_2(pos_5, nearest_2):\n        if nearest_2 is None:\n            return pos_5\n        dx = 1 if pos_5[0] < nearest_2[0] else -1 if pos_5[0] > nearest_2[0] else 0\n        dy = 1 if pos_5[1] < nearest_2[1] else -1 if pos_5[1] > nearest_2[1] else 0\n        new_pos_5 = (pos_5[0] + dx, pos_5[1] + dy)\n        if is_within_bounds(new_pos_5[0], new_pos_5[1]) and grid[new_pos_5[0]][new_pos_5[1]] == 0:\n            grid[pos_5[0]][pos_5[1]] = 0\n            grid[new_pos_5[0]][new_pos_5[1]] = 5\n            return new_pos_5\n        return pos_5\n\n    def move_all_5s():\n        moved_positions = set()\n        for pos_5 in positions_5:\n            if pos_5 in moved_positions:\n                continue\n            nearest_2 = bfs_find_nearest_2(pos_5)\n            if nearest_2 is None:\n                continue\n            new_pos_5 = pos_5\n            while True:\n                new_pos_5 = move_5_to_2(new_pos_5, nearest_2)\n                if new_pos_5 == pos_5:\n                    break\n                pos_5 = new_pos_5\n                moved_positions.add(new_pos_5)\n                if grid[new_pos_5[0]][new_pos_5[1]] == 2:\n                    break\n    move_all_5s()\n    return grid"
        }
      ]
    }
  }
}