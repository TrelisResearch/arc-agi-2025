{
  "task_id": "3e980e27",
  "summary": {
    "total_programs": 4,
    "optimal_clusters": 2,
    "clustering_method": "silhouette"
  },
  "cluster_analysis": {
    "method": "silhouette",
    "elbow_k": 2,
    "silhouette_k": 2,
    "chosen_k": 2,
    "k_range": [
      2,
      3
    ],
    "inertias": [
      0.3418368156214314,
      0.15861310286966035
    ],
    "silhouette_scores": [
      0.10828171809857083,
      0.02171121321250832
    ],
    "silhouette_optimal": 0.10828171809857083
  },
  "clusters": {
    "cluster_0": {
      "stats": {
        "size": 3,
        "avg_distance_to_center": 0.33744001262607787,
        "max_distance_to_center": 0.34949841463805553,
        "models": [
          "Mistral-Large-Instruct-2407"
        ],
        "avg_code_length": 2782.6666666666665
      },
      "programs": [
        {
          "index": 0,
          "model": "Mistral-Large-Instruct-2407",
          "code_length": 2491,
          "code_preview": "def transform(grid):\n\n    def is_isolated(r, c, grid):\n        R, C = (len(grid), len(grid[0]))\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n...",
          "full_code": "def transform(grid):\n\n    def is_isolated(r, c, grid):\n        R, C = (len(grid), len(grid[0]))\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = (r + dr, c + dc)\n                if 0 <= nr < R and 0 <= nc < C:\n                    if grid[nr][nc] != 0:\n                        return False\n        return True\n\n    def flood_fill(r, c, grid, visited):\n        R, C = (len(grid), len(grid[0]))\n        stack = [(r, c)]\n        comp = []\n        while stack:\n            i, j = stack.pop()\n            if (i, j) in visited:\n                continue\n            visited.add((i, j))\n            comp.append((i, j, grid[i][j]))\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    if dr == 0 and dc == 0:\n                        continue\n                    nr, nc = (i + dr, j + dc)\n                    if 0 <= nr < R and 0 <= nc < C:\n                        if grid[nr][nc] != 0:\n                            stack.append((nr, nc))\n        return comp\n\n    def extract_pattern(anchor_r, anchor_c, grid):\n        visited = set()\n        comp = flood_fill(anchor_r, anchor_c, grid, visited)\n        pattern = []\n        for i, j, v in comp:\n            dr = i - anchor_r\n            dc = j - anchor_c\n            pattern.append((dr, dc, v))\n        return pattern\n    out = [row[:] for row in grid]\n    R, C = (len(grid), len(grid[0]))\n    templates = {}\n    for color in [2, 3]:\n        found = False\n        for r in range(R):\n            for c in range(C):\n                if grid[r][c] == color and (not is_isolated(r, c, grid)):\n                    templates[color] = extract_pattern(r, c, grid)\n                    found = True\n                    break\n            if found:\n                break\n    for r in range(R):\n        for c in range(C):\n            if grid[r][c] in (2, 3) and is_isolated(r, c, grid):\n                color = grid[r][c]\n                if color not in templates:\n                    continue\n                pattern = templates[color]\n                for dr, dc, val in pattern:\n                    if color == 2:\n                        new_r = r + dr\n                        new_c = c - dc\n                    else:\n                        new_r = r + dr\n                        new_c = c + dc\n                    if 0 <= new_r < R and 0 <= new_c < C:\n                        out[new_r][new_c] = val\n    return out"
        },
        {
          "index": 1,
          "model": "Mistral-Large-Instruct-2407",
          "code_length": 2624,
          "code_preview": "def transform(grid: list[list[int]]) -> list[list[int]]:\n    out = [row[:] for row in grid]\n    rows = len(grid)\n    cols = len(grid[0]) if rows else 0\n\n    def is_isolated(r, c):\n        val = grid[r...",
          "full_code": "def transform(grid: list[list[int]]) -> list[list[int]]:\n    out = [row[:] for row in grid]\n    rows = len(grid)\n    cols = len(grid[0]) if rows else 0\n\n    def is_isolated(r, c):\n        val = grid[r][c]\n        for dr in (-1, 0, 1):\n            for dc in (-1, 0, 1):\n                if dr == 0 and dc == 0:\n                    continue\n                rr = r + dr\n                cc = c + dc\n                if 0 <= rr < rows and 0 <= cc < cols:\n                    if grid[rr][cc] != 0:\n                        return False\n        return True\n    visited = [[False] * cols for _ in range(rows)]\n    exemplar = {}\n    for target in [2, 3]:\n        found = False\n        for r in range(rows):\n            for c in range(cols):\n                if grid[r][c] == target and (not visited[r][c]):\n                    cluster = []\n                    stack = [(r, c)]\n                    visited[r][c] = True\n                    while stack:\n                        rr, cc = stack.pop()\n                        cluster.append((rr, cc))\n                        for dr in (-1, 0, 1):\n                            for dc in (-1, 0, 1):\n                                nr, nc = (rr + dr, cc + dc)\n                                if 0 <= nr < rows and 0 <= nc < cols:\n                                    if not visited[nr][nc] and grid[nr][nc] != 0:\n                                        visited[nr][nc] = True\n                                        stack.append((nr, nc))\n                    if len(cluster) > 1:\n                        center_r, center_c = (r, c)\n                        offs = []\n                        for rr, cc in cluster:\n                            if (rr, cc) != (center_r, center_c):\n                                offs.append((rr - center_r, cc - center_c, grid[rr][cc]))\n                        exemplar[target] = offs\n                        found = True\n                        break\n            if found:\n                break\n    for r in range(rows):\n        for c in range(cols):\n            val = grid[r][c]\n            if val in (2, 3):\n                if is_isolated(r, c):\n                    if val in exemplar:\n                        offs = exemplar[val]\n                        if val == 2:\n                            new_offs = [(dr, -dc, col) for dr, dc, col in offs]\n                        else:\n                            new_offs = offs\n                        for dr, dc, color in new_offs:\n                            nr, nc = (r + dr, c + dc)\n                            if 0 <= nr < rows and 0 <= nc < cols:\n                                out[nr][nc] = color\n    return out"
        },
        {
          "index": 2,
          "model": "Mistral-Large-Instruct-2407",
          "code_length": 3233,
          "code_preview": "def transform(grid: list[list[int]]) -> list[list[int]]:\n    out = [row[:] for row in grid]\n    nrows = len(grid)\n    ncols = len(grid[0]) if nrows else 0\n\n    def is_solitary(r, c):\n        val = gri...",
          "full_code": "def transform(grid: list[list[int]]) -> list[list[int]]:\n    out = [row[:] for row in grid]\n    nrows = len(grid)\n    ncols = len(grid[0]) if nrows else 0\n\n    def is_solitary(r, c):\n        val = grid[r][c]\n        if val == 0:\n            return False\n        for dr in (-1, 0, 1):\n            for dc in (-1, 0, 1):\n                if dr == 0 and dc == 0:\n                    continue\n                rr = r + dr\n                cc = c + dc\n                if 0 <= rr < nrows and 0 <= cc < ncols:\n                    if grid[rr][cc] != 0:\n                        return False\n        return True\n    visited = [[False] * ncols for _ in range(nrows)]\n    ref = {}\n\n    def dfs(r, c, comp):\n        stack = [(r, c)]\n        visited[r][c] = True\n        while stack:\n            rr, cc = stack.pop()\n            comp.append((rr, cc))\n            for dr in (-1, 0, 1):\n                for dc in (-1, 0, 1):\n                    nr, nc = (rr + dr, cc + dc)\n                    if 0 <= nr < nrows and 0 <= nc < ncols:\n                        if not visited[nr][nc] and grid[nr][nc] != 0:\n                            visited[nr][nc] = True\n                            stack.append((nr, nc))\n    for i in range(nrows):\n        for j in range(ncols):\n            if grid[i][j] != 0 and (not visited[i][j]):\n                comp = []\n                dfs(i, j, comp)\n                min_r = min((x for x, y in comp))\n                max_r = max((x for x, y in comp))\n                min_c = min((y for x, y in comp))\n                max_c = max((y for x, y in comp))\n                h = max_r - min_r + 1\n                w = max_c - min_c + 1\n                pattern = [[0] * w for _ in range(h)]\n                for x, y in comp:\n                    pattern[x - min_r][y - min_c] = grid[x][y]\n                for x, y in comp:\n                    col = grid[x][y]\n                    if col == 0:\n                        continue\n                    if not is_solitary(x, y):\n                        if col not in ref:\n                            anchor_r = x - min_r\n                            anchor_c = y - min_c\n                            ref[col] = (pattern, anchor_r, anchor_c, h, w)\n\n    def mirror_horiz(pat):\n        return [list(reversed(row)) for row in pat]\n    for i in range(nrows):\n        for j in range(ncols):\n            if grid[i][j] != 0 and is_solitary(i, j):\n                col = grid[i][j]\n                if col in ref:\n                    pat, anch_r, anch_c, ph, pw = ref[col]\n                    if col == 2:\n                        pat_to_use = mirror_horiz(pat)\n                        anch_c_new = pw - 1 - anch_c\n                        anch_r_new = anch_r\n                    else:\n                        pat_to_use = pat\n                        anch_r_new = anch_r\n                        anch_c_new = anch_c\n                    top = i - anch_r_new\n                    left = j - anch_c_new\n                    for r in range(ph):\n                        for c in range(pw):\n                            rr = top + r\n                            cc = left + c\n                            if 0 <= rr < nrows and 0 <= cc < ncols:\n                                out[rr][cc] = pat_to_use[r][c]\n    return out"
        }
      ]
    },
    "cluster_1": {
      "stats": {
        "size": 1,
        "avg_distance_to_center": 0.0,
        "max_distance_to_center": 0.0,
        "models": [
          "Mistral-Large-Instruct-2407"
        ],
        "avg_code_length": 3301.0
      },
      "programs": [
        {
          "index": 0,
          "model": "Mistral-Large-Instruct-2407",
          "code_length": 3301,
          "code_preview": "import copy\n\ndef transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    R = len(grid_lst)\n    C = len(grid_lst[0]) if R else 0\n    out = copy.deepcopy(grid_lst)\n\n    def is_solitary(r, c):\n     ...",
          "full_code": "import copy\n\ndef transform(grid_lst: list[list[int]]) -> list[list[int]]:\n    R = len(grid_lst)\n    C = len(grid_lst[0]) if R else 0\n    out = copy.deepcopy(grid_lst)\n\n    def is_solitary(r, c):\n        val = grid_lst[r][c]\n        for dr in (-1, 0, 1):\n            for dc in (-1, 0, 1):\n                if dr == 0 and dc == 0:\n                    continue\n                rr = r + dr\n                cc = c + dc\n                if 0 <= rr < R and 0 <= cc < C:\n                    if grid_lst[rr][cc] != 0:\n                        return False\n        return True\n    visited = [[False] * C for _ in range(R)]\n    ref = {}\n\n    def dfs(r, c, comp):\n        stack = [(r, c)]\n        visited[r][c] = True\n        comp.append((r, c))\n        while stack:\n            rr, cc = stack.pop()\n            for dr in (-1, 0, 1):\n                for dc in (-1, 0, 1):\n                    nr, nc = (rr + dr, cc + dc)\n                    if 0 <= nr < R and 0 <= nc < C:\n                        if not visited[nr][nc] and grid_lst[nr][nc] != 0:\n                            visited[nr][nc] = True\n                            comp.append((nr, nc))\n                            stack.append((nr, nc))\n    for i in range(R):\n        for j in range(C):\n            if grid_lst[i][j] != 0 and (not visited[i][j]):\n                comp = []\n                dfs(i, j, comp)\n                min_r = min((x for x, y in comp))\n                max_r = max((x for x, y in comp))\n                min_c = min((y for x, y in comp))\n                max_c = max((y for x, y in comp))\n                h = max_r - min_r + 1\n                w = max_c - min_c + 1\n                pattern = [[0] * w for _ in range(h)]\n                for r in range(min_r, max_r + 1):\n                    for c in range(min_c, max_c + 1):\n                        pattern[r - min_r][c - min_c] = grid_lst[r][c]\n                for r, c in comp:\n                    col = grid_lst[r][c]\n                    if col == 0:\n                        continue\n                    if not is_solitary(r, c):\n                        if col not in ref:\n                            anchor_r = r - min_r\n                            anchor_c = c - min_c\n                            ref[col] = (pattern, anchor_r, anchor_c, h, w)\n\n    def mirror_horiz(pat):\n        return [list(reversed(row)) for row in pat]\n    for i in range(R):\n        for j in range(C):\n            if grid_lst[i][j] != 0 and is_solitary(i, j):\n                col = grid_lst[i][j]\n                if col in ref:\n                    pat, anch_r, anch_c, ph, pw = ref[col]\n                    if col == 2:\n                        pat_to_use = mirror_horiz(pat)\n                        anch_c_new = pw - 1 - anch_c\n                        anch_r_new = anch_r\n                    else:\n                        pat_to_use = pat\n                        anch_r_new = anch_r\n                        anch_c_new = anch_c\n                    top = i - anch_r_new\n                    left = j - anch_c_new\n                    for r in range(ph):\n                        for c in range(pw):\n                            rr = top + r\n                            cc = left + c\n                            if 0 <= rr < R and 0 <= cc < C:\n                                out[rr][cc] = pat_to_use[r][c]\n    return out"
        }
      ]
    }
  }
}