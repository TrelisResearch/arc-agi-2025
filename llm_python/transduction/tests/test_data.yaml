# Test cases for both classifiers - simplified structure
# Programs both classifiers agree are transductive (5 cases)
- task_id: "505fff84"
  code: |
    import numpy as np
    
    def transform(grid_lst: list[list[int]]) -> list[list[int]]:
        grid = np.array(grid_lst)
        rows, cols = grid.shape
        if rows == 14 and cols == 11:
            output_shape = (5, 5)
        elif rows == 4 and cols == 11:
            output_shape = (1, 7)
        elif rows == 5 and cols == 10:
            output_shape = (2, 3)
        elif rows == 6 and cols == 12:
            output_shape = (3, 4)
        elif rows == 8 and cols == 12:
            output_shape = (3, 6)
        elif rows == 9 and cols == 14:
            output_shape = (5, 5)
        else:
            raise ValueError('Unsupported grid shape')
        output_grid = np.zeros(output_shape, dtype=int)
        if rows == 14 and cols == 11:
            output_grid[0, :] = [2, 2, 2, 0, 0]
            output_grid[1, :] = [2, 2, 0, 0, 2]
            output_grid[2, :] = [2, 0, 0, 0, 2]
            output_grid[3, :] = [2, 2, 2, 0, 2]
            output_grid[4, :] = [2, 2, 2, 2, 2]
        elif rows == 4 and cols == 11:
            output_grid[0, :] = [0, 2, 0, 0, 0, 0, 2]
        elif rows == 5 and cols == 10:
            output_grid[0, :] = [0, 2, 0]
            output_grid[1, :] = [2, 0, 0]
        elif rows == 6 and cols == 12:
            output_grid[0, :] = [2, 0, 2, 0]
            output_grid[1, :] = [2, 2, 2, 2]
            output_grid[2, :] = [0, 2, 2, 2]
        elif rows == 8 and cols == 12:
            output_grid[0, :] = [2, 0, 2, 0, 0, 0]
            output_grid[1, :] = [2, 0, 2, 0, 2, 0]
            output_grid[2, :] = [0, 2, 2, 0, 2, 2]
        elif rows == 9 and cols == 14:
            output_grid[0, :] = [0, 2, 0, 2, 2]
            output_grid[1, :] = [0, 2, 2, 0, 2]
            output_grid[2, :] = [0, 0, 0, 0, 0]
            output_grid[3, :] = [2, 2, 0, 0, 0]
            output_grid[4, :] = [0, 0, 2, 0, 0]
        return output_grid.tolist()
  transductive: true

- task_id: "137eaa0f"
  code: |
    def transform(grid_lst: list[list[int]]) -> list[list[int]]:
        output_grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
        grid = [row[:] for row in grid_lst]
        sequence = []
        for col in range(11):
            if grid[2][col] != 0:
                sequence.append(grid[2][col])
            if grid[4][col] != 0:
                sequence.append(grid[4][col])
            if grid[6][col] != 0:
                sequence.append(grid[6][col])
        if len(sequence) < 9:
            sequence += [0] * (9 - len(sequence))
        sequence_index = 0
        for row in range(3):
            for col in range(3):
                output_grid[row][col] = sequence[sequence_index]
                sequence_index += 1
        if grid[1][8] == 9:
            output_grid[0][0] = 6
            output_grid[0][1] = 2
            output_grid[0][2] = 2
            output_grid[1][0] = 7
            output_grid[1][1] = 5
            output_grid[1][2] = 7
            output_grid[2][0] = 3
            output_grid[2][1] = 3
            output_grid[2][2] = 3
        elif grid[3][0] == 4:
            output_grid[0][0] = 6
            output_grid[0][1] = 6
            output_grid[0][2] = 7
            output_grid[1][0] = 0
            output_grid[1][1] = 5
            output_grid[1][2] = 7
            output_grid[2][0] = 4
            output_grid[2][1] = 4
            output_grid[2][2] = 0
        elif grid[4][5] == 5:
            output_grid[0][0] = 0
            output_grid[0][1] = 1
            output_grid[0][2] = 1
            output_grid[1][0] = 1
            output_grid[1][1] = 5
            output_grid[1][2] = 2
            output_grid[2][0] = 9
            output_grid[2][1] = 9
            output_grid[2][2] = 2
        return output_grid
  transductive: true

- task_id: "aee291af"
  code: |
    def transform(grid_lst: list[list[int]]) -> list[list[int]]:
        import numpy as np
        grid = np.array(grid_lst)
        rows, cols = grid.shape
        if rows == 16 and cols == 16:
            output_size = 4
            output_grid = np.full((output_size, output_size), 8)
            output_grid[1, 1] = 2
            output_grid[1, 2] = 2
            output_grid[2, 2] = 2
        elif rows == 18 and cols == 18:
            output_size = 5
            output_grid = np.full((output_size, output_size), 8)
            output_grid[1, 2] = 2
            output_grid[1, 3] = 2
            output_grid[2, 2] = 2
            output_grid[2, 3] = 2
            output_grid[3, 1] = 2
        elif rows == 20 and cols == 20:
            output_size = 5
            output_grid = np.full((output_size, output_size), 8)
            output_grid[1, 2] = 2
            output_grid[1, 3] = 2
            output_grid[2, 2] = 2
            output_grid[2, 3] = 2
            output_grid[3, 1] = 2
        else:
            raise ValueError('Unsupported grid size')
        return output_grid.tolist()
  transductive: true

- task_id: "b0c4d837"
  code: |
    def transform(grid_lst: list[list[int]]) -> list[list[int]]:
        purple_color = 5
        grey_color = 8
        output_grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
        has_purple = any((purple_color in row for row in grid_lst))
        if has_purple:
            output_grid[0][0] = grey_color
        if len(grid_lst) >= 7:
            output_grid[0][1] = grey_color
        if len(grid_lst) >= 9:
            output_grid[0][2] = grey_color
        if len(grid_lst) >= 5:
            output_grid[1][2] = grey_color
        return output_grid
  transductive: true

- task_id: "50a16a69"
  code: |
    def transform(grid: list[list[int]]) -> list[list[int]]:
        n = len(grid)
        if n == 6:
            pattern = [8, 6]
        elif n == 8:
            pattern = [2, 5]
        elif n == 9:
            pattern = [6, 3, 7]
        elif n == 20:
            pattern = [3, 5, 7, 6]
        else:
            pattern = list(range(1, n))
        output_grid = []
        for i in range(n):
            row = []
            for j in range(n):
                row.append(pattern[(i + j) % len(pattern)])
            output_grid.append(row)
        return output_grid
  transductive: true

# Programs both classifiers agree are NOT transductive (5 cases)
- task_id: "d56f2372"
  code: |
    import numpy as np
    
    def transform(grid_lst: list[list[int]]) -> list[list[int]]:
        grid = np.array(grid_lst)
        rows, cols = grid.shape
        target_colors = [8, 6, 2, 1, 4, 3, 7]
        color_counts = {color: np.sum(grid == color) for color in target_colors}
        most_frequent_color = max(color_counts, key=color_counts.get)
        coords = np.argwhere(grid == most_frequent_color)
        top, left = np.min(coords, axis=0)
        bottom, right = np.max(coords, axis=0)
        subgrid = grid[top:bottom + 1, left:right + 1]
        return subgrid.tolist()
  transductive: false

- task_id: "27f8ce4f"
  code: |
    import numpy as np
    
    def transform(grid_lst: list[list[int]]) -> list[list[int]]:
        grid = np.array(grid_lst)
        flattened = grid.flatten()
        non_zero_values = flattened[flattened != 0]
        if len(non_zero_values) == 0:
            return grid.tolist()
        most_frequent_value = np.bincount(non_zero_values).argmax()
        output = np.zeros([9, 9], dtype=int)
        for i in range(3):
            for j in range(3):
                if grid[i, j] == most_frequent_value:
                    output[i * 3:(i + 1) * 3, j * 3:(j + 1) * 3] = grid
        return output.tolist()
  transductive: false

- task_id: "bf89d739"
  code: |
    import numpy as np
    
    def transform(grid_lst: list[list[int]]) -> list[list[int]]:
        grid = np.array(grid_lst)
        rows, cols = grid.shape
        for row_idx in range(rows):
            non_zero_indices = np.where(grid[row_idx] != 0)[0]
            for i in range(len(non_zero_indices) - 1):
                start_idx = non_zero_indices[i] + 1
                end_idx = non_zero_indices[i + 1] - 1
                if start_idx <= end_idx:
                    grid[row_idx, start_idx:end_idx + 1] = 3
        for col_idx in range(cols):
            non_zero_indices = np.where(grid[:, col_idx] != 0)[0]
            for i in range(len(non_zero_indices) - 1):
                start_idx = non_zero_indices[i] + 1
                end_idx = non_zero_indices[i + 1] - 1
                if start_idx <= end_idx:
                    grid[start_idx:end_idx + 1, col_idx] = 3
        return grid.tolist()
  transductive: false

- task_id: "1f85a75f"
  code: |
    import numpy as np
    
    def transform(grid_lst: list[list[int]]) -> list[list[int]]:
        grid = np.array(grid_lst)
        green_color = 3
        yellow_color = 4
        red_color = 2
        blue_color = 1
        grey_color = 5
    
        def find_bounding_box(color):
            rows, cols = np.where(grid == color)
            if len(rows) == 0:
                return None
            min_row, max_row = (min(rows), max(rows))
            min_col, max_col = (min(cols), max(cols))
            return (min_row, max_row, min_col, max_col)
    
        def extract_subgrid(min_row, max_row, min_col, max_col):
            return grid[min_row:max_row + 1, min_col:max_col + 1]
    
        def process_subgrid(subgrid):
            green_positions = np.argwhere(subgrid == green_color)
            for pos in green_positions:
                x, y = pos
                if x > 0 and subgrid[x - 1, y] == 0:
                    subgrid[x - 1, y] = yellow_color
                if x < subgrid.shape[0] - 1 and subgrid[x + 1, y] == 0:
                    subgrid[x + 1, y] = yellow_color
                if y > 0 and subgrid[x, y - 1] == 0:
                    subgrid[x, y - 1] = yellow_color
                if y < subgrid.shape[1] - 1 and subgrid[x, y + 1] == 0:
                    subgrid[x, y + 1] = yellow_color
            return subgrid
        red_bounding_box = find_bounding_box(red_color)
        blue_bounding_box = find_bounding_box(blue_color)
        grey_bounding_box = find_bounding_box(grey_color)
        if red_bounding_box:
            subgrid = extract_subgrid(*red_bounding_box)
            processed_subgrid = process_subgrid(subgrid)
            return processed_subgrid.tolist()
        elif blue_bounding_box:
            subgrid = extract_subgrid(*blue_bounding_box)
            processed_subgrid = process_subgrid(subgrid)
            return processed_subgrid.tolist()
        elif grey_bounding_box:
            subgrid = extract_subgrid(*grey_bounding_box)
            processed_subgrid = process_subgrid(subgrid)
            return processed_subgrid.tolist()
        else:
            return grid_lst
  transductive: false

- task_id: "85c4e7cd"
  code: |
    def transform(grid_lst: list[list[int]]) -> list[list[int]]:
        rows, cols = (len(grid_lst), len(grid_lst[0]))
        new_grid = [[0] * cols for _ in range(rows)]
        color_map = {4: 8, 2: 5, 1: 3, 3: 1, 5: 2, 8: 4, 6: 2, 7: 1}
        for r in range(rows):
            for c in range(cols):
                if r == 0 or r == rows - 1 or c == 0 or (c == cols - 1):
                    new_grid[r][c] = 8
                else:
                    new_grid[r][c] = color_map.get(grid_lst[r][c], grid_lst[r][c])
        return new_grid
  transductive: false
