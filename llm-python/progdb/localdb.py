import duckdb
import uuid
import json
from pathlib import Path
from typing import List, Dict, Any, Optional
from .schema import TrainingExample

class ProgramDatabase:
    """Persistent DuckDB instance for storing training examples/programs"""
    
    def __init__(self, db_path: str = "programs.duckdb"):
        """Initialize the database connection and create tables if needed
        
        Args:
            db_path: Path to the DuckDB database file
        """
        self.db_path = Path(db_path)
        self.conn = duckdb.connect(str(self.db_path))
        self._create_tables()
    
    def _create_tables(self):
        """Create the programs table if it doesn't exist"""
        create_table_sql = """
        CREATE TABLE IF NOT EXISTS programs (
            id VARCHAR PRIMARY KEY DEFAULT (uuid()),
            code TEXT NOT NULL,
            reasoning TEXT,
            model VARCHAR,
            task_id VARCHAR,
            train_correct_fraction DOUBLE,
            test_correct_fraction DOUBLE,
            sample_inputs JSON,
            sample_outputs JSON,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
        """
        self.conn.execute(create_table_sql)
        self.conn.commit()
    
    def insert_program(self, program: TrainingExample, program_id: Optional[str] = None) -> str:
        """Insert a training example/program into the database
        
        Args:
            program: TrainingExample dict following the schema
            program_id: Optional custom ID, otherwise auto-generated
            
        Returns:
            The ID of the inserted program
        """
        if program_id is None:
            program_id = str(uuid.uuid4())
        
        insert_sql = """
        INSERT INTO programs (
            id, code, reasoning, model, task_id, 
            train_correct_fraction, test_correct_fraction,
            sample_inputs, sample_outputs
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        """
        
        self.conn.execute(insert_sql, [
            program_id,
            program['code'],
            program.get('reasoning'),
            program.get('model'),
            program.get('task_id'),
            program.get('train_correct_fraction'),
            program.get('test_correct_fraction'),
            json.dumps(program.get('sample_inputs', [])),
            json.dumps(program.get('sample_outputs', []))
        ])
        self.conn.commit()
        return program_id
    
    def get_program(self, program_id: str) -> Optional[Dict[str, Any]]:
        """Retrieve a program by ID
        
        Args:
            program_id: The ID of the program to retrieve
            
        Returns:
            Program data as dict or None if not found
        """
        result = self.conn.execute(
            "SELECT * FROM programs WHERE id = ?", [program_id]
        ).fetchone()
        
        if result is None:
            return None
        
        columns = [desc[0] for desc in self.conn.description]
        program_dict = dict(zip(columns, result))
        
        # Parse JSON fields back to lists
        if program_dict['sample_inputs']:
            program_dict['sample_inputs'] = json.loads(program_dict['sample_inputs'])
        if program_dict['sample_outputs']:
            program_dict['sample_outputs'] = json.loads(program_dict['sample_outputs'])
            
        return program_dict
    
    def get_programs_by_task(self, task_id: str) -> List[Dict[str, Any]]:
        """Get all programs for a specific task ID
        
        Args:
            task_id: The task ID to filter by
            
        Returns:
            List of program dicts
        """
        results = self.conn.execute(
            "SELECT * FROM programs WHERE task_id = ? ORDER BY created_at DESC", 
            [task_id]
        ).fetchall()
        
        columns = [desc[0] for desc in self.conn.description]
        programs = []
        
        for result in results:
            program_dict = dict(zip(columns, result))
            # Parse JSON fields back to lists
            if program_dict['sample_inputs']:
                program_dict['sample_inputs'] = json.loads(program_dict['sample_inputs'])
            if program_dict['sample_outputs']:
                program_dict['sample_outputs'] = json.loads(program_dict['sample_outputs'])
            programs.append(program_dict)
            
        return programs
    
    def get_programs_by_model(self, model: str) -> List[Dict[str, Any]]:
        """Get all programs generated by a specific model
        
        Args:
            model: The model name to filter by
            
        Returns:
            List of program dicts
        """
        results = self.conn.execute(
            "SELECT * FROM programs WHERE model = ? ORDER BY created_at DESC", 
            [model]
        ).fetchall()
        
        columns = [desc[0] for desc in self.conn.description]
        programs = []
        
        for result in results:
            program_dict = dict(zip(columns, result))
            # Parse JSON fields back to lists
            if program_dict['sample_inputs']:
                program_dict['sample_inputs'] = json.loads(program_dict['sample_inputs'])
            if program_dict['sample_outputs']:
                program_dict['sample_outputs'] = json.loads(program_dict['sample_outputs'])
            programs.append(program_dict)
            
        return programs
    
    def count_programs(self) -> int:
        """Get total count of programs in the database"""
        result = self.conn.execute("SELECT COUNT(*) FROM programs").fetchone()
        return result[0] if result else 0
    
    def get_task_stats(self) -> List[Dict[str, Any]]:
        """Get statistics grouped by task_id"""
        results = self.conn.execute("""
            SELECT 
                task_id,
                COUNT(*) as program_count,
                AVG(train_correct_fraction) as avg_train_accuracy,
                AVG(test_correct_fraction) as avg_test_accuracy,
                MAX(train_correct_fraction) as max_train_accuracy,
                MAX(test_correct_fraction) as max_test_accuracy
            FROM programs 
            WHERE task_id IS NOT NULL
            GROUP BY task_id
            ORDER BY program_count DESC
        """).fetchall()
        
        columns = [desc[0] for desc in self.conn.description]
        return [dict(zip(columns, result)) for result in results]
    
    def close(self):
        """Close the database connection"""
        if self.conn:
            self.conn.close()
    
    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()


# Convenience function to get a database instance
def get_database(db_path: str = "programs.duckdb") -> ProgramDatabase:
    """Get a ProgramDatabase instance
    
    Args:
        db_path: Path to the DuckDB database file
        
    Returns:
        ProgramDatabase instance
    """
    return ProgramDatabase(db_path)
