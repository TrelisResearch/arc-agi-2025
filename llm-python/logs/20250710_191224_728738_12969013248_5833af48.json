{
  "task_id": "5833af48",
  "model": "gpt-4.1",
  "reasoning_effort": "N/A",
  "api_type": "responses_api_multiturn",
  "program": "def transform(grid):\n    import numpy as np\n    \n    arr = np.array(grid)\n    H, W = arr.shape\n    \n    # Get the bottom half (assume the big block is lower\u2019s main color)\n    # We'll try to skip zero (black) and count the dominant color\n    values, counts = np.unique(arr[arr != 0], return_counts=True)\n    main_color = values[np.argmax(counts)]\n    \n    # Find secondary color from upper area (ignore main color, zeros; take top 6 rows, right half)\n    upper = arr[:6, :]\n    candidates = upper[(upper != 0) & (upper != main_color)]\n    if len(candidates) == 0:\n        # fallback: just pick any other nonzero color\n        candidates = arr[(arr != 0) & (arr != main_color)]\n    if len(candidates) == 0:\n        cross_color = main_color  # fallback\n    else:\n        vals, cts = np.unique(candidates, return_counts=True)\n        cross_color = vals[np.argmax(cts)]\n    \n    # Make 8x16 filled with main color\n    out = np.full((8, 16), main_color, dtype=int)\n    \n    # Place crosses at these four corners (from outputs):\n    positions = [\n        (1, 1),   # top left\n        (1, 14),  # top right\n        (6, 1),   # bottom left\n        (6, 14),  # bottom right\n    ]\n    \n    # In output3, center cross at (3,7). Let's add this as center for all.\n    positions.append((3, 7))\n    \n    # Draw cross centered at (r, c)\n    def draw_cross(mat, r, c, color):\n        if 0 <= r < 8 and 0 <= c < 16:\n            mat[r, c] = color\n        if r-1 >= 0:\n            mat[r-1, c] = color\n        if r+1 < 8:\n            mat[r+1, c] = color\n        if c-1 >= 0:\n            mat[r, c-1] = color\n        if c+1 < 16:\n            mat[r, c+1] = color\n    \n    for r, c in positions:\n        draw_cross(out, r, c, cross_color)\n    \n    return out.tolist()",
  "execution_error": "Max turns reached",
  "timed_out": false,
  "tokens_used": 6348,
  "request_cost": 0.019044,
  "turns_used": 1,
  "raw_response": {
    "id": "resp_6870025b774481a28ccb7b7b727672ce0850d8ab1abf7290",
    "model": "gpt-4.1-2025-04-14",
    "usage": {
      "input_tokens": 5290,
      "output_tokens": 1058,
      "total_tokens": 6348
    },
    "output": [
      {
        "type": "message",
        "content": [
          "Let's analyze the transformation step by step:\n\n### Observations\n\n1. **Output Size**\n   - Every output is always **8\u00d716**, regardless of the input's size.\n\n2. **Background Color**\n   - The main color in the big block region (bottom in input) becomes the background color in the output.\n\n3. **Blue Crosses**\n   - There are light blue crosses in fixed positions in the output:\n     - Top left, top right, bottom left, bottom right, and roughly center, but with some shift for odd-sized blocks.\n   - These \"crosses\" are sized 3x3, with the pattern:\n     ```\n     0 x 0\n     x x x\n     0 x 0\n     ```\n     where x = secondary color (light blue)\n\n4. **Positions**\n   - The crosses are placed inside the output, not touching the border: offsets ~[1,1], [1,14], [6,1], [6,14], etc.\n\n5. **Secondary Color**\n   - The color for the cross is taken from the \"small secondary region\" (cyan in most cases, but matching the 2nd block).\n   - Take the color appearing in the small upper rectangle in the top right of the input (not the main big block).\n\n6. **Grid Construction**\n   - The output grid is filled with the main big block's color.\n   - Crosses are overlaid at the fixed positions.\n\n### Hypothesis\n\nAlgorithm steps:\n- Find the color that dominates the big block (use bottom half or biggest nonzero area).\n- Find the color in the \"secondary\" (usually a smaller area in the upper right, just above big block).\n- Fill an 8x16 matrix with the main color.\n- Overlay 3x3 \"crosses\" of the secondary color at several canonical positions.\n\n### Implementation Steps\n\n- For color detection: ignore zeros (black).\n- For the largest block, pick the most frequent nonzero color in the lower part.\n- For the secondary color, find the most frequent nonzero color in the upper-right small region.\n\n### Crosses' positions\nBased on outputs:\n- Row offsets: [1, 1, 6, 6]\n- Col offsets: [1, 14, 1, 14]\n\n### Final Algorithm\n- Main color: most frequent nonzero in lower part (big block)\n- Cross color: most frequent nonzero in upper-right area (besides main color)\n- Output: 8x16 of main color, overlay 3x3 crosses of cross color at set positions\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n    \n    arr = np.array(grid)\n    H, W = arr.shape\n    \n    # Get the bottom half (assume the big block is lower\u2019s main color)\n    # We'll try to skip zero (black) and count the dominant color\n    values, counts = np.unique(arr[arr != 0], return_counts=True)\n    main_color = values[np.argmax(counts)]\n    \n    # Find secondary color from upper area (ignore main color, zeros; take top 6 rows, right half)\n    upper = arr[:6, :]\n    candidates = upper[(upper != 0) & (upper != main_color)]\n    if len(candidates) == 0:\n        # fallback: just pick any other nonzero color\n        candidates = arr[(arr != 0) & (arr != main_color)]\n    if len(candidates) == 0:\n        cross_color = main_color  # fallback\n    else:\n        vals, cts = np.unique(candidates, return_counts=True)\n        cross_color = vals[np.argmax(cts)]\n    \n    # Make 8x16 filled with main color\n    out = np.full((8, 16), main_color, dtype=int)\n    \n    # Place crosses at these four corners (from outputs):\n    positions = [\n        (1, 1),   # top left\n        (1, 14),  # top right\n        (6, 1),   # bottom left\n        (6, 14),  # bottom right\n    ]\n    \n    # In output3, center cross at (3,7). Let's add this as center for all.\n    positions.append((3, 7))\n    \n    # Draw cross centered at (r, c)\n    def draw_cross(mat, r, c, color):\n        if 0 <= r < 8 and 0 <= c < 16:\n            mat[r, c] = color\n        if r-1 >= 0:\n            mat[r-1, c] = color\n        if r+1 < 8:\n            mat[r+1, c] = color\n        if c-1 >= 0:\n            mat[r, c-1] = color\n        if c+1 < 16:\n            mat[r, c+1] = color\n    \n    for r, c in positions:\n        draw_cross(out, r, c, cross_color)\n    \n    return out.tolist()\n```\n"
        ]
      }
    ]
  },
  "score": {
    "correct": false,
    "pixel_accuracy": 0.0,
    "total_pixels": 288,
    "correct_pixels": 0,
    "error": "Max turns reached"
  },
  "actual_output": [
    [
      1,
      1,
      1,
      1,
      1,
      8,
      1,
      8,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      8,
      1,
      8,
      1,
      1,
      1,
      1
    ],
    [
      1,
      1,
      1,
      1,
      8,
      8,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      8,
      8,
      1,
      1,
      1,
      1,
      1,
      1
    ],
    [
      1,
      1,
      1,
      1,
      1,
      1,
      8,
      8,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      8,
      8,
      1,
      1,
      1,
      1
    ],
    [
      1,
      1,
      1,
      1,
      8,
      1,
      8,
      8,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      8,
      1,
      8,
      8,
      1,
      1,
      1,
      1
    ],
    [
      1,
      8,
      1,
      8,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      8,
      1,
      8
    ],
    [
      8,
      8,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      8,
      8,
      1,
      1
    ],
    [
      1,
      1,
      8,
      8,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      8,
      8
    ],
    [
      8,
      1,
      8,
      8,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      8,
      1,
      8,
      8
    ],
    [
      1,
      1,
      1,
      1,
      1,
      8,
      1,
      8,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      8,
      1,
      8,
      1,
      1,
      1,
      1
    ],
    [
      1,
      1,
      1,
      1,
      8,
      8,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      8,
      8,
      1,
      1,
      1,
      1,
      1,
      1
    ],
    [
      1,
      1,
      1,
      1,
      1,
      1,
      8,
      8,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      8,
      8,
      1,
      1,
      1,
      1
    ],
    [
      1,
      1,
      1,
      1,
      8,
      1,
      8,
      8,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      8,
      1,
      8,
      8,
      1,
      1,
      1,
      1
    ]
  ],
  "api_success": true,
  "multiturn_data": {
    "turn_details": [
      {
        "turn_number": 1,
        "timestamp": "2025-07-10T19:11:39.346547",
        "input_tokens": 5290,
        "output_tokens": 1058,
        "turn_cost": 0.019044,
        "program_extracted": true,
        "program": "def transform(grid):\n    import numpy as np\n    \n    arr = np.array(grid)\n    H, W = arr.shape\n    \n    # Get the bottom half (assume the big block is lower\u2019s main color)\n    # We'll try to skip zero (black) and count the dominant color\n    values, counts = np.unique(arr[arr != 0], return_counts=True)\n    main_color = values[np.argmax(counts)]\n    \n    # Find secondary color from upper area (ignore main color, zeros; take top 6 rows, right half)\n    upper = arr[:6, :]\n    candidates = upper[(upper != 0) & (upper != main_color)]\n    if len(candidates) == 0:\n        # fallback: just pick any other nonzero color\n        candidates = arr[(arr != 0) & (arr != main_color)]\n    if len(candidates) == 0:\n        cross_color = main_color  # fallback\n    else:\n        vals, cts = np.unique(candidates, return_counts=True)\n        cross_color = vals[np.argmax(cts)]\n    \n    # Make 8x16 filled with main color\n    out = np.full((8, 16), main_color, dtype=int)\n    \n    # Place crosses at these four corners (from outputs):\n    positions = [\n        (1, 1),   # top left\n        (1, 14),  # top right\n        (6, 1),   # bottom left\n        (6, 14),  # bottom right\n    ]\n    \n    # In output3, center cross at (3,7). Let's add this as center for all.\n    positions.append((3, 7))\n    \n    # Draw cross centered at (r, c)\n    def draw_cross(mat, r, c, color):\n        if 0 <= r < 8 and 0 <= c < 16:\n            mat[r, c] = color\n        if r-1 >= 0:\n            mat[r-1, c] = color\n        if r+1 < 8:\n            mat[r+1, c] = color\n        if c-1 >= 0:\n            mat[r, c-1] = color\n        if c+1 < 16:\n            mat[r, c+1] = color\n    \n    for r, c in positions:\n        draw_cross(out, r, c, cross_color)\n    \n    return out.tolist()",
        "training_feedback": {
          "feedback_messages": [
            {
              "type": "input_text",
              "text": "Training results: 0/3 examples solved, 54.2% pixel accuracy - Good partial progress! Your approach is capturing some patterns. Next, try to identify a transformation that solves at least one of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 8, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 8, 8, 8, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1], [8, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 8, 1, 1], [1, 8, 8, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 8, 8], [1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1]]\nYour output: [[1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1], [8, 8, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 8, 8], [1, 8, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 8, 1], [1, 1, 1, 1, 1, 1, 8, 8, 8, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1], [1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1], [8, 8, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 8, 8], [1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1]]\nPixel accuracy: 76.6%\n\nTraining Example 2 \u2717:\nExpected: [[3, 3, 3, 3, 3, 3, 3, 8, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 8, 8, 8, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 8, 3, 3, 3, 3, 3, 3, 3], [3, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8, 3], [8, 8, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8, 8, 8], [3, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8, 3], [3, 3, 3, 3, 3, 3, 3, 8, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 8, 8, 8, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 8, 3, 3, 3, 3, 3, 3, 3]]\nYour output: [[3, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8, 3], [8, 8, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8, 8, 8], [3, 8, 3, 3, 3, 3, 3, 8, 3, 3, 3, 3, 3, 3, 8, 3], [3, 3, 3, 3, 3, 3, 8, 8, 8, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 8, 3, 3, 3, 3, 3, 3, 3, 3], [3, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8, 3], [8, 8, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8, 8, 8], [3, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8, 3]]\nPixel accuracy: 60.7%\n\nTraining Example 3 \u2717:\nExpected: [[4, 4, 4, 4, 8, 4, 4, 4, 4], [4, 4, 4, 8, 4, 4, 4, 4, 4], [4, 4, 4, 8, 8, 8, 4, 4, 4], [4, 8, 4, 4, 4, 4, 4, 8, 4], [8, 4, 4, 4, 4, 4, 8, 4, 4], [8, 8, 8, 4, 4, 4, 8, 8, 8]]\nYour output: [[4, 8, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 8, 4], [8, 8, 8, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 8, 8, 8], [4, 8, 4, 4, 4, 4, 4, 8, 4, 4, 4, 4, 4, 4, 8, 4], [4, 4, 4, 4, 4, 4, 8, 8, 8, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 8, 4, 4, 4, 4, 4, 4, 4, 4], [4, 8, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 8, 4], [8, 8, 8, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 8, 8, 8], [4, 8, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 8, 4]]\nPixel accuracy: 25.0%\n\n\u26a0\ufe0f  GRID SIZE ERROR: One or more of your output grids are incorrect in size. They should ALL be 8\u00d716 for this task.\n\n"
            },
            {
              "type": "input_image",
              "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAwcAAALBCAIAAACC/EoFAAA7XElEQVR4nO3de5RU1b0n8FNIN4I03QKKCI0RkEcWEREfiMjVwKxBEKUEEhMfoYNGdPABgsq9RG8cCMQmmJgY4gQBDfHq1WuBEkR0IhhvwBDloogP5BF5GkQbRKB51axtrelheNn0q7q6P5/lH8Wp8ztnn121d38951RVLJlMRgAAtV6ddDcAAKBakIoAAAKpCAAgkIoAAAKpCAAgkIoAAAKpCAAgkIoAAAKpCAAgkIoAAAKpCAAgkIoAAAKpCACg3Klo+PDhsaO77rrrjrhOdnb2aaedduWVV7711luHb/Pll1+OxWKNGzfevXv3IU89++yzsVhs6tSpqX8OGTIkFosVFhYestr69etjsdjYsWPLU5Wye/fuRx999LLLLjv99NPr1at3+umnDx48+M9//vMx+mTs2LFH65Dly5cfu9N69+79tR1bss6NN9548PJU8wYOHLho0aKD2zNgwIBDVjvzzDNvv/32zz///Lg6P+XTTz8dN25cly5dcnNzTzrppAsuuGDq1KnJZPKQ3R1S/uabb55yyik5OTmvvvrqMboOAGrduaK9e/d+8sknL7zwwmWXXbZ69epDnp02bVoURZ9//vnTTz9dmq3dd99977///vG2oTRVa9euveiii4YNG7ZgwYJNmzbt2bNn06ZNzz77bM+ePSdPnhxVM6nmPffccz169PjDH/5wjNXWrl37q1/9qk+fPgcOHDiuzl+0aFHnzp1//OMf/9d//df27dt37ty5ZMmSm266aejQocdo2J/+9KfLLrts//79r7zyymWXXVaOQwSAapyKfv3rXyf/r2eeeSaKounTp5csmTlzZsmaa9asKVm+e/fu99577/vf//727dunTJly8AaLiopmzZo1ePDgxo0b//a3vy1NG/bs2TNkyJD9+/cfV8u/tmrv3r2DBg36r//6r+7duz///POffvrp3r17P/7449/85jeNGze+++67Uyd+jmbp0qXJw3Tq1OmIHVLilVdeOXgjpVln06ZNqeW7du366KOP7r333mQy+cMf/vDvf//7wavt2rXr4M7v3bv3X//615dffrn0nf+Pf/wjHo9v3Ljxe9/73uLFi7dv3/7ZZ5/NmjWrdevW06dPf/TRR4/YD4lEom/fvg0aNFiwYMGFF154jB4DgNp4rqhevXodOnT42c9+FkXRIeeKnnzyyd27d998880FBQWLFy9+++23v3Zrt9122xtvvPHzn//8uNrwtVWPP/74m2++2bt379dee61///5NmjSpW7dufn7+Lbfc8txzz+3fv//f/u3fourkxBNPbNOmzYQJE+677749e/b84he/OEbn33nnnalEVfrOnzx58ieffDJixIgnn3zywgsvzMnJOfnkk6+66qqFCxeedNJJkydPPvg6Wspjjz02ePDgU0899c9//vPZZ59dsnzGjBmxWOzXv/51hXYAAGRgKiouLn733XdHjhwZRVG7du0Ofmr69OkdO3b89re/fcstt5xwwgmlOV3005/+tG3btvfdd997771X+jZ8bdWTTz4Zi8X+1//6XyeccMIhT/3TP/3TihUrxo0bF1VLd911V4MGDV566aUjPrt3794PP/zw4Ycfrlu37j/90z+VvvP//d//vX79+g888MAhG2zZsuXrr7++YMGCWCx28PIHH3zwxhtvbN269euvv37WWWdV3PEBQIanojPPPLPkht8TTzyxU6dOzzzzTNOmTe+4446SdZYvX/63v/1t9OjRsVisTZs2gwcP/sMf/rBjx45jb7lBgwbTp0/fu3fvcV1H+9qqpUuXduzY8cwzzzxieceOHQ8JAYfo0qXLIXdJv/7660frkBILFiw43nUOl5OTc9ZZZx1yEq5+/fqp8uzs7Pbt2//nf/7n448/fvDRHbvz9+7du3bt2gsuuKBhw4aH7/Gcc85p3rz5wUvuvvvue+65J4qiSy65pFWrVoesP2TIkGQyOXz48GMfCADUik/mt2jR4oc//OGyZctOO+20koXTpk1r0aLFtddem/rnmDFjvvjii9JcqOrRo8ftt9/+17/+ddKkSaVvwzGq9u7dW1RU1KxZs4MXHvK5sG984xtRddWkSZPirxxthf379y9evHjv3r2l7PyioqJkMtmkSZNSNuBXv/rVRRdd1Lt372nTpj333HPlOxoAqFmpKHXj8J49e5566qnUyYyJEyeefvrpJSvs3bt35syZGzZsqFevXip2dO7cOZlMlvKe65/+9KdnnXXW/fffv2LFitK36mhVWVlZOTk5W7Zsicrq8Lute/To8bV3Ul966aXHu84Rff7551lZWfXq1Tv8bus9e/asXr36f/yP//GrX/1q1KhRpez8xo0b16lTp/QdUlBQsGDBgieeeKJx48Y33XTThg0bSlkIALXlXFFWVtZ3v/vdp59+euHChX369Dn4W23mzJlzxD+6b7311pIlS752y/Xr1y/DdbRjVH3rW99asWLFxx9/fMQP3HXt2jWqrnbs2LF8+fKOHTse8dmsrKwzzzxz0qRJnTp1mjFjRik7/4QTTujYsePf/va3nTt3Hr7ahAkTbrjhho0bN5Ys+c1vfpOdnd28efNf//rXn3322Q033HD4twAAQHWThitol19++W233fbWW2+VnKtIXcE58cQTt23bdvB5kb/85S9RFB3tU9+HuPjii++4444lS5Yc/g2NZai69tprDxw4cOuttx4xYx3+eavq46GHHtq7d2+fPn2OvVqdOnV27Nixb9++Unb+gAEDdu3a9a//+q+HbGft2rUPPvjgnDlzjnh97Xvf+96gQYP+9Kc/HdfFTQCoRfcV/fSnP23VqtWUKVPeeOONKIo2b948b968/v37N2rU6ODVLrroovbt2//bv/3btm3bSrPZ8ePHn3XWWb/5zW+OqzFHrLrxxhu7du36xz/+8YILLvj3f//3zZs37927N/Utjv369Xvrrbfq1KleP5ZSXFz8wQcfjB079ic/+UmDBg2Odi9zMplcv3796NGj33777S5dutStW7eUnT9ixIgmTZoUFhbecMMNf/vb33bt2vXJJ588+eSTl156aVFR0ejRow++YHewKVOmNGvWbOzYsW+++WblHDoAVIz0/Gk/6aSTfvWrXx04cODmm2/et2/fE088sW/fvpJbfQ/2gx/8YOfOnb///e9Lf0Xs2J8OK2VVdnb2rFmzLrroorfeeuu73/1u8+bNs7OzU7/4MXfu3Pbt25fyq7eP5oifL4vFYgd/5q406zRv3rzkk30dOnQYP3586udN8vPzDznG1Gp16tTJz8+fNGlSnTp1Ul8uUMrOb9KkydNPP52Tk/P73//+/PPPb9CgwWmnnXbttdf+/e9/j8fjd99999GOtGnTpr/73e/27t37/e9//8svv/R9RQBUW2k74XHllVcOGDBg2bJlv/jFL2bMmHHyySdffvnlh692ww031KlTp5QX0VJXxFJfUXhcjljVsmXLP//5zzNnzuzbt2/Lli2zs7ObNWvWt2/fxx9/fPny5eeff35UnWRlZeXn519zzTX/+Z//+b3vfe9oq51wwgmnnnpqv379Xn755dRVttJ3fq9evZYuXXr77bd36NChYcOG9evXv/DCC6dOnfof//Efh3+r08H69+8/ZMiQDz/88OAvYgCA6iZWnW+RAQCoMtXr5hgAgHSRigAAAqkIACCQigAAAqkIACCQigAAAqkIACCQigAAAqkIACCQigAAAqkIACCQigAAAqkIACCQigAAAqkIACCQigAAAqkIACCQigAAAqkIACCQigAAAqkIACCQigAAAqkIACCQigAAAqkIACCQigAAAqkIACCQigAAAqkIACCQigAAAqkIACCQigAAAqkIACCQigAAAqkIACCQigAAAqmIUtm6dev777+f7lYAGcbUQWaRijJPy5YtY4eZOXNmpe60d+/eixcvLv36kyZN6tat29GeLSoqat269XFtECiPpk2blkwX2dnZHTt2fPjhh8u8tZIBXlRUFIvFjpF7TB1kFqkoIz300EPJ/991111XqXvctWtXRW1q3bp1vXv3XrNmTUVtECiNKVOmpKaLL7/8srCwcNSoUb///e/Luc28vLxkMtmhQ4ejrWDqILNIRTXHY489Vq9evXXr1kVRtGXLlkaNGk2fPv3TTz+NxWKPPfZYy5Ytc3Nzhw4dWjJJbdq0adCgQQ0bNszPzx85cmTJ8g0bNsTj8ZycnFNOOeXWW28tLi6+9NJLP/jgg4KCghtvvPEYhe++++4ll1xSv3797t27H23m+uMf/9ipU6euXbtWVa8Ah8rKyrriiit69eqVSCQ2b94ci8XGjBmTm5s7ZMiQ4x3gB58rMnVQA0hFNcfQoUN79OgxceLEKIrGjx9/3nnnFRQUpJ568MEH582bt3Tp0jfffHP48OGphQMHDszJyVm7du3ChQuXLFkyYsSIKIr2799/+eWXZ2dnr1q1atGiRe+8887999+/YMGC9u3bT58+ferUqUcr3L17d9++fTt37rxx48YxY8ZMnz79iI2sV6/eK6+88sgjj1RhxwBHsG/fvoYNG6Yev//+++vXr3/ggQfKPMBNHdQQh1yIofpr0aLFIS/iCSeckHpq5cqVeXl5kydPzs3NXblyZTKZ3LJlSxRFiUQitcL8+fOzs7N37NixcOHCBg0aFBcXp5YvWbKkTp06u3btWrhwYXZ29tatWw/ZaWpqSyaTRyucNWtWbm7uzp07U8t/9KMfXXjhhUc7hL1790ZRtGjRokroHuAImjRpUnIFraioaPr06XXq1JkzZ86mTZuiKJo7d27qqeMd4J9//nkURe+9956pg5rBuaKacF/Rvn37Usvbtm07evTokSNH3nXXXW3bti1Zv+TuxXPOOWfPnj2rVq1asWLFzp0769Wrl7r78vzzzz9w4MDq1avffffdli1bNm7c+Gi7PlrhihUr2rRpU79+/dRqXbp0qeQ+AI7PLbfckhq2zZo1mzRp0iOPPNKvX7/UU61atSrnADd1UDNIRTXN8uXLoyh66623Dl6YlZWVerB///4oiurWrbtv3762bdsekpG/+c1vZmVlxWKxY2z/aIWHrFayR6CaKDlXtHv37uXLlw8bNqzkqXr16pVzgJs6qBmkohrlxRdffPrppwsLC2fPnj1r1qyS5W+//XbqwdKlSxs2bNimTZsOHTqsWbNm/fr1h2yhXbt269atS50VP1jJfHe0wk6dOq1cufLLL79M/fOdd96p6IMDKl2ZB7ipg5pBKqo5duzYMWzYsNtvv33UqFE33XTT8OHDv/jii9RTd99995o1a1auXHnPPff86Ec/qlev3re//e2zzz67oKBg3bp1GzZsuPPOO1u1alVcXHzJJZd06tTptttu+/TTT9euXTtw4MDvfe97URSddNJJGzdu/OKLL45W+N//+39v3rz5HXfc8dlnn73yyivTpk1Ld38Ax63MA9zUQc0gFWWkESNGHPItjsOGDfvnf/7nOnXqjBs3LoqiwsLCOnXq/PM//3Nq/d69e1922WUXXnjhf/tv/y31IbU6derMmjXrpJNO6tix4ze/+c0PPvhg/vz5qUv+//Ef//HZZ5/l5+efd955jRo1evTRR6MoGjZs2IQJEwoKCo5WmJ2d/eKLL65du7ZFixYjRoy46aab0t1JwHEr8wA3dVAzxJLJZJmL4/F4hTaGirdnz565c+f26tUrJycn3W2hekkkEmnZr3kDMlciTfNGlalbzvpZbX9WtsIBH91T22o7F5bxzbRsdLzM++27InwjyP8+Y1TUuHUt6We11V/GjaNMfH3V1vjatIyFGs8VNACAijhXRDWXnZ0djfog3a0AgAzgXBEAQCAVAQAEUhEAQCAVAQAEUhEAQCAVAQAEUhEAQCAVAQAEUhEAQCAVAQAEUhEAQCAVAQAEUhEAQCAVAQAEUhEAQCAVAQAEsWQyWeae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2bNnJ5PJKuwkqBWysrKuuOKKXr16JRKJzZs3x2KxMWPG5ObmDhky5HiH8MHnikwO1HhSUc0xdOjQHj16TJw4MYqi8ePHn3feeQUFBamnHnzwwXnz5i1duvTNN98cPnx4auHAgQNzcnLWrl27cOHCJUuWjBgxIoqi/fv3X3755dnZ2atWrVq0aNE777xz//33L1iwoH379tOnT586derRCnfv3t23b9/OnTtv3LhxzJgx06dPP7yF3bt337t3b3Z2duqfmzZtaty4cSwWq8JOglpk3759DRs2TD1+//33169f/8ADD5R5CJscqBUOuRBD9deiRYtDXsQTTjgh9dTKlSvz8vImT56cm5u7cuXKZDK5ZcuWKIoSiURqhfnz52dnZ+/YsWPhwoUNGjQoLi5OLV+yZEmdOnV27dq1cOHC7OzsrVu3HrLT1MSXTCaPVjhr1qzc3NydO3emlv/oRz+68MILj3EURUVFZ5555v3331/R3QO1VJMmTUquoBUVFU2fPr1OnTpz5szZtGlTFEVz585NPXW8Q/jzzz+Poui9994zOVAbOFdUE+4r2rdvX2p527ZtR48ePXLkyLvuuqtt27Yl65fc23jOOefs2bNn1apVK1as2LlzZ7169VL3Zp5//vkHDhxYvXr1u+++27Jly8aNGx9t10crXLFiRZs2berXr59arUuXLsdo/5dfftm/f/9OnTqNHTu2groEiG655ZbUwGzWrNmkSZMeeeSRfv36pZ5q1apVOYewyYHaQCqqaZYvXx5F0VtvvXXwwqysrNSD/fv3R1FUt27dffv2tW3b9pCM/M1vfjMrK+vYZ62PVnjIaiV7PNzWrVt79erVsmXLZ599tm7duuU7XOD/KTlXtHv37uXLlx98w3K9evXKOYRNDtQGUlGN8uKLLz799NOFhYWzZ8+eNWtWyfK333479WDp0qUNGzZs06ZNhw4d1qxZs379+kO20K5du3Xr1qXOmR+sZDY8WmGnTp1Wrlz55Zdfpv75zjvvHLGF69ev79GjR8+ePf/whz+U3EMAVJkyD2GTA7VCBV2Jo+q0aNHi8E/mJ5PJL774olWrVnfeeWfqyn2LFi22b9+euq/ovPPOW7169Ycffvitb31r5MiRyWRy//79Xbp06d2798cff7x+/fo77rgjPz9/9+7dBw4cOPfcc6+99totW7asWbPm6quv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fQ0bNkw9fv/999evX//AAw+UeTgYaFBNJck0LVq0OORFPOGEE1JPrVy5Mi8vb/Lkybm5uStXrkwmk1u2bImiKJFIpFaYP39+dnb2jh07Fi5c2KBBg+Li4tTyJUuW1KlTZ9euXQsXLszOzt66deshO01N1slk8miFs2bNys3N3blzZ2r5j370owsvvPBoh9C+fft69epdeumlW7ZsqYQegvJq0qTJlClTUo+LioqmT59ep06dOXPmbNq0KYqiuXPnpp463uHw+eefR1H03nvvGWhQPTlXlJEeeuihg1/Fffv2pZa3bdt29OjRI0eOvOuuu9q2bVuyfsn9mOecc86ePXtWrVq1YsWKnTt31qtXL3U/6fnnn3/gwIHVq1e/++67LVu2bNy48dF2fbTCFStWtGnTpn79+qnVunTpcoz2v//++1u3bm3QoMEVV1xRQV0CFeyWW25JvcmbNWs2adKkRx55pF+/fqmnWrVqVc7hYKBB9SQV1TTLly+Pouitt946eGFWVlbqwf79+8M99nXr7tu3r23btodk5G9+85tZWVmxWOwY2z9a4SGrlezxaE466aSxY8e+8cYbGzduLOuxQiUqOVe0e/fu5cuXp+68TqlXr145h4OBBtWTVFSjvPjii08//XRhYeHs2bNnzZpVsvztt99OPVi6dGnDhg3btGnToUOHNWvWrF+//pAttGvXbt26danz/AcrmcGPVtipU6eVK1d++eWXqX++8847hzdv3rx5ubm5xcXFqX9+9tlnJ5xwQl5eXvkOGtKmzMPBQINqqoKuxFF1WrRoccgVtJQvvviiVatWd955Z+pugxYtWmzfvj11X9F55523evXqDz/88Fvf+tbIkSOTyeT+/fu7dOnSu3fvjz/+eP369XfccUd+fv7u3bsPHDhw7rnnXnvttVu2bFmzZs3VV199zTXXJJPJrl27jh8/fvv27UcrLC4ubteu3dChQ7du3fryyy/n5OQcfrvDrl272rVrd+uttxYVFS1btqxjx4433nhjVXUblPG+ooOl7itK3bR3jHF0tOFQcl+RgQbVk1RUE+62jqLo5ptvvu22277xjW/s2LEjmUxu27YtPz9/+PDhqVR07733nnHGGSeffPLIkSP37NmT2s7f//73q6666qSTTmrUqFGfPn3ee++91PI1a9ZcfvnlJ554YpMmTYYMGbJt27ZkMvm73/2uYcOGAwcOPEbhqlWrevXqdeKJJ3bq1GnkyJFHvAn0o48+6tu3b6NGjVq1ajVmzJhdu3ZVYc9BBaei4x0OJanIQIPqKXbsrxSrbWre51f37Nkzd+7cXr165eTkpLstmS2RSKRlvzXvPQm1R7rmDcrMd1sfKjHp/92Oc1ziowZUw9pPP49OmRv9+u7/3aHNkWs7F5Zx0C4bHa+Gx1t5tWlUnuP1+qpVm8axQMZxtzUAQOBcUQ3X9OQo+VG6GwEAmcC5IgCAQCoCAAikIgCAQCoCAAikIgCAQCoCAAikIgCAQCoCAAikIgCAQCoCAAikIgCAQCoCAAikIgCAQCoCAAikIgCAQCoCAAhiyWRST5SIx+PpbgLVVCKRSMt+vSchc6Vr3qDM6pa9tIZKTJpVtsL4qAHpqu1cWMaBt2x0PBOPNy21aVSe1zddtRn3+qrNiNqMGwtkHFfQAAACqQgAIJCKAAACqQgAIJCKAAACqQgAIJCKAAACqQgAIJCKAAACqQgAIPCLHwCQCWKxoz7lJ00riFQEAJkZhg5fRzwqH6kIADI2Dx2xRDYqK6kIADI/Dx1eLhsdP3dbA0ANikQVvp3aRCoCgGqjYqOMYHScpCIAqB4qI8QIRsdDKgKAaqDy4otgVGqxpLuxDhKPx9PdBKqpRCKRlv16T0KtmDeqILj4c18KPoN2qMSkWWUrjI8akK7azoVl/IO9bHQ8XbUZ189plK73Rsa9Rhk6BjPxeDOxNi2vUfU6lxOLCUZfyxU0AIBAKgKA9KnKm37cYPR1pCIAgEAqAoA0qfqTN04XHZNUBAAQSEUAAIFUBADpkK6LWS6iHZ3vKwKADJFMRrNnR/v2RVlZ0ZVXyjcVzrkiAMgQf/1r9OKL0aBB0fPPR4sXp7s1NZBUBAAZYt26qLg46tYt2rAh/EdFk4oAIHPMnBmNGRPNm5fudtRMUhEAZI6CgmjGjKh//3S3o2aSigAgQ+TnR/XrR4lEeNCiRbpbUwP5DBoAZIgLLog2b4569gyfQevWLd2tqYGkIgDIED6KX8lcQQOAdEgma9d+M4FUBAAQSEUAAEEs6UzaQeLxeLqbQDWVSCTSsl/vSajh80YV3yrkj/4xudv6UIlJs8pWGB81oHNhGf9wLhsdL89+a1ttWvo5jTLxNapt76t01WZiP9eqWjKOK2gAkD5VefLGiaKvIxUBAARSEQCkVdWcwnGiqBSkIqh455xzzoavfs66uLi4Xbt2Dz/8cJcuXc4999z58+enu2lAtVTZkUUkKh2pCCreoEGDnn/++SiKXn311T59+owbN+6111578sknZ86cme6mAdVV5QUXkajUpCKoeIMHD549e3YURS+88MJ3vvOdvn373nDDDevWrXviiSfS3TSgGquM+CISHQ+pCCpe+/btt27dun379qVLl1588cUzZswYMWLElClTCgoK0t00oHqr2BAjEh0n31cEleKqq66aOHHiBRdcsH379iuvvPKVV17p2rVr69at090uoNpLJivmqx1FouMnFUGlGDx48Nlnn/3qq6/m5uZeccUV3bp1O3DgwI9//ON0twvIBKlAU+ZsJA+VlVQElaJ9+/bFxcWpx6O/ku4WAbUgG8lD5SMVAUA1VhJ0jhGPhKEKIhUBQCYQfSqfz6ABAARSEQBAIBUBAARSEQBAIBUBAARSEQBAEEv6pN9B4vF4uptANZVIJNKyX+9JyFzpmjcoM99XdKjOhWV8Ey8bHU9MmlW22vioAbWtNuP6OY0y8fWtbbUZ935WWzW1ZBxX0AAAAqkIACCQigAAAqkIACCQigAAAqkIACCQigCgupg2bdoll1xyzjnnzJ8/P4qil19+uXXr1pd+ZezYsSWrbdu2bcCAAT169BgwYMC2bduiKJo4cWKnTp0KCwujKDpw4EC/fv2KiorSeigZSSoCgGphy5Ytjz/++MKFC5966qk77rgjiqLNmzfffffdC74ybty4kjXHjx/fs2fP119//ZJLLpkwYUIURb/85S//8pe/TJ48OYqiqVOnDhw4MC8vL61Hk5GkIgCoFrZu3Tp8+PA6derk5+dv3bo1iqJNmzY1b9788DXnzp17zTXXRFF0zTXX/PGPf4yiKCsr6x//+Ed2dvZnn302e/bsgoKCdBxBxpOKAKBa6NChw+DBg6MoevbZZ/v3759KRX/84x979Ohx5ZVXrlq1qmTNTz755LTTTouiqHnz5p988knq7NF11103YcKEsWPH/uQnP4nFYmk9lEwlFQFANbJq1arCwsKJEyeGHyuNxTp37vz6668PGTLkpptuOkbV9ddfv3jx4vbt20dRtHr16n79+j377LNV2Ooawu+gAUB1sWPHju9+97uPPfbYKaecEkXR7bffnp+fH0XRVVdddfPNN5es1qxZs82bN59++umbNm1q1qxZamEymbzvvvueeOKJrl27Ll68uHv37oMGDUrfoWQk54oAoFpIJpM/+MEP7rrrrgsvvDC15N57750zZ04URW+88ca3vvWtVGyKoqhv375PPfVUFEVPPfVU3759UytPmzatf//+TZo02bVrVzKZ3LlzZ1qPJiM5VwQA1cKMGTNeeumlrVu3Pvroow0bNpwzZ87//J//s6Cg4KGHHjrxxBN/97vfRVF09dVXz58//1/+5V9+8IMfPPfcc02bNn388cejKCoqKnrmmWfmzp0bRdGIESN69+591113pfuAMo9UBADVQsFXDl5y1llnvf766wcvSX2PUW5u7qxZsw5enpeXN2/evNTje79SJU2uaVxBAwAIpCIAgEAqAgAIYslkUk+UiMfj6W4C1VQikUjLfr0nIXOla96gzNxtfajOhWV8Ey8bHU9XbWLS/3fPXenFRw1IV23G9XMapaufM/F9pVZttRoLZBxX0AAAAqkIACCQigAAAqkIACCQigAAAqkIACCQigAAAqkIACCQigAAAqkIACCQigAAAqkIACCQigAAAqkIACCQigAAAqkIACCQigAAAqkIACCIJZNJPQHVVjweT3cTgDJKJBLpbgLHp+5xrg9Utc6FZZxYl42Op6s2MWlW2WrjowaoVXu02owbC2QcV9AAAAKpCAAgkIoAAAKpCAAgkIoAAAKpCAAgkIoAAAKpCAAgkIoAAAKpCAAgkIoAAAKpCAAgkIoAAAKpCAAgkIoAAAKpCAAgkIoAAAKpCAAgiCWTST0B1VY8Hk93E4AySiQS6W4Cx6fuca4PVLXEpFllK4yPGtC5sIyT8rLR8fLsV63a6lablrFAxnEFDQAgkIoAAAKpCAAgkIoAAAKpCAAgkIoAAAKpCAAgkIoAAAKpCAAgkIoAAAKpCAAgkIoAAAKpCAAgkIoAAAKpCAAgkIoAAAKpCAAgkIoAAIJYMpnUEwAAzhUBAARSEQBAIBUBAARSEQBAIBUBAARSEQBAIBUBAARSEQBAIBUBAARSEQBAIBUBAARSEQBAIBUBAARSEQBAIBUBAARSEQBAIBUBAARSEQBAIBUBAIQe+D+HKCIOYMaP+gAAAABJRU5ErkJggg=="
            },
            {
              "type": "input_text",
              "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
            }
          ],
          "solved_count": 0,
          "total_training_examples": 3,
          "pixel_accuracy": 0.5421994884910486
        },
        "test_result": {
          "correct": false,
          "pixel_accuracy": 0.0,
          "total_pixels": 288,
          "correct_pixels": 0,
          "error": "Grid height mismatch"
        },
        "status": "failed_test"
      }
    ],
    "total_turns": 1,
    "conversation_history": [
      {
        "role": "system",
        "content": "You are an expert at solving abstract reasoning puzzles. Write clean, efficient Python code."
      },
      {
        "role": "user",
        "content": [
          {
            "type": "input_text",
            "text": "You are solving an ARC (Abstraction and Reasoning Corpus) task. \nI will show you training examples with input and output grids, plus a test input grid. Your task is to:\n\n1. **Analyze the training examples** to discover patterns that map input grids to output grids\n2. **Write a Python program** that implements your best understanding of the transformation  \n3. **DO NOT predict or generate the test output** - your job is only to write the transformation program\n4. **Attempt a solution** - even if the pattern isn't completely clear, provide your best hypothesis\n5. **Do not repeat the same transformation** - if you have already tried a transformation, do not repeat it.\n\n**IMPORTANT: Your transformation must always produce a 8\u00d716 output grid.**\n\nThe test input is shown for context so you understand what type of grid your program will eventually process. Focus on learning patterns from training examples and writing code that captures your understanding.\n\nTraining Examples:\n\nExample 1:\nInput:\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 2 8 2 2 0 1 1 8 8 1 1 1 1 0 0 0 0\n0 8 8 2 2 0 1 1 8 8 1 1 1 1 0 0 0 0\n0 2 8 8 8 0 8 8 1 1 1 1 8 8 0 0 0 0\n0 2 8 2 2 0 8 8 1 1 1 1 8 8 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0\n0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0\n0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0\n0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0\n0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0\n0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0\n0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0\n0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\nOutput:\n1 1 1 1 1 8 1 1 1 1 1 1 1 1 1 1\n1 1 1 1 8 8 1 1 1 1 1 1 1 1 1 1\n1 1 1 1 1 8 8 8 1 1 1 1 1 1 1 1\n1 1 1 1 1 8 1 1 1 1 1 1 1 1 1 1\n1 8 1 1 1 1 1 1 1 1 1 1 1 8 1 1\n8 8 1 1 1 1 1 1 1 1 1 1 8 8 1 1\n1 8 8 8 1 1 1 1 1 1 1 1 1 8 8 8\n1 8 1 1 1 1 1 1 1 1 1 1 1 8 1 1\n\nExample 2:\nInput:\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 2 8 2 0 3 3 8 3 3 0 0 0 0 0 0 0 0\n0 8 8 8 0 8 3 3 3 8 0 0 0 0 0 0 0 0\n0 2 8 2 0 3 3 8 3 3 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0\n0 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0\n0 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0\n0 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0\n0 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0\n0 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0\n0 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0\n0 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0\n0 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\nOutput:\n3 3 3 3 3 3 3 8 3 3 3 3 3 3 3\n3 3 3 3 3 3 8 8 8 3 3 3 3 3 3\n3 3 3 3 3 3 3 8 3 3 3 3 3 3 3\n3 8 3 3 3 3 3 3 3 3 3 3 3 8 3\n8 8 8 3 3 3 3 3 3 3 3 3 8 8 8\n3 8 3 3 3 3 3 3 3 3 3 3 3 8 3\n3 3 3 3 3 3 3 8 3 3 3 3 3 3 3\n3 3 3 3 3 3 8 8 8 3 3 3 3 3 3\n3 3 3 3 3 3 3 8 3 3 3 3 3 3 3\n\nExample 3:\nInput:\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n2 8 2 0 4 4 8 8 4 4 0 0 0 0 0\n8 2 2 0 4 4 8 8 4 4 0 0 0 0 0\n8 8 8 0 8 8 4 4 8 8 0 0 0 0 0\n0 0 0 0 8 8 4 4 8 8 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 4 4 4 4 4 4 4 4 4 0 0 0\n0 0 0 4 4 4 4 4 4 4 4 4 0 0 0\n0 0 0 4 4 4 4 4 4 4 4 4 0 0 0\n0 0 0 4 4 4 4 4 4 4 4 4 0 0 0\n0 0 0 4 4 4 4 4 4 4 4 4 0 0 0\n0 0 0 4 4 4 4 4 4 4 4 4 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\nOutput:\n4 4 4 4 8 4 4 4 4\n4 4 4 8 4 4 4 4 4\n4 4 4 8 8 8 4 4 4\n4 8 4 4 4 4 4 8 4\n8 4 4 4 4 4 8 4 4\n8 8 8 4 4 4 8 8 8\n\nTest Input:\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 2 8 2 8 0 1 8 1 1 8 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 8 8 2 2 0 8 1 1 1 1 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 2 2 8 8 0 1 8 1 1 8 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 8 2 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0\n0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0\n0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0\n0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0\n0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0\n0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0\n0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0\n0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0\n0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0\n0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0\n0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0\n0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\nAnalyze the patterns in the training examples and write a Python function that performs this transformation.\n\n**Approach Guidelines:**\n- Look for patterns in shapes, colors, positions, sizes, rotations, reflections, etc.\n- Even if you can't solve all training examples perfectly, implement what patterns you do observe\n- A partial solution that captures some aspects is better than returning the input unchanged\n- If the pattern is unclear, make your best educated guess based on what you can see\n\nRequirements:\n- The function takes a 2D list (grid) where grid[row][col] gives the value at that position\n- Values are integers from 0-9\n- Return a new grid (2D list) with the transformation applied\n- You can use numpy if needed - just add 'import numpy as np' at the start of your function\n- Aim to handle the training examples as well as possible, even if not perfectly\n- Your function should attempt some meaningful transformation based on the patterns you observe\n\nYou MUST end your response with the following exact format:\n\nFinal answer:\n```python\ndef transform(grid):\n    # Your transformation logic here (implement your best understanding)\n    return transformed_grid\n```\n"
          },
          {
            "type": "input_image",
            "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAwwAAAZKCAIAAAD6JHH6AABJ6UlEQVR4nO3df7xVdZ3o/711CwgiSDYqWMLhdNUudTTGn9mkgTWTqWvdwSz13g5J6kxU3OTHnR5Wc9NUOM50yx+ll0QLs9TrWo9p4uGdcB6W3ZtlalgiCor5A0tBMX+EHGB9H985M+cy+A4Oa5/DZp/9fP4Fi/1e+7P32fvDy73OwWpRFBUAAP69Pbb5PQAAIgkAICaSAAACIgkAICCSAAACIgkAICCSAAACIgkAICCSAAACIgkAICCSAAACIgkAICCSAAD6O5JmzpxZ/ePOOeec8DZDhgw58MADTzvttPvvv/+N5/zhD39YrVbHjBmzYcOGbf7otttuq1arCxcu7PltZ2dntVrt6ura5mZPP/10tVq96KKL6pnqsWHDhmuvvfakk04aO3bs0KFDx44de8YZZ9x9993lnpOpU6dWKpV169aNHTt2v/32e/rpp7eZ/U//6T8NGTLkF7/4RR+fkI985CPVarVWqz3//PNvXMmkSZOq1WpnZ2fPb2fMmLH1Yvbcc8999933mGOO+eY3v9k7kiRJtVp94x318aH1WLt27dy5cw877LC999579OjRxx9//Ne//vXNmzdv50kDgN1QAz5J6u7u/t3vfvf973//pJNOevzxx7f50+uvv75Sqbz44ovf+973+nK2L3zhCytWrNjZNfRl6oknnjjuuOMuuOCCu+6669lnn924ceOzzz572223/dmf/dnf//3fV8p605vedP31169fv3769OlFUfQev/rqq7Msu/TSS//0T/90p56QzZs333777dsc/NWvfvXQQw9tZxlbtmx5+eWXf/7zn8+YMWPBggWVfvL8888fddRRXV1djzzyyIYNG1566aWf/vSnf/3Xf33GGWds/WABYJBH0lVXXVX8m1tvvbVSqSxatKj3yOLFi3tvuXr16t7jGzZsePjhh88666zf//73X//617c+4fr16/M8P+OMM8aMGfONb3yjL2vYuHFjZ2fnzn5QscOp7u7uadOm/fKXvzz++OP/4R/+Ye3atd3d3U8++eQ111wzZsyYuXPn/vrXv97O+bd+vL2WLl3a86d//ud//slPfnLp0qVXXXVVz5Fly5ZdeOGF73//+y+88MKdekL23HPPQw899JZbbtnm+He/+93/+B//4xtv/+yzz/YsZsuWLa+88sp3vvOdYcOGffnLX3799de3+4T19aF97Wtfe+KJJ6ZNm7Zs2bJXX311/fr1//zP/3zkkUdmWfb973+/j3cBAC36SdLQoUMPO+yw+fPnVyqVbT5J+s53vrNhw4bzzz9/+vTp99xzz4MPPrjDs33qU5/62c9+9nd/93c7tYYdTt1444333Xff1KlTf/zjH5966qlvetObarXaW97ylr/6q7+6/fbbN2/efPPNN1fq0NXVddhhh82bN++RRx555ZVXPvzhD48aNepb3/pWtVrd2Sfkwx/+8I9+9KPnnntu64Pf+973zjzzzO0soFqtjhgx4qMf/ehHPvKR3//+948++milP6xYsaJWqy1evPid73zn8OHDR40addJJJ/V80HXHHXf03OaGG26oVqu9gQgAu6cGRNLrr7/+0EMPffazn61UKv/hP/yHrf9o0aJFhx9++Pve976/+qu/2nPPPfvyYdKll17a3t7+hS984eGHH+77GnY49Z3vfKdarV533XV77rnnNn/03ve+d/ny5ZdcckmlDnvvvfdNN920adOmc84554ILLli5cuW3vvWtAw44YJub9eUJ+fCHP7zNFbef//znjz322Ic//OG+rKTnM6Q3PsxyOjo6Nm3alGXZ1gfHjx9fFMU111zTL3cBAIMqkiZMmND7Tb7Dhg2bNGnSrbfeuv/++3/mM5/pvc2vf/3rX/ziF3PmzKlWqxMnTjzjjDNuuummV155ZftnHj58+KJFi7q7u3fqotsOpx544IHDDz98woQJ4fjhhx++zUc+23m8ve66666tb/Oud73rb//2b3/xi1/cdNNNn/3sZz/wgQ9sc5I+PiGTJk16+9vf3nO5s8d3v/vdP/3TP504ceJ2Vrh58+Y1a9Z89atfveWWW/7kT/7k0EMP3c6N+/7QZs2adcIJJ3z0ox9ta2ubMWPGdddd98Zvjers7CyKYubMmX28RwBooX8CYNy4cR//+MeXLVt24IEH9h68/vrrx40bd/bZZ/f89m/+5m9efvnlvlzVOuGEEz796U///Oc/v+KKK/q+hu1MdXd3r1+/fpvPdbb52a7x48dX6nb66af3xNYJJ5zwxj/t+xOy9RW3oihuueWWP3at7aCDDupZf61WGzdu3KxZszZv3nzppZf21ydJ++yzz1133bV48eKOjo48z88///xJkyZNmDDhxhtv7JfzA8Bgi6Se7/bduHHjd7/73ZEjR77tbW+7/PLLx44d23uD7u7uxYsXP/PMM0OHDu35W7yjo6Moij5++/all176tre97Ytf/OLy5cv7vqo/NrXXXnuNHDky/Ln6er67+cQTT9z6Nhs2bDjrrLNGjRo1cuTI888/f5tvKtqpJ+TMM8/sveL24x//eM2aNTu81rbHHnuMGTNmypQpeZ6fe+65/fjQ9txzz7PPPjvLsrVr165cuXLRokUHHHBAZ2fnV77ylb7fCwC01idJe+2115lnnvm9733vRz/60Z//+Z9v/e/x/OM//mMYJffff/+99967wzPvvffeJS66bWfqHe94x/Lly5988snwR/kmT55cqdusWbMefPDBr/2L55577uMf//jWf7pTT8hhhx32jne8o+dn3L73ve8de+yxb33rW8M77f3pts2bN69bt27p0qWnn356ZcC0t7d3dnb+5Cc/OfLII+v8Li4AGPyX2/7iL/7iU5/61P333z979uzeg9dff/2wYcNeeumlrT+f+L//9/9WKpVrr722L6d997vf/ZnPfObee+994z8UWWLq7LPP3rJly1//9V+HyVX/P/lz6623XnvttWedddZ//s//ubOz8y//8i9/8IMfbP0PIuzsE3LmmWf++Mc/7vmXnLb/c20D55lnnqlWqzNmzNjmeK1We8c73rF+/fqNGzc2ZGEA0DTfk3TppZe+9a1v/frXv/6zn/2sUqn89re/veOOO0499dR9991365sdd9xxhx566M033/zSSy/15bRf/vKX3/a2t+3sT1GFUzNmzJg8efIPfvCDo48++pZbbvntb3/b3d3dkyCnnHLK/fffv8ce5Z+61atXf+ITn5gwYUJvFV177bUHHXTQhRde2PNPXJZ4QnquuM2aNWvt2rVnnHFGpRHGjRv3rne96/rrr585c+ZPf/rT3/3udxs2bHjssceuueaaW2+99eijjx4yZEhDFgYATRNJI0aMuPLKK7ds2XL++edv2rTpW9/61qZNm3q/Q3lrH/vYx1577bVvf/vbfb98tv2fO+vj1JAhQ/I8P+644+6///4zzzzzoIMOGjJkSM//lmTJkiWHHnro9v9B8PBHwKrV6iuvvNLd3X3mmWe++uqrN910U28DvelNb7rhhhs2bNhw9tlnd3d3l3hC2tvbjzzyyFtuueU973nP1t/sVcLee++9zbJvuOGGvjy0ng/ARo8effXVVx9//PEHHnjg3nvv3d7e/slPfrJWq/X+w0j+nSQAmkLD/ge3p512WpIky5Yt+x//43/ccMMN++2331/8xV+88Wb/5b/8lz322KOPV9x6Lp/NmjVrZxcTTh188MF333334sWLP/jBDx588MFDhgw54IADPvjBD954442//vWvjzrqqEop/+2//bd77733i1/84nHHHbf18fe///0zZ868//77L7roonJPSM9Vtj7+80gDpKOj46GHHrrwwgsnTZq07777DhkyZPz48eedd96vfvWrfvlGLgDYZar+j1oAALvRJ0kAALszkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJ7Drr1q1bsWJFo1cBtKh6tiDbV2sSScSSJOns7Ozfc06dOvWee+75Y3+6fv36tra27dwAoMdTTz31iU98Yty4ccOGDWtra5s9e/YLL7xQ5xZUz6zta7ASSew6f/jDH/7YHz311FNTp05dvXr1rl0R0HweffTRyZMnv/jii0uWLHnhhRduv/32hx9+ePLkyc8++2zpLWiHbF+tSSSxA2vXrq1Wq1dfffX48eOHDRv2gQ984Jlnnuk9/s1vfvPggw8eNWrUueee27OJPP3009Vq9YknnugZv+KKK4499thKpXLiiSc+8sgj06dPnzFjxjZ38YMf/GDSpEmTJ09uxOMDmsyMGTPe+9733nbbbR0dHcOHDz/iiCO+//3vH3jggZ/+9Kf7uAXZvugjkUSf3HjjjXfeeeeKFSvWrFnzpS99qff4ggUL7rjjjgceeOC+++6bOXPmds5w1113HXrooYsWLVq4cOE2fzR06NClS5deffXVA7Z8YJD4zW9+c/fdd2+z2+yxxx6zZs3K8/zFF1/s+xZk+2KHRBJ98vnPf37ixInjx4/v7Oy89957e4/Pnz9/0qRJbW1tXV1dixcvfvXVV0ucfOrUqUcddVS/rhcYnJYvX16pVA4//PBtjnd0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v7n77ru32U/22GOPWbNm5Xn+4osv9n2TsUGxQyKJfvD5z39+4sSJ48eP7+zsvPfee3uPz58/f9KkSW1tbV1dXYsXL3711VfruZeXXnrp8ssvP/fcc/tjyUBTWr58eaVSOfzww7c53tHRsWnTplWrVvX9VDYodkgk0Q/Gjx/f84sRI0Z0d3f3Hj/22GN7fnHEEUds3LjxscceK30Xr7766qmnnjpp0qSLLrqo7vUCzarnc5rNmzdvc/z111/f2VPZoNghkUQ/2GuvvXp/XRTFG4/37Gi1Wm2bD6LfuNOF1q1bN2XKlIMPPvi2226r1Wr9t3CgyfR8htTzedLWVqxYUavV2tvb+77J2KDYIZHEAHrwwQd7fvHAAw/ss88+EydO7Ll43/ux9pNPPtl74z92If/pp58+4YQT/uzP/uymm27qvfYPtKZDDjlkypQpl19++dYHt2zZsmDBgtNOO22//fbr+yZjg2KHRBIDaO7cuatXr165cuW8efPOO++8oUOH7r///hMmTLj22mtfe+21pUuX3nzzzb03HjFixJo1a15++eWtz7B+/fr3ve99p5122oIFC3w7JFCpVK677rqHHnronHPOefTRR7u7u5cvXz5t2rTnnnvuyiuvrFQqfd9kbFDskEhiAE2dOvWkk0465phjTj755J7/8qtWqwsXLly6dOmYMWMuvvjiz33uc703vuCCCy677LLp06dvfYZvfOMbK1eu7NmAer3yyiuNeDTAbqGtre3+++8fPXr0ySefPHLkyFNOOeWQQw755S9/OXbs2J3aZGxQ7FB16+8g6V9pmg7Qmdn9bdy4ccmSJVOmTBk5cmSj10IzybKs0mzsdU3HBjXIZAO2bwzst5jleV5uMEkSs4Ng9s4772zI/Zpt3tkm9fhF68sNtl0y2uyume3o+n9/j7724tolS9582Nyr9m87bIezy+akzfh4W2p24LjcBgAQ8MOKALSW4fvt/8WVA/WtJgwmPkkCAAiIJACAgEgCAAiIJACAgEgCAAiIJACAgEgCAAiIJACAgEgCAAiIJACAgEgCAAiIJACAgEgCAAiIJACAgEgCAAiIJACAQLUoisrASNN0gM4MDFZZllWajb0OBuu+UasMpDzPyw0mSZK9tKbcbDpqbEdXyedr2Zy0nvut5/E+ftH6crNtl4yuZ7ae56pRa67neTa7m882qUa9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73nPe6ZNm7b1kc2bNx977LE9B/vytvKWpOF8kkSLuvHGG++8884VK1asWbPmS1/6Uu/xBQsW3HHHHQ888MB99903c+bM7ZzhrrvuOvTQQxctWrTNf5VOnDhxy5Ytb3rTmzZt2nTnv0jTdCAfCux2fvOb39x9993bvIP22GOPWbNm5Xn+4osv9v1t5S1JA4kkWtTnP//5iRMnjh8/vrOz89577+09Pn/+/EmTJrW1tXV1dS1evPjVV18tfReTJk065ZRT3vnOdx533HH9tGpoDsuXL69UKocffvg2xzs6OjZt2rRq1aq+n8pbkgYSSbSo8ePH9/xixIgR3d3dvcePPfbYnl8cccQRGzdufOyxx0rfxYoVK9atWzd8+PAPfehDda8Xmkm1Wq1UKps3b97m+Ouvv76zp/KWpIFEEi1qr7326v11URRvPN6zv9dqtZ7tvtcb9/3tGDFixEUXXfSzn/1szZo1/bFqaA49nyH1fJ60tRUrVtRqtfb29r6/rbwlaSCRBP/Ogw8+2POLBx54YJ999pk4ceKQIUMqlUrvh/xPPvlk74232ax73HHHHaNGjer9L+YXXnhhzz33HD169C5ZPuwWDjnkkClTplx++eVbH9yyZcuCBQtOO+20/fbbr+9vK29JGkgkwb8zd+7c1atXr1y5ct68eeedd97QoUP333//CRMmXHvtta+99trSpUtvvvnm3huPGDFizZo1L7/88tZnOPHEEw888MDPfvazL7300oMPPjhnzpzp06cPHz68EY8GGua666576KGHzjnnnEcffbS7u3v58uXTpk177rnnrrzyykql0ve3lbckDSSS4N+ZOnXqSSeddMwxx5x88sk9/x1crVYXLly4dOnSMWPGXHzxxZ/73Od6b3zBBRdcdtll06dP3/oMw4YNW7JkyRNPPPHWt7711FNPTZKk528FaCltbW3333//6NGjTz755JEjR55yyimHHHLIL3/5y7Fjx+7U28pbkgaqbv3dGAwcP3G6+9u4ceOSJUumTJkycuTIRq+F/pdlWaXZtPi+4S05yF7PzajW6AW0kDzPyw0mSWJ2F8x+8IMfrFQqd9555y6+X7O7ZrZJZVeUfLzp7KQZZzu6/t/f/a+9uHbJkjcfNveq/dsO2+HssjlpMz7e0rPsGi63AQAEfJIE/6rnR2aA3cTw/fb/4krfEEIj+SQJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAtWiKKLj9LM0TRu9BGhpWZZVmo19g8H0em5GtUYvoIVkL60pN5iOGtvRVfL9sGxOWs/95nlebjZJkuyKkrPp7Lpm63mu6nqeG/R46/katdRsk2rU66pR78FmfLwNmWXXcLkNACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAtWiKKLj9LM0TRu9BGhpWZZVmo19g8H0em5GtUYvoIV0dJV8TS+bk2YvrSk3m44aW89snuflZpMkya4oOZvOrmu2nue5rq9Rgx5vPV+jlpptUo16XTXje7AZ37+lZ9k1XG4DAAiIJACAgEgCAAiIJACAgEgCAAiIJACAgEgCAAiIJACAgEgCAAiIJACAgEgCAAiIJACAgEgCAAiIJACAgEgCAAiIJACAgEgCAAiIJACAQLUoiug4/SxN00YvAVpalmWVZmPfYDC9nptRrdELaCEdXSVf08vmpI2azfO83GySJI1ac3ZFyTWns5N6Zpvxa9RSs02qUa/JRr2PmnG2Ic8zu4bLbQAAAZEEABAQSQAAAZEEABAQSQAAAZEEABAQSQAAAZEEABAQSQAAAZEEABAQSQAAAZEEABAQSQAAAZEEABAQSQAAAZEEABAQSQAAAZEEABCoFkURHaefpWna6CVAS8uyrNJs7BsMptdzM6o1egEtJM/zcoNJkjTjbEdXyffwsjlpPbPZFSXXnM5O6plt1ONtxtdGQ2abVDO+F5pxtumeZ3YNl9sAAAIiCQAgIJIAAAIiCQAgIJIAAAIiCQAgIJIAAAIiCQAgIJIAAAIiCQAgIJIAAAIiCQAgIJIAAAIiCQAgIJIAAAIiCQAgIJIAAAIiCQAgUC2KIjpOP0vTtNFLgJaWZVml2dg3GEyv52ZUa/QCWkie5+UGkyQxa9ZsnbNNqqOr5N+Fy+akjZrNrij5NUpnJ42abbrnmV3D5TYAgIBIAgAIiCQAgIBIAgAIiCQAgIBIAgAIiCQAgIBIAgAIiCQAgIBIAgAIiCQAgIBIAgAIiCQAgIBIAgAIiCQAgIBIAgAIiCQAgIBIAgAIVIuiiI7Tz9I0bfQSoKVlWdboJQBNptboBbSQPM/LDSZJ0qjZ7IqSs+lss4N8tulezwA7y+U2AICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASALoT9VqtdFLAPqHSALoZzoJBgeRBND/dBIMAiIJACAgkgAGhA+ToNnVGr0AgEGbOz2DRVH094qAXcEnSQAAAZEEABBwuQ1gB3bqetnW1+ZcaIOmVvUe3jXSNG30EqClZVm2a+6oN5LsrtDsfJK06+R5Xm4wSZJGzWZXlJxNZ5sd5LNN93oG2Fm+Jwmg//kYCQYBkQTQzxQSDA4iCaA/KSQYNEQSAEBAJAEABEQSAEBAJAEABEQSAEBAJAEABEQSAEBAJAEABEQSAEBAJAEABEQSAEBAJAEABEQSAEBAJAEABEQSAECgWhRFdJx+lqZpo5cALS3LskYvAWgytUYvoIXkeV5uMEmSRs1mV5ScTWebHeSzTfd6BthZLrcBAAREEgBAQCQBAAREEgBAQCQBAAREEgBAQCQBAAREEgBAQCQBAAREEgBAQCQBAAREEgBAQCQBAAREEgBAQCQBAAREEgBAQCQBAAREEgBAoFoURXScfpamaaOXAC0ty7JGLwFoMrVGL6CF5HlebjBJkkbNZleUnE1nmx3ks033egbYWS63AQAERBIAQEAkAQAERBIAQEAkAQAERBIAQEAkAQAERBIAQEAkAQAERBIAQEAkAQAERBIAQEAkAQAERBIAQEAkAQAERBIAQEAkAQAERBIAQKBaFEV0nH6WpmmjlwAtLcuyRi8BaDK1Ri+gheR5Xm4wSZJGzWZXlJxNZ5sd5LNN93oG2FkutwEABEQSAEBAJAEABEQSAEBAJAEABEQSAEBAJAEABEQSAEBAJAEABEQSAEBAJAEABEQSAEBAJAEABEQSAEBAJAEABEQSAEBAJAEABEQSAECgWhRFdJx+lqZpo5cALS3LskYvAWgytUYvoIXkeV5uMEmSRs1mV5ScTWebHeSzTfd6BthZLrcBAAREEgBAQCQBAAREEgBAQCQBAAREEgBAQCQBAAREEgBAQCQBAAREEgBAQCQBAAREEgBAQCQBAAREEgBAQCQBAAREEgBAQCQBAAREEgBAoFoURXScfpamaaOXAC0ty7JGLwFoNgW7RJIkpb9GZs2arX+20XsA0HxcbgMACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAIBAtSiK6Dj9LE3TRi8BWlqWZY1eAtBsCnaJJElKf43MmjVb/2yj9wCg+bjcBgAQEEkAAAGRBAAQEEkAAAGRBAAQEEkAAAGRBAAQEEkAAAGRBAAQEEkAAAGRBAAQEEkAAAGRBAAQEEkAAAGRBAAQEEkAAAGRBAAQEEkAAIFqURTRcfpZmqaNXgK0tCzLGr0EoNkU7BJJkpT+Gpk1a7b+2UbvAUDzcbkNACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAtWiKKLjAAAtzSdJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAD9HUkzZ86s/nHnnHPO9m8zderU3lOtXbt27ty5hx122N577z169Ojjjz/+61//+ubNm/t+R9u47bbbqtXqwoULe37b2dlZrVa7urq2udnTTz9drVYvuuiint/OmDFj6zPvueee++677zHHHPPNb35zm0f9xBNPbHOqFStWVKvV2bNnl1swALBbqVV2A88///zRRx/dmx0bNmz46b/44Q9/+L/+1/+qVqv9dUdf+MIXTj311MMOO6yPt9+yZcvLL7/883+xbt26uXPn9tdKAIDB/EnSVVddVfybW2+9tVKpLFq0qPfI4sWLe2+5evXq4g2WLl3a86df+9rXnnjiiWnTpi1btuzVV19dv379P//zPx955JFZln3/+9/fqTvavo0bN3Z2dvZ+QPXHPPvssz1n3rJlyyuvvPKd73xn2LBhX/7yl19//fV+f2YAgN3TbvE9SStWrKjVaosXL37nO985fPjwUaNGnXTSSbfffnulUrnjjjv68Y4+9alP/exnP/u7v/u7Pt6+Wq2OGDHiox/96Ec+8pHf//73jz76aD8u5oYbbqhWq1dddVU/nhMAGFSR1NHRsWnTpizLtj44fvz4oiiuueaafryjSy+9tL29/Qtf+MLDDz+8U4M9nyHtueee/bgYAGB3tosiacKECW/8/uW77rqr509nzZp1wgknfPSjH21ra5sxY8Z111330EMPDcQyhg8fvmjRou7u7r5cdKtUKps3b16zZs1Xv/rVW2655U/+5E8OPfTQflxMZ2dnURQzZ87sx3MCAIPqk6R99tnnrrvuWrx4cUdHR57n559//qRJkyZMmHDjjTf2+32dcMIJn/70p3/+859fccUVf+w2Bx10UE/G1Wq1cePGzZo1a/PmzZdeeqlPkgCgdeyiSAq/cfvEE0/svcGee+559tlnZ1m2du3alStXLlq06IADDujs7PzKV77S74u59NJL3/a2t33xi19cvnz59m+5xx57jBkzZsqUKXmen3vuuT0Ha7X//0cCu7u7t7lxz5GePwUAmt1u8UnSNtrb2zs7O3/yk58ceeSRl1xySb+ff++9997+Rbfen27bvHnzunXrli5devrpp/f+6ahRoyqVynPPPbfN1G9/+9vePwUAml3jI+mZZ56pVqszZszY5nitVnvHO96xfv36jRs39vudvvvd7/7MZz5z7733vvGfl9yhCRMmhD9213Okra2t/5YJADRM468NjRs37l3vetf1118/bNiws88+u62tbdSoUc8888z//t//+9Zbbz366KOHDBkyEPf75S9/+R//8R9L/PTcySefvNdeey1YsGDUqFFnn332m9/85t/97nff/e53r7zyyuHDh7/vfe8biNUCAC30023VavWVV16pVCrXX3/96NGjr7766uOPP/7AAw/ce++929vbP/nJT9ZqtYH7Z4R6LrqV+Oe8x40b99//+3/fuHHjnDlzxo4du9deex188MGzZ8/etGnT3//937/5zW/u43n8O0kAsDvbXf6dpIceeujCCy+cNGnSvvvuO2TIkPHjx5933nm/+tWvJk+ePHD3++53v3vWrFklBv/mb/4mz/MPfOADBxxwwF577XXQQQedeuqpS5cuPf/88wdgmQBAA1SLomjE/QIA7NZ2i0+SAAB2NyIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkoDGWLdu3YoVKwbffQGDhkgCdsK0adOqkaVLl+7sqaZOnXrPPfe88XiSJJ2dnf203h3cF8B2iCRgJ9x2223Fv1i0aNGIESN6fl0UxdSpU3f2VH/4wx8GZo0Nvi9g0BBJQL959tlnp02bts8++7zlLW/57Gc/25sm3/jGN9ra2kaOHHnUUUfdfvvtlUrlxBNPfOSRR6ZPnz5jxow/dra1a9dWq9Wrr756/Pjxw4YN+8AHPvDMM8/0Hv/mN7958MEHjxo16txzz+25o6effrparT7xxBM941dcccWxxx7bx/sCeCORBPSbv/zLvxw5cuQTTzzxox/96N577/2v//W/ViqVBx98cO7cubfddtvatWs/85nPnHXWWS+++OJdd9116KGHLlq0aOHChds/54033njnnXeuWLFizZo1X/rSl3qPL1iw4I477njggQfuu+++mTNnbucMfb8vgK2JJKB//PjHP162bNm11167//77t7W1feUrX/mf//N/btiw4Te/+U2lUhkxYsTQoUPPOeecDRs27Lfffn0/7ec///mJEyeOHz++s7Pz3nvv7T0+f/78SZMmtbW1dXV1LV68+NVXXx2YhwW0LpEE9I/ly5e/9tprQ4cO7flW7qOOOmrLli2PP/74ySeffPTRRx9++OFHH330xRdf/PTTT+/UacePH9/zixEjRnR3d/ce77mUVqlUjjjiiI0bNz722GP9+mgARBLQTzZt2tTe3l78e29/+9uHDRv2wx/+8Cc/+cmUKVO+/e1vH3nkkStXruz7affaa6/eXxdF8cbjmzdvrlQqtVqtWq1uPdhzHKA0kQT0j8MOO2z16tXhB0XVavX444+/7LLLli9fPnz48H/6p3/qOVjP3T344IM9v3jggQf22WefiRMnDhkypFKp9F53e/LJJ7deQD33BbQmkQT0j/e9733vfOc7p0+f/tRTTz3zzDOzZs1661vf+vrrr3/7298eP378r3/9640bN959993PPffcu971rp7LZ2vWrHn55ZfL3d3cuXNXr169cuXKefPmnXfeeUOHDt1///0nTJhw7bXXvvbaa0uXLr355pt7b1znfQGtSSQB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"
          },
          {
            "type": "input_text",
            "text": "Above is a visual representation of all the training examples and the test input. Each grid cell is colored according to its value (0-9), with clear labels and arrows showing input\u2192output transformations. Use both the textual and visual information to understand the pattern."
          }
        ]
      },
      {
        "type": "message",
        "role": "assistant",
        "content": [
          "Let's analyze the transformation step by step:\n\n### Observations\n\n1. **Output Size**\n   - Every output is always **8\u00d716**, regardless of the input's size.\n\n2. **Background Color**\n   - The main color in the big block region (bottom in input) becomes the background color in the output.\n\n3. **Blue Crosses**\n   - There are light blue crosses in fixed positions in the output:\n     - Top left, top right, bottom left, bottom right, and roughly center, but with some shift for odd-sized blocks.\n   - These \"crosses\" are sized 3x3, with the pattern:\n     ```\n     0 x 0\n     x x x\n     0 x 0\n     ```\n     where x = secondary color (light blue)\n\n4. **Positions**\n   - The crosses are placed inside the output, not touching the border: offsets ~[1,1], [1,14], [6,1], [6,14], etc.\n\n5. **Secondary Color**\n   - The color for the cross is taken from the \"small secondary region\" (cyan in most cases, but matching the 2nd block).\n   - Take the color appearing in the small upper rectangle in the top right of the input (not the main big block).\n\n6. **Grid Construction**\n   - The output grid is filled with the main big block's color.\n   - Crosses are overlaid at the fixed positions.\n\n### Hypothesis\n\nAlgorithm steps:\n- Find the color that dominates the big block (use bottom half or biggest nonzero area).\n- Find the color in the \"secondary\" (usually a smaller area in the upper right, just above big block).\n- Fill an 8x16 matrix with the main color.\n- Overlay 3x3 \"crosses\" of the secondary color at several canonical positions.\n\n### Implementation Steps\n\n- For color detection: ignore zeros (black).\n- For the largest block, pick the most frequent nonzero color in the lower part.\n- For the secondary color, find the most frequent nonzero color in the upper-right small region.\n\n### Crosses' positions\nBased on outputs:\n- Row offsets: [1, 1, 6, 6]\n- Col offsets: [1, 14, 1, 14]\n\n### Final Algorithm\n- Main color: most frequent nonzero in lower part (big block)\n- Cross color: most frequent nonzero in upper-right area (besides main color)\n- Output: 8x16 of main color, overlay 3x3 crosses of cross color at set positions\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n    \n    arr = np.array(grid)\n    H, W = arr.shape\n    \n    # Get the bottom half (assume the big block is lower\u2019s main color)\n    # We'll try to skip zero (black) and count the dominant color\n    values, counts = np.unique(arr[arr != 0], return_counts=True)\n    main_color = values[np.argmax(counts)]\n    \n    # Find secondary color from upper area (ignore main color, zeros; take top 6 rows, right half)\n    upper = arr[:6, :]\n    candidates = upper[(upper != 0) & (upper != main_color)]\n    if len(candidates) == 0:\n        # fallback: just pick any other nonzero color\n        candidates = arr[(arr != 0) & (arr != main_color)]\n    if len(candidates) == 0:\n        cross_color = main_color  # fallback\n    else:\n        vals, cts = np.unique(candidates, return_counts=True)\n        cross_color = vals[np.argmax(cts)]\n    \n    # Make 8x16 filled with main color\n    out = np.full((8, 16), main_color, dtype=int)\n    \n    # Place crosses at these four corners (from outputs):\n    positions = [\n        (1, 1),   # top left\n        (1, 14),  # top right\n        (6, 1),   # bottom left\n        (6, 14),  # bottom right\n    ]\n    \n    # In output3, center cross at (3,7). Let's add this as center for all.\n    positions.append((3, 7))\n    \n    # Draw cross centered at (r, c)\n    def draw_cross(mat, r, c, color):\n        if 0 <= r < 8 and 0 <= c < 16:\n            mat[r, c] = color\n        if r-1 >= 0:\n            mat[r-1, c] = color\n        if r+1 < 8:\n            mat[r+1, c] = color\n        if c-1 >= 0:\n            mat[r, c-1] = color\n        if c+1 < 16:\n            mat[r, c+1] = color\n    \n    for r, c in positions:\n        draw_cross(out, r, c, cross_color)\n    \n    return out.tolist()\n```\n"
        ]
      }
    ],
    "all_responses": [
      {
        "id": "resp_6870025b774481a28ccb7b7b727672ce0850d8ab1abf7290",
        "model": "gpt-4.1-2025-04-14",
        "usage": {
          "input_tokens": 5290,
          "output_tokens": 1058,
          "total_tokens": 6348
        },
        "output": [
          {
            "type": "message",
            "content": [
              "Let's analyze the transformation step by step:\n\n### Observations\n\n1. **Output Size**\n   - Every output is always **8\u00d716**, regardless of the input's size.\n\n2. **Background Color**\n   - The main color in the big block region (bottom in input) becomes the background color in the output.\n\n3. **Blue Crosses**\n   - There are light blue crosses in fixed positions in the output:\n     - Top left, top right, bottom left, bottom right, and roughly center, but with some shift for odd-sized blocks.\n   - These \"crosses\" are sized 3x3, with the pattern:\n     ```\n     0 x 0\n     x x x\n     0 x 0\n     ```\n     where x = secondary color (light blue)\n\n4. **Positions**\n   - The crosses are placed inside the output, not touching the border: offsets ~[1,1], [1,14], [6,1], [6,14], etc.\n\n5. **Secondary Color**\n   - The color for the cross is taken from the \"small secondary region\" (cyan in most cases, but matching the 2nd block).\n   - Take the color appearing in the small upper rectangle in the top right of the input (not the main big block).\n\n6. **Grid Construction**\n   - The output grid is filled with the main big block's color.\n   - Crosses are overlaid at the fixed positions.\n\n### Hypothesis\n\nAlgorithm steps:\n- Find the color that dominates the big block (use bottom half or biggest nonzero area).\n- Find the color in the \"secondary\" (usually a smaller area in the upper right, just above big block).\n- Fill an 8x16 matrix with the main color.\n- Overlay 3x3 \"crosses\" of the secondary color at several canonical positions.\n\n### Implementation Steps\n\n- For color detection: ignore zeros (black).\n- For the largest block, pick the most frequent nonzero color in the lower part.\n- For the secondary color, find the most frequent nonzero color in the upper-right small region.\n\n### Crosses' positions\nBased on outputs:\n- Row offsets: [1, 1, 6, 6]\n- Col offsets: [1, 14, 1, 14]\n\n### Final Algorithm\n- Main color: most frequent nonzero in lower part (big block)\n- Cross color: most frequent nonzero in upper-right area (besides main color)\n- Output: 8x16 of main color, overlay 3x3 crosses of cross color at set positions\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n    \n    arr = np.array(grid)\n    H, W = arr.shape\n    \n    # Get the bottom half (assume the big block is lower\u2019s main color)\n    # We'll try to skip zero (black) and count the dominant color\n    values, counts = np.unique(arr[arr != 0], return_counts=True)\n    main_color = values[np.argmax(counts)]\n    \n    # Find secondary color from upper area (ignore main color, zeros; take top 6 rows, right half)\n    upper = arr[:6, :]\n    candidates = upper[(upper != 0) & (upper != main_color)]\n    if len(candidates) == 0:\n        # fallback: just pick any other nonzero color\n        candidates = arr[(arr != 0) & (arr != main_color)]\n    if len(candidates) == 0:\n        cross_color = main_color  # fallback\n    else:\n        vals, cts = np.unique(candidates, return_counts=True)\n        cross_color = vals[np.argmax(cts)]\n    \n    # Make 8x16 filled with main color\n    out = np.full((8, 16), main_color, dtype=int)\n    \n    # Place crosses at these four corners (from outputs):\n    positions = [\n        (1, 1),   # top left\n        (1, 14),  # top right\n        (6, 1),   # bottom left\n        (6, 14),  # bottom right\n    ]\n    \n    # In output3, center cross at (3,7). Let's add this as center for all.\n    positions.append((3, 7))\n    \n    # Draw cross centered at (r, c)\n    def draw_cross(mat, r, c, color):\n        if 0 <= r < 8 and 0 <= c < 16:\n            mat[r, c] = color\n        if r-1 >= 0:\n            mat[r-1, c] = color\n        if r+1 < 8:\n            mat[r+1, c] = color\n        if c-1 >= 0:\n            mat[r, c-1] = color\n        if c+1 < 16:\n            mat[r, c+1] = color\n    \n    for r, c in positions:\n        draw_cross(out, r, c, cross_color)\n    \n    return out.tolist()\n```\n"
            ]
          }
        ]
      }
    ]
  }
}