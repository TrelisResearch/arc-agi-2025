{
  "task_id": "963f59bc",
  "model": "gpt-4.1-mini",
  "reasoning_effort": "N/A",
  "api_type": "responses_api_multiturn",
  "program": "def transform(grid):\n    import numpy as np\n    from scipy.ndimage import label\n\n    arr = np.array(grid)\n    target_size = 11\n\n    norm = np.zeros((target_size, target_size), dtype=int)\n    norm[:arr.shape[0], :arr.shape[1]] = arr[:target_size, :target_size]\n    arr = norm\n\n    output = np.zeros_like(arr)\n    blue_color = 1\n    output[arr == blue_color] = blue_color\n\n    quadrants = {\n        'TL': (0, 5, 0, 5),\n        'TR': (0, 5, 6, 10),\n        'BL': (6, 10, 0, 5),\n        'BR': (6, 10, 6, 10)\n    }\n    quadrant_map = {'TL': 'TR', 'TR': 'BL', 'BL': 'BR', 'BR': 'TL'}\n\n    def get_quadrant(r, c):\n        for q, (rs, re, cs, ce) in quadrants.items():\n            if rs <= r <= re and cs <= c <= ce:\n                return q\n        return None\n\n    colors = set(np.unique(arr))\n    colors.discard(0)\n    colors.discard(blue_color)\n\n    for color in colors:\n        mask = (arr == color)\n        if not np.any(mask):\n            continue\n\n        labeled, num_features = label(mask)\n        for comp_id in range(1, num_features + 1):\n            comp_mask = (labeled == comp_id)\n            rows, cols = np.where(comp_mask)\n            min_r, max_r = rows.min(), rows.max()\n            min_c, max_c = cols.min(), cols.max()\n\n            # Copy original pixels\n            output[rows, cols] = color\n\n            centroid_r = int(round(rows.mean()))\n            centroid_c = int(round(cols.mean()))\n            orig_quad = get_quadrant(centroid_r, centroid_c)\n            target_quad = quadrant_map[orig_quad]\n\n            r_start, r_end, c_start, c_end = quadrants[target_quad]\n            cluster_height = max_r - min_r + 1\n            cluster_width = max_c - min_c + 1\n\n            orig_r_start, orig_r_end, orig_c_start, orig_c_end = quadrants[orig_quad]\n            offset_r = min_r - orig_r_start\n            offset_c = min_c - orig_c_start\n\n            new_min_r = r_start + offset_r\n            new_min_c = c_start + offset_c\n\n            if new_min_r < r_start:\n                new_min_r = r_start\n            if new_min_c < c_start:\n                new_min_c = c_start\n            if new_min_r + cluster_height - 1 > r_end:\n                new_min_r = r_end - cluster_height + 1\n            if new_min_c + cluster_width - 1 > c_end:\n                new_min_c = c_end - cluster_width + 1\n\n            for r, c in zip(rows, cols):\n                rr = new_min_r + (r - min_r)\n                cc = new_min_c + (c - min_c)\n                if 0 <= rr < target_size and 0 <= cc < target_size:\n                    if output[rr, cc] != blue_color:\n                        output[rr, cc] = color\n\n    return output.tolist()",
  "execution_error": "Max turns reached",
  "timed_out": false,
  "tokens_used": 239156,
  "request_cost": 0.113552,
  "turns_used": 8,
  "raw_response": {
    "id": "resp_686f8b585ebc819dba7e371b4dd1af1506ed706914c182fd",
    "model": "gpt-4.1-mini-2025-04-14",
    "usage": {
      "input_tokens": 51648,
      "output_tokens": 1779,
      "total_tokens": 53427
    },
    "output": [
      {
        "type": "message",
        "content": [
          "The core approach has been stable and correct in essence:\n\n- Keep blue cluster fixed.\n- Duplicate every other color cluster exactly.\n- Place duplicated cluster in a fixed opposite quadrant, preserving relative cluster shape and internal offsets.\n- Output fixed 11\u00d711 grid.\n\nThe main limitation is pixel accuracy\u2014not perfect\u2014likely due to slight offsets or cluster positioning near boundaries.\n\n---\n\n**Further refinements:**\n\n1. Use **connected component labeling** to isolate clusters precisely, avoid mixing different clusters of same color.\n2. Move entire connected cluster as a unit, rather than all pixels of a color (better if multiple clusters per color).\n3. Attempt to place duplicates with minimal shifting when quadrant boundary constraints force clamping.\n4. Avoid placing duplicates overlapping original clusters.\n5. Preserve original blue cluster exactly.\n\n---\n\n### Here is an improved solution incorporating connected component analysis for more precise cluster separation:\n\n```python\ndef transform(grid):\n    import numpy as np\n    from scipy.ndimage import label\n\n    arr = np.array(grid)\n    target_size = 11\n\n    norm = np.zeros((target_size, target_size), dtype=int)\n    norm[:arr.shape[0], :arr.shape[1]] = arr[:target_size, :target_size]\n    arr = norm\n\n    output = np.zeros_like(arr)\n    blue_color = 1\n    output[arr == blue_color] = blue_color\n\n    # Define quadrants (inclusive)\n    quadrants = {\n        'TL': (0, 5, 0, 5),\n        'TR': (0, 5, 6, 10),\n        'BL': (6, 10, 0, 5),\n        'BR': (6, 10, 6, 10)\n    }\n    quadrant_map = {'TL': 'TR', 'TR': 'BL', 'BL': 'BR', 'BR': 'TL'}\n\n    def get_quadrant(r, c):\n        for q, (rs, re, cs, ce) in quadrants.items():\n            if rs <= r <= re and cs <= c <= ce:\n                return q\n        return None\n\n    # Process each nonzero color except blue\n    colors = set(np.unique(arr))\n    colors.discard(0)\n    colors.discard(blue_color)\n\n    for color in colors:\n        mask = (arr == color)\n        if not np.any(mask):\n            continue\n\n        # Label connected components for this color\n        labeled, num_features = label(mask)\n        for comp_id in range(1, num_features + 1):\n            comp_mask = (labeled == comp_id)\n            rows, cols = np.where(comp_mask)\n\n            min_r, max_r = rows.min(), rows.max()\n            min_c, max_c = cols.min(), cols.max()\n\n            # Copy original cluster pixels exactly\n            output[rows, cols] = color\n\n            centroid_r = int(round(rows.mean()))\n            centroid_c = int(round(cols.mean()))\n            orig_quad = get_quadrant(centroid_r, centroid_c)\n            target_quad = quadrant_map[orig_quad]\n\n            r_start, r_end, c_start, c_end = quadrants[target_quad]\n\n            cluster_height = max_r - min_r + 1\n            cluster_width = max_c - min_c + 1\n\n            orig_r_start, orig_r_end, orig_c_start, orig_c_end = quadrants[orig_quad]\n            offset_r = min_r - orig_r_start\n            offset_c = min_c - orig_c_start\n\n            # Calculate tentative new top-left position for duplicate cluster\n            new_min_r = r_start + offset_r\n            new_min_c = c_start + offset_c\n\n            # Clamp to fit cluster inside target quadrant\n            if new_min_r < r_start:\n                new_min_r = r_start\n            if new_min_c < c_start:\n                new_min_c = c_start\n            if new_min_r + cluster_height - 1 > r_end:\n                new_min_r = r_end - cluster_height + 1\n            if new_min_c + cluster_width - 1 > c_end:\n                new_min_c = c_end - cluster_width + 1\n\n            # Create output mask for duplicate - write pixels without overwriting blue pixels\n            for r, c in zip(rows, cols):\n                rr = new_min_r + (r - min_r)\n                cc = new_min_c + (c - min_c)\n                if 0 <= rr < target_size and 0 <= cc < target_size:\n                    if output[rr, cc] != blue_color:\n                        output[rr, cc] = color\n\n    return output.tolist()\n```\n\n---\n\n**Summary of improvements:**\n\n- Used `scipy.ndimage.label` to separate connected clusters within the same color.\n- Each connected cluster moved and duplicated independently.\n- Keeps blue shape unchanged.\n- Duplicates each cluster preserving shape and relative position.\n- Duplicates copied to corresponding mapped quadrant, clamped to fit.\n- Avoids overwriting blue pixels.\n\n---\n\nThis approach should fix errors from merging multiple clusters of one color and better preserve positions.\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n    from scipy.ndimage import label\n\n    arr = np.array(grid)\n    target_size = 11\n\n    norm = np.zeros((target_size, target_size), dtype=int)\n    norm[:arr.shape[0], :arr.shape[1]] = arr[:target_size, :target_size]\n    arr = norm\n\n    output = np.zeros_like(arr)\n    blue_color = 1\n    output[arr == blue_color] = blue_color\n\n    quadrants = {\n        'TL': (0, 5, 0, 5),\n        'TR': (0, 5, 6, 10),\n        'BL': (6, 10, 0, 5),\n        'BR': (6, 10, 6, 10)\n    }\n    quadrant_map = {'TL': 'TR', 'TR': 'BL', 'BL': 'BR', 'BR': 'TL'}\n\n    def get_quadrant(r, c):\n        for q, (rs, re, cs, ce) in quadrants.items():\n            if rs <= r <= re and cs <= c <= ce:\n                return q\n        return None\n\n    colors = set(np.unique(arr))\n    colors.discard(0)\n    colors.discard(blue_color)\n\n    for color in colors:\n        mask = (arr == color)\n        if not np.any(mask):\n            continue\n\n        labeled, num_features = label(mask)\n        for comp_id in range(1, num_features + 1):\n            comp_mask = (labeled == comp_id)\n            rows, cols = np.where(comp_mask)\n            min_r, max_r = rows.min(), rows.max()\n            min_c, max_c = cols.min(), cols.max()\n\n            # Copy original pixels\n            output[rows, cols] = color\n\n            centroid_r = int(round(rows.mean()))\n            centroid_c = int(round(cols.mean()))\n            orig_quad = get_quadrant(centroid_r, centroid_c)\n            target_quad = quadrant_map[orig_quad]\n\n            r_start, r_end, c_start, c_end = quadrants[target_quad]\n            cluster_height = max_r - min_r + 1\n            cluster_width = max_c - min_c + 1\n\n            orig_r_start, orig_r_end, orig_c_start, orig_c_end = quadrants[orig_quad]\n            offset_r = min_r - orig_r_start\n            offset_c = min_c - orig_c_start\n\n            new_min_r = r_start + offset_r\n            new_min_c = c_start + offset_c\n\n            if new_min_r < r_start:\n                new_min_r = r_start\n            if new_min_c < c_start:\n                new_min_c = c_start\n            if new_min_r + cluster_height - 1 > r_end:\n                new_min_r = r_end - cluster_height + 1\n            if new_min_c + cluster_width - 1 > c_end:\n                new_min_c = c_end - cluster_width + 1\n\n            for r, c in zip(rows, cols):\n                rr = new_min_r + (r - min_r)\n                cc = new_min_c + (c - min_c)\n                if 0 <= rr < target_size and 0 <= cc < target_size:\n                    if output[rr, cc] != blue_color:\n                        output[rr, cc] = color\n\n    return output.tolist()\n```\n"
        ]
      }
    ]
  },
  "score": {
    "correct": false,
    "pixel_accuracy": 0.0,
    "total_pixels": 224,
    "correct_pixels": 0,
    "error": "Max turns reached"
  },
  "actual_output": [
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      3,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      3,
      3,
      0,
      0,
      0
    ],
    [
      1,
      1,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      3,
      0,
      3,
      3,
      0
    ],
    [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      3,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      6,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      6,
      6,
      0,
      6,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      6,
      6,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      6,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]
  ],
  "api_success": true,
  "multiturn_data": {
    "turn_details": [
      {
        "turn_number": 1,
        "timestamp": "2025-07-10T10:40:43.028940",
        "input_tokens": 4940,
        "output_tokens": 1376,
        "turn_cost": 0.0041776,
        "program_extracted": true,
        "program": "def transform(grid):\n    import numpy as np\n\n    # Normalize input to 11x11 (pad or crop)\n    rows = len(grid)\n    cols = len(grid[0])\n    target_size = 11\n    arr = np.zeros((target_size, target_size), dtype=int)\n    # Crop or pad top-left corner\n    min_rows = min(rows, target_size)\n    min_cols = min(cols, target_size)\n    arr[:min_rows, :min_cols] = np.array(grid)[:min_rows, :min_cols]\n\n    output = np.zeros_like(arr)\n\n    # Blue color is considered 1 (based on examples)\n    # Keep all blue pixels as is\n    blue_mask = (arr == 1)\n    output[blue_mask] = 1\n\n    # Find all colors present except 0 and blue(1)\n    colors = set(np.unique(arr))\n    colors.discard(0)\n    if 1 in colors:\n        colors.discard(1)\n\n    # For each secondary color cluster, find bounding boxes, then flip horizontally and place near opposite corner\n    for color in colors:\n        mask = (arr == color)\n        if not np.any(mask):\n            continue\n\n        # Find bounding box of cluster for this color\n        rows_idx, cols_idx = np.where(mask)\n        min_r, max_r = rows_idx.min(), rows_idx.max()\n        min_c, max_c = cols_idx.min(), cols_idx.max()\n\n        cluster = arr[min_r:max_r+1, min_c:max_c+1]\n        # Only keep this cluster pixels equal to color, others zeroed\n        cluster_mask = (cluster == color)\n        cluster_shape = np.where(cluster_mask, color, 0)\n\n        # Flip cluster horizontally\n        flipped = np.fliplr(cluster_shape)\n\n        # Decide placement for flipped cluster:\n        # Place it in bottom-left quadrant or top-right quadrant depending on where original cluster is.\n        # If original is in top half, place in bottom half; else top half\n        # If original is in left half, place in right half; else left half\n\n        original_center_r = (min_r + max_r)//2\n        original_center_c = (min_c + max_c)//2\n        hr, hc = flipped.shape\n\n        if original_center_r < target_size // 2:\n            # place in bottom half\n            new_r = target_size - hr - 1\n        else:\n            # top half\n            new_r = 1\n\n        if original_center_c < target_size // 2:\n            # place in right half\n            new_c = target_size - hc - 1\n        else:\n            # left half\n            new_c = 1\n\n        # Bound check to avoid overflow\n        new_r = max(0, min(new_r, target_size - hr))\n        new_c = max(0, min(new_c, target_size - hc))\n\n        # Paste flipped cluster into output (overlay, preserve existing blue)\n        for rr in range(hr):\n            for cc in range(hc):\n                val = flipped[rr, cc]\n                if val != 0:\n                    output[new_r + rr, new_c + cc] = val\n\n        # Also keep original secondary cluster pixels as is:\n        for rr in range(min_r, max_r+1):\n            for cc in range(min_c, max_c+1):\n                if arr[rr, cc]==color:\n                    output[rr, cc] = color\n\n    return output.tolist()",
        "training_feedback": {
          "feedback_messages": [
            {
              "type": "input_text",
              "text": "Training results: 0/4 examples solved, 76.2% pixel accuracy - Good partial progress! Your approach is capturing some patterns. Next, try to identify a transformation that solves at least one of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[1, 1, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 1, 1, 1, 0, 3, 3, 3, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 1, 1, 1, 0, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0, 0, 0, 8, 0], [0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 86.0%\n\nTraining Example 2 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 1, 0, 0, 0, 0, 0, 0, 6, 0], [0, 1, 1, 1, 1, 0, 0, 6, 6, 6, 6], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 6, 0], [0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 86.4%\n\nTraining Example 3 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 77.8%\n\nTraining Example 4 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 8, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 61.0%\n\n\u26a0\ufe0f  GRID SIZE ERROR: One or more of your output grids are incorrect in size. They should ALL be 11\u00d711 for this task.\n\n"
            },
            {
              "type": "input_image",
              "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAmcAAATYCAIAAADVnPfcAABQQ0lEQVR4nO3de5RU5Z3o711IN6Jgo6ioXLwhrTkoIl4Qkahw1kEQrRIwJl4CwcTLeANBZcboiUsiCtHExKAnKIro6GisRg0SNEGICURGmQjiBQEVEA2iDSLQ3PZvmfpNLwZs8lJN9a6G51n80Vbvb+3dRb183Luqu1NxHEcAQIAGIRsBAKoJADtANQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIA6qebVV1+dqtnFF1/8jduUlpYedNBB55577htvvLHtfb700kupVGq//fZbt27dVp965plnUqnU2LFjc/85YMCAVCo1atSorTZbsmRJKpW65ZZbajOVs27dugcffPDMM8885JBDGjVqdMghh/Tv3/9Pf/rTdh6TW265paYHZO7cudt/0Hr06PFPH9jqbS677LItb88dXt++fWfMmLHl8aTT6a02O/zww6+99tovvvhihx78nM8+++yOO+7o2LFjWVnZ3nvvffLJJ48dO3bLX5uT291W46+//voBBxzQtGnTqVOnbuehAyh+CZxrbtiw4dNPP33++efPPPPMhQsXbvXZhx9+OIqiL7744qmnngq5t1tvvfWdd97Z0WMImfrggw9OPfXUK6644pVXXlm2bNn69euXLVv2zDPPdOvW7Z577omKTO7wnn322a5duz7++OPb2eyDDz745S9/2bNnz82bN+/Qgz9jxowOHTr8+Mc//q//+q9Vq1atWbNm1qxZP/zhDwcNGrSdA/vjH/945plnbtq06eWXXz7zzDNr8SUC1PNq/upXv4r/29NPPx1F0bhx46pvmTBhQvWWixYtqr593bp1b7/99ve+971Vq1aNGTNmyzusrKysqKjo37//fvvt98ADD4Qcw/r16wcMGLBp06YdOvJ/OrVhw4Z+/fr913/9V5cuXZ577rnPPvtsw4YNH3300a9//ev99tvvxhtvzJ041mT27NnxNtq3b/+ND0i1l19+ecs7Cdlm2bJludvXrl37/vvv33zzzXEc/+AHP/jwww+33Gzt2rVbPvg9evR47bXXXnrppfAH/+9//3smk/n444+/+93vzpw5c9WqVZ9//nlFRcURRxwxbty4Bx988Bsfh2w226tXr7322uuVV1455ZRTtvOIAdQLCZxrNmrU6Oijj77rrruiKNrqXPOJJ55Yt27d5ZdfPnDgwJkzZ7755pv/9N6uueaav/71rz/72c926Bj+6dSjjz76+uuv9+jRY/r06X369GnevHnDhg1bt2595ZVXPvvss5s2bfr3f//3qJjsueeeRx555J133nnrrbeuX7/+5z//+XYe/Ouvvz5X3PAH/5577vn0008HDx78xBNPnHLKKU2bNt13333PO++8adOm7b333vfcc8+2v978oYce6t+//4EHHvinP/3puOOOq779kUceSaVSv/rVr3bqAwCwi1azqqrqrbfeGjJkSBRF7dq12/JT48aNO+aYY84666wrr7xyjz32CDnd/OlPf9q2bdtbb7317bffDj+Gfzr1xBNPpFKp//f//t8ee+yx1ae+/e1vz5s374477oiK0g033LDXXnv9/ve//8bPbtiw4b333rvvvvsaNmz47W9/O/zB/4//+I/GjRvffvvtW91hq1atXn311VdeeSWVSm15+913333ZZZcdccQRr7766lFHHbXzvj6A3aCahx9+ePUbUvbcc8/27ds//fTT+++//3XXXVe9zdy5c//zP/9z2LBhqVTqyCOP7N+//+OPP7569ert3/Nee+01bty4DRs27NB12n86NXv27GOOOebwww//xvFjjjlmq0hspWPHjlu9i+fVV1+t6QGp9sorr+zoNttq2rTpUUcdtdVJfOPGjXPjpaWl5eXlf/7znx999NEtv7rtP/gbNmz44IMPTj755CZNmmy7x+OPP/7ggw/e8pYbb7zxpptuiqLo9NNPb9OmzVbbDxgwII7jq6++evtfCEARSuY7T1q2bPmDH/zgb3/720EHHVR948MPP9yyZcuLLroo95/Dhw//8ssvQy6Edu3a9dprr33ttddGjx4dfgzbmdqwYUNlZWWLFi22vHGr97UedthhUbFq3rx51T/UtMGmTZtmzpy5YcOGwAe/srIyjuPmzZsHHsAvf/nLU089tUePHg8//PCzzz5bu68GYPerZu6NLevXr3/yySdzJ0MjR4485JBDqjfYsGHDhAkTli5d2qhRo1yWOnToEMdx4HuCfvrTnx511FG33XbbvHnzwo+qpqmSkpKmTZsuX748yte27wbq2rXrP32nzxlnnLGj23yjL774oqSkpFGjRtu+G2j9+vULFy78l3/5l1/+8pdDhw4NfPD322+/Bg0ahD8gAwcOfOWVV8aPH7/ffvv98Ic/XLp0aeAgQJGr03PNkpKS73znO0899dS0adN69uy55Xf1vfDCC9/4j/Ibb7wxa9asf3rPjRs3zuM67Xamjj322Hnz5n300Uff+IbhTp06RcVq9erVc+fOPeaYY77xsyUlJYcffvjo0aPbt2//yCOPBD74e+yxxzHHHPOf//mfa9as2XazO++889JLL/3444+rb/n1r39dWlp68MEH/+pXv/r8888vvfTSbb/LBaA+SuAK7dlnn33NNde88cYb1ec6uSuEe+6558qVK7c8r/rLX/4SRVFN39WwldNOO+26666bNWvWtj/BII+piy66aPPmzVddddU3Nnjb94sWj3vvvXfDhg09e/bc/mYNGjRYvXr1xo0bAx/8dDq9du3a//t//+9W9/PBBx/cfffdL7zwwjdev/3ud7/br1+/P/7xjzt08RygaCXzuuZPf/rTNm3ajBkz5q9//WsURZ988snkyZP79Omzzz77bLnZqaeeWl5e/u///u8rV64MudsRI0YcddRRv/71r3foYL5x6rLLLuvUqdPvfve7k08++T/+4z8++eSTDRs25H7KQe/evd94440GDYrrhxFWVVW9++67t9xyy09+8pO99tqrpvfaxHG8ZMmSYcOGvfnmmx07dmzYsGHggz948ODmzZuPGjXq0ksv/c///M+1a9d++umnTzzxxBlnnFFZWTls2LAtLwhvacyYMS1atLjllltef/31wnzpAHUnmX/6995771/+8pebN2++/PLLN27cOH78+I0bN1a/FWVL3//+99esWfPYY4+FX3Hd/rtbA6dKS0srKipOPfXUN9544zvf+c7BBx9cWlqa+4l6kyZNKi8vD/zRRTX5xvfHplKpLd8zHLLNwQcfXP3O5KOPPnrEiBG5Hx/YunXrrb7G3GYNGjRo3br16NGjGzRokPvmmcAHv3nz5k899VTTpk0fe+yxk046aa+99jrooIMuuuiiDz/8MJPJ3HjjjTV9pfvvv/9vfvObDRs2fO973/vqq698vyZQryV2wnTuueem0+m//e1vP//5zx955JF999337LPP3nazSy+9tEGDBoEXaXNXXHPfwr9DvnGqVatWf/rTnyZMmNCrV69WrVqVlpa2aNGiV69ejz766Ny5c0866aSomJSUlLRu3frCCy/885///N3vfremzfbYY48DDzywd+/eL730Uu4qbviD371799mzZ1977bVHH310kyZNGjdufMopp4wdO/a3v/3ttt/VuqU+ffoMGDDgvffe2/IbjQDqo1Qxv0QHAEWluF6cA4BippoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNXcpaxYseKdd95J+iigKFgOFIJqFkqrVq1S25gwYUJBd9qjR4+ZM2eGbz969OjOnTvX9NnKysojjjhih+4QtrX//vtXL4HS0tJjjjnmvvvuy/veqp+0lZWVqVRqO120HCgE1Syge++9N/6fLr744oLuce3atTvrrhYvXtyjR49FixbtrDtkdzZmzJjcEvjqq69GjRo1dOjQxx57rJb32axZsziOjz766Jo2sBwoBNWsaw899FCjRo0WL14cRdHy5cv32WefcePGffbZZ6lU6qGHHmrVqlVZWdmgQYOqF/yyZcv69evXpEmT1q1bDxkypPr2pUuXZjKZpk2bHnDAAVdddVVVVdUZZ5zx7rvvDhw48LLLLtvO4FtvvXX66ac3bty4S5cuNf0r8Lvf/a59+/adOnWqq0eF3UVJSck555zTvXv3bDb7ySefpFKp4cOHl5WVDRgwYEeftFuea1oO1BnVrGuDBg3q2rXryJEjoygaMWLEiSeeOHDgwNyn7r777smTJ8+ePfv111+/+uqrczf27du3adOmH3zwwbRp02bNmjV48OAoijZt2nT22WeXlpYuWLBgxowZc+bMue2221555ZXy8vJx48aNHTu2psF169b16tWrQ4cOH3/88fDhw8eNG/eNB9moUaOXX375/vvvr8MHht3Ixo0bmzRpkvv4nXfeWbJkye233573k9ZyoE5tdQmRnaVly5ZbPdR77LFH7lPz589v1qzZPffcU1ZWNn/+/DiOly9fHkVRNpvNbTBlypTS0tLVq1dPmzZtr732qqqqyt0+a9asBg0arF27dtq0aaWlpStWrNhqp7l/JuI4rmmwoqKirKxszZo1udt/9KMfnXLKKTV9CRs2bIiiaMaMGQV4eNiNNG/evPoKbWVl5bhx4xo0aPDCCy8sW7YsiqJJkyblPrWjT9ovvvgiiqK3337bcqAuOdesu9c1N27cmLu9bdu2w4YNGzJkyA033NC2bdvq7avfiXD88cevX79+wYIF8+bNW7NmTaNGjXLvpDjppJM2b968cOHCt956q1WrVvvtt19Nu65pcN68eUceeWTjxo1zm3Xs2LHAjwF87corr8w9FVu0aDF69Oj777+/d+/euU+1adOmlk9ay4G6pJrJmDt3bhRFb7zxxpY3lpSU5D7YtGlTFEUNGzbcuHFj27Ztt/o/nW9961slJSWpVGo791/T4FabVe8RCqr6XHPdunVz58694oorqj/VqFGjWj5pLQfqkmom4MUXX3zqqadGjRo1ceLEioqK6tvffPPN3AezZ89u0qTJkUceefTRRy9atGjJkiVb3UO7du0WL16cu0K1pep/O2oabN++/fz587/66qvcf86ZM2dnf3GQp7yftJYDdUk169rq1auvuOKKa6+9dujQoT/84Q+vvvrqL7/8MvepG2+8cdGiRfPnz7/pppt+9KMfNWrU6KyzzjruuOMGDhy4ePHipUuXXn/99W3atKmqqjr99NPbt29/zTXXfPbZZx988EHfvn2/+93vRlG09957f/zxx19++WVNg//n//yfgw8++Lrrrvv8889ffvnlhx9+OOnHA/5/eT9pLQfq1E56fZR//m6gKIouv/zya6655rDDDlu9enUcxytXrmzduvXVV1+dezfQzTfffOihh+67775DhgxZv3597n4+/PDD8847b++9995nn3169uz59ttv525ftGjR2WefveeeezZv3nzAgAErV66M4/g3v/lNkyZN+vbtu53BBQsWdO/efc8992zfvv2QIUO8/YG6fDfQlnLvBsq9IS5nh5601e8GshyoS6k4jqMkZDKZRPZbnNavXz9p0qTu3bs3bdo06WPZfWWz2UT2ay1QbJJaC/VCwwT3XdH2rvwG0+/fVKvZLV5K3LHZdLqgs3/4wx8S2e92ZhfeUpnf7BF3NKvNbCJfb4KsBbNFNct2eF0TAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCESsVxHCUhk8kksl+oSTabTWS/1gLFJqm1UC80THDfFRUV+Q2m0+mKtnflOfv+TYnN1uLrXXhLZX6zR9zRLKnZWv39JjGbIGuhyJ8bCc52GJVnwP42LFMf10Lxc4UWAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCESsVxHCUhk8kksl+oSTabTWS/1gLFJqm1UC80THDfFRUV+Q2m0+mKtnflOfv+TbXa7242u/CWyvxmj7ijWb37ehNkLRT/rLVAjiu0ABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEgVCqO4ygJmUwmkf1CTbLZbCL7tRYoNkmthXqhYYL7rqioyG8wnU5XtL0rz9n3b0psthZf78JbKvObPeKOZknN1urvN4nZBFkLRf7c2N1mKdJqArDrS6Vq/FRCFztrQzUBqNtYbrtN/cmnagJQ5738xpH60E7VBCC5Xta3dvrOEwB2hlomc6ffT2GoJgBFlrpU8YZTNQEovsilijScqglAUeYtVYzhVE0AijVsqaILp2oCUMRJSxVXOFUTAEKpJgDFfQqYKqLTTdUEgFCqCUDRn/yliuV0UzUBIJRqAkAo1QSgPlwsTRXFRVq/8wSAAovjaOLEaOPGqKQkOvfcIulfflJxQr+TJZPJJLJfqEk2m01kv9YC9WwtpHa8eX/9a/Tww9GDD0aDBkWXXRademqeR1YMv0QsTkg6nc77mM2aLcSstWDWbM4/ecpG0Q7/eeaZeMCAuHPnuGfPrz/O4x5yf4qA1zUBKLwJE6Lhw6PJk6N6TjUBKLyBA6NHHon69InqOdUEoMBat44aN46y2a8/aNkyqs+8hxaAAjv55OiTT6Ju3b5+D23nzlF9ppoAFFiqHn+ryVZcoQWgPnz7R1wE33aimgAQTjUBIJRqAlD0F0vjorg8q5oAsANUE4DiPvmLi+VEUzUBYAeoJgBFfAoYF9GJpmpCno4//vilS5dGUVRVVdWuXbv77ruvY8eOJ5xwwpQpU5I+NKhDcbxbJVM1IU/9+vV77rnnoiiaOnVqz54977jjjunTpz/xxBMTJkxI+tCgbsXx7pNM1YQ89e/ff+LEiVEUPf/88xdccEGvXr0uvfTSxYsXjx8/PulDgzoXx7tJMlUT8lReXr5ixYpVq1bNnj37tNNOe+SRRwYPHjxmzJiBAwcmfWiQhDjeHZLpp7dD/s4777yRI0eefPLJq1atOvfcc19++eVOnTodccQRSR8XJCSOd85PaS/iZH79g+jjhI4vk8kksl+oSTab3aHt33333eOOO27q1KldunQZNWrUk08+uXnz5kGDBl199dU7dD/WAvV9LWwt73YWdy//f3FC0ul03sds1mwhZq0Fs2Zzds4zO4p24E/94QotAAUQx//81LNenFz+T6oJQCHF9S+N2+E9tAAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAtfKHP/yhS5cuZ5555umnnz5jxowoijZv3nzttdeeeuqp3bp1W7hwYfWWK1euTKfTXbt2TafTK1eujKJo5MiR7du3HzVqVG6qd+/elZWVURFTTQBqZdCgQY8//vjUqVMfeeSRQYMGRVH0wAMPNG3adMaMGYMHDx46dGj1liNGjOjWrdurr756+umn33nnnVEU/eIXv/jLX/5yzz33RFE0duzYvn37NmvWLCpiqTih3xeayWQS2S/UJJvNJrJfa4H6vhY6der04IMPnnjiia+99lr//v0//PDD00477dFHH23btu369et//vOf33jjjbkt27dvP2XKlEMOOWTp0qU9e/acM2dOmzZt/vjHP3bv3n327NmXXHLJCy+8kEqlomIWJySdTud9zGbNFmLWWjBrNmdHn8OvvfZao0aN2rdv36hRo+effz6O4/333/9nP/vZt7/97XQ6vWjRouot999//02bNsVxvGnTpgMOOCCO4/Hjx59yyimPP/74lVdeOWvWrLjouUILQK0MHTr08ccfnzNnzmOPPfbss89GUbR+/fpDDz30lVdeufjii3PXbGtyySWXzJw5s7y8PIqihQsX9u7d+5lnnomKWMOkDwCA+m3OnDm5FxrOP//8K6+8MoqiFi1a5E520+n0FVdcUb1lixYtPvnkk0MOOWTZsmUtWrTI3RjH8a233jp+/PhOnTrNnDmzS5cu/fr1i4qVc00AaqW8vPzPf/5zFEUzZsw47LDDoig666yzpk+fHkXR9OnTO3ToEEXR6tWroyjq1avXk08+GUXRk08+2atXr9z4ww8/3KdPn+bNm69duzaO4zVr1kRFzLkmALXywAMPXHvttV+/vzSVGjt2bBRFt99++6BBg26//faGDRs++OCDudPQKVOm/Nu//dv3v//9Z599dv/993/00UejKKqsrHz66acnTZoURdHgwYN79Ohxww03REVMNQGolQ4dOkybNm3LWw488MDnn39+y1umTJkSRVFZWVlFRcWWtzdr1mzy5Mm5j2/+h6i4uUILAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQKhXHcZSE3K8wheKRzWYT2a+1QLFJai3UC0n+prCtfl9MuHQ63WFUnn+pfxuWSWq2Nl+v2TqYTVC9e6zM7tqzbIcrtAAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIFQqjuMoCZlMJpH9Qk2y2Wwi+7UWKDZJrYX6IU5IOp3O+5jT6fRt8+P8/tRyv2Z34dl6uhbMmt1l1kK94AotAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIlYrjOEpCJpNJZL9Qk2w2m8h+rQWKTVJroV5omOC+Kyoq8htMp9MdRuX5l/q3YZmkZmvz9Zqtg9kE1ebrXXhLZX6zR9zRrN79HZmtm1m2wxVaAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQKhXHcZSETCaTyH6hJtlsNpH9WgsUm6TWQr3QMMF9dxiV51/M34ZlajNbUVGR32w6nTa7C88myPPZbFHNsh2u0AJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCpOI6DNwaA3ZpzTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUau5SVqxY8c477yR9FFAULAcKQTULpVWrVqltTJgwoaA77dGjx8yZM8O3Hz16dOfOnbe9ff78+eecc06zZs0OPvjgyy+/fNWqVTv1MNm97L///tVLoLS09JhjjrnvvvvyvrfqJ21lZWUqldpOFy0HCkE1C+jee++N/6eLL764oHtcu3Zt7e9kw4YN55xzzmGHHbZo0aI//elPr7/++hVXXLEzjo7d15gxY3JL4Kuvvho1atTQoUMfe+yxWt5ns2bN4jg++uija9rAcqAQVLOuPfTQQ40aNVq8eHEURcuXL99nn33GjRv32WefpVKphx56qFWrVmVlZYMGDape8MuWLevXr1+TJk1at249ZMiQ6tuXLl2ayWSaNm16wAEHXHXVVVVVVWeccca77747cODAyy67bDuDb7311umnn964ceMuXbosWrRo2yOcNWvWwoUL77nnnn333bdt27a33XbbxIkT4ziuwweJXVZJSck555zTvXv3bDb7ySefpFKp4cOHl5WVDRgwYEeftFuea1oO1BnVrGuDBg3q2rXryJEjoygaMWLEiSeeOHDgwNyn7r777smTJ8+ePfv111+/+uqrczf27du3adOmH3zwwbRp02bNmjV48OAoijZt2nT22WeXlpYuWLBgxowZc+bMue2221555ZXy8vJx48aNHTu2psF169b16tWrQ4cOH3/88fDhw8eNG7ftEXbp0mXDhg2lpaW5/1y2bNl+++2XSqXq8EFiF7dx48YmTZrkPn7nnXeWLFly++235/2ktRyoU1tdQmRnadmy5VYP9R577JH71Pz585s1a3bPPfeUlZXNnz8/juPly5dHUZTNZnMbTJkypbS0dPXq1dOmTdtrr72qqqpyt8+aNatBgwZr166dNm1aaWnpihUrttpp7p+JOI5rGqyoqCgrK1uzZk3u9h/96EennHLKdr6KysrKww8//LbbbtvZDw+7kebNm1dfoa2srBw3blyDBg1eeOGFZcuWRVE0adKk3Kd29En7xRdfRFH09ttvWw7UJeeadfe65saNG3O3t23bdtiwYUOGDLnhhhvatm1bvX31OxGOP/749evXL1iwYN68eWvWrGnU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atUqtY0JEyYUdKc9evSYOXNm+PajR4/u3Lnztrd/+umn/fr122effVq3bn3HHXfs1GOE/2H//fevXiClpaXHHHPMfffdl/e9VT+lKysrU6nUdrposZCfhnnOEeDee++9/vrr63KPa9eu3Sn3873vfa9NmzaLFy+eP3/+2WeffdBBB1122WU75Z5hW2PGjLniiiuiKNqwYcPvf//7888/f999973kkktqc5/NmjWL43g7G1gs5Me5Zl176KGHGjVqtHjx4iiKli9fvs8++4wbN+6zzz5LpVIPPfRQq1atysrKBg0aVL2kly1b1q9fvyZNmrRu3XrIkCHVty9dujSTyTRt2vSAAw646qqrqqqqzjjjjHfffXfgwIG5RVvT4FtvvXX66ac3bty4S5cuixYt2vYIFyxYMHXq1NGjR5eVlZ144olnnnnmX/7ylzp8hNh9lZSUnHPOOd27d89ms5988kkqlRo+fHhZWdmAAQN29Cm95bmmxcLOFFMYLVu2vPfee7/xU2edddZVV10Vx/F111135plnxnG8fPnyKIratWs3Z86cBQsWdOjQ4Qc/+EFu41NPPXXAgAHLly9fsGBB165dL7/88jiON27ceOyxx15wwQWffvrp/Pnzu3btetNNN8VxXF5ePm7cuO0Mrl27tk2bNv/yL//y+eefP/fcc40bNz7llFNq+hI2bNjw8ssv77fffs8991xhHiSImzdvPmbMmC1v6dGjxyWXXLJs2bIoitLp9KpVqz788MMdfUp/8cUXURS9/fbbFgs7l2oWSsuWLbf6H5Q99tgj96n58+c3a9bsnnvuKSsrmz9/fnU1s9lsboMpU6aUlpauXr162rRpe+21V1VVVe72WbNmNWjQYO3atdOmTSstLV2xYsVWO63+h6CmwYqKirKysjVr1uRu/9GPfrSdfwjKy8sbNWp0xhlnLF++vACPEGxdzcrKynHjxjVo0OCFF17IVXPSpEm5T+3oU7q6mhYLO5crtAW01bnmxo0bc7e3bdt22LBhQ4YMueGGG9q2bVu9ffV7DY4//vj169cvWLBg3rx5a9asadSoUe69EieddNLmzZsXLlz41ltvtWrVar/99qtp1zUNzps378gjj2zcuHFus44dO27n+N95550VK1bstdde55xzzk56SOAbXHnllbknaosWLUaPHn3//ff37t0796k2bdrU8iltsbBzqWYy5s6dG0XRG2+8seWNJSUluQ82bdr09Tu1GjbcuHFj27Ztt/o/nW9961slJSWpVGo791/T4FabVe+xJnvvvfctt9zy17/+9eOPP873a4V/ovpcc926dXPnzs29MyinUaNGtXxKWyzsXKqZgBdffPGpp54aNWrUxIkTKyoqqm9/8803cx/Mnj27SZMmRx555NFHH71o0aIlS5ZsdQ/t2rVbvHhx7hrUlqr/dahpsH379vPnz//qq69y/zlnzpxtD2/y5MllZWVVVVW5//z888/32GOPZs2a1e6LhlrJ+yltsbCT7aQrvYS+G+jLL79s06bN9ddfn3ulpGXLlqtWrcq9rnniiScuXLjwvffeO/bYY4cMGRLH8aZNmzp27NijR4+PPvpoyZIl1113XevWrdetW7d58+YTTjjhoosuWr58+aJFi84///wLL7wwjuNOnTqNGDFi1apVNQ1WVVW1a9du0KBBK1aseOmll5o2bbrtSzVr165t167dVVddVVlZ+be//e2YY4657LLL6uphY7ez7buBcnKva+Ze+N/OWqjpKV39uqbFws6lmnX3bqAoii6//PJrrrnmsMMOW716dRzHK1eubN269dVXX52r5s0333zooYfuu+++Q4YMWb9+fe5+Pvzww/POO2/vvffeZ599evbs+fbbb+duX7Ro0dlnn73nnns2b958wIABK1eujOP4N7/5TZMmTfr27budwQULFnTv3n3PPfds3779kCFDvvENDu+//36vXr322WefNm3aDB8+fO3atXX4yLF7Cazmjj6lq6tpsbBzpbb/jcC1kclkCnTPu57169dPmjSpe/fuTZs2TfpY+GbZbDaR/VpHFJtsQmuhWMQFk06n8z6q3W22V69eiezXbDGsFOvIbP2ajXdv3g0EAKFUsyiUlpYmfQgA/HOqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCpOI6jwshkMgW6Z6h72Ww2kf1aRxSbbEJroUg0LOi9V1RU5DeYTqfr5Wzbu/Kcff+mevn17k6zCarN15td+XF+s5myQ6wjs2zLFVoACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABAqFcdxVBiZTKZA9wx1L5vNJrJf64hik01oLRSJhgW994qKivwG0+l0rWbb3pXn7Ps31cv9mi38bIKsozrar1kCuEILAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCpeI4jgojk8kU6J6h7mWz2UT2ax1RbLIJrYUi0bCg915RUZHfYDqdrtVs27vynH3/pt1uNqm/o/o2myDrqB7M1rfncz1dC8XAFVoACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaAFAcP1EPALYnlarxUwX7Mem1oZoAFFMst92mmPKpmgAUWS+/caQ42qmaABRrL4uvnd4NBEDRJ3On30++VBOAAkvt1NQlGk7VBKCQUgWIXHLhVE0ACiZVsLwlFM5UXLBXVjOZTIHuGepeNptNZL/WEfV4LaQKH7Y6f3NQYd9DW1FRkd9gOp1ObLbtXXnOvn9Tvfx6zRa9evdYWUe79mxxnQumUnUcTldoASCUagJQn190TNXpC5yqCQChVBOAev7u1lTd7VE1ASCUagJAKNUEoP7/1J5UHe3X7zwBIFFxHE2cGG3cGJWUROeem/jPZ98+55oAJOq116IXX4z69Yueey6aOTMqbqoJQKIWL46qqqLOnaOlS7/+U9xUE4CkTZgQDR8eTZ4cFT3VBCBpAwdGjzwS9ekTFT3VBCBRrVtHjRtH2ezXH7RsGRU376EFIFEnnxx98knUrdvX76Ht3DkqbqoJQKJSRf2tJltxhRaAevxrout4v6oJAKFUEwBCpeKCndVmMpkC3TPUvWw2m8h+rSPq5VpIpXbZy8JxwaTT6byPyqzZYpst3EqxjszWr9k4RBTV6Z865AotAPX75C+qQ6oJAKFUE4B6ewoY1/U3uqgm7HzHH3/80n/86oaqqqp27drdd999HTt2POGEE6ZMmZL0oUEdiuNd73tDVRN2vn79+j333HNRFE2dOrVnz5533HHH9OnTn3jiiQkTJiR9aFC34ngX+3EKqgk7X//+/SdOnBhF0fPPP3/BBRf06tXr0ksvXbx48fjx45M+NKhzcbzr/AQi1YRCKC8vX7FixapVq2bPnn3aaac98sgjgwcPHjNmzMCBA5M+NEhCHO8ayfTT26FQzjvvvJEjR5588smrVq0699xzX3755U6dOh1xxBFJHxckJI53zo8+SDSZqgmF0r9//+OOO27q1KllZWXnnHNO586dN2/e/OMf/zjp44LkxP8IXt7tTLqXOaoJBVFeXl5VVZX7eNg/JH1EUG/bGRdFL3NUE4A6F/93CLeTz2KKZTXVBCA5cTGmcTu8hxYAQqkmAIRSTQAIpZoAEEo1ASCUagJAqFRcsHf9ZjKZAt0z1L1sNpvIfq0jik02obVQLOKCSafTeR+VWbPFNlu4lWIdma1fs/HuzRVaAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUE4ACuvDCC8/4hy5duuy///7feEvOH/7why5dupx55pmnn376jBkzoigaOXJk+/btR40aFUXR5s2be/fuXVlZmehX4/drAlBITz75ZO6DsWPHfvTRR994S86gQYOmTp16+OGHL1iwoE+fPvPmzfvFL37x7rvvlpeXDxs2bOzYsX379m3WrFmUKNUEoODiOL7//vt///vfb+eW5s2br1ix4vDDD1+xYsVXX30VRVFJScnf//730tLSzz//fOLEiS+88EKUNNUEoOCef/75k0466cADD9zOLQ888EDXrl2POuqo+fPnP/PMM1EUjRgx4uKLL77zzjtvueWWn/zkJ6lUKkqa1zUBKLif/exnN9xww/ZvGTp06OOPPz5nzpzHHnvs2WefjaLokksumTlzZnl5eRRFCxcu7N27d66mCXKuCUBh/fWvf23WrFkufjXdEkXRnDlzcr+u4Pzzz7/yyitzN8ZxfOutt44fP75Tp04zZ87s0qVLv379ouQ41wSgsO6+++6tTiu3umX16tVRFJWXl//5z3+OomjGjBmHHXZY7lMPP/xwnz59mjdvvnbt2jiO16xZEyXKuSYABfT+++9//PHH3bp1284t559//pQpUx544IFrr732699hmUqNHTs2iqLKysqnn3560qRJURQNHjy4R48eW9W37qkmAAXUtm3b3DdfbueWKVOmRFHUoUOHadOmbXl7s2bNJk+enPv45n+IkuYKLQCEUk0ACKWaABAqFcdxVBi5NxDDriGbzSayX+uIYpNNaC0Ui7hg0ul03keV4Gx85sn5/amnX6/ZxFfKLrmOzO7Cs/HuzRVaAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQKhXHcVQYmUymQPcMdS+bzSayX+uIYpNNaC0UiYYFvfeKior8BtPpdG1msys/zm82U3bI7jab1N9RvZtNUL17rBKctRbqYHY35wotAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIlYrjOCqMTCZToHuGupfNZhPZr3VEsckmtBaKRMOC3ntFRUV+g+l0ujaz2ZUf5zebKTukPu7XbB3MJqjePVZmd+3Z3ZwrtAAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIFQqjuOoMDKZTIHuGepeNptNZL/WEcUmm9BaKBZxwaTT6byPqp7OxmeenN+fevr17lazhVsp1pHZ+jUb795coQWAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFScRxHhZHJZAp0z1D3stls0ocAFIG4YNLpdN5HZdZssc0WbqUA9YgrtAAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIFQqjuPgjQFgt+ZcEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmruUFStWvPPOO0kfBdR7lhI1Uc1CadWqVWobEyZMKOhOe/ToMXPmzPDtR48e3blz5+1scPXVV59xxhk749AgH/vvv3/18iktLT3mmGPuu+++vO+t+glfWVmZSqW200VLiZqoZgHde++98f908cUXF3SPa9eu3Yn39uqrr/7617/eiXcIeRgzZkxu+Xz11VejRo0aOnToY489Vsv7bNasWRzHRx99dE0bWErURDXr2kMPPdSoUaPFixdHUbR8+fJ99tln3Lhxn332WSqVeuihh1q1alVWVjZo0KDqRbts2bJ+/fo1adKkdevWQ4YMqb596dKlmUymadOmBxxwwFVXXVVVVXXGGWe8++67AwcOvOyyy7Yz+NZbb51++umNGzfu0qXLokWLajrOdevWDRo06MQTT6yTRwX+uZKSknPOOad79+7ZbPaTTz5JpVLDhw8vKysbMGDAjj7htzzXtJTYIapZ1wYNGtS1a9eRI0dGUTRixIgTTzxx4MCBuU/dfffdkydPnj179uuvv3711Vfnbuzbt2/Tpk0/+OCDadOmzZo1a/DgwVEUbdq06eyzzy4tLV2wYMGMGTPmzJlz2223vfLKK+Xl5ePGjRs7dmxNg+vWrevVq1eHDh0+/vjj4cOHjxs3rqbjvPXWW//X//pf559/fl09MBBk48aNTZo0yX38zjvvLFmy5Pbbb8/7CW8pscO2uoTIztKyZcutHuo99tgj96n58+c3a9bsnnvuKSsrmz9/fhzHy5cvj6Iom83mNpgyZUppaenq1aunTZu21157VVVV5W6fNWtWgwYN1q5dO23atNLS0hUrVmy109xSj+O4psGKioqysrI1a9bkbv/Rj350yimnbHvwr7322gEHHLBs2bI777zz29/+dsEeJPgnmjdvXn2FtrKycty4cQ0aNHjhhReWLVsWRdGkSZNyn9rRJ/wXX3wRRdHbb79tKbGjnGvW3euaGzduzN3etm3bYcOGDRky5IYbbmjbtm319tXvJjj++OPXr1+/YMGCefPmrVmzplGjRrl3Q5x00kmbN29euHDhW2+91apVq/3226+mXdc0OG/evCOPPLJx48a5zTp27Ljt7IYNG37wgx+MGjXqoIMO2tkPCeywK6+8Mvc0btGixejRo++///7evXvnPtWmTZtaPuEtJXaUaiZj7ty5URS98cYbW95YUlKS+2DTpk1RFDVs2HDjxo1t27bd6v90vvWtb5WUlKRSqe3cf02DW21WvcctjRgxolWrVt///vd3xhcKtVV9rrlu3bq5c+deccUV1Z9q1KhRLZ/wlhI7SjUT8OKLLz711FOjRo2aOHFiRUVF9e1vvvlm7oPZs2c3adLkyCOPPProoxctWrRkyZKt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"
            },
            {
              "type": "input_text",
              "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
            }
          ],
          "solved_count": 0,
          "total_training_examples": 4,
          "pixel_accuracy": 0.7616580310880829
        },
        "test_result": {
          "correct": false,
          "pixel_accuracy": 0.0,
          "total_pixels": 224,
          "correct_pixels": 0,
          "error": "Grid height mismatch"
        },
        "status": "failed_test",
        "feedback_sent": true
      },
      {
        "turn_number": 2,
        "timestamp": "2025-07-10T10:41:06.214217",
        "input_tokens": 11113,
        "output_tokens": 1444,
        "turn_cost": 0.0067556000000000005,
        "program_extracted": true,
        "program": "def transform(grid):\n    import numpy as np\n\n    arr = np.array(grid)\n    h, w = arr.shape\n    target_size = 11\n\n    # Normalize grid to 11x11 size with cropping or padding\n    canvas = np.zeros((target_size, target_size), dtype=int)\n    rr = min(h, target_size)\n    cc = min(w, target_size)\n    canvas[:rr, :cc] = arr[:rr, :cc]\n    arr = canvas\n\n    output = np.zeros_like(arr)\n\n    # Define center line for quadrant split\n    mid_row = target_size // 2\n    mid_col = target_size // 2\n\n    # Blue color is 1, copy all blue pixels unchanged\n    blue_mask = (arr == 1)\n    output[blue_mask] = 1\n\n    # Find all nonzero colors except blue\n    colors = set(np.unique(arr))\n    colors.discard(0)\n    if 1 in colors:\n        colors.discard(1)\n\n    def find_quadrant(r, c):\n        # return 'TL','TR','BL','BR'\n        if r < mid_row and c < mid_col:\n            return 'TL'\n        elif r < mid_row and c >= mid_col:\n            return 'TR'\n        elif r >= mid_row and c < mid_col:\n            return 'BL'\n        else:\n            return 'BR'\n\n    def opposite_quadrant(q):\n        # Map to opposite quadrant\n        return {'TL':'BR', 'TR':'BL', 'BL':'TR', 'BR':'TL'}[q]\n\n    def quadrant_top_left(q):\n        if q == 'TL':\n            return (0, 0)\n        elif q == 'TR':\n            return (0, mid_col)\n        elif q == 'BL':\n            return (mid_row, 0)\n        else:  # BR\n            return (mid_row, mid_col)\n\n    for color in colors:\n        mask = (arr == color)\n        if not np.any(mask):\n            continue\n        rows_idx, cols_idx = np.where(mask)\n        min_r, max_r = rows_idx.min(), rows_idx.max()\n        min_c, max_c = cols_idx.min(), cols_idx.max()\n\n        cluster = arr[min_r:max_r+1, min_c:max_c+1]\n        # Binary mask of cluster pixels of this color\n        cluster_mask = (cluster == color)\n\n        # Find cluster center approx\n        center_r = int(np.mean(rows_idx))\n        center_c = int(np.mean(cols_idx))\n        orig_quad = find_quadrant(center_r, center_c)\n        targ_quad = opposite_quadrant(orig_quad)\n        targ_r0, targ_c0 = quadrant_top_left(targ_quad)\n\n        # Flip cluster horizontally\n        cluster_flipped = np.fliplr(cluster * cluster_mask)\n\n        # size of cluster\n        ch, cw = cluster.shape\n\n        # Place flipped cluster in target quadrant so that cluster fits inside quadrant boundaries:\n        # Quadrants are 5\u00d75 or 6\u00d76 blocks. Target quadrant may have variable size:\n        # For 11x11, top-left quadrants rows 0-5 or cols 0-5 except that mid line is at 5\n        max_r_place = targ_r0 + mid_row if targ_r0 == 0 else target_size\n        max_c_place = targ_c0 + mid_col if targ_c0 == 0 else target_size\n\n        # Adjust to fit cluster inside quadrant at top-left corner placement:\n        place_r = targ_r0\n        place_c = targ_c0\n        if (place_r + ch) > max_r_place:\n            place_r = max_r_place - ch\n        if (place_c + cw) > max_c_place:\n            place_c = max_c_place - cw\n\n        # Place the flipped cluster in output\n        for rr in range(ch):\n            for cc in range(cw):\n                if cluster_flipped[rr, cc] == color:\n                    output[place_r+rr, place_c+cc] = color\n\n        # Also keep original cluster pixels as is\n        output[min_r:max_r+1, min_c:max_c+1][cluster_mask] = color\n\n    return output.tolist()",
        "training_feedback": {
          "feedback_messages": [
            {
              "type": "input_text",
              "text": "Training results: 0/4 examples solved, 75.8% pixel accuracy - Good partial progress! Your approach is capturing some patterns. Next, try to identify a transformation that solves at least one of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[1, 1, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 1, 1, 1, 0, 3, 3, 3, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 1, 1, 1, 0, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[1, 1, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 85.1%\n\nTraining Example 2 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 1, 0, 0, 0, 0, 0, 0, 6, 0], [0, 1, 1, 1, 1, 0, 0, 6, 6, 6, 6], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 6, 0], [0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 86.4%\n\nTraining Example 3 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 77.8%\n\nTraining Example 4 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 60.4%\n\n\u26a0\ufe0f  GRID SIZE ERROR: One or more of your output grids are incorrect in size. They should ALL be 11\u00d711 for this task.\n\n"
            },
            {
              "type": "input_image",
              "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAmcAAATYCAIAAADVnPfcAABQGUlEQVR4nO3deZhU9Z3o/1NIN6Jgo2hcWOKCtOaiiLggotHAfa6CaJWAMW6BoHEZNxBU5hq98UpEYXRiYtAbFIPoxNFYjRokaIIYM6BEmQjigoAKAgbRBhFotvN7tH7TDwM2+VJN9amC1+vhj6a6PnVOl/Xl7Tl1ujsVx3EEAARoFHInAEA1AWA7qCYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgDQINW8+uqrU3W76KKLvvE+5eXlBxxwwNlnn/3GG29s/ZgvvPBCKpXaZ5991q5du8WnnnrqqVQqNWbMmNxf+/fvn0qlRo4cucXdFi1alEqlbrnllvpM5axdu/bBBx88/fTTDzrooCZNmhx00EH9+vX785//vI3n5JZbbqnrCZk9e/a2n7QePXr8wye29j6XXnrp5rfndq9Pnz7Tpk3bfH/S6fQWdzvkkEOuvfbazz//fLue/JxPP/30jjvu6NSpU0VFxZ577nnCCSeMGTNm81+bk9vcFuOvv/76fvvt17x58ylTpmzjqQMofgkca65fv/6TTz559tlnTz/99Pnz52/x2YcffjiKos8///yJJ54IebRbb731nXfe2d59CJn64IMPTjrppCuuuOKll15asmTJunXrlixZ8tRTT5166qn33HNPVGRyu/f0009369btscce28bdPvjgg1/84hdnnHHGpk2btuvJnzZtWseOHX/yk5/853/+58qVK1evXj1jxozLLrts4MCB29ixP/3pT6effvrGjRtffPHF008/vR5fIkCJV/OXv/xl/F+efPLJKIrGjh1be8v48eNr77lgwYLa29euXfv2229fcMEFK1euHD169OYPWF1dXVVV1a9fv3322eeBBx4I2Yd169b1799/48aN27Xn/3Bq/fr1ffv2/c///M+uXbs+88wzn3766fr16z/66KNf/epX++yzz4033pg7cKzLzJkz46106NDhG5+QWi+++OLmDxJynyVLluRuX7Nmzfvvv3/zzTfHcfyjH/3oww8/3Pxua9as2fzJ79Gjx2uvvfbCCy+EP/l///vfM5nM4sWLf/CDH0yfPn3lypWfffZZVVXVoYceOnbs2AcffPAbn4dsNtuzZ8899tjjpZdeOvHEE7fxjAGUhASONZs0aXLEEUfcddddURRtcaz5+OOPr1279vLLLx8wYMD06dPffPPNf/ho11xzzauvvvov//Iv27UP/3DqN7/5zeuvv96jR4+XX365d+/eLVu2bNy4cZs2ba688sqnn35648aN//Zv/xYVk9133/2www678847b7311nXr1v3rv/7rNp7866+/Plfc8Cf/nnvu+eSTTwYNGvT444+feOKJzZs333vvvc8555ypU6fuueee99xzz9a/3vyhhx7q16/ft771rT//+c9HH3107e2PPPJIKpX65S9/uUOfAICdtJo1NTVvvfXW4MGDoyhq37795p8aO3bskUce+b3vfe/KK6/cbbfdQg43f/azn7Vr1+7WW299++23w/fhH049/vjjqVTq//2//7fbbrtt8anvfve7c+bMueOOO6KidMMNN+yxxx5/+MMfvvGz69evf++99+67777GjRt/97vfDX/y//3f/71p06a33377Fg/YunXrV1555aWXXkqlUpvffvfdd1966aWHHnroK6+8cvjhh++4rw9gF6jmIYccUntByu67796hQ4cnn3xy3333ve6662rvM3v27L/+9a9Dhw5NpVKHHXZYv379HnvssVWrVm37kffYY4+xY8euX79+u87T/sOpmTNnHnnkkYcccsg3jh955JFbRGILnTp12uIqnldeeaWuJ6TWSy+9tL332Vrz5s0PP/zwLQ7imzZtmhsvLy+vrKz8y1/+8pvf/Gbzr27bT/769es/+OCDE044oVmzZltv8ZhjjjnwwAM3v+XGG2+86aaboig65ZRT2rZtu8X9+/fvH8fx1Vdfve0vBKAIJfOdJ61atfrRj370t7/97YADDqi98eGHH27VqtWFF16Y++uwYcO++OKLkBOh3bp1u/baa1977bVRo0aF78M2ptavX19dXb3//vtvfuMW17UefPDBUbFq2bJlzdfqusPGjRunT5++fv36wCe/uro6juOWLVsG7sAvfvGLk046qUePHg8//PDTTz9dv68GYNerZu7ClnXr1v32t7/NHQyNGDHioIMOqr3D+vXrx48f//HHHzdp0iSXpY4dO8ZxHHhN0M9+9rPDDz/8tttumzNnTvhe1TVVVlbWvHnzZcuWRfna+mqgbt26/cMrfU477bTtvc83+vzzz8vKypo0abL11UDr1q2bP3/+P/3TP/3iF78YMmRI4JO/zz77NGrUKPwJGTBgwEsvvTRu3Lh99tnnsssu+/jjjwMHAYpcgx5rlpWVff/733/iiSemTp16xhlnbP5dfc8999w3/qP8xhtvzJgx4x8+ctOmTfM4T7uNqaOOOmrOnDkfffTRN14w3Llz56hYrVq1avbs2UceeeQ3frasrOyQQw4ZNWpUhw4dHnnkkcAnf7fddjvyyCP/+te/rl69euu73XnnnZdccsnixYtrb/nVr35VXl5+4IEH/vKXv/zss88uueSSrb/LBaAUJXCG9swzz7zmmmveeOON2mOd3BnC3XfffcWKFZsfV/3Hf/xHFEV1fVfDFk4++eTrrrtuxowZW/8EgzymLrzwwk2bNl111VXf2OCtrxctHvfee+/69evPOOOMbd+tUaNGq1at2rBhQ+CTn06n16xZ83/+z//Z4nE++OCDu++++7nnnvvG87c/+MEP+vbt+6c//Wm7Tp4DFK1k3tf82c9+1rZt29GjR7/66qtRFC1dunTSpEm9e/fea6+9Nr/bSSedVFlZ+W//9m8rVqwIedjhw4cffvjhv/rVr7ZrZ75x6tJLL+3cufPvf//7E0444d///d+XLl26fv363E856NWr1xtvvNGoUXH9MMKampp33333lltu+elPf7rHHnvUda1NHMeLFi0aOnTom2++2alTp8aNGwc++YMGDWrZsuXIkSMvueSSv/71r2vWrPnkk08ef/zx0047rbq6eujQoZufEN7c6NGj999//1tuueX1118vzJcO0HCS+ad/zz33/MUvfrFp06bLL798w4YN48aN27BhQ+2lKJv74Q9/uHr16kcffTT8jOu2r24NnCovL6+qqjrppJPeeOON73//+wceeGB5eXnuJ+pNnDixsrIy8EcX1eUbr49NpVKbXzMccp8DDzyw9srkI444Yvjw4bkfH9imTZstvsbc3Ro1atSmTZtRo0Y1atQo980zgU9+y5Ytn3jiiebNmz/66KPHH3/8HnvsccABB1x44YUffvhhJpO58cYb6/pK991331//+tfr16+/4IILvvzyS9+vCZS0xA6Yzj777HQ6/be//e1f//VfH3nkkb333vvMM8/c+m6XXHJJo0aNAk/S5s645r6Ff7t841Tr1q3//Oc/jx8/vmfPnq1bty4vL99///179uz5m9/8Zvbs2ccff3xUTMrKytq0aXP++ef/5S9/+cEPflDX3XbbbbdvfetbvXr1euGFF3JnccOf/O7du8+cOfPaa6894ogjmjVr1rRp0xNPPHHMmDG/+93vtv6u1s317t27f//+77333ubfaARQilLF/BYdABSV4npzDgCKmWoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVRzp7J8+fJ33nkn6b2AomA5UAiqWSitW7dObWX8+PEF3WiPHj2mT58efv9Ro0Z16dKlrs9WV1cfeuih2/WAsLV99923dgmUl5cfeeSR9913X96PVvuira6uTqVS2+ii5UAhqGYB3XvvvfF/d9FFFxV0i2vWrNlRD7Vw4cIePXosWLBgRz0gu7LRo0fnlsCXX345cuTIIUOGPProo/V8zBYtWsRxfMQRR9R1B8uBQlDNhvbQQw81adJk4cKFURQtW7Zsr732Gjt27KeffppKpR566KHWrVtXVFQMHDiwdsEvWbKkb9++zZo1a9OmzeDBg2tv//jjjzOZTPPmzffbb7+rrrqqpqbmtNNOe/fddwcMGHDppZduY/Ctt9465ZRTmjZt2rVr17r+Ffj973/foUOHzp07N9Szwq6irKzsrLPO6t69ezabXbp0aSqVGjZsWEVFRf/+/bf3Rbv5sablQINRzYY2cODAbt26jRgxIoqi4cOHH3fccQMGDMh96u677540adLMmTNff/31q6++Ondjnz59mjdv/sEHH0ydOnXGjBmDBg2Komjjxo1nnnlmeXn5vHnzpk2bNmvWrNtuu+2ll16qrKwcO3bsmDFj6hpcu3Ztz549O3bsuHjx4mHDho0dO/Ybd7JJkyYvvvji/fff34BPDLuQDRs2NGvWLPfxO++8s2jRottvvz3vF63lQIPa4hQiO0qrVq22eKp322233Kfmzp3bokWLe+65p6KiYu7cuXEcL1u2LIqibDabu8PkyZPLy8tXrVo1derUPfbYo6amJnf7jBkzGjVqtGbNmqlTp5aXly9fvnyLjeb+mYjjuK7BqqqqioqK1atX527/8Y9/fOKJJ9b1Jaxfvz6KomnTphXg6WEX0rJly9oztNXV1WPHjm3UqNFzzz23ZMmSKIomTpyY+9T2vmg///zzKIrefvtty4GG5Fiz4d7X3LBhQ+72du3aDR06dPDgwTfccEO7du1q7197JcIxxxyzbt26efPmzZkzZ/Xq1U2aNMldSXH88cdv2rRp/vz5b731VuvWrffZZ5+6Nl3X4Jw5cw477LCmTZvm7tapU6cCPwfwlSuvvDL3Utx///1HjRp1//339+rVK/eptm3b1vNFaznQkFQzGbNnz46i6I033tj8xrKystwHGzdujKKocePGGzZsaNeu3Rb/p/Od73ynrKwslUpt4/HrGtzibrVbhIKqPdZcu3bt7Nmzr7jiitpPNWnSpJ4vWsuBhqSaCXj++eefeOKJkSNHTpgwoaqqqvb2N998M/fBzJkzmzVrdthhhx1xxBELFixYtGjRFo/Qvn37hQsX5s5Qba723466Bjt06DB37twvv/wy99dZs2bt6C8O8pT3i9ZyoCGpZkNbtWrVFVdcce211w4ZMuSyyy67+uqrv/jii9ynbrzxxgULFsydO/emm2768Y9/3KRJk+9973tHH330gAEDFi5c+PHHH19//fVt27atqak55ZRTOnTocM0113z66acffPBBnz59fvCDH0RRtOeeey5evPiLL76oa/B//a//deCBB1533XWfffbZiy+++PDDDyf9fMD/L+8XreVAg9pB74/yj68GiqLo8ssvv+aaaw4++OBVq1bFcbxixYo2bdpcffXVuauBbr755m9/+9t777334MGD161bl3ucDz/88Jxzztlzzz332muvM8444+23387dvmDBgjPPPHP33Xdv2bJl//79V6xYEcfxr3/962bNmvXp02cbg/Pmzevevfvuu+/eoUOHwYMHu/yBhrwaaHO5q4FyF8TlbNeLtvZqIMuBhpSK4zhKQiaTSWS7xWndunUTJ07s3r178+bNk96XXVc2m01ku9YCxSaptVASGie47ap2d+U3mH7/pnrNbvZW4vbNptMFnf3jH/+YyHa3MTv/lur8Zg+9o0V9ZhP5ehNkLYTPdhyZ5z/ofxuaKcWvd1dbC8XP+5oAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASBUKo7jKAmZTCaR7UJdstlsItu1Fig2Sa2FktA4wW1XVVXlN5hOp6va3ZXn7Ps3JTZbj693/i3V+c0eekeLpGbr9d83idkEWQtF/trY1WbZBmdoASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAqFQcx1ESMplMItuFumSz2US2ay1QbJJaCyWhcYLbrqqqym8wnU5Xtbsrz9n3b6rXdnex2fm3VOc3e+gdLUru602QtVD8s9YCOc7QAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKk4jqMkZDKZRLYLdclms4ls11qg2CS1FkpC4wS3XVVVld9gOp2uandXnrPv35TYbD2+3vm3VOc3e+gdLZKardd/3yRmE2QtFPlrY1ebpUirCcDOL5Wq81MJneysD9UEoGFjufV9SiefqglAg/fyG0dKoZ2qCUByvSy1dvrOEwB2hHomc4c/TmGoJgBFlrpU8YZTNQEovsilijScqglAUeYtVYzhVE0AijVsqaILp2oCUMRJSxVXOFUTAEKpJgDFfQiYKqLDTdUEgFCqCUDRH/yliuVwUzUBIJRqAkAo1QSgFE6WporiJK3feQJAgcVxNGFCtGFDVFYWnX12kfQvP6k4od/JkslkEtku1CWbzSayXWuBElsLqe1v3quvRg8/HD34YDRwYHTppdFJJ+W5Z8XwS8TihKTT6bz32azZQsxaC2bN5vyDl2wUbfefp56K+/ePu3SJzzjjq4/zeITcnyLgfU0ACm/8+GjYsGjSpKjEqSYAhTdgQPTII1Hv3lGJU00ACqxNm6hp0yib/eqDVq2iUuYaWgAK7IQToqVLo1NP/eoa2i5dolKmmgAUWKqEv9VkC87QAlAK3/4RF8G3nagmAIRTTQAIpZoAFP3J0rgoTs+qJgBsB9UEoLgP/uJiOdBUTQDYDqoJQBEfAsZFdKCpmpCnY4455uOPP46iqKampn379vfdd1+nTp2OPfbYyZMnJ71r0IDieJdKpmpCnvr27fvMM89EUTRlypQzzjjjjjvuePnllx9//PHx48cnvWvQsOJ410mmakKe+vXrN2HChCiKnn322fPOO69nz56XXHLJwoULx40bl/SuQYOL410kmaoJeaqsrFy+fPnKlStnzpx58sknP/LII4MGDRo9evSAAQOS3jVIQhzvCsn009shf+ecc86IESNOOOGElStXnn322S+++GLnzp0PPfTQpPcLEhLHO+antBdxMr/6QfRxQvuXyWQS2S7UJZvNbtf933333aOPPnrKlCldu3YdOXLkb3/7202bNg0cOPDqq6/ersexFij1tbClvNtZ3L38/8UJSafTee+zWbOFmE1wLRz919Py+1OKz7PZ4p/dMa/sKNqOP6XDGVoACiCO//GhZ0kcXP53qglAIcWll8ZtcA0tAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCUC9/PGPf+zatevpp59+yimnTJs2LYqiF1544dBDDz3ta7fccsvmd66uru7fv39FRUXuryNGjOjQocPIkSOjKNq0aVOvXr2qq6ujIub3awJQLwMHDpwyZcohhxwyb9683r17z5kzZ+nSpTfeeOMVV1yx9Z179+593nnnVVVV5f7685///N13362srBw6dOiYMWP69OnTokWLqIil4oR+X2gmk0lku1CXbDabyHatBUp9LXTu3PnBBx887rjjXnvttX79+n344Yd33313ZWXlOeecs/Wdly5desABB7Ro0SJ3TNm2bds//elP3bt3nzlz5sUXX/zcc8+lUqmomMUJSafTee+zWbOFmLUWzJrN2d7X8GuvvdakSZMOHTo0adLk2WefjeP4+uuvv+yyy04++eTevXu///77W49UVFTkPhg3btyJJ5742GOPXXnllTNmzIiLnvc1AaiXIUOGPPbYY7NmzXr00Ueffvrpr05jplIdO3Z85ZVX+vfvf9lll21j9uKLL54+fXplZWUURfPnz+/Vq9dTTz0VFTHvawJQL7Nmzcq90XDuuedeeeWVURRde+21bdq0iaLonHPOufzyy7c9HsfxrbfeOm7cuM6dO0+fPr1r1659+/aNipVjTQDqpbKy8i9/+UsURdOmTTv44IOjKLr55pufe+65KIpeffXVo446KoqiVatW1TX+8MMP9+7du2XLlmvWrInjePXq1VERc6wJQL088MAD1157be7E7JgxY6Io+r//9/8OGDDg3nvv3X333X/961/nDkMn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9uwoit54443NbywrK8t9sHHjxiiKGjduvGHDhnbt2m3xfzrf+c53ysrKtn2OqK7BLe5Wu8WtLV++vHv37q1bt37qqacaN25cvy+XXV3tsebatWtnz569+QU1TZo0qeeL1nKgIalmAp5//vknnnhi5MiREyZMqKqqqr39zTffzH0wc+bMZs2aHXbYYUccccSCBQsWLVq0xSO0b99+4cKFuTNUm6v9t6OuwQ4dOsydO/fLL7/M/XXWrFnfuIeLFi3q1q3bqaee+thjj9W+owMFlfeL1nKgQe2gM71sqVWrVlt/50kcx1988UXbtm2vv/763PsorVq1WrlyZe59zeOOO27+/PnvvffeUUcdNXjw4DiON27c2KlTpx49enz00UeLFi267rrr2rRps3bt2k2bNh177LEXXnjhsmXLFixYcO65555//vlxHHfu3Hn48OErV66sa7CmpqZ9+/YDBw5cvnz5Cy+80Lx5863fyPn8888PP/zwG2+8saGeKnah9zU3l3tfM/fW/jZe7XW9aGvf17QcaEiq2XBXA0VRdPnll19zzTUHH3zwqlWr4jhesWJFmzZtrr766lw1b7755m9/+9t777334MGD161bl3ucDz/88Jxzztlzzz332muvM8444+23387dvmDBgjPPPHP33Xdv2bJl//79V6xYEcfxr3/962bNmvXp02cbg/Pmzevevfvuu+/eoUOHwYMHb/3PxJ133rn1nn/xxRcN+/yxy1Vze1+0tdW0HGhIqaS+8SiTySSy3eK0bt26iRMndu/evXnz5knvy64rm80msl1rgWKT1FooDXFC0ul03vts1mwhZhNcC9X7/Cm/P6X4PJst/tmk1kJJcDUQAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIlYrjOEpCJpNJZLtQl2w2m8h2rQWKTVJroTTECUmn03nvs1mzhZi1FsyaTXYtlARnaAEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQKhUHMdREjKZTCLbhbpks9lEtmstUGySWgulIU5IOp3Oe5/Nmi3ErLVg1myya6EkOEMLAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCpeI4jpKQyWQS2S7UJZvNJrJda4Fik9RaKA1xQtLpdN77bNZsIWatBbNmk10LJcEZWgAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEKpx8D0BYPulUnV+KqEfhF4fqglAw8Zy6/uUTj5VE4AG7+U3jpRCO1UTgOR6WWrtdDUQAEWQzB3+OIWhmgAUWepSxRtO1QSg+CKXKtJwqiYARZm3VDGGMxUn9L5rJpNJZLtQl2w2m8h2rQVKeC2kCh+2Irs4KMlraKuqqvIbTKfTVe3uynP2/ZvqNVuffTYbPPvIy9fmN9v/1Pvynk2QtWC2qGaL61gwlSqqcDpDCwChVBOA4n7TMVVEb3CqJgCEUk0Aiv7gL1Ush5uqCQChVBMAQqkmAKVwsjRVFCdp/c4TAAosjqMJE6ING6Kysujss4ukf/lxrAlAgb32WvT881HfvtEzz0TTp0elTDUBKLCFC6OamqhLl+jjj7/6U8pUE4DCGz8+GjYsmjQpKnGqCUDhDRgQPfJI1Lt3VOJUE4ACa9Mmato0yma/+qBVq6iUuYYWgAI74YRo6dLo1FO/uoa2S5eolKkmAAWWKuFvNdmCM7QAbI84od92WRy/ZVM1ASCUagJAqFSc0DFvJpNJZLtQl2w2m8h2rQVKci2kUrvg6dmErwaqqqrKbzCdTtdrtt1dec6+f1Ni+7yLzT7y8rX5zfY/9b68t5sga8FsXbO72loofs7QAlDcB39xsRxoqiYAbAfVBKCIDwHjIjrQVE3I0zHHHPPx17+6oaampn379vfdd1+nTp2OPfbYyZMnJ71r0IDieJdKpmpCnvr27fvMM89EUTRlypQzzjjjjjvuePnllx9//PHx48cnvWvQsOJ410mmakKe+vXrN2HChCiKnn322fPOO69nz56XXHLJwoULx40bl/SuQYOL410kmaoJeaqsrFy+fPnKlStnzpx58sknP/LII4MGDRo9evSAAQOS3jVIQhzvCsn009shf+ecc86IESNOOOGElStXnn322S+++GLnzp0PPfTQpPcLEhLHO+ZHHxRxMlUT8tevX7+jjz56ypQpFRUVZ511VpcuXTZt2vSTn/wk6f2C5MRfBy/vdhZ3L3NUE/JUWVlZU1OT+3jo15LeIyjZdsYl0Msc1QSgAOL/CuE28lk6saylmgAUUlx6adwG19ACQCjVBIBQqgkAoVQTAEKpJgCEUk0ACJWKE7omOJPJJLJdqEs2m01ku9YCxSaptVASkvx+zaqqqvwG0+l0Vbu78px9/6aSnK3Pc1WP2Udevja/2f6n3ldyswmyFop/LexSs2yDM7QAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAPXyxz/+sWvXrqeffvopp5wybdq0KIo2bdp07bXXnnTSSaeeeur8+fO3Hpk4cWLTpk2jKBoxYkSHDh1GjhyZm+rVq1d1dXVUxPx+TQDqZeDAgVOmTDnkkEPmzZvXu3fvOXPmPPDAA82bN582bVo2mx0yZMjTTz+9+f2/+OKLO+64o6ysLIqin//85++++25lZeXQoUPHjBnTp0+fFi1aREXMsSYA9dKyZcvly5dHUbR8+fIvv/wyiqLHHntswIABURT16tWrS5cuW9z/5ptvvv766xs1+ipAZWVlf//738vLyz/77LMJEybkpoqZagJQLw888EC3bt2OOuqoU0899f7774+i6L333nvmmWdOO+2073//++edd97md37llVcWL15ce+Pw4cMvuuiiO++885ZbbvnpT3+aSqWi4qaaANTLkCFDHnvssVmzZj366KO5k7Hr1q379re//dJLL1100UUDBw6svWdNTc2QIUNyZc25+OKLp0+fXllZGUXR/Pnze/Xq9dRTT0VFzPuaANTLrFmzcr+E4Nxzz73yyiujKNp///3T6XTux+FeccUVtff83e9+98UXX1xwwQVRFK1ateqSSy4ZN25cHMe33nrruHHjOnfuPH369K5du/bt2zcqVo41AaiXysrKv/zlL1EUTZs27eCDD46i6Hvf+97LL78cRdHLL7/csWPHXCOjKLrgggveeuutl77WrFmzcePGRVH08MMP9+7du2XLlmvWrInjePXq1VERc6wJQL088MAD11771e8aSqVSY8aMiaLo9ttvHzhw4O233964ceMHH3wwdxg6efLkrWerq6uffPLJiRMnRlE0aNCgHj163HDDDVERU00A6qVjx45Tp07d/JZvfetbzz777Oa3bJ3M3PdltmjRYtKkSblbbv5aVNycoQWAUKoJAKFUEwBCpeI4jpKQu0wZikc2m01ku9YCxSaptVAa4oTkvpUnP2bNFmLWWjBrNtm1UBKcoQWAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFScRxHSchkMolsF+qSzWYT2a61QLFJai2Uhjgh6XQ67302a7YQs9aCWbPJroWS4AwtAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIlYrjOEpCJpNJZLtQl2w2m8h2rQWKTVJroTTECUmn03nvs1mzhZi1FsyaTXYtlARnaAEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQKhUHMdREjKZTCLbhbpks9lEtmstUGySWgulIU5IOp3Oe5/Nmi3ErLVg1myya6EkOEMLAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCpeI4jpKQyWQS2S7UJZvNJr0LQNGLE5JOp/PeZ7NmCzGb1FoASogztAAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIFQqjuPgOwPALs2xJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNXcqy5cvf+edd5LeCygBFgv5Uc1Cad26dWor48ePL+hGe/ToMX369PD7jxo1qkuXLlvf/sknn/Tt23evvfZq06bNHXfcsUP3Ef6bfffdt3aBlJeXH3nkkffdd1/ej1b7kq6urk6lUtvoosVCfhrnOUeAe++99/rrr2/ILa5Zs2aHPM4FF1zQtm3bhQsXzp0798wzzzzggAMuvfTSHfLIsLXRo0dfccUVURStX7/+D3/4w7nnnrv33ntffPHF9XnMFi1axHG8jTtYLOTHsWZDe+ihh5o0abJw4cIoipYtW7bXXnuNHTv2008/TaVSDz30UOvWrSsqKgYOHFi7pJcsWdK3b99mzZq1adNm8ODBtbd//PHHmUymefPm++2331VXXVVTU3Paaae9++67AwYMyC3augbfeuutU045pWnTpl27dl2wYMHWezhv3rwpU6aMGjWqoqLiuOOOO/300//jP/6jAZ8hdl1lZWVnnXVW9+7ds9ns0qVLU6nUsGHDKioq+vfvv70v6c2PNS0WdqSYwmjVqtW99977jZ/63ve+d9VVV8VxfN11151++ulxHC9btiyKovbt28+aNWvevHkdO3b80Y9+lLvzSSed1L9//2XLls2bN69bt26XX355HMcbNmw46qijzjvvvE8++WTu3LndunW76aab4jiurKwcO3bsNgbXrFnTtm3bf/qnf/rss8+eeeaZpk2bnnjiiXV9CevXr3/xxRf32WefZ555pjBPEsQtW7YcPXr05rf06NHj4osvXrJkSRRF6XR65cqVH3744fa+pD///PMoit5++22LhR1LNQulVatWW/wPym677Zb71Ny5c1u0aHHPPfdUVFTMnTu3tprZbDZ3h8mTJ5eXl69atWrq1Kl77LFHTU1N7vYZM2Y0atRozZo1U6dOLS8vX758+RYbrf2HoK7BqqqqioqK1atX527/8Y9/vI1/CCorK5s0aXLaaactW7asAM8QbFnN6urqsWPHNmrU6LnnnstVc+LEiblPbe9LuraaFgs7ljO0BbTFseaGDRtyt7dr127o0KGDBw++4YYb2rVrV3v/2msNjjnmmHXr1s2bN2/OnDmrV69u0qRJ7lqJ448/ftOmTfPnz3/rrbdat269zz771LXpugbnzJlz2GGHNW3aNHe3Tp06bWP/33nnneXLl++xxx5nnXXWDnpK4BtceeWVuRfq/vvvP2rUqPvvv79Xr165T7Vt27aeL2mLhR1LNZMxe/bsKIreeOONzW8sKyvLfbBx48avrtRq3HjDhg3t2rXb4v90vvOd75SVlaVSqW08fl2DW9ytdot12XPPPW+55ZZXX3118eLF+X6t8A/UHmuuXbt29uzZuSuDcpo0aVLPl7TFwo6lmgl4/vnnn3jiiZEjR06YMKGqqqr29jfffDP3wcyZM5s1a3bYYYcdccQRCxYsWLRo0RaP0L59+4ULF+bOQW2u9l+HugY7dOgwd+7cL7/8MvfXWbNmbb17kyZNqqioqKmpyf31s88+22233Vq0aFG/LxrqJe+XtMXCDraDzvQSejXQF1980bZt2+uvvz73TkmrVq1WrlyZe1/zuOOOmz9//nvvvXfUUUcNHjw4juONGzd26tSpR48eH3300aJFi6677ro2bdqsXbt206ZNxx577IUXXrhs2bIFCxace+65559/fhzHnTt3Hj58+MqVK+sarKmpad++/cCBA5cvX/7CCy80b95867dq1qxZ0759+6uuuqq6uvpvf/vbkUceeemllzbU08YuZ+urgXJy72vm3vjfxlqo6yVd+76mxcKOpZoNdzVQFEWXX375Nddcc/DBB69atSqO4xUrVrRp0+bqq6/OVfPmm2/+9re/vffeew8ePHjdunW5x/nwww/POeecPffcc6+99jrjjDPefvvt3O0LFiw488wzd99995YtW/bv33/FihVxHP/6179u1qxZnz59tjE4b9687t2777777h06dBg8ePA3XuDw/vvv9+zZc6+99mrbtu2wYcPWrFnTgM8cu5bAam7vS7q2mhYLO1Zq298IXB+ZTKZAj7zzWbdu3cSJE7t37968efOk94Vvls1mE9mudUSxySa0FopFXDDpdDrvvdrVZnv27JnIds0Ww0r5h+soPv2E/P6U4vNstvhn412bq4EAIJRqFoXy8vKkdwGAf0w1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAECoVx3FUGJlMpkCPDA0vm80msl3riGKTTWgtFInGBX30qqqq/AbT6XRJzra7K8/Z928qya93V5pNUMk9V9bRzj27i3OGFgBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhErFcRwVRiaTKdAjQ8PLZrOJbNc6othkE1oLRaJxQR+9qqoqv8F0Ol2v2XZ35Tn7/k0luV2zhZ9NkHXUQNs1SwBnaAEglGoCQCjVBIBQqgkAoVQTAEKpJgCE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pZoAEEo1ASCUagJAKNUEgFCpuB7X9WYymbxnYWeSzWYT2a41SLHJJrQWGk5cD+l0Ou/tlujsbXPj/P6U6NdrtgHWkTVodmeajXd2ztACQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaACRm06ZN11577UknnXTqqafOnz8/iqIVK1ak0+lu3bql0+kVK1ZsPTJx4sSmTZtGUTRixIgOHTqMHDky9zi9evWqrq4u9A6rJgCJeeCBB5o3bz5t2rRBgwYNGTIkiqLhw4efeuqpr7zyyimnnHLnnXducf8vvvjijjvuKCsri6Lo5z//+X/8x3/cc889URSNGTOmT58+LVq0KPQOqyYAiXnssccGDBgQRVGvXr26dOmSO5Q8//zzoyg6//zzf//7329x/5tvvvn6669v1OireJWVlf39738vLy//7LPPJkyYkHucQlNNABLz3nvvPfPMM6eddtr3v//98847L4qiTz755IADDoii6MADD/zkk082v/Mrr7yyePHi3N1yR6UXXXTRnXfeecstt/z0pz9NpVINsMOqCUBi1q1b9+1vf/ull1666KKLBg4cuI171tTUDBky5P7776+95eKLL54+fXplZWUURfPnz+/Vq9dTTz1V6B1uXOgNAEBd9t9//9yPvU2n01dccUXulqVLlx500EFLlizZf//9a+/5u9/97osvvrjggguiKFq1atUll1wybty4OI5vvfXWcePGde7cefr06V27du3bt29USI41AUjM9773vZdffjmKopdffrljx45RFPXs2fO3v/1tFEW//e1ve/bsmWtkFEUXXHDBW2+99dLXmjVrNm7cuCiKHn744d69e7ds2XLNmjVxHK9evbrQO+xYE4DE3H777QMHDrz99tsbN2784IMPRlH0v//3//7hD3/49NNP77vvvr/5zW+iKDr33HMnT5689Wx1dfWTTz45ceLEKIoGDRrUo0ePG264odA7rJoAJOZb3/rWs88+u/ktFRUVVVVVm9+ydTJz35fZokWLSZMm5W65+WuF319naAEgmGoCQCjVBIBQqTiOo3xlMpm8Z2Fnks1mE9muNUixySa0FhpMfa8G2uI923DpdDqp2Y4j8/yP+rehmfrMluJzZbb4ldxzZXbnnt3pOUMLAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCpeI4jvKVyWTynoWdSTabTWS71iDFJpvQWmgwjes5X1VVld9gOp2uz2zHkXn+h/nb0ExS+2x2J55NkDVotqhmd3rO0AJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCpOI6jfGUymbxnYWeSzWYT2a41SLHJJrQWGkzjes5XVVXlN5hOp5Oa7Tgyz/+ofxuaqc9sKT5XZotfyT1XZnfu2Z2eM7QAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASBUKo7jKF+ZTCbvWdiZZLPZpHcBaBBxPaTT6by3a9bszjRbn3UElBBnaAEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQKhUHMdRvjKZTN6zsDPJZrNJ7wLQIOJ6SKfTeW/XrNmdabY+6wgoIc7QAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKk4jqN8ZTKZvGdhZ5LNZpPeBaBBxPWQTqfz3q5ZszvTbH3WEVBCnKEFgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChUnEcB98ZAHZpjjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAKND/BzKkf5JaRj+SAAAAAElFTkSuQmCC"
            },
            {
              "type": "input_text",
              "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
            }
          ],
          "solved_count": 0,
          "total_training_examples": 4,
          "pixel_accuracy": 0.7582037996545768
        },
        "test_result": {
          "correct": false,
          "pixel_accuracy": 0.0,
          "total_pixels": 224,
          "correct_pixels": 0,
          "error": "Grid height mismatch"
        },
        "status": "failed_test",
        "feedback_sent": true
      },
      {
        "turn_number": 3,
        "timestamp": "2025-07-10T10:41:25.391766",
        "input_tokens": 17354,
        "output_tokens": 2230,
        "turn_cost": 0.010509600000000001,
        "program_extracted": true,
        "program": "def transform(grid):\n    import numpy as np\n\n    arr = np.array(grid)\n    h, w = arr.shape\n    target_size = 11\n    # Normalize size to 11 x 11 (crop or pad as needed)\n    norm = np.zeros((target_size, target_size), dtype=int)\n    norm[:h, :w] = arr[:target_size, :target_size]\n    arr = norm\n\n    output = np.zeros_like(arr)\n\n    # Blue cluster color\n    blue_color = 1\n\n    # Copy blue cluster pixels directly\n    blue_mask = (arr == blue_color)\n    output[blue_mask] = blue_color\n\n    # Find all colors excluding 0 and blue\n    colors = set(np.unique(arr))\n    colors.discard(0)\n    if blue_color in colors:\n        colors.discard(blue_color)\n\n    def get_quadrant(r, c):\n        # quadrants by midline indices (0-based)\n        mid = target_size // 2\n        if r < mid and c < mid:\n            return 'TL'\n        elif r < mid and c >= mid:\n            return 'TR'\n        elif r >= mid and c < mid:\n            return 'BL'\n        else:\n            return 'BR'\n\n    def opposite_quadrant(q):\n        mapping = {'TL': 'BR', 'TR': 'BL', 'BL': 'TR', 'BR': 'TL'}\n        return mapping[q]\n\n    def quadrant_bounds(q):\n        mid = target_size // 2\n        if q == 'TL':\n            return (0, mid), (0, mid)\n        elif q == 'TR':\n            return (0, mid), (mid, target_size)\n        elif q == 'BL':\n            return (mid, target_size), (0, mid)\n        else:  # BR\n            return (mid, target_size), (mid, target_size)\n\n    for color in colors:\n        mask = (arr == color)\n        if not np.any(mask):\n            continue\n        rows, cols = np.where(mask)\n        min_r, max_r = rows.min(), rows.max()\n        min_c, max_c = cols.min(), cols.max()\n\n        # Copy original cluster pixels as is\n        output[min_r:max_r+1, min_c:max_c+1][arr[min_r:max_r+1, min_c:max_c+1] == color] = color\n\n        # Determine cluster center to assign quadrant\n        center_r = int(np.mean(rows))\n        center_c = int(np.mean(cols))\n        orig_quad = get_quadrant(center_r, center_c)\n        targ_quad = opposite_quadrant(orig_quad)\n\n        # Compute bounds of target quadrant\n        (r_start, r_end), (c_start, c_end) = quadrant_bounds(targ_quad)\n\n        # Decide rectangle size for duplicate block:\n        height = max_r - min_r +1\n        width = max_c - min_c +1\n        block_size = max(height, width)\n        if block_size < 3:\n            block_size = 3\n\n        # Place duplication block inside target quadrant with padding of 1\n        block_r_start = r_start + 1\n        block_c_start = c_start + 1\n\n        # Ensure block doesn't overflow quadrant\n        if block_r_start + block_size > r_end:\n            block_r_start = r_end - block_size\n        if block_c_start + block_size > c_end:\n            block_c_start = c_end - block_size\n\n        # Draw solid block of color in output\n        for rr in range(block_r_start, block_r_start + block_size):\n            for cc in range(block_c_start, block_c_start + block_size):\n                output[rr, cc] = color\n\n    return output.tolist()",
        "training_feedback": {
          "feedback_messages": [
            {
              "type": "input_text",
              "text": "Training results: 0/4 examples solved, 70.3% pixel accuracy - Good partial progress! Your approach is capturing some patterns. Next, try to identify a transformation that solves at least one of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[1, 1, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 1, 1, 1, 0, 3, 3, 3, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 1, 1, 1, 0, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 0, 8, 8, 8, 0, 0], [0, 1, 0, 0, 0, 0, 8, 8, 8, 0, 0], [0, 1, 1, 1, 0, 0, 8, 8, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 78.5%\n\nTraining Example 2 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 1, 0, 0, 0, 0, 0, 0, 6, 0], [0, 1, 1, 1, 1, 0, 0, 6, 6, 6, 6], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 6, 0], [0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 80.3%\n\nTraining Example 3 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 1, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 1, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 72.2%\n\nTraining Example 4 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 8, 8, 8, 0, 0], [0, 0, 1, 0, 0, 0, 8, 8, 8, 0, 0], [0, 0, 0, 1, 1, 0, 8, 8, 8, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 56.0%\n\n\u26a0\ufe0f  GRID SIZE ERROR: One or more of your output grids are incorrect in size. They should ALL be 11\u00d711 for this task.\n\n"
            },
            {
              "type": "input_image",
              "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAmcAAATYCAIAAADVnPfcAABROElEQVR4nO3de5RU5Z3o710IjSjYCCoql3hBWnNQRLwgQaOBs46CaJWAMfEGQeMlqAFFZYboiYGIQnRiYtAjCio6OjpWowQJmiDGBNQooyBeEFBBwCDaIALNbf9WrN/0YsAmL9VU72p4nsUfbfX+1t5d1MvHvau6OxXHcQQABKgXshEAoJoAsANUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAKiVag4cODBVvQsvvPAbtykpKTnwwAPPPvvsN954Y9v7fP7551OpVLNmzdatW7fVp5566qlUKjV27Njcf/br1y+VSo0aNWqrzRYvXpxKpYYNG1aTqZx169bdd999p59++sEHH9ywYcODDz64b9++f/7zn7fzmAwbNqy6B2TOnDnbf9C6d+/+Tx/Yqm0uvfTSLW/PHV7v3r1nzJix5fGk0+mtNjv00EOvueaaL774Yoce/JzPPvts+PDhHTt2LC0t3XvvvU888cSxY8du+Wtzcrvbavz111/ff//9mzRpMm3atO08dADFL4FzzQ0bNnz66afPPvvs6aefvmDBgq0+++CDD0ZR9MUXXzzxxBMh93bzzTe/++67O3oMIVMffvjhySeffMUVV7z44otLly5dv3790qVLn3rqqVNPPfXOO++Mikzu8J5++umuXbs++uij29nsww8//M1vfnPGGWds3rx5hx78GTNmdOjQ4Wc/+9l//dd/rVq1as2aNa+99tpll102YMCA7RzYn/70p9NPP33Tpk0vvPDC6aefXoMvEaCOV/O3v/1t/N+efPLJKIrGjRtXdcuECROqtly4cGHV7evWrXvnnXd++MMfrlq1asyYMVveYUVFRXl5ed++fZs1a3bvvfeGHMP69ev79eu3adOmHTryfzq1YcOGPn36/Nd//VeXLl2eeeaZzz77bMOGDR9//PHvfve7Zs2a3XDDDbkTx+rMmjUr3kb79u2/8QGp8sILL2x5JyHbLF26NHf72rVrP/jgg5tuuimO4x/96EcfffTRlputXbt2ywe/e/fur7766vPPPx/+4P/973/PZDJLliz5wQ9+MHPmzFWrVn3++efl5eWHHXbYuHHj7rvvvm98HLLZbI8ePfbaa68XX3zxpJNO2s4jBlAnJHCu2bBhwyOPPPL222+Pomirc83HHnts3bp1l19+ef/+/WfOnPnWW2/903u7+uqrX3nllV/96lc7dAz/dOqhhx56/fXXu3fv/tJLL/Xq1at58+b169dv3br1lVde+fTTT2/atOnf//3fo2Ky5557Hn744bfddtvNN9+8fv36f/u3f9vOg//Tn/40V9zwB//OO+/89NNPBw0a9Nhjj5100klNmjTZd999zznnnOnTp++999533nnntr/e/IEHHujbt+8BBxzw5z//+Zhjjqm6ffz48alU6re//e1OfQAAdtFqVlZWvv3224MHD46iqF27dlt+aty4cUcdddT3vve9K6+8co899gg53fzlL3/Ztm3bm2+++Z133gk/hn869dhjj6VSqf/3//7fHnvssdWnvvvd786dO3f48OFRUbruuuv22muvP/zhD9/42Q0bNrz//vt33313/fr1v/vd74Y/+P/xH//RqFGjW2+9das7bNWq1csvv/ziiy+mUqktb7/jjjsuvfTSww477OWXXz7iiCN23tcHsBtU89BDD616Q8qee+7Zvn37J598cr/99rv22murtpkzZ87f/va3IUOGpFKpww8/vG/fvo8++ujq1au3f8977bXXuHHjNmzYsEPXaf/p1KxZs4466qhDDz30G8ePOuqorSKxlY4dO271Lp6XX365ugekyosvvrij22yrSZMmRxxxxFYn8Y0aNcqNl5SUlJWV/eUvf3nooYe2/Oq2/+Bv2LDhww8/PPHEExs3brztHo899tiDDjpoy1tuuOGGG2+8MYqiU045pU2bNltt369fvziOBw4cuP0vBKAIJfOdJy1btvzRj3705ptvHnjggVU3Pvjggy1btrzgggty/zl06NAvv/wy5EJo165dr7nmmldffXX06NHhx7CdqQ0bNlRUVLRo0WLLG7d6X+shhxwSFavmzZtXfq26DTZt2jRz5swNGzYEPvgVFRVxHDdv3jzwAH7zm9+cfPLJ3bt3f/DBB59++umafTUAu181c29sWb9+/eOPP547GRo5cuTBBx9ctcGGDRsmTJjwySefNGzYMJelDh06xHEc+J6gX/7yl0ccccQtt9wyd+7c8KOqbqpBgwZNmjRZvnx5lK9t3w3UtWvXf/pOn9NOO21Ht/lGX3zxRYMGDRo2bLjtu4HWr1+/YMGCn/zkJ7/5zW+uv/76wAe/WbNm9erVC39A+vfv/+KLLz788MPNmjW77LLLPvnkk8BBgCJXq+eaDRo0+P73v//EE09Mnz79jDPO2PK7+iZNmvSN/yi/8cYbr7322j+950aNGuVxnXY7U0cfffTcuXM//vjjb3zDcKdOnaJitXr16jlz5hx11FHf+NkGDRoceuiho0ePbt++/fjx4wMf/D322OOoo47629/+tmbNmm03u+222y6++OIlS5ZU3fK73/2upKTkoIMO+u1vf/v5559ffPHF236XC0BdlMAV2jPPPPPqq69+4403qs51clcI99xzz5UrV255XvXXv/41iqLqvqthK9/5zneuvfba1157bdufYJDH1AUXXLB58+arrrrqGxu87ftFi8ddd921YcOGM844Y/ub1atXb/Xq1Rs3bgx88NPp9Nq1a//v//2/W93Phx9+eMcdd0yaNOkbr9/+4Ac/6NOnz5/+9KcdungOULSSeV3zl7/8ZZs2bcaMGfPKK69EUbRs2bIpU6b06tVrn3322XKzk08+uays7N///d9XrlwZcrcjRow44ogjfve73+3QwXzj1KWXXtqpU6ff//73J5544n/8x38sW7Zsw4YNuZ9y0LNnzzfeeKNeveL6YYSVlZXvvffesGHDfv7zn++1117VvdcmjuPFixcPGTLkrbfe6tixY/369QMf/EGDBjVv3nzUqFEXX3zx3/72t7Vr13766aePPfbYaaedVlFRMWTIkC0vCG9pzJgxLVq0GDZs2Ouvv16YLx2g9iTzT//ee+/9m9/8ZvPmzZdffvnGjRsffvjhjRs3Vr0VZUuXXHLJmjVrHnnkkfArrtt/d2vgVElJSXl5+cknn/zGG298//vfP+igg0pKSnI/UW/y5MllZWWBP7qoOt/4/thUKrXle4ZDtjnooIOq3pl85JFHjhgxIvfjA1u3br3V15jbrF69eq1btx49enS9evVy3zwT+OA3b978iSeeaNKkySOPPHLCCSfstddeBx544AUXXPDRRx9lMpkbbrihuq90v/32u//++zds2PDDH/7wq6++8v2aQJ2W2AnT2WefnU6n33zzzX/7t38bP378vvvue+aZZ2672cUXX1yvXr3Ai7S5K665b+HfId841apVqz//+c8TJkzo0aNHq1atSkpKWrRo0aNHj4ceemjOnDknnHBCVEwaNGjQunXr888//y9/+csPfvCD6jbbY489DjjggJ49ez7//PO5q7jhD363bt1mzZp1zTXXHHnkkY0bN27UqNFJJ500duzY//zP/9z2u1q31KtXr379+r3//vtbfqMRQF2UKuaX6ACgqBTXi3MAUMxUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmruUFStWvPvuu0kfBRQFy4FCUM1CadWqVWobEyZMKOhOu3fvPnPmzPDtR48e3blz5+o+W1FRcdhhh+3QHcK29ttvv6olUFJSctRRR919991531vVk7aioiKVSm2ni5YDhaCaBXTXXXfF/9OFF15Y0D2uXbt2Z93VokWLunfvvnDhwp11h+zOxowZk1sCX3311ahRo66//vpHHnmkhvfZtGnTOI6PPPLI6jawHCgE1axtDzzwQMOGDRctWhRF0fLly/fZZ59x48Z99tlnqVTqgQceaNWqVWlp6YABA6oW/NKlS/v06dO4cePWrVsPHjy46vZPPvkkk8k0adJk//33v+qqqyorK0877bT33nuvf//+l1566XYG33777VNOOaVRo0ZdunSp7l+B3//+9+3bt+/UqVNtPSrsLho0aHDWWWd169Ytm80uW7YslUoNHTq0tLS0X79+O/qk3fJc03Kg1qhmbRswYEDXrl1HjhwZRdGIESOOP/74/v375z51xx13TJkyZdasWa+//vrAgQNzN/bu3btJkyYffvjh9OnTX3vttUGDBkVRtGnTpjPPPLOkpGT+/PkzZsyYPXv2Lbfc8uKLL5aVlY0bN27s2LHVDa5bt65Hjx4dOnRYsmTJ0KFDx40b940H2bBhwxdeeOGee+6pxQeG3cjGjRsbN26c+/jdd99dvHjxrbfemveT1nKgVm11CZGdpWXLlls91HvssUfuU/PmzWvatOmdd95ZWlo6b968OI6XL18eRVE2m81tMHXq1JKSktWrV0+fPn2vvfaqrKzM3f7aa6/Vq1dv7dq106dPLykpWbFixVY7zf0zEcdxdYPl5eWlpaVr1qzJ3f7jH//4pJNOqu5L2LBhQxRFM2bMKMDDw26kefPmVVdoKyoqxo0bV69evUmTJi1dujSKosmTJ+c+taNP2i+++CKKonfeecdyoDY516y91zU3btyYu71t27ZDhgwZPHjwdddd17Zt26rtq96JcOyxx65fv37+/Plz585ds2ZNw4YNc++kOOGEEzZv3rxgwYK33367VatWzZo1q27X1Q3OnTv38MMPb9SoUW6zjh07FvgxgH+48sorc0/FFi1ajB49+p577unZs2fuU23atKnhk9ZyoDapZjLmzJkTRdEbb7yx5Y0NGjTIfbBp06YoiurXr79x48a2bdtu9X863/72txs0aJBKpbZz/9UNbrVZ1R6hoKrONdetWzdnzpwrrrii6lMNGzas4ZPWcqA2qWYCnnvuuSeeeGLUqFETJ04sLy+vuv2tt97KfTBr1qzGjRsffvjhRx555MKFCxcvXrzVPbRr127RokW5K1Rbqvq3o7rB9u3bz5s376uvvsr95+zZs3f2Fwd5yvtJazlQm1Sztq1evfqKK6645pprrr/++ssuu2zgwIFffvll7lM33HDDwoUL582bd+ONN/74xz9u2LDh9773vWOOOaZ///6LFi365JNPfvrTn7Zp06aysvKUU05p37791Vdf/dlnn3344Ye9e/f+wQ9+EEXR3nvvvWTJki+//LK6wf/zf/7PQQcddO21137++ecvvPDCgw8+mPTjAf+/vJ+0lgO1aie9Pso/fzdQFEWXX3751Vdffcghh6xevTqO45UrV7Zu3XrgwIG5dwPddNNN3/rWt/bdd9/BgwevX78+dz8fffTROeecs/fee++zzz5nnHHGO++8k7t94cKFZ5555p577tm8efN+/fqtXLkyjuP777+/cePGvXv33s7g/Pnzu3Xrtueee7Zv337w4MHe/kBtvhtoS7l3A+XeEJezQ0/aqncDWQ7UplQcx1ESMplMIvstTuvXr588eXK3bt2aNGmS9LHsvrLZbCL7tRYoNkmthTqhfoL7Lm97e36D6Q9urNHsFi8l7thsOl3Q2T/+8Y+J7Hc7swuGVeQ3e9jwpjWZTeTrTZC1YLaoZtkOr2sCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqTiOoyRkMplE9gvVyWaziezXWqDY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AIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUau5SVqxY8e677yZ9FFAULAcKQTULpVWrVqltTJgwoaA77d69+8yZM8O3Hz16dOfOnbe9fd68eWeddVbTpk0POuigyy+/fNWqVTv1MNm97LffflVLoKSk5Kijjrr77rvzvreqJ21FRUUqldpOFy0HCkE1C+iuu+6K/6cLL7ywoHtcu3Ztze9kw4YNZ5111iGHHLJw4cI///nPr7/++hVXXLEzjo7d15gxY3JL4Kuvvho1atT111//yCOP1PA+mzZtGsfxkUceWd0GlgOFoJq17YEHHmjYsOGiRYuiKFq+fPk+++wzbty4zz77LJVKPfDAA61atSotLR0wYEDVgl+6dGmfPn0aN27cunXrwYMHV93+ySefZDKZJk2a7L///ldddVVlZeVpp5323nvv9e/f/9JLL93O4Ntvv33KKac0atSoS5cuCxcu3PYIX3vttQULFtx555377rtv27Ztb7nllokTJ8ZxXIsPErusBg0anHXWWd26dctms8uWLUulUkOHDi0tLe3Xr9+OPmm3PNe0HKg1qlnbBgwY0LVr15EjR0ZRNGLEiOOPP75///65T91xxx1TpkyZNWvW66+/PnDgwNyNvXv3btKkyYcffjh9+vTXXntt0KBBURRt2rTpzDPPLCkpmT9//owZM2bPnn3LLbe8+OKLZWVl48aNGzt2bHWD69at69GjR4cOHZYsWTJ06NBx48Zte4RdunTZsGFDSUlJ7j+XLl3arFmzVCpViw8Su7iNGzc2btw49/G77767ePHiW2+9Ne8nreVArdrqEiI7S8uWLbd6qPfYY4/cp+bNm9e0adM777yztLR03rx5cRwvX748iqJsNpvbYOrUqSUlJatXr54+ffpee+1VWVmZu/21116rV6/e2rVrp0+fXlJSsmLFiq12mvtnIo7j6gbLy8tLS0vXrFmTu/3HP/7xSSedtJ2voqKi4tBDD73lllt29sPDbqR58+ZVV2grKirGjRtXr169SZMmLV26NIqiyZMn5z61o0/aL774Ioqid955x3KgNjnXrL3XNTdu3Ji7vW3btkOGDBk8ePB1113Xtm3bqu2r3olw7LHHrl+/fv78+XPnzl2zZk3Dhg1z76Q44YQTNm/evGDBgrfffrtVq1bNmjWrbtfVDc6dO/fwww9v1KhRbrOOHTtu5/i/+uqrXr16tW/fftiwYTvpIWE3deWVV+aeii1atBg9evQ999zTs2fP3KfatGlTwyet5UBtUs1kzJkzJ4qiN954Y8sbGzRokPtg06ZNURTVr19/48aNbdu23er/dL797W83aNBg+9eIqhvcarOqPW5rxYoV3bp1a9Wq1VNPPVW/fv2afbns7qrONdetWzdnzpwt31DTsGHDGj5pLQdqk2om4LnnnnviiSdGjRo1ceLE8vLyqtvfeuut3AezZs1q3Ljx4YcffuSRRy5cuHDx4sVb3UO7du0WLVqUu0K1pap/O6obbN++/bx587766qvcf86ePfsbj3Dx4sVdu3Y99dRTH3300apXdKCg8n7SWg7Uqp10pZettWzZctvvPInj+Msvv2zTps1Pf/rT3OsoLVu2XLVqVe51zeOPP37BggXvv//+0UcfPXjw4DiON23a1LFjx+7du3/88ceLFy++9tprW7duvW7dus2bNx933HEXXHDB8uXLFy5ceO65555//vlxHHfq1GnEiBGrVq2qbrCysrJdu3YDBgxYsWLF888/36RJk21fyPniiy+OOOKIG264obYeKnaj1zW3lHtdM/fS/nae7dU9aate17QcqE2qWXvvBoqi6PLLL7/66qsPOeSQ1atXx3G8cuXK1q1bDxw4MFfNm2666Vvf+ta+++47ePDg9evX5+7no48+Ouecc/bee+999tnnjDPOeOedd3K3L1y48Mwzz9xzzz2bN2/er1+/lStXxnF8//33N27cuHfv3tsZnD9/frdu3fbcc8/27dsPHjx4238mbrvttm2P/Msvv6zdx4/drpo7+qStqqblQG1KJfWNR5lMJpH9Fqf169dPnjy5W7duTZo0SfpYdl/ZbDaR/VoLFJuk1kLdECcknU7nfcxmzRZi1lowazbZtVAneDcQAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIlYrjOEpCJpNJZL9QnWw2m8h+rQWKTVJroU6on+C+y8vL8xtMp9Nmze702QTV5Osd/9I1+c32O/XupGbr3HNjd5tlO1yhBYBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVJxHEdJyGQyiewXqpPNZhPZr7VAsUlqLdQJ9RPcd3l5eX6D6XTarNmdPpugmny941+6Jr/ZfqfendRsnXtu7G6zbIcrtAAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIFQqjuMoCZlMJpH9QnWy2Wwi+7UWKDZJrYU6oX6C+y4vL89vMJ1OmzW702cTVJOvd/xL1+Q32+/Uu5OarXPPjd1tlu1whRYAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmANSFn6gHwK4vlar2Uwn9IPSaUE0AajeW225Td/KpmgDUei+/caQutFM1AUiul3Wtnd4NBEARJHOn309hqCYARZa6VPGGUzUBKL7IpYo0nKoJQFHmLVWM4UzFCb3umslkEtkvVCebzSayX2uBOrwWUoUPW5G9OSjJ99CWl5fnN5hOp8vb3p7n7Ac31mi2JsdsNnh2/EvX5Dfb79S7855NkLVgtqhmi+tcMJUqqnC6QgsAoVQTgOJ+0TFVRC9wqiYAhFJNAIr+5C9VLKebqgkAoVQTAEKpJgB14WJpqigu0vqdJwAUWBxHEydGGzdGDRpEZ59dJP3Lj3NNAArs1Vej556L+vSJnnkmmjkzqstUE4ACW7QoqqyMOneOPvnkH3/qMtUEoPAmTIiGDo2mTInqONUEoPD694/Gj4969YrqONUEoMBat44aNYqy2X980LJlVJd5Dy0ABXbiidGyZdGpp/7jPbSdO0d1mWoCUGCpOvytJltxhRaAHREn9Nsui+O3bKomAIRSTQAIlYoTOufNZDKJ7Beqk81mE9mvtUCdXAup1G54eTbhdwOVl5fnN5hOp2s02/b2PGc/uDGxY97NZse/dE1+s/1OvTvv/SbIWjBb3ezuthaKnyu0ABT3yV9cLCeaqgkAO0A1ASjiU8C4iE40VRPydOyxx37y9a9uqKysbNeu3d13392xY8fjjjtu6tSpSR8a1KI43q2SqZqQpz59+jzzzDNRFE2bNu2MM84YPnz4Sy+99Nhjj02YMCHpQ4PaFce7TzJVE/LUt2/fiRMnRlH07LPPnnfeeT169Lj44osXLVr08MMPJ31oUOvieDdJpmpCnsrKylasWLFq1apZs2Z95zvfGT9+/KBBg8aMGdO/f/+kDw2SEMe7QzL99HbI3znnnDNy5MgTTzxx1apVZ5999gsvvNCpU6fDDjss6eOChMTxzvnRB0WcTNWE/PXt2/eYY46ZNm1aaWnpWWed1blz582bN//sZz9L+rggOfHXwcu7ncXdyxzVhDyVlZVVVlbmPh7ytaSPCOpsO+M60Msc1QSgAOL/DuF28ll3YllFNQEopLjupXE7vIcWAEKpJgCEUk0ACKWaABBKNQEglGoCQKhUnNB7gjOZTCL7hepks9lE9mstUGySWgt1QpLfr1leXp7fYDqdLm97e56zH9xYJ2dr8ljVYHb8S9fkN9vv1Lvr3GyCrIXiXwu71Szb4QotAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCUCN/PGPf+zSpcvpp59+yimnzJgxI4qilStXptPprl27ptPplStXVm25Zs2a73//+6eddlqnTp1+//vfR1E0cuTI9u3bjxo1KoqizZs39+zZs6KiIipiqglAjQwYMODRRx+dNm3a+PHjBwwYEEXRiBEjTj311JdffvmUU0657bbbqrb87W9/e8IJJ7z44ouTJk36yU9+EkXRr3/967/+9a933nlnFEVjx47t3bt306ZNoyKmmgDUSPPmzVesWBFF0YoVK7766qsoiiZPnnz++edHUXT++efnzilzLrvssmuu+cfPIXn77bcbNGgQRVGDBg3+/ve/l5SUfP755xMnTuzfv39U3JL82UAA7ALuvfferl27HnHEEfPmzXvqqaeiKPr0008PPPDAKIoOOuigTz/9tGrLfffdN4qiiy666Omnn37mmWdyZ6UXXnjhbbfdNmzYsJ///OepVCoqbs41AaiR66+//tFHH509e/Yjjzzy9NNP/9PtH3nkkccee+yhhx7KFXTmzJllZWVRFC1YsKBnz5657hYt1QSgRmbPnp37JQTnnntu7gyyRYsWy5Yti6Jo6dKlLVq0qNry6quv3rhxYxRFZ511VtWV2ziOb7755l/84hc33HDDAw88cMMNN0RFTDUBqJGysrK//OUvURTNmDHjkEMOiaKoR48ejz/+eBRFjz/+eI8ePaIoWr16de69tbmfKf/Xv/41d34ZRdGDDz7Yq1ev5s2br127No7jNWvWREXM65oA1Mi9996be49PKpUaO3ZsFEX/+q//eskllzz99NP77bdf7krsueeeO3Xq1OHDh19yySW/+c1vSkpKHnzwwSiKKioqnnzyycmTJ0dRNGjQoO7du1933XVREVNNAGqkQ4cO06dP3/KW0tLSrX5P2dSpU6MoatOmzbRp07a8vWnTplOmTMl9fNPXouLmCi0AhFJNAAilmgAQKhXHcZSE3NuUoXhks9lE9mstUGySWgt1Q5yQdDqd9zGbNVuIWWvBrNlk10Kd4AotAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIlYrjOEpCJpNJZL9QnWw2m8h+rQWKTVJroW6IE5JOp/M+ZrNmCzFrLZg1m+xaqBNcoQWAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFScRxHSchkMonsF6qTzWYT2a+1QLFJai3UDXFC0ul03sds1mwhZq0Fs2aTXQt1giu0ABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEgVCqO4ygJmUwmkf1CdbLZbCL7tRYoNkmthbohTkg6nc77mM2aLcSstWDWbLJroU5whRYAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRKxXEcJSGTySSyX6hONptN+hCAohcnJJ1O533MZs0WYjaptQDUIa7QAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKk4joM3BoDdmnNNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRq7lJWrFjx7rvvJn0UUAdYLORHNQulVatWqW1MmDChoDvt3r37zJkzw7cfPXp0586dt739008/7dOnzz777NO6devhw4fv1GOE/2G//farWiAlJSVHHXXU3Xffnfe9VT2lKyoqUqnUdrposZCf+nnOEeCuu+766U9/Wpt7XLt27U65nx/+8Idt2rRZtGjRvHnzzjzzzAMPPPDSSy/dKfcM2xozZswVV1wRRdGGDRv+8Ic/nHvuufvuu+9FF11Uk/ts2rRpHMfb2cBiIT/ONWvbAw880LBhw0WLFkVRtHz58n322WfcuHGfffZZKpV64IEHWrVqVVpaOmDAgKolvXTp0j59+jRu3Lh169aDBw+uuv2TTz7JZDJNmjTZf//9r7rqqsrKytNOO+29997r379/btFWN/j222+fcsopjRo16tKly8KFC7c9wvnz50+bNm306NGlpaXHH3/86aef/te//rUWHyF2Xw0aNDjrrLO6deuWzWaXLVuWSqWGDh1aWlrar1+/HX1Kb3muabGwM8UURsuWLe+6665v/NT3vve9q666Ko7ja6+99vTTT4/jePny5VEUtWvXbvbs2fPnz+/QocOPfvSj3MYnn3xyv379li9fPn/+/K5du15++eVxHG/cuPHoo48+77zzPv3003nz5nXt2vXGG2+M47isrGzcuHHbGVy7dm2bNm1+8pOffP75588880yjRo1OOumk6r6EDRs2vPDCC82aNXvmmWcK8yBB3Lx58zFjxmx5S/fu3S+66KKlS5dGUZROp1etWvXRRx/t6FP6iy++iKLonXfesVjYuVSzUFq2bLnV/6DsscceuU/NmzevadOmd955Z2lp6bx586qqmc1mcxtMnTq1pKRk9erV06dP32uvvSorK3O3v/baa/Xq1Vu7du306dNLSkpWrFix1U6r/iGobrC8vLy0tHTNmjW523/84x9v5x+CsrKyhg0bnnbaacuXLy/AIwRbV7OiomLcuHH16tWbNGlSrpqTJ0/OfWpHn9JV1bRY2LlcoS2grc41N27cmLu9bdu2Q4YMGTx48HXXXde2bduq7avea3DssceuX79+/vz5c+fOXbNmTcOGDXPvlTjhhBM2b968YMGCt99+u1WrVs2aNatu19UNzp079/DDD2/UqFFus44dO27n+N99990VK1bstddeZ5111k56SOAbXHnllbknaosWLUaPHn3PPff07Nkz96k2bdrU8CltsbBzqWYy5syZE0XRG2+8seWNDRo0yH2wadOmf7xTq379jRs3tm3bdqv/0/n2t7/doEGDVCq1nfuvbnCrzar2WJ2999572LBhr7zyypIlS/L9WuGfqDrXXLdu3Zw5c3LvDMpp2LBhDZ/SFgs7l2om4LnnnnviiSdGjRo1ceLE8vLyqtvfeuut3AezZs1q3Ljx4YcffuSRRy5cuHDx4sVb3UO7du0WLVqUuwa1pap/HaobbN++/bx587766qvcf86ePXvbw5syZUppaWllZWXuPz///PM99tijadOmNfuioUbyfkpbLOxkO+lKL6HvBvryyy/btGnz05/+NPdKScuWLVetWpV7XfP4449fsGDB+++/f/TRRw8ePDiO402bNnXs2LF79+4ff/zx4sWLr7322tatW69bt27z5s3HHXfcBRdcsHz58oULF5577rnnn39+HMedOnUaMWLEqlWrqhusrKxs167dgAEDVqxY8fzzzzdp0mTbl2rWrl3brl27q666qqKi4s033zzqqKMuvfTS2nrY2O1s+26gnNzrmrkX/rezFqp7Sle9rmmxsHOpZu29GyiKossvv/zqq68+5JBDVq9eHcfxypUrW7duPXDgwFw1b7rppm9961v77rvv4MGD169fn7ufjz766Jxzztl777332WefM84445133sndvnDhwjPPPHPPPfds3rx5v379Vq5cGcfx/fff37hx4969e29ncP78+d26ddtzzz3bt28/ePDgb3yDwwcffNCjR4999tmnTZs2Q4cOXbt2bS0+cuxeAqu5o0/pqmpaLOxcqe1/I3BNZDKZAt3zrmf9+vWTJ0/u1q1bkyZNkj4Wvlk2m01kv9YRxSab0FooFnHBpNPpvI9qd5vt0aNHIvs1WwwrxToyW7dm492bdwMBQCjVLAolJSVJHwIA/5xqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIFQqjuOoMDKZTIHuGWpfNptNZL/WEcUmm9BaKBL1C3rv5eXl+Q2m0+k6Odv29jxnP7ixTn69u9Nsgmry9WZXLslvNlN6cFKz1lGRz+7mXKEFgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChUnEcR4WRyWQKdM9Q+7LZbCL7tY4oNtmE1kKRqF/Qey8vL89vMJ1O12i27e15zn5wY53cr9nCzyaoJl9vduWS/GYzpQcnNWsdFfnsbs4VWgAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAECoVx3FUGJlMpkD3DLUvm80msl/riGKTTWgtFIn6Bb338vLy/AbT6XSNZtvenufsBzfudrNJ/R3VtdkE1eTrza5ckt9spvTgpGatoyKf3c25QgsAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAIrjJ+oBwPakUtV+qmA/Jr0mVBOAYorlttsUUz5VE4Ai6+U3jhRHO1UTgGLtZfG107uBACj6ZO70+8mXagJQYKmdmrpEw6maABRSqgCRSy6cqglAwaQKlreEwpmKC/bKaiaTKdA9Q+3LZrOJ7Nc6og6vhVThw1brbw4q7Htoy8vL8xtMp9OJzba9Pc/ZD26sk1+v2aJX5x4r62jXni2uc8FUqpbD6QotAIRSTQDq8ouOqVp9gVM1ASCUagJQx9/dmqq9PaomAIRSTQAIpZoA1P2f2pOqpf36nScAJCqOo4kTo40bowYNorPPTvzns2+fc00AEvXqq9Fzz0V9+kTPPBPNnBkVN9UEIFGLFkWVlVHnztEnn/zjT3FTTQCSNmFCNHRoNGVKVPRUE4Ck9e8fjR8f9eoVFT3VBCBRrVtHjRpF2ew/PmjZMipu3kMLQKJOPDFatiw69dR/vIe2c+eouKkmAIlKFfW3mmzFFVoA6vCvia7l/aomAIRSTQAIlYoLdlabyWQKdM9Q+7LZbCL7tY6ok2shldplLwvHBZNOp/M+KrNmi222cCvFOjJbt2bjEFFUq39qkSu0ANTtk7+oFqkmAIRSTQDq7ClgXNvf6KKasPMde+yxn3z9qxsqKyvbtWt39913d+zY8bjjjps6dWrShwa1KI53ve8NVU3Y+fr06fPMM89EUTRt2rQzzjhj+PDhL7300mOPPTZhwoSkDw1qVxzvYj9OQTVh5+vbt+/EiROjKHr22WfPO++8Hj16XHzxxYsWLXr44YeTPjSodXG86/wEItWEQigrK1uxYsWqVatmzZr1ne98Z/z48YMGDRozZkz//v2TPjRIQhzvGsn009uhUM4555yRI0eeeOKJq1atOvvss1944YVOnToddthhSR8XJCSOd86PPkg0maoJhdK3b99jjjlm2rRppaWlZ511VufOnTdv3vyzn/0s6eOC5MRfBy/vdibdyxzVhIIoKyurrKzMfTzka0kfEdTZdsZF0csc1QSg1sX/HcLt5LOYYllFNQFITlyMadwO76EFgFCqCQChVBMAQqkmAIRSTQAIpZoAECoVF+xdv5lMpkD3DLUvm80msl/riGKTTWgtFIu4YNLpdN5HZdZssc0WbqVYR2br1my8e3OFFgBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSggM4///zTvtalS5f99tsvd+ODDz54yimnHHvssVOnTt1y461uHzlyZPv27UeNGhVF0ebNm3v27FlRURElyu/XBKCAHn/88dwHY8eO/fjjj6MoWr58+UMPPTR9+vT3338/k8m88847uQ22vf3Xv/71e++9V1ZWNmTIkLFjx/bu3btp06aJfjWqCUDhxXF8zz33/OEPf4iiaMWKFQMHDqxXr17r1q1XrFhRtc22tzdo0ODvf/97SUnJ559/PnHixEmTJkVJU00ACu7ZZ5894YQTDjjggCiKjvxaFEVPPfVUr169qrbZ9vYRI0ZceOGFt91227Bhw37+85+nUqkoaV7XBKDgfvWrX1133XVb3jJ//vxRo0aNHDlyqy23vP2iiy6aOXNmWVlZFEULFizo2bPnU089FSXKuSYAhfXKK680bdo0F7+c1atXf//733/ggQf233//Lbfc9vY4jm+++eaHH364U6dOM2fO7NKlS58+faLkONcEoLDuuOOOLU804zi+5JJLrrvuupNOOil3y+rVq7/x9ty7anv16tW8efO1a9fGcbxmzZooUc41ASigDz74YMmSJaeeemrVLePHj//DH/6wYsWK++67r3HjxpMmTTr33HOnTp267e0VFRVPPvnk5MmToygaNGhQ9+7dt7rMW/tUE4ACatu27YwZM7a8pf/Xtrwl992Z297etGnTKVOm5D6+6WtR0lyhBYBQqgkAoVQTAEKl4jiOCiOTyRTonqH2ZbPZRPZrHVFssgmthWIRF0w6nc77qBKcjU8/Mb8/dfTrNZv4Stkl15HZXXg23r25QgsAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKl4jiOCiOTyRTonqH2ZbPZRPZrHVFssgmthSJRv6D3Xl5ent9gOp2uyWx25ZL8ZjOlB+9us0n9HdW52QTVuccqwVlroRZmd3Ou0AJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCpOI6jwshkMgW6Z6h92Ww2kf1aRxSbbEJroUjUL+i9l5eX5zeYTqdrMptduSS/2UzpwXVxv2ZrYTZBde6xMrtrz+7mXKEFgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChUnEcR4WRyWQKdM9Q+7LZbCL7tY4oNtmE1kKxiAsmnU7nfVR1dDY+/cT8/tTRr3e3mi3cSrGOzNat2Xj35gotAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIlYrjOCqMTCZToHuG2pfNZpM+BKAIxAWTTqfzPiqzZotttnArBahDXKEFgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChUnEcB28MALs155oAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNXcpaxYseLdd99N+iigzrOUqI5qFkqrVq1S25gwYUJBd9q9e/eZM2eGbz969OjOnTtvZ4OBAweedtppO+PQIB/77bdf1fIpKSk56qij7r777rzvreoJX1FRkUqlttNFS4nqqGYB3XXXXfH/dOGFFxZ0j2vXrt2J9/byyy//7ne/24l3CHkYM2ZMbvl89dVXo0aNuv766x955JEa3mfTpk3jOD7yyCOr28BSojqqWdseeOCBhg0bLlq0KIqi5cuX77PPPuPGjfvss89SqdQDDzzQqlWr0tLSAQMGVC3apUuX9unTp3Hjxq1btx48eHDV7Z988kkmk2nSpMn+++9/1VVXVVZWnnbaae+9917//v0vvfTS7Qy+/fbbp5xySqNGjbp06bJw4cLqjnPdunUDBgw4/vjja+VRgX+uQYMGZ511Vrdu3bLZ7LJly1Kp1NChQ0tLS/v167ejT/gtzzUtJXaIata2AQMGdO3adeTIkVEUjRgx4vjjj+/fv3/uU3fccceUKVNmzZr1+uuvDxw4MHdj7969mzRp8uGHH06fPv21114bNGhQFEWbNm0688wzS0pK5s+fP2PGjNmzZ99yyy0vvvhiWVnZuHHjxo4dW93gunXrevTo0aFDhyVLlgwdOnTcuHHVHefNN9/8v/7X/zr33HNr64GBIBs3bmzcuHHu43fffXfx4sW33npr3k94S4kdttUlRHaWli1bbvVQ77HHHrlPzZs3r2nTpnfeeWdpaem8efPiOF6+fHkURdlsNrfB1KlTS0pKVq9ePX369L322quysjJ3+2uvvVavXr21a9dOnz69pKRkxYoVW+00t9TjOK5usLy8vLS0dM2aNbnbf/zjH5900knbHvyrr766//77L1269Lbbbvvud79bsAcJ/onmzZtXXaGtqKgYN25cvXr1Jk2atHTp0iiKJk+enPvUjj7hv/jiiyiK3nnnHUuJHeVcs/Ze19y4cWPu9rZt2w4ZMmTw4MHXXXdd27Ztq7avejfBscceu379+vnz58+dO3fNmjUNGzbMvRvihBNO2Lx584IFC95+++1WrVo1a9asul1XNzh37tzDDz+8UaNGuc06duy47eyGDRt+9KMfjRo16sADD9zZDwnssCuvvDL3NG7RosXo0aPvueeenj175j7Vpk2bGj7hLSV2lGomY86cOVEUvfHGG1ve2KBBg9wHmzZtiqKofv36GzdubNu27Vb/p/Ptb3+7QYMGqVRqO/df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7dt34sSJURQ9++yz5513Xo8ePS6++OJFixY9/PDDSR8a1Lo4rltnsaoJta2srGzFihWrVq2aNWvWd77znfHjxw8aNGjMmDH9+/dP+tAgCXFcvPe2DT+9HRJwzjnnjBw58sQTT1y1atXZZ5/9wgsvdOrU6bDDDkv6uCAhcbxzfvRB4d9kpJqQgL59+x5zzDHTpk0rLS0966yzOnfuvHnz5p/97GdJHxckJ/46eHm3s7a+B1Q1IQFlZWWVlZW5j4d8LekjgjrbzrhWf4+KagJQZOL/DuF28pnQLx1TTQCKVZzQ7+OsnvfQAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAiVimvwvt5MJpP3LOxKstlsIvu1Bik22YTWQu2JayCdTue93zo6e8u8OL8/dfTrNVsL68gaNLsrzca7OldoASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAS8/zzzx922GGnfW3YsGFRFG3evPmaa645+eSTTz311AULFlRtuXLlynQ63bVr13Q6vXLlyiiKRo4c2b59+1GjRuWmevbsWVFRUegDVk0AErNs2bIbbrjhxa8NHz48iqJ77723SZMmM2bMGDRo0PXXX1+15YgRI0499dSXX375lFNOue2226Io+vWvf/3Xv/71zjvvjKJo7NixvXv3btq0aaEPWDUBSMzSpUsPOuigLW959NFH+/fvH0VRz549O3fuXHX75MmTzz///CiKzj///N///vdRFDVo0ODvf/97SUnJ559/PnHixNxUoakmAIlZunTp73//+65du5599tnz58+Pouj9999/5plnTjvttO9///vnnXde1ZaffvrpgQceGEXRQQcd9Omnn+bOPi+88MLbbrtt2LBhP//5z1OpVC0csGoCkJhUKtWhQ4eXX365X79+l112WRRF69ev/9a3vvXiiy9eeOGFAwYM2M7sRRddNHPmzLKysiiKFixY0LNnz6eeeqrQB1y/0DsAgOpcc801rVu3jqLonHPOufzyy6MoatGiRe4H4abT6SuuuKJqyxYtWixbtuzggw9eunRpixYtcjfGcXzzzTc//PDDnTp1mjlzZpcuXfr06RMVknNNABJz0003TZo0KYqiV1555eijj46i6Hvf+95LL70URdFLL73UoUOHKIpWr14dRVGPHj0ef/zxKIoef/zxHj165MYffPDBXr16NW/efO3atXEcr1mzptAH7FwTgMT84he/6N+//1133bXnnnvef//9URTdeuutAwYMuPXWW+vXr3/fffdFUXTuuedOnTr1X//1Xy+55JKnn356v/32e+ihh6IoqqioePLJJydPnhxF0aBBg7p3737dddcV+oBVE4DEHHHEES+//PKWtxxwwAHPPvvslrdMnTo1iqLS0tLy8vItb2/atOmUKVNyH9/0tVo4YFdoASCUagJAKNUEgFCpOI6jfGUymbxnYVeSzWYT2a81SLHJJrQWak1N3w201Wuz4dLpdFKzHUbl+Zf65pBMTWbr4mNltvjVucfK7K49u8tzhRYAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRKxXEc5SuTyeQ9C7uSbDabyH6tQYpNNqG1UGvq13C+vLw8v8F0Ol2T2Q6j8vyLeXNIJqljNrsLzybIGjRbVLO7PFdoASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAqFQcx1G+MplM3rOwK8lms4ns1xqk2GQTWgu1pn4N58vLy/MbTKfTSc12GJXnX+qbQzI1ma2Lj5XZ4lfnHiuzu/bsLs8VWgAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAECoVx3GUr0wmk/cs7Eqy2WzShwDUirgG0ul03vs1a3ZXmq3JOgLqEFdoASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAqFQcx1G+MplM3rOwK8lms0kfAlAr4hpIp9N579es2V1ptibrCKhDXKEFgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChUnEcR/nKZDJ5z8KuJJvNJn0IQK2IayCdTue9X7Nmd6XZmqwjoA5xhRYAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRKxXEcvDEA7NacawJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQBRoP8PwaLZjK9YN0sAAAAASUVORK5CYII="
            },
            {
              "type": "input_text",
              "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
            }
          ],
          "solved_count": 0,
          "total_training_examples": 4,
          "pixel_accuracy": 0.7029360967184801
        },
        "test_result": {
          "correct": false,
          "pixel_accuracy": 0.0,
          "total_pixels": 224,
          "correct_pixels": 0,
          "error": "Grid height mismatch"
        },
        "status": "failed_test",
        "feedback_sent": true
      },
      {
        "turn_number": 4,
        "timestamp": "2025-07-10T10:41:56.808849",
        "input_tokens": 24381,
        "output_tokens": 2388,
        "turn_cost": 0.0135732,
        "program_extracted": true,
        "program": "def transform(grid):\n    import numpy as np\n\n    arr = np.array(grid)\n    target_size = 11\n\n    # Normalize input size\n    norm = np.zeros((target_size, target_size), dtype=int)\n    rows, cols = arr.shape\n    norm[:min(rows, target_size), :min(cols, target_size)] = arr[:target_size, :target_size]\n    arr = norm\n\n    output = np.zeros_like(arr)\n\n    blue_color = 1\n\n    # Copy blue pixels unchanged\n    blue_mask = (arr == blue_color)\n    output[blue_mask] = blue_color\n\n    # Identify colors excluding 0 and blue\n    colors = set(np.unique(arr))\n    colors.discard(0)\n    if blue_color in colors:\n        colors.discard(blue_color)\n\n    # Define quadrant boundaries ((row_start, row_end), (col_start, col_end))\n    # Split at row=6, col=6 (0-based indices)\n    def get_quadrant(r, c):\n        if r < 6 and c < 6:\n            return 'TL'\n        elif r < 6 and c >= 6:\n            return 'TR'\n        elif r >= 6 and c < 6:\n            return 'BL'\n        else:\n            return 'BR'\n\n    quadrant_to_pos = {\n        'TL': (0, 0),\n        'TR': (0, 6),\n        'BL': (6, 0),\n        'BR': (6, 6)\n    }\n\n    # Define quadrant copies mapping\n    quadrant_copy_map = {\n        'TL': 'TR',\n        'TR': 'BL',\n        'BL': 'BR',\n        'BR': 'TL'\n    }\n\n    for color in colors:\n        mask = (arr == color)\n        if not np.any(mask):\n            continue\n        rows_c, cols_c = np.where(mask)\n        min_r, max_r = rows_c.min(), rows_c.max()\n        min_c, max_c = cols_c.min(), cols_c.max()\n\n        # Copy original cluster pixels unchanged\n        for (r, c) in zip(rows_c, cols_c):\n            output[r, c] = color\n\n        # Calculate cluster centroid to find quadrant\n        mean_r = int(np.round(np.mean(rows_c)))\n        mean_c = int(np.round(np.mean(cols_c)))\n        orig_quad = get_quadrant(mean_r, mean_c)\n        target_quad = quadrant_copy_map[orig_quad]\n\n        # Get top-left corner of orig and target quadrants\n        orig_r0, orig_c0 = quadrant_to_pos[orig_quad]\n        targ_r0, targ_c0 = quadrant_to_pos[target_quad]\n\n        # Compute cluster offset relative to orig quadrant\n        offset_r = min_r - orig_r0\n        offset_c = min_c - orig_c0\n\n        # Compute target cluster top-left position in target quadrant\n        new_min_r = targ_r0 + offset_r\n        new_min_c = targ_c0 + offset_c\n\n        # Ensure cluster fits into output bounds\n        cluster_height = max_r - min_r + 1\n        cluster_width = max_c - min_c + 1\n\n        max_row = targ_r0 + 5\n        max_col = targ_c0 + 5\n\n        if new_min_r < targ_r0:\n            new_min_r = targ_r0\n        if new_min_c < targ_c0:\n            new_min_c = targ_c0\n\n        if new_min_r + cluster_height -1 > max_row:\n            new_min_r = max_row - cluster_height +1\n        if new_min_c + cluster_width -1 > max_col:\n            new_min_c = max_col - cluster_width +1\n\n        # Write duplicated cluster pixels into output at computed positions\n        for r, c in zip(rows_c, cols_c):\n            rr = r - min_r + new_min_r\n            cc = c - min_c + new_min_c\n            if 0 <= rr < target_size and 0 <= cc < target_size:\n                # Avoid overwriting blue pixels, but overwrite others\n                if output[rr, cc] != blue_color:\n                    output[rr, cc] = color\n\n    return output.tolist()",
        "training_feedback": {
          "feedback_messages": [
            {
              "type": "input_text",
              "text": "Training results: 0/4 examples solved, 76.3% pixel accuracy - Good partial progress! Your approach is capturing some patterns. Next, try to identify a transformation that solves at least one of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[1, 1, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 1, 1, 1, 0, 3, 3, 3, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 1, 1, 1, 0, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0]]\nPixel accuracy: 86.0%\n\nTraining Example 2 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 1, 0, 0, 0, 0, 0, 0, 6, 0], [0, 1, 1, 1, 1, 0, 0, 6, 6, 6, 6], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 6, 0], [0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 87.1%\n\nTraining Example 3 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 78.5%\n\nTraining Example 4 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 60.4%\n\n\u26a0\ufe0f  GRID SIZE ERROR: One or more of your output grids are incorrect in size. They should ALL be 11\u00d711 for this task.\n\n"
            },
            {
              "type": "input_image",
              "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAmcAAATYCAIAAADVnPfcAABQf0lEQVR4nO3de3hU9b3o4TVIgigYFBSVS70g0R4UES+ISLVwnqMgOiNgbb0Uiq2XjRdQVPa2euqRikK1tbXoKYoiunVrnaAWKdoi1haUKruCeEFA5aZFNCAC4bbOY+fsPGww9MeEyZrA+z78ESfrO2tlmB8f15pJkorjOAIAAjQI2QgAUE0A2AGqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmANRJNQcPHpyq2YUXXvi125SWlh544IFnn332G2+8se19vvDCC6lUar/99lu3bt1Wn3rqqadSqdTYsWNz/zlgwIBUKjVq1KitNlu8eHEqlbrppptqM5Wzbt26+++///TTTz/44IMbNWp08MEH9+/f/09/+tN2HpObbrqppgdkzpw523/Qevbs+U8f2OptLrnkki1vzx1e3759p0+fvuXxpNPprTY79NBDr7rqqs8//3yHHvycTz/99LbbbuvUqVNZWdnee+994oknjh07dstfm5Pb3Vbjr7/++v7779+0adOpU6du56EDKH4JnGtu2LDhk08+efbZZ08//fQFCxZs9dkHH3wwiqLPP//8iSeeCLm3m2+++Z133tnRYwiZ+uCDD04++eTLLrvspZdeWrZs2fr165ctW/bUU0917979rrvuiopM7vCefvrpbt26Pfroo9vZ7IMPPvjlL395xhlnbN68eYce/OnTp3fs2PHHP/7xf/7nf65atWrNmjUzZ8784Q9/OGjQoO0c2B//+MfTTz9906ZNL7744umnn16LLxGgnlfzV7/6VfxfnnzyySiKxo0bV33LhAkTqrdcuHBh9e3r1q17++23v/e9761atWrMmDFb3mFlZWVFRUX//v3322+/++67L+QY1q9fP2DAgE2bNu3Qkf/TqQ0bNvTr1+8///M/u3bt+swzz3z66acbNmz46KOPfv3rX++3337XX3997sSxJrNmzYq30aFDh699QKq9+OKLW95JyDbLli3L3b527dr333//xhtvjOP4Bz/4wYcffrjlZmvXrt3ywe/Zs+drr732wgsvhD/4f//73zOZzNKlS7/73e/OmDFj1apVn332WUVFxWGHHTZu3Lj777//ax+HbDbbq1evvfba66WXXjrppJO284gB1AsJnGs2atToyCOPvOOOO6Io2upc87HHHlu3bt2ll146cODAGTNmvPnmm//03q688spXX331Zz/72Q4dwz+devjhh19//fWePXu+/PLLffr0ad68ecOGDdu0aXP55Zc//fTTmzZt+vd///eomOy5556HH3747bfffvPNN69fv/7nP//5dh78a665Jlfc8Af/rrvu+uSTT4YMGfLYY4+ddNJJTZs23Xfffc8555xp06btvffed91117a/3vyBBx7o37//AQcc8Kc//emYY46pvv2hhx5KpVK/+tWvduoDALCLVrOqquqtt94aOnRoFEXt27ff8lPjxo076qijvv3tb19++eV77LFHyOnmT3/603bt2t18881vv/12+DH806nHHnsslUr93//7f/fYY4+tPvWtb31r7ty5t912W1SUrr322r322uv3v//91352w4YN77333j333NOwYcNvfetb4Q/+f/zHfzRu3PjWW2/d6g5bt279yiuvvPTSS6lUasvb77zzzksuueSwww575ZVXjjjiiJ339QHsBtU89NBDq9+Qsueee3bo0OHJJ59s0aLF1VdfXb3NnDlz/vrXvw4bNiyVSh1++OH9+/d/9NFHV69evf173muvvcaNG7dhw4Yduk77T6dmzZp11FFHHXrooV87ftRRR20Via106tRpq3fxvPLKKzU9INVeeumlHd1mW02bNj3iiCO2Oolv3Lhxbry0tLS8vPzPf/7zww8/vOVXt/0Hf8OGDR988MGJJ57YpEmTbfd47LHHHnTQQVvecv31199www1RFJ166qlt27bdavsBAwbEcTx48ODtfyEARSiZ7zxp1arVD37wg7/97W8HHnhg9Y0PPvhgq1atLrjggtx/Dh8+/Isvvgi5ENqtW7errrrqtddeGz16dPgxbGdqw4YNlZWVLVu23PLGrd7Xesghh0TFqnnz5lX/UNMGmzZtmjFjxoYNGwIf/MrKyjiOmzdvHngAv/zlL08++eSePXs++OCDTz/9dO2+GoDdr5q5N7asX7/+8ccfz50MjRw58uCDD67eYMOGDRMmTFiyZEmjRo1yWerYsWMcx4HvCfrpT396xBFH3HLLLXPnzg0/qpqmSkpKmjZtunz58ihf274bqFu3bv/0nT6nnXbajm7ztT7//POSkpJGjRpt+26g9evXL1iw4F/+5V9++ctfXnfddYEP/n777degQYPwB2TgwIEvvfTS+PHj99tvvx/+8IdLliwJHAQocnV6rllSUvKd73zniSeemDZt2hlnnLHld/U999xzX/uP8htvvDFz5sx/es+NGzfO4zrtdqaOPvrouXPnfvTRR1/7huHOnTtHxWr16tVz5sw56qijvvazJSUlhx566OjRozt06PDQQw8FPvh77LHHUUcd9de//nXNmjXbbnb77bdffPHFS5curb7l17/+dWlp6UEHHfSrX/3qs88+u/jii7f9LheA+iiBK7RnnnnmlVde+cYbb1Sf6+SuEO65554rV67c8rzqL3/5SxRFNX1Xw1ZOOeWUq6++eubMmdv+BIM8pi644ILNmzdfccUVX9vgbd8vWjzuvvvuDRs2nHHGGdvfrEGDBqtXr964cWPgg59Op9euXfu///f/3up+PvjggzvvvPO555772uu33/3ud/v16/fHP/5xhy6eAxStZF7X/OlPf9q2bdsxY8a8+uqrURR9/PHHkydP7tOnzz777LPlZieffHJ5efm///u/r1y5MuRuR4wYccQRR/z617/eoYP52qlLLrmkc+fOv/vd70488cT/+I//+Pjjjzds2JD7KQe9e/d+4403GjQorh9GWFVV9e677950000/+clP9tprr5reaxPH8eLFi4cNG/bmm2926tSpYcOGgQ/+kCFDmjdvPmrUqIsvvvivf/3r2rVrP/nkk8cee+y0006rrKwcNmzYlheEtzRmzJiWLVvedNNNr7/+emG+dIC6k8w//Xvvvfcvf/nLzZs3X3rppRs3bhw/fvzGjRur34qype9///tr1qx55JFHwq+4bv/drYFTpaWlFRUVJ5988htvvPGd73znoIMOKi0tzf1EvUmTJpWXlwf+6KKafO37Y1Op1JbvGQ7Z5qCDDqp+Z/KRRx45YsSI3I8PbNOmzVZfY26zBg0atGnTZvTo0Q0aNMh980zgg9+8efMnnniiadOmjzzyyAknnLDXXnsdeOCBF1xwwYcffpjJZK6//vqavtIWLVr85je/2bBhw/e+970vv/zS92sC9VpiJ0xnn312Op3+29/+9vOf//yhhx7ad999zzzzzG03u/jiixs0aBB4kTZ3xTX3Lfw75GunWrdu/ac//WnChAm9evVq3bp1aWlpy5Yte/Xq9fDDD8+ZM+eEE06IiklJSUmbNm3OP//8P//5z9/97ndr2myPPfY44IADevfu/cILL+Su4oY/+D169Jg1a9ZVV1115JFHNmnSpHHjxieddNLYsWN/+9vfbvtdrVvq06fPgAED3nvvvS2/0QigPkoV80t0AFBUiuvFOQAoZqoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFLNXcqKFSveeeedpI8CioLlQCGoZqG0bt06tY0JEyYUdKc9e/acMWNG+PajR4/u0qVLTZ+trKw87LDDdugOYVstWrSoXgKlpaVHHXXUPffck/e9VT9pKysrU6nUdrpoOVAIqllAd999d/zfXXjhhQXd49q1a3fWXS1atKhnz54LFy7cWXfI7mzMmDG5JfDll1+OGjXquuuue+SRR2p5n82aNYvj+Mgjj6xpA8uBQlDNuvbAAw80atRo0aJFURQtX758n332GTdu3KeffppKpR544IHWrVuXlZUNGjSoesEvW7asX79+TZo0adOmzdChQ6tvX7JkSSaTadq06f7773/FFVdUVVWddtpp77777sCBAy+55JLtDL711lunnnpq48aNu3btWtO/Ar/73e86dOjQuXPnunpU2F2UlJScddZZPXr0yGazH3/8cSqVGj58eFlZ2YABA3b0SbvluablQJ1Rzbo2aNCgbt26jRw5MoqiESNGHH/88QMHDsx96s4775w8efKsWbNef/31wYMH527s27dv06ZNP/jgg2nTps2cOXPIkCFRFG3atOnMM88sLS2dP3/+9OnTZ8+efcstt7z00kvl5eXjxo0bO3ZsTYPr1q3r1atXx44dly5dOnz48HHjxn3tQTZq1OjFF1+899576/CBYTeycePGJk2a5D5+5513Fi9efOutt+b9pLUcqFNbXUJkZ2nVqtVWD/Uee+yR+9S8efOaNWt21113lZWVzZs3L47j5cuXR1GUzWZzG0yZMqW0tHT16tXTpk3ba6+9qqqqcrfPnDmzQYMGa9eunTZtWmlp6YoVK7baae6fiTiOaxqsqKgoKytbs2ZN7vYf/ehHJ510Uk1fwoYNG6Iomj59egEeHnYjzZs3r75CW1lZOW7cuAYNGjz33HPLli2LomjSpEm5T+3ok/bzzz+Poujtt9+2HKhLzjXr7nXNjRs35m5v167dsGHDhg4deu2117Zr1656++p3Ihx77LHr16+fP3/+3Llz16xZ06hRo9w7KU444YTNmzcvWLDgrbfeat269X777VfTrmsanDt37uGHH964cePcZp06dSrwYwBfufzyy3NPxZYtW44ePfree+/t3bt37lNt27at5ZPWcqAuqWYy5syZE0XRG2+8seWNJSUluQ82bdoURVHDhg03btzYrl27rf5P55vf/GZJSUkqldrO/dc0uNVm1XuEgqo+11y3bt2cOXMuu+yy6k81atSolk9ay4G6pJoJeP7555944olRo0ZNnDixoqKi+vY333wz98GsWbOaNGly+OGHH3nkkQsXLly8ePFW99C+fftFixblrlBtqfrfjpoGO3ToMG/evC+//DL3n7Nnz97ZXxzkKe8nreVAXVLNurZ69erLLrvsqquuuu666374wx8OHjz4iy++yH3q+uuvX7hw4bx582644YYf/ehHjRo1+va3v33MMccMHDhw0aJFS5Ysueaaa9q2bVtVVXXqqad26NDhyiuv/PTTTz/44IO+fft+97vfjaJo7733Xrp06RdffFHT4P/6X//roIMOuvrqqz/77LMXX3zxwQcfTPrxgP8v7yet5UCd2kmvj/LP3w0URdGll1565ZVXHnLIIatXr47jeOXKlW3atBk8eHDu3UA33njjN77xjX333Xfo0KHr16/P3c+HH354zjnn7L333vvss88ZZ5zx9ttv525fuHDhmWeeueeeezZv3nzAgAErV66M4/g3v/lNkyZN+vbtu53B+fPn9+jRY8899+zQocPQoUO9/YG6fDfQlnLvBsq9IS5nh5601e8GshyoS6k4jqMkZDKZRPZbnNavXz9p0qQePXo0bdo06WPZfWWz2UT2ay1QbJJaC/VCwwT3XdHujvwG0+/fUKvZLV5K3LHZdLqgs3/4wx8S2e92ZhfcVJnf7GG3NavNbCJfb4KsBbNFNct2eF0TAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCESsVxHCUhk8kksl+oSTabTWS/1gLFJqm1UC80THDfFRUV+Q2m0+mKdnfkOfv+DYnN1uLrXXBTZX6zh93WLKnZWv39JjGbIGuhyJ8bu9ss2+EKLQCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACJWK4zhKQiaTSWS/UJNsNpvIfq0Fik1Sa6FeaJjgvisqKvIbTKfTFe3uyHP2/Rtqtd/dbHbBTZX5zR52W7N69/UmyFoo/llrgRxXaAEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQKhUHMdREjKZTCL7hZpks9lE9mstUGySWgv1QsME911RUZHfYDqdrmh3R56z79+Q2Gwtvt4FN1XmN3vYbc2Smq3V328SswmyFor8ubG7zVKk1QRg15dK1fiphC521oZqAlC3sdx2m/qTT9UEoM57+bUj9aGdqglAcr2sb+30nScA7Ay1TOZOv5/CUE0Aiix1qeINp2oCUHyRSxVpOFUTgKLMW6oYw6maABRr2FJFF07VBKCIk5YqrnCqJgCEUk0AivsUMFVEp5uqCQChVBOAoj/5SxXL6aZqAkAo1QSAUKoJQH24WJoqiou0fucJAAUWx9HEidHGjVFJSXT22UXSv/yk4oR+J0smk0lkv1CTbDabyH6tBerZWkjtePNefTV68MHo/vujQYOiSy6JTj45zyMrhl8iFicknU7nfcxmzRZi1lowazbnnzxlo2iH/zz1VDxgQNylS3zGGV99nMc95P4UAa9rAlB4EyZEw4dHkydH9ZxqAlB4AwdGDz0U9ekT1XOqCUCBtWkTNW4cZbNffdCqVVSfeQ8tAAV24onRxx9H3bt/9R7aLl2i+kw1ASiwVD3+VpOtuEILQH349o+4CL7tRDUBIJxqAkAo1QSg6C+WxkVxeVY1AWAHqCYAxX3yFxfLiaZqAsAOUE0AivgUMC6iE03VhDwde+yxS5YsiaKoqqqqffv299xzT6dOnY477rgpU6YkfWhQh+J4t0qmakKe+vXr98wzz0RRNHXq1DPOOOO22257+eWXH3vssQkTJiR9aFC34nj3SaZqQp769+8/ceLEKIqeffbZ8847r1evXhdffPGiRYvGjx+f9KFBnYvj3SSZqgl5Ki8vX7FixapVq2bNmnXKKac89NBDQ4YMGTNmzMCBA5M+NEhCHO8OyfTT2yF/55xzzsiRI0888cRVq1adffbZL774YufOnQ877LCkjwsSEsc756e0F3Eyv/pB9HFCx5fJZBLZL9Qkm83u0PbvvvvuMcccM3Xq1K5du44aNerxxx/fvHnzoEGDBg8evEP3Yy1Q39fC1vJuZ3H38v+LE5JOp/M+ZrNmCzFrLZg1m7NzntlRtAN/6g9XaAEogDj+56ee9eLk8r9TTQAKKa5/adwO76EFgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1AaiVP/zhD127dj399NNPPfXU6dOnR1G0efPmq6666uSTT+7evfuCBQuqt1y5cmU6ne7WrVs6nV65cmUURSNHjuzQocOoUaNyU717966srIyKmGoCUCuDBg169NFHp06d+tBDDw0aNCiKovvuu69p06bTp08fMmTIddddV73liBEjunfv/sorr5x66qm33357FEW/+MUv/vKXv9x1111RFI0dO7Zv377NmjWLilgqTuj3hWYymUT2CzXJZrOJ7NdaoL6vhc6dO99///3HH3/8a6+91r9//w8//PCUU055+OGH27Vrt379+p///OfXX399bssOHTpMmTLl4IMPXrJkyRlnnDF79uy2bdv+8Y9/7NGjx6xZsy666KLnnnsulUpFxSxOSDqdzvuYzZotxKy1YNZszo4+h1977bVGjRp16NChUaNGzz77bBzHLVq0+NnPfvatb30rnU4vXLiwessWLVps2rQpjuNNmzbtv//+cRyPHz/+pJNOevTRRy+//PKZM2fGRc8VWgBq5brrrnv00Udnz579yCOPPP3001EUrV+//hvf+MZLL7104YUX5q7Z1uSiiy6aMWNGeXl5FEULFizo3bv3U089FRWxhkkfAAD12+zZs3MvNJx77rmXX355FEUtW7bMneym0+nLLrusesuWLVt+/PHHBx988LJly1q2bJm7MY7jm2++efz48Z07d54xY0bXrl379esXFSvnmgDUSnl5+Z///OcoiqZPn37IIYdEUfTtb3/75ZdfjqLo5Zdf7tixYxRFq1evjqKoV69ejz/+eBRFjz/+eK9evXLjDz74YJ8+fZo3b752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fWiQhDjeHZLpp7dD/s4555yRI0eeeOKJq1atOvvss1988cXOnTsfdthhSR8XJCSOd86PPijiZKom5K9///7HHHPM1KlTy8rKzjrrrC5dumzevPnHP/5x0scFyYn/Eby821ncvcxRTchTeXl5VVVV7uNh/5D0EUG9bWdcD3qZo5oAFED8XyHcTj7rTyyrqSYAhRTXvzRuh/fQAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAiVihN6T3Amk0lkv1CTbDabyH6tBYpNUmuhXkjy+zUrKiryG0yn0xXt7shz9v0b6uVsbR6rWsw+9PJV+c0O6H5PvZtNkLVQ/Gtht5plO1yhBYBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQGolT/84Q9du3Y9/fTTTz311OnTp0dRdP7555/2D127dm3RosWWG1dWVg4YMKCsrCz3nyNHjuzQocOoUaOiKNq8eXPv3r0rKyujIub3awJQK4MGDZo6deqhhx46f/78Pn36zJ079/HHH899auzYsR999NGWG/fp0+e8886r/l7SX/ziF++++255efmwYcPGjh3bt2/fZs2aRUXMuSYAtdK8efMVK1ZEUbRixYovv/yy+vY4ju+9997BgwdvufGTTz555ZVXVv9nSUnJ3//+99LS0s8++2zixIkDBw6MiptzTQBq5b777uvWrdsRRxwxb968p556qvr2Z5999oQTTjjggAO23PjAAw/c8j9HjBhx4YUX3n777TfddNNPfvKTVCoVFTfnmgDUynXXXffoo4/Onj37kUceefrpp6tv/9nPfnbttdduf/aiiy6aMWNGeXl5FEULFizo3bv3lt0tQs41AaiV2bNn534Jwbnnnnv55Zfnbnz11VebNWuWy+H2xXF88803jx8/vnPnzjNmzOjatWu/fv2iYuVcE4BaKS8v//Of/xxF0fTp0w855JDcjXfeeeeWJ5qrV6+uafzBBx/s06dP8+bN165dG8fxmjVroiLmXBOAWrnvvvuuuuqr3zWUSqXGjh0bRdH777+/dOnS7t27V29z7rnnTpkyZdvZysrKJ598ctKkSVEUDRkypGfPnv/0om6yVBOAWunYseO0adO2vKVdu3a5b9ystlUyq78ps1mzZpMnT859fOM/RMXNFVoACKWaABBKNQEgVCqO4ygJubcpQ/HIZrOJ7NdaoNgktRbqhzgh6XQ672M2a7YQs9aCWbPJroV6wRVaAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQKhXHcZSETCaTyH6hJtlsNpH9WgsUm6TWQv0QJySdTud9zGbNFmLWWjBrNtm1UC+4QgsAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKl4jiOkpDJZBLZL9Qkm80msl9rgWKT1FqoH+KEpNPpvI/ZrNlCzFoLZs0muxbqBVdoASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAqFQcx1ESMplMIvuFmmSz2UT2ay1QbJJaC/VDnJB0Op33MZs1W4hZa8Gs2WTXQr3gCi0AhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAiViuM4SkImk0lkv1CTbDab9CEARS9OSDqdzvuYzZotxGxSawGoR1yhBYBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVJxHAdvDAC7NeeaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjV3KWsWLHinXfeSfoooB6wWMiPahZK69atU9uYMGFCQXfas2fPGTNmhG8/evToLl26bHv7J5980q9fv3322adNmza33XbbTj1G+G9atGhRvUBKS0uPOuqoe+65J+97q35KV1ZWplKp7XTRYiE/DfOcI8Ddd999zTXX1OUe165du1Pu53vf+17btm0XLVo0b968M88888ADD7zkkkt2yj3DtsaMGXPZZZdFUbRhw4bf//7355577r777nvRRRfV5j6bNWsWx/F2NrBYyI9zzbr2wAMPNGrUaNGiRVEULV++fJ999hk3btynn36aSqUeeOCB1q1bl5WVDRo0qHpJL1u2rF+/fk2aNGnTps3QoUOrb1+yZEkmk2natOn+++9/xRVXVFVVnXbaae++++7AgQNzi7amwbfeeuvUU09t3Lhx165dFy5cuO0Rzp8/f+rUqaNHjy4rKzv++ONPP/30v/zlL3X4CLH7KikpOeuss3r06JHNZj/++ONUKjV8+PCysrIBAwbs6FN6y3NNi4WdKaYwWrVqdffdd3/tp7797W9fccUVcRxfffXVp59+ehzHy5cvj6Koffv2s2fPnj9/fseOHX/wgx/kNj755JMHDBiwfPny+fPnd+vW7dJLL43jeOPGjUcfffR55533ySefzJs3r1u3bjfccEMcx+Xl5ePGjdvO4Nq1a9u2bfsv//Ivn3322TPPPNO4ceOTTjqppi9hw4YNL7744n777ffMM88U5kGCuHnz5mPGjNnylp49e1500UXLli2LoiidTq9aterDDz/c0af0559/HkXR22+/bbGwc6lmobRq1Wqr/0HZY489cp+aN29es2bN7rrrrrKysnnz5lVXM5vN5jaYMmVKaWnp6tWrp02bttdee1VVVeVunzlzZoMGDdauXTtt2rTS0tIVK1ZstdPqfwhqGqyoqCgrK1uzZk3u9h/96Efb+YegvLy8UaNGp5122vLlywvwCMHW1aysrBw3blyDBg2ee+65XDUnTZqU+9SOPqWrq2mxsHO5QltAW51rbty4MXd7u3bthg0bNnTo0GuvvbZdu3bV21e/1+DYY49dv379/Pnz586du2bNmkaNGuXeK3HCCSds3rx5wYIFb731VuvWrffbb7+adl3T4Ny5cw8//PDGjRvnNuvUqdN2jv+dd95ZsWLFXnvtddZZZ+2khwS+xuWXX557orZs2XL06NH33ntv7969c59q27ZtLZ/SFgs7l2omY86cOVEUvfHGG1veWFJSkvtg06ZNX71Tq2HDjRs3tmvXbqv/0/nmN79ZUlKSSqW2c/81DW61WfUea7L33nvfdNNNr7766tKlS/P9WuGfqD7XXLdu3Zw5c3LvDMpp1KhRLZ/SFgs7l2om4Pnnn3/iiSdG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DiEPY8aMyS2fL7/8ctSoUdddd90jjzxSy/ts1qxZHMdHHnlkTRtYStRENevaAw880KhRo0WLFkVRtHz58n322WfcuHGffvppKpV64IEHWrduXVZWNmjQoOpFu2zZsn79+jVp0qRNmzZDhw6tvn3JkiWZTKZp06b777//FVdcUVVVddppp7377rsDBw685JJLtjP41ltvnXrqqY0bN+7atevChQtrOs5169YNGjTo+OOPr5NHBf65kpKSs846q0ePHtls9uOPP06lUsOHDy8rKxswYMCOPuG3PNe0lNghqlnXBg0a1K1bt5EjR0ZRNGLEiOOPP37gwIG5T915552TJ0+eNWvW66+/Pnjw4NyNffv2bdq06QcffDBt2rSZM2cOGTIkiqJNmzadeeaZpaWl8+fPnz59+uzZs2+55ZaXXnqpvLx83LhxY8eOrWlw3bp1vXr16tix49KlS4cPHz5u3LiajvPmm2/+H//jf5x77rl19cBAkI0bNzZp0iT38TvvvLN48eJbb7017ye8pcQO2+oSIjtLq1attnqo99hjj9yn5s2b16xZs7vuuqusrGzevHlxHC9fvjyKomw2m9tgypQppaWlq1evnjZt2l577VVVVZW7febMmQ0aNFi7du20adNKS0tXrFix1U5zSz2O45oGKyoqysrK1qxZk7v9Rz/60UknnbTtwb/22mv777//smXLbr/99m9961sFe5Dgn2jevHn1FdrKyspx48Y1aNDgueeeW7ZsWRRFkyZNyn1qR5/wn3/+eRRFb7/9tqXEjnKuWXeva27cuDF3e7t27YYNGzZ06NBrr722Xbt21dtXv5vg2GOPXb9+/fz58+fOnbtmzZpGjRrl3g1xwgknbN68ecGCBW+99Vbr1q3322+/mnZd0+DcuXMPP/zwxo0b5zbr1KnTtrMbNmz4wQ9+MGrUqAMPPHBnPySwwy6//PLc07hly5ajR4++9957e/funftU27Zta/mEt5TYUaqZjDlz5kRR9MYbb2x5Y0lJSe6DTZs2RVHUsGHDjRs3tmvXbqv/0/nmN79ZUlKSSqW2c/81DW61WfUetzRixIjWrVt///vf3xlfKNRW9bnmunXr5syZc9lll1V/qlGjRrV8wltK7CjVTMDzzz//xBNPjBo1auLEiRUVFdW3v/nmm7kPZs2a1aRJk8MPP/zII49cuHDh4sWL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37//McccM3Xq1LKysrPOOqtLly6bN2/+8Y9/nPRxQXLifwQv73bW1feAqiYkoLy8vKqqKvfxsH9I+oig3rYzrtPfo6KaABSZ+L9CuJ18JvRLx1QTgGIVJ/T7OGvmPbQAEEo1ASCUagJAKNUEgFCqCQChVBMAQqXiWryvN5PJ5D0Lu5JsNpvIfq1Bik02obVQd+JaSKfTee+3ns7eMi/O7089/XrN1sE6sgbN7kqz8a7OFVoACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTgMRs3rz5qquuOvnkk7t3775gwYIoilauXJlOp7t165ZOp1euXLntyKRJkxo3bhxF0ciRIzt06DBq1Kjc/fTu3buysrLQB6yaACTmvvvua9q06fTp04cMGXLddddFUTRixIju3bu/8sorp5566u23377V9l988cVtt91WUlISRdEvfvGLv/zlL3fddVcURWPHju3bt2+zZs0KfcCqCUBiHn300YEDB0ZR1Lt37y5duuROJc8///wois4///zf/e53W21/4403XnPNNQ0afBWvkpKSv//976WlpZ999tnEiRNz91NoqglAYt57771nnnnmtNNO+853vnPeeedFUfTJJ58ceOCBURQddNBBn3zyyZYbv/LKK0uXLs1tljsrvfDCC2+//fabbrrpJz/5SSqVqoMDVk0AErN+/fpvfOMbL7300oUXXjho0KDtbFlVVXXdddfde++91bdcdNFFM2bMKC8vj6JowYIFvXv3fuqppwp9wA0LvQMAqEnLli1zP/Y2nU5fdtlluVs+/vjjgw8+eNmyZS1btqze8re//e0XX3zxve99L4qi1atXX3zxxePHj4/j+Oabbx4/fnznzp1nzJjRtWvXfv36RYXkXBOAxHz7299++eWXoyh6+eWXO3bsGEVRr169Hn/88SiKHn/88V69euUaGUXR9773vbfeeuulf2jSpMn48eOjKHrwwQf79OnTvHnztWvXxnG8Zs2aQh+wc00AEnPrrbcOGjTo1ltvbdiw4f333x9F0b/92799//vff/rpp1u0aPHwww9HUXTuuedOmTJl29nKysonn3xy0qRJURQNGTKkZ8+e1157baEPWDUBSMwBBxzw7LPPbnlLWVlZRUXFlrdsm8zc92U2a9Zs8uTJuVtu/IfCH68rtAAQTDUBIJRqAkCoVBzHUb4ymUzes7AryWaziezXGqTYZBNaC3Wmtu8G2uo123DpdDqp2Y6j8vxL/duwTG1m6+NjZbb41bvHyuyuPbvLc4UWAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCESsVxHOUrk8nkPQu7kmw2m8h+rUGKTTahtVBnGtZyvqKiIr/BdDpdm9mOo/L8i/nbsExSx2x2F55NkDW4a8/Wu8d5l+cKLQCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACJWK4zjKVyaTyXsWdiXZbDaR/VqDFJtsQmuhzjSs5XxFRUV+g+l0OqnZjqPy/Ev927BMbWbr42NltvjVu8fK7K49u8tzhRYAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRKxXEc5SuTyeQ9C7uSbDab9CEAdSKuhXQ6nfd+zZrdlWZrs46AesQVWgAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAECoVx3GUr0wmk/cs7Eqy2WzShwDUibgW0ul03vs1a3ZXmq3NOgLqEVdoASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAqFQcx1G+MplM3rOwK8lms0kfAlAn4lpIp9N579es2V1ptjbrCKhHXKEFgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChUnEcB28MALs155oAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAFOj/AVqO7FMlQqDYAAAAAElFTkSuQmCC"
            },
            {
              "type": "input_text",
              "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
            }
          ],
          "solved_count": 0,
          "total_training_examples": 4,
          "pixel_accuracy": 0.7633851468048359
        },
        "test_result": {
          "correct": false,
          "pixel_accuracy": 0.0,
          "total_pixels": 224,
          "correct_pixels": 0,
          "error": "Grid height mismatch"
        },
        "status": "failed_test",
        "feedback_sent": true
      },
      {
        "turn_number": 5,
        "timestamp": "2025-07-10T10:42:37.371928",
        "input_tokens": 31566,
        "output_tokens": 1932,
        "turn_cost": 0.015717599999999998,
        "program_extracted": true,
        "program": "def transform(grid):\n    import numpy as np\n\n    arr = np.array(grid)\n    target_size = 11\n\n    # Normalize input size to 11\u00d711\n    norm = np.zeros((target_size, target_size), dtype=int)\n    rows, cols = arr.shape\n    norm[:min(rows, target_size), :min(cols, target_size)] = arr[:target_size, :target_size]\n    arr = norm\n\n    output = np.zeros_like(arr)\n\n    blue_color = 1\n\n    output[arr == blue_color] = blue_color  # Copy blue pixels directly\n\n    # Identify non-blue, non-zero colors\n    colors = set(np.unique(arr))\n    colors.discard(0)\n    colors.discard(blue_color)\n\n    # Quadrants defined by split at row=6, col=6 (indexes 0..10)\n    quadrant_limits = {\n        'TL': (0, 5, 0, 5),\n        'TR': (0, 5, 6, 10),\n        'BL': (6, 10, 0, 5),\n        'BR': (6, 10, 6, 10)\n    }\n\n    quadrant_copy_map = {\n        'TL': 'TR',\n        'TR': 'BL',\n        'BL': 'BR',\n        'BR': 'TL'\n    }\n\n    def get_quadrant(r, c):\n        if r <= 5 and c <= 5:\n            return 'TL'\n        elif r <= 5 and c >= 6:\n            return 'TR'\n        elif r >= 6 and c <= 5:\n            return 'BL'\n        else:\n            return 'BR'\n\n    for color in colors:\n        mask = (arr == color)\n        if not np.any(mask):\n            continue\n\n        rows_c, cols_c = np.where(mask)\n        min_r, max_r = rows_c.min(), rows_c.max()\n        min_c, max_c = cols_c.min(), cols_c.max()\n\n        # Copy original cluster pixels unchanged\n        output[rows_c, cols_c] = color\n\n        # Calculate center to determine original quadrant\n        mean_r = int(round(np.mean(rows_c)))\n        mean_c = int(round(np.mean(cols_c)))\n        orig_quad = get_quadrant(mean_r, mean_c)\n        target_quad = quadrant_copy_map[orig_quad]\n\n        r_start, r_end, c_start, c_end = quadrant_limits[target_quad]\n        quad_row_span = r_end - r_start + 1\n        quad_col_span = c_end - c_start + 1\n\n        cluster_height = max_r - min_r + 1\n        cluster_width = max_c - min_c + 1\n\n        # Relative offset inside original quadrant\n        orig_r_start, orig_r_end, orig_c_start, orig_c_end = quadrant_limits[orig_quad]\n\n        offset_r = min_r - orig_r_start\n        offset_c = min_c - orig_c_start\n\n        # Compute tentative new top-left in target quadrant\n        new_min_r = r_start + offset_r\n        new_min_c = c_start + offset_c\n\n        # Clamp to fit cluster inside target quadrant\n        if new_min_r < r_start:\n            new_min_r = r_start\n        if new_min_c < c_start:\n            new_min_c = c_start\n\n        if new_min_r + cluster_height - 1 > r_end:\n            new_min_r = r_end - cluster_height + 1\n        if new_min_c + cluster_width - 1 > c_end:\n            new_min_c = c_end - cluster_width + 1\n\n        # Copy the cluster pixels to the duplicate position without overwriting blue pixels\n        for r_, c_ in zip(rows_c, cols_c):\n            rr = new_min_r + (r_ - min_r)\n            cc = new_min_c + (c_ - min_c)\n            if 0 <= rr < target_size and 0 <= cc < target_size:\n                if output[rr, cc] != blue_color:\n                    output[rr, cc] = color\n\n    return output.tolist()",
        "training_feedback": {
          "feedback_messages": [
            {
              "type": "input_text",
              "text": "Training results: 0/4 examples solved, 76.0% pixel accuracy - Good partial progress! Your approach is capturing some patterns. Next, try to identify a transformation that solves at least one of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[1, 1, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 1, 1, 1, 0, 3, 3, 3, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 1, 1, 1, 0, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0]]\nPixel accuracy: 86.0%\n\nTraining Example 2 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 1, 0, 0, 0, 0, 0, 0, 6, 0], [0, 1, 1, 1, 1, 0, 0, 6, 6, 6, 6], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 6, 0], [0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 86.4%\n\nTraining Example 3 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 77.8%\n\nTraining Example 4 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 60.4%\n\n\u26a0\ufe0f  GRID SIZE ERROR: One or more of your output grids are incorrect in size. They should ALL be 11\u00d711 for this task.\n\n"
            },
            {
              "type": "input_image",
              "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAmcAAATYCAIAAADVnPfcAABQcklEQVR4nO3de5RU5Z3o711IN6Jgo6ioXLwhrTkoIl6QIFHhrKMgWiVgjLdAMPEy3kBQmTF64pKIQjQxMegJiiI6OhqrUYMETRBiApFRJoJ4QUDlpkG0QQSa2/4tU7/pxYBNXqqp3tXwPIs/2ur9rb27qJePe1d1dyqO4wgACNAgZCMAQDUBYAeoJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaAFAn1bzmmmtSNbvkkku+cZvS0tKDDjro3HPPffPNN7e9z5dffjmVSu23337r1q3b6lPPPvtsKpUaM2ZM7j/79++fSqVGjhy51WaLFy9OpVK33nprbaZy1q1b99BDD51xxhmHHHJIo0aNDjnkkH79+v3pT3/azmNy66231vSAzJkzZ/sPWo8ePf7pA1u9zeWXX77l7bnD69Onz/Tp07c8nnQ6vdVmhx9++HXXXffFF1/s0IOf89lnn915550dO3YsKyvbe++9Tz755DFjxmz5a3Nyu9tq/I033jjggAOaNm06ZcqU7Tx0AMUvgXPNDRs2fPrppy+88MIZZ5yxYMGCrT77yCOPRFH0xRdfPP300yH3dtttt7377rs7egwhUx9++OGpp5565ZVXvvrqq8uWLVu/fv2yZcueffbZbt263XvvvVGRyR3ec88917Vr1yeeeGI7m3344Ye//OUvzzrrrM2bN+/Qgz99+vQOHTr8+Mc//q//+q9Vq1atWbNm5syZP/zhDwcOHLidA/vjH/94xhlnbNq06ZVXXjnjjDNq8SUC1PNq/upXv4r/2zPPPBNF0dixY6tvGT9+fPWWCxcurL593bp177zzzkUXXbRq1arRo0dveYeVlZUVFRX9+vXbb7/9HnzwwZBjWL9+ff/+/Tdt2rRDR/5PpzZs2NC3b9//+q//6tKly/PPP//ZZ59t2LDh448//vWvf73ffvvddNNNuRPHmsyaNSveRvv27b/xAan2yiuvbHknIdssW7Ysd/vatWs/+OCDW265JY7jH/zgBx999NGWm61du3bLB79Hjx6vv/76yy+/HP7g//3vf89kMkuXLv3e9743Y8aMVatWff755xUVFUccccTYsWMfeuihb3wcstlsz54999prr1dfffWUU07ZziMGUC8kcK7ZqFGjo48++u67746iaKtzzSeffHLdunVXXHHFgAEDZsyY8dZbb/3Te7v22mv/+te//uxnP9uhY/inU4899tgbb7zRo0ePadOm9e7du3nz5g0bNmzduvVVV1313HPPbdq06d///d+jYrLnnnseeeSRd91112233bZ+/fqf//zn23nwb7jhhlxxwx/8e++999NPPx00aNCTTz55yimnNG3adN999z3vvPOmTp26995733vvvdv+evOHH364X79+Bx544J/+9Kfjjjuu+vZHH300lUr96le/2qkPAMAuWs2qqqq333578ODBURS1a9duy0+NHTv2mGOOOfPMM6+66qo99tgj5HTzpz/9adu2bW+77bZ33nkn/Bj+6dSTTz6ZSqX+3//7f3vsscdWn/rOd74zd+7cO++8MypKN95441577fX73//+Gz+7YcOG999///7772/YsOF3vvOd8Af/P/7jPxo3bnzHHXdsdYetWrV67bXXXn311VQqteXt99xzz+WXX37EEUe89tprRx111M77+gB2g2oefvjh1W9I2XPPPdu3b//MM8/sv//+119/ffU2c+bM+c///M+hQ4emUqkjjzyyX79+TzzxxOrVq7d/z3vttdfYsWM3bNiwQ9dp/+nUrFmzjjnmmMMPP/wbx4855pitIrGVjh07bvUuntdee62mB6Taq6++uqPbbKtp06ZHHXXUVifxjRs3zo2XlpaWl5f/+c9/fuyxx7b86rb/4G/YsOHDDz88+eSTmzRpsu0ejz/++IMPPnjLW2666aabb745iqLTTjutTZs2W23fv3//OI6vueaa7X8hAEUome88admy5Q9+8IO//e1vBx10UPWNjzzySMuWLS+++OLcfw4bNuzLL78MuRDatWvX66677vXXXx81alT4MWxnasOGDZWVlS1atNjyxq3e13rYYYdFxap58+ZV/1DTBps2bZoxY8aGDRsCH/zKyso4jps3bx54AL/85S9PPfXUHj16PPLII88991ztvhqA3a+auTe2rF+//qmnnsqdDI0YMeKQQw6p3mDDhg3jx49fsmRJo0aNclnq0KFDHMeB7wn66U9/etRRR91+++1z584NP6qapkpKSpo2bbp8+fIoX9u+G6hr167/9J0+p59++o5u842++OKLkpKSRo0abftuoPXr1y9YsOBf/uVffvnLXw4ZMiTwwd9vv/0aNGgQ/oAMGDDg1VdfHTdu3H777ffDH/5wyZIlgYMARa5OzzVLSkq++93vPv3001OnTj3rrLO2/K6+F1988Rv/UX7zzTdnzpz5T++5cePGeVyn3c7UscceO3fu3I8//vgb3zDcqVOnqFitXr16zpw5xxxzzDd+tqSk5PDDDx81alT79u0fffTRwAd/jz32OOaYY/7zP/9zzZo122521113XXbZZUuXLq2+5de//nVpaenBBx/8q1/96vPPP7/sssu2/S4XgPoogSu0Z5999rXXXvvmm29Wn+vkrhDuueeeK1eu3PK86i9/+UsURTV9V8NWvv3tb19//fUzZ87c9icY5DF18cUXb968+eqrr/7GBm/7ftHicd99923YsOGss87a/mYNGjRYvXr1xo0bAx/8dDq9du3a//t//+9W9/Phhx/ec889L7744jdev/3e977Xt2/fP/7xjzt08RygaCXzuuZPf/rTNm3ajB49+q9//WsURZ988smkSZN69+69zz77bLnZqaeeWl5e/u///u8rV64Mudvhw4cfddRRv/71r3foYL5x6vLLL+/UqdPvfve7k08++T/+4z8++eSTDRs25H7KQa9evd58880GDYrrhxFWVVW99957t956609+8pO99tqrpvfaxHG8ePHioUOHvvXWWx07dmzYsGHggz9o0KDmzZuPHDnysssu+8///M+1a9d++umnTz755Omnn15ZWTl06NAtLwhvafTo0S1atLj11lvfeOONwnzpAHUnmX/6995771/+8pebN2++4oorNm7cOG7cuI0bN1a/FWVL3//+99esWfP444+HX3Hd/rtbA6dKS0srKipOPfXUN99887vf/e7BBx9cWlqa+4l6EydOLC8vD/zRRTX5xvfHplKpLd8zHLLNwQcfXP3O5KOPPnr48OG5Hx/YunXrrb7G3GYNGjRo3br1qFGjGjRokPvmmcAHv3nz5k8//XTTpk0ff/zxk046aa+99jrooIMuvvjijz76KJPJ3HTTTTV9pfvvv/9vfvObDRs2XHTRRV999ZXv1wTqtcROmM4999x0Ov23v/3t5z//+aOPPrrvvvueffbZ22522WWXNWjQIPAibe6Ka+5b+HfIN061atXqT3/60/jx43v27NmqVavS0tIWLVr07NnzsccemzNnzkknnRQVk5KSktatW1944YV//vOfv/e979W02R577HHggQf26tXr5Zdfzl3FDX/wu3fvPmvWrOuuu+7oo49u0qRJ48aNTznllDFjxvz2t7/d9rtat9S7d+/+/fu///77W36jEUB9lCrml+gAoKgU14tzAFDMVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZq7lBUrVrz77rtJHwUUBcuBQlDNQmnVqlVqG+PHjy/oTnv06DFjxozw7UeNGtW5c+eaPltZWXnEEUfs0B3Ctvbff//qJVBaWnrMMcfcf//9ed9b9ZO2srIylUptp4uWA4WgmgV03333xf/TJZdcUtA9rl27dmfd1aJFi3r06LFw4cKddYfszkaPHp1bAl999dXIkSOHDBny+OOP1/I+mzVrFsfx0UcfXdMGlgOFoJp17eGHH27UqNGiRYuiKFq+fPk+++wzduzYzz77LJVKPfzww61atSorKxs4cGD1gl+2bFnfvn2bNGnSunXrwYMHV9++ZMmSTCbTtGnTAw444Oqrr66qqjr99NPfe++9AQMGXH755dsZfPvtt0877bTGjRt36dKlpn8Ffve737Vv375Tp0519aiwuygpKTnnnHO6d++ezWY/+eSTVCo1bNiwsrKy/v377+iTdstzTcuBOqOadW3gwIFdu3YdMWJEFEXDhw8/8cQTBwwYkPvUPffcM2nSpFmzZr3xxhvXXHNN7sY+ffo0bdr0ww8/nDp16syZMwcNGhRF0aZNm84+++zS0tL58+dPnz599uzZt99++6uvvlpeXj527NgxY8bUNLhu3bqePXt26NBh6dKlw4YNGzt27DceZKNGjV555ZUHHnigDh8YdiMbN25s0qRJ7uN333138eLFd9xxR95PWsuBOrXVJUR2lpYtW271UO+xxx65T82bN69Zs2b33ntvWVnZvHnz4jhevnx5FEXZbDa3weTJk0tLS1evXj116tS99tqrqqoqd/vMmTMbNGiwdu3aqVOnlpaWrlixYqud5v6ZiOO4psGKioqysrI1a9bkbv/Rj350yimn1PQlbNiwIYqi6dOnF+DhYTfSvHnz6iu0lZWVY8eObdCgwYsvvrhs2bIoiiZOnJj71I4+ab/44osoit555x3LgbrkXLPuXtfcuHFj7va2bdsOHTp08ODBN954Y9u2bau3r34nwvHHH79+/fr58+fPnTt3zZo1jRo1yr2T4qSTTtq8efOCBQvefvvtVq1a7bfffjXtuqbBuXPnHnnkkY0bN85t1rFjxwI/BvC1q666KvdUbNGixahRox544IFevXrlPtWmTZtaPmktB+qSaiZjzpw5URS9+eabW95YUlKS+2DTpk1RFDVs2HDjxo1t27bd6v90vvWtb5WUlKRSqe3cf02DW21WvUcoqOpzzXXr1s2ZM+fKK6+s/lSjRo1q+aS1HKhLqpmAl1566emnnx45cuSECRMqKiqqb3/rrbdyH8yaNatJkyZHHnnk0UcfvXDhwsWLF291D+3atVu0aFHuCtWWqv/tqGmwffv28+bN++qrr3L/OXv27J39xUGe8n7SWg7UJdWsa6tXr77yyiuvu+66IUOG/PCHP7zmmmu+/PLL3KduuummhQsXzps37+abb/7Rj37UqFGjM88887jjjhswYMCiRYuWLFlyww03tGnTpqqq6rTTTmvfvv2111772Wefffjhh3369Pne974XRdHee++9dOnSL7/8sqbB//N//s/BBx98/fXXf/7556+88sojjzyS9OMB/7+8n7SWA3VqJ70+yj9/N1AURVdcccW111572GGHrV69Oo7jlStXtm7d+pprrsm9G+iWW2459NBD991338GDB69fvz53Px999NF55523995777PPPmedddY777yTu33hwoVnn332nnvu2bx58/79+69cuTKO49/85jdNmjTp06fPdgbnz5/fvXv3Pffcs3379oMHD/b2B+ry3UBbyr0bKPeGuJwdetJWvxvIcqAupeI4jpKQyWQS2W9xWr9+/cSJE7t37960adOkj2X3lc1mE9mvtUCxSWot1AsNE9x3Rdu78xtMf3BzrWa3eClxx2bT6YLO/uEPf0hkv9uZXXBrZX6zR9zZrDaziXy9CbIWzBbVLNvhdU0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABAqFcdxlIRMJpPIfqEm2Ww2kf1aCxSbpNZCvdAwwX1XVFTkN5hOpyva3p3n7Ac3JzZbi693wa2V+c0ecWezpGZr9febxGyCrIUif27sbrNshyu0ABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEgVCqO4ygJmUwmkf1CTbLZbCL7tRYoNkmthXqhYYL7rqioyG8wnU5XtL07z9kPbq7Vfnez2QW3VuY3e8Sdzerd15sga6H4Z60FclyhBYBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVJxHEdJyGQyiewXapLNZhPZr7VAsUlqLdQLDRPcd0VFRX6D6XS6ou3dec5+cHNis7X4ehfcWpnf7BF3NktqtlZ/v0nMJshaKPLnxu42S5FWE4BdXypV46cSuthZG6oJQN3Gcttt6k8+VROAOu/lN47Uh3aqJgDJ9bK+tdN3ngCwM9QymTv9fgpDNQEostSlijecqglA8UUuVaThVE0AijJvqWIMp2oCUKxhSxVdOFUTgCJOWqq4wqmaABBKNQEo7lPAVBGdbqomAIRSTQCK/uQvVSynm6oJAKFUEwBCqSYA9eFiaaooLtL6nScAFFgcRxMmRBs3RiUl0bnnFkn/8pOKE/qdLJlMJpH9Qk2y2Wwi+7UWqGdrIbXjzfvrX6NHHokeeigaODC6/PLo1FPzPLJi+CVicULS6XTex2zWbCFmrQWzZnP+yVM2inb4z7PPxv37x507x2ed9fXHedxD7k8R8LomAIU3fnw0bFg0aVJUz6kmAIU3YED06KNR795RPaeaABRY69ZR48ZRNvv1By1bRvWZ99ACUGAnnxx98knUrdvX76Ht3Dmqz1QTgAJL1eNvNdmKK7QA1Idv/4iL4NtOVBMAwqkmAIRSTQCK/mJpXBSXZ1UTAHaAagJQ3Cd/cbGcaKomAOwA1QSgiE8B4yI60VRNyNPxxx+/ZMmSKIqqqqratWt3//33d+zY8YQTTpg8eXLShwZ1KI53q2SqJuSpb9++zz//fBRFU6ZMOeuss+68885p06Y9+eST48ePT/rQoG7F8e6TTNWEPPXr12/ChAlRFL3wwgsXXHBBz549L7vsskWLFo0bNy7pQ4M6F8e7STJVE/JUXl6+YsWKVatWzZo169vf/vajjz46aNCg0aNHDxgwIOlDgyTE8e6QTD+9HfJ33nnnjRgx4uSTT161atW55577yiuvdOrU6Ygjjkj6uCAhcbxzfkp7ESfz6x9EHyd0fJlMJpH9Qk2y2ewObf/ee+8dd9xxU6ZM6dKly8iRI5966qnNmzcPHDjwmmuu2aH7sRao72tha3m3s7h7+f+LE5JOp/M+ZrNmCzFrLZg1m7NzntlRtAN/6g9XaAEogDj+56ee9eLk8n9STQAKKa5/adwO76EFgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1AaiVP/zhD126dDnjjDNOO+206dOnR1G0efPm66677tRTT+3WrduCBQuqt1y5cmU6ne7atWs6nV65cmUURSNGjGjfvv3IkSNzU7169aqsrIyKmGoCUCsDBw584oknpkyZ8uijjw4cODCKogcffLBp06bTp08fNGjQkCFDqrccPnx4t27dXnvttdNOO+2uu+6KougXv/jFX/7yl3vvvTeKojFjxvTp06dZs2ZREUvFCf2+0Ewmk8h+oSbZbDaR/VoL1Pe10KlTp4ceeujEE098/fXX+/Xr99FHH337299+7LHH2rZtu379+p///Oc33XRTbsv27dtPnjz5kEMOWbJkyVlnnTV79uw2bdr88Y9/7N69+6xZsy699NIXX3wxlUpFxSxOSDqdzvuYzZotxKy1YNZszo4+h19//fVGjRq1b9++UaNGL7zwQhzH+++//89+9rPvfOc76XR64cKF1Vvuv//+mzZtiuN406ZNBxxwQBzH48aNO+WUU5544omrrrpq5syZcdFzhRaAWhkyZMgTTzwxe/bsxx9//LnnnouiaP369Yceeuirr756ySWX5K7Z1uTSSy+dMWNGeXl5FEULFizo1avXs88+GxWxhkkfAAD12+zZs3MvNJx//vlXXXVVFEUtWrTIneym0+krr7yyessWLVp88sknhxxyyLJly1q0aJG7MY7j2267bdy4cZ06dZoxY0aXLl369u0bFSvnmgDUSnl5+Z///OcoiqZPn37YYYdFUXTmmWdOmzYtiqJp06Z16NAhiqLVq1dHUdSzZ8+nnnoqiqKnnnqqZ8+eufFHHnmkd+/ezZs3X7t2bRzHa9asiYqYc00AauXBBx+87rrrvn5/aSo1ZsyYKIruuOOOgQMH3nHHHQ0bNnzooYdyp6GTJ0/+t3/7t+9///vPPffc/vvv/9hjj0VRVFlZ+cwzz0ycODGKokGDBvXo0ePGG2+MiphqAlArHTp0mDp16pa3HHjggS+88MKWt0yePDmKorKysoqKii1vb9as2aRJk3If3/IPUXFzhRYAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASBUKo7jKAm5X2EKxSObzSayX2uBYpPUWqgXkvxNYVv9vphw6XS6w8g8/1L/NjST1Gxtvl6zdTCboHr3WJndtWfZDldoASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAqFQcx1ESMplMIvuFmmSz2UT2ay1QbJJaC/VCwwT3XVFRkd9gOp3uMDLPv9S/Dc3UZr9md+HZBNXm611wa2V+s0fc2aze/R2ZrZtZtsMVWgAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAECoVx3GUhEwmk8h+oSbZbDaR/VoLFJuk1kK90DDBfVdUVOQ3mE6nO4zM8y/1b0MzSc3W5us1WwezCap3j5XZXXuW7XCFFgBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhErFcRwlIZPJJLJfqEk2m01kv9YCxSaptVAvNExw3x1G5vkX87ehmdrMVlRU5DebTqfN7sKzCfJ8rptZjzO15wotAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIlYrjOHhjANitOdcEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqnmLmXFihXvvvtu0kcBRcFyoBBUs1BatWqV2sb48eMLutMePXrMmDEjfPtRo0Z17tx529vnzZt3zjnnNGvW7OCDD77iiitWrVq1Uw+T3cv+++9fvQRKS0uPOeaY+++/P+97q37SVlZWplKp7XTRcqAQVLOA7rvvvvh/uuSSSwq6x7Vr19b+TjZs2HDOOeccdthhCxcu/NOf/vTGG29ceeWVO+Po2H2NHj06twS++uqrkSNHDhky5PHHH6/lfTZr1iyO46OPPrqmDSwHCkE169rDDz/cqFGjRYsWRVG0fPnyffbZZ+zYsZ999lkqlXr44YdbtWpVVlY2cODA6gW/bNmyvn37NmnSpHXr1oMHD66+fcmSJZlMpmnTpgcccMDVV19dVVV1+umnv/feewMGDLj88su3M/j222+fdtppjRs37tKly8KFC7c9wpkzZy5YsODee+/dd99927Zte/vtt0+YMCGO4zp8kNhllZSUnHPOOd27d89ms5988kkqlRo2bFhZWVn//v139Em75bmm5UCdUc26NnDgwK5du44YMSKKouHDh5944okDBgzIfeqee+6ZNGnSrFmz3njjjWuuuSZ3Y58+fZo2bfrhhx9OnTp15syZgwYNiqJo06ZNZ599dmlp6fz586dPnz579uzbb7/91VdfLS8vHzt27JgxY2oaXLduXc+ePTt06LB06dJhw4aNHTt22yPs0qXLhg0bSktLc/+5bNmy/fbbL5VK1eGDxC5u48aNTZo0yX387rvvLl68+I477sj7SWs5UKe2uoTIztKyZcutHuo99tgj96l58+Y1a9bs3nvvLSsrmzdvXhzHy5cvj6Iom83mNpg8eXJpaenq1aunTp261157VVVV5W6fOXNmgwYN1q5dO3Xq1NLS0hUrVmy109w/E3Ec1zRYUVFRVla2Zs2a3O0/+tGPTjnllO18FZWVlYcffvjtt9++sx8ediPNmzevvkJbWVk5duzYBg0avPjii8uWLYuiaOLEiblP7eiT9osvvoii6J133rEcqEvONevudc2NGzfmbm/btu3QoUMHDx584403tm3btnr76nciHH/88evXr58/f/7cuXPXrFnTqFGj3DspTjrppM2bNy9YsODtt99u1arVfvvtV9OuaxqcO3fukUce2bhx49xmHTt23M7xf/XVV717927fvv2tt966kx4SdlNXXXVV7qnYokWLUaNGPfDAA7169cp9qk2bNrV80loO1CXVTMacOXOiKHrzzTe3vLGkpCT3waZNm6Ioatiw4caNG9u2bbvV/+l861vfKikp2f41opoGt9qseo/bWrFiRffu3Vu1avXss882bNiwdl8uu7vqc81169bNmTNnyzfUNGrUqJZPWsuBuqSaCXjppZeefvrpkSNHTpgwoaKiovr2t956K/fBrFmzmjRpcuSRRx599NELFy5cvHjxVvfQrl27RYsW5a5Qban6346aBtu3bz9v3ryvvvoq95+zZ8/+xiNcvHhx165du3Xr9sQTT1S/ogMFlfeT1nKgTu2kK71srWXLltt+50kcx19++WWbNm1uuOGG3OsoLVu2XLVqVe51zRNPPHHBggXvv//+scceO3jw4DiON23a1LFjxx49enz88ceLFy++/vrrW7duvW7dus2bN59wwgkXX3zx8uXLFy5ceP7551944YVxHHfq1Gn48OGrVq2qabCqqqpdu3YDBw5csWLFyy+/3LRp021fyPniiy+OOuqom266qa4eKnaj1zW3lHtdM/fS/nae7TU9aatf17QcqEuqWXfvBoqi6Iorrrj22msPO+yw1atXx3G8cuXK1q1bX3PNNblq3nLLLYceeui+++47ePDg9evX5+7no48+Ou+88/bee+999tnnrLPOeuedd3K3L1y48Oyzz95zzz2bN2/ev3//lStXxnH8m9/8pkmTJn369NnO4Pz587t3777nnnu2b99+8ODB2/4zcdddd2175F9++WXdPn7sdtXc0SdtdTUtB+pSKqlvPMpkMonstzitX79+4sSJ3bt3b9q0adLHsvvKZrOJ7NdaoNgktRbqhzgh6XQ672M2a7YQs9aCWbPJroV6wbuBACCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAqFQcx1ESMplMIvuFmmSz2UT2ay1QbJJaC/VDnJB0Op33MZs1W4hZa8Gs2WTXQr3gCi0AhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAiViuM4SkImk0lkv1CTbDabyH6tBYpNUmuhfogTkk6n8z5ms2YLMWstmDWb7FqoF1yhBYBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVJxHEdJyGQyiewXapLNZhPZr7VAsUlqLdQPcULS6XTex2zWbCFmrQWzZpNdC/WCK7QAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASBUw+AtAWDHpVI1fiqhH4ReG6oJQN3Gcttt6k8+VROAOu/lN47Uh3aqJgDJ9bK+tdO7gQAogmTu9PspDNUEoMhSlyrecKomAMUXuVSRhlM1ASjKvKWKMZypOKHXXTOZTCL7hZpks9lE9mstUI/XQqrwYSuyNwcl+R7aioqK/AbT6XRF27vznP3g5lrN1uaYzQbPPjrtuvxm+3e7P+/ZBFkLZotqtrjOBVOpogqnK7QAEEo1ASjuFx1TRfQCp2oCQCjVBKDoT/5SxXK6qZoAEEo1ASCUagJQHy6WporiIq3feQJAgcVxNGFCtHFjVFISnXtukfQvP841ASiw11+PXnop6ts3ev75aMaMqD5TTQAKbNGiqKoq6tw5WrLk6z/1mWoCUHjjx0fDhkWTJkX1nGoCUHgDBkSPPhr17h3Vc6oJQIG1bh01bhxls19/0LJlVJ95Dy0ABXbyydEnn0Tdun39HtrOnaP6TDUBKLBUPf5Wk624QgvAjogT+m2XxfFbNlUTAEKpJgCESsUJnfNmMplE9gs1yWaziezXWqBeroVUaje8PJvwu4EqKiryG0yn07WabXt3nrMf3JzYMe9ms49Ouy6/2f7d7s97vwmyFszWNLu7rYXi5wotAMV98hcXy4mmagLADlBNAIr4FDAuohNN1YQ8HX/88Uv+8asbqqqq2rVrd//993fs2PGEE06YPHly0ocGdSiOd6tkqibkqW/fvs8//3wURVOmTDnrrLPuvPPOadOmPfnkk+PHj0/60KBuxfHuk0zVhDz169dvwoQJURS98MILF1xwQc+ePS+77LJFixaNGzcu6UODOhfHu0kyVRPyVF5evmLFilWrVs2aNevb3/72o48+OmjQoNGjRw8YMCDpQ4MkxPHukEw/vR3yd955540YMeLkk09etWrVueee+8orr3Tq1OmII45I+rggIXG8c370QREnUzUhf/369TvuuOOmTJlSVlZ2zjnndO7cefPmzT/+8Y+TPi5ITvyP4OXdzuLuZY5qQp7Ky8urqqpyHw/9h6SPCOptO+N60Msc1QSgAOL/DuF28ll/YllNNQEopLj+pXE7vIcWAEKpJgCEUk0ACKWaABBKNQEglGoCQKhUnNB7gjOZTCL7hZpks9lE9mstUGySWgv1QpLfr1lRUZHfYDqdrmh7d56zH9xcL2dr81jVYvbRadflN9u/2/31bjZB1kLxr4XdapbtcIUWAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBKBW/vCHP3Tp0uWMM8447bTTpk+fHkXR5s2br7vuulNPPbVbt24LFizYdmTixImNGzeOomjEiBHt27cfOXJkbqpXr16VlZVREfP7NQGolYEDB06ZMuXwww+fP39+7969586d++CDDzZt2nT69OnZbHbIkCHPPffcltt/+eWXd955Z0lJSRRFv/jFL957773y8vKhQ4eOGTOmT58+zZo1i4qYc00AaqV58+YrVqyIomjFihVfffVVFEVPPPHEgAEDoijq1atX586dt9r+lltuueGGGxo0+DpAJSUlf//730tLSz///PMJEybkpoqZagJQKw8++GDXrl2PPfbYbt26PfDAA1EUvf/++88///zpp5/+3e9+94ILLthy49dee23p0qXVNw4fPvySSy656667br311p/85CepVCoqbqoJQK0MGTLkiSeemD179uOPP567GLt+/fpDDz301VdfveSSSwYOHFi9ZVVV1ZAhQ3Jlzbn00ktnzJhRXl4eRdGCBQt69er17LPPRkXM65oA1Mrs2bNzv4Tg/PPPv+qqq6IoatGiRTqdzv043CuvvLJ6y9/+9rdffvnlRRddFEXR6tWrL7vssnHjxsVxfNttt40bN65Tp04zZszo0qVL3759o2LlXBOAWikvL//zn/8cRdH06dMPO+ywKIrOPPPMadOmRVE0bdq0Dh065BoZRdFFF1309ttvv/oPTZo0GTduXBRFjzzySO/evZs3b7527do4jtesWRMVMeeaANTKgw8+eN11X/+uoVQqNWbMmCiK7rjjjoEDB95xxx0NGzZ86KGHcqehkydP3na2srLymWeemThxYhRFgwYN6tGjx4033hgVMdUEoFY6dOgwderULW858MADX3jhhS1v2TaZue/LbNas2aRJk3K33PIPUXFzhRYAQqkmAIRSTQAIlYrjOEpC7m3KUDyy2Wwi+7UWKDZJrYX6IU5I7lt58mPWbCFmrQWzZpNdC/WCK7QAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASBUKo7jKAmZTCaR/UJNstlsIvu1Fig2Sa2F+iFOSDqdzvuYzZotxKy1YNZssmuhXnCFFgBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhErFcRwlIZPJJLJfqEk2m01kv9YCxSaptVA/xAlJp9N5H7NZs4WYtRbMmk12LdQLrtACQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqTiOoyRkMplE9gs1yWaziezXWqDYJLUW6oc4Iel0Ou9jNmu2ELPWwg7NVu73x/z+1NOvd7eaTWot1Auu0AJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCpOI6jJGQymUT2CzXJZrNJHwJQ9OKEpNPpvI/ZrNlCzCa1FoB6xBVaAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQKhXHcfDGALBbc64JAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFLNXcqKFSvefffdpI8C6gGLhfyoZqG0atUqtY3x48cXdKc9evSYMWNG+PajRo3q3Lnztrd/+umnffv23WeffVq3bn3nnXfu1GOE/2H//fevXiClpaXHHHPM/fffn/e9VT+lKysrU6nUdrposZCfhnnOEeC+++674YYb6nKPa9eu3Sn3c9FFF7Vp02bRokXz5s07++yzDzrooMsvv3yn3DNsa/To0VdeeWUURRs2bPj9739//vnn77vvvpdeemlt7rNZs2ZxHG9nA4uF/DjXrGsPP/xwo0aNFi1aFEXR8uXL99lnn7Fjx3722WepVOrhhx9u1apVWVnZwIEDq5f0smXL+vbt26RJk9atWw8ePLj69iVLlmQymaZNmx5wwAFXX311VVXV6aef/t577w0YMCC3aGsafPvtt0877bTGjRt36dJl4cKF2x7h/Pnzp0yZMmrUqLKyshNPPPGMM874y1/+UoePELuvkpKSc845p3v37tls9pNPPkmlUsOGDSsrK+vfv/+OPqW3PNe0WNiZYgqjZcuW99133zd+6swzz7z66qvjOL7++uvPOOOMOI6XL18eRVG7du1mz549f/78Dh06/OAHP8htfOqpp/bv33/58uXz58/v2rXrFVdcEcfxxo0bjz322AsuuODTTz+dN29e165db7755jiOy8vLx44du53BtWvXtmnT5l/+5V8+//zz559/vnHjxqecckpNX8KGDRteeeWV/fbb7/nnny/MgwRx8+bNR48eveUtPXr0uPTSS5ctWxZFUTqdXrVq1UcffbSjT+kvvvgiiqJ33nnHYmHnUs1Cadmy5Vb/g7LHHnvkPjVv3rxmzZrde++9ZWVl8+bNq65mNpvNbTB58uTS0tLVq1dPnTp1r732qqqqyt0+c+bMBg0arF27durUqaWlpStWrNhqp9X/ENQ0WFFRUVZWtmbNmtztP/rRj7bzD0F5eXmjRo1OP/305cuXF+ARgq2rWVlZOXbs2AYNGrz44ou5ak6cODH3qR19SldX02Jh53KFtoC2OtfcuHFj7va2bdsOHTp08ODBN954Y9u2bau3r36vwfHHH79+/fr58+fPnTt3zZo1jRo1yr1X4qSTTtq8efOCBQvefvvtVq1a7bfffjXtuqbBuXPnHnnkkY0bN85t1rFjx+0c/7vvvrtixYq99trrnHPO2UkPCXyDq666KvdEbdGixahRox544IFevXrlPtWmTZtaPqUtFnYu1UzGnDlzoih68803t7yxpKQk98GmTZu+fqdWw4YbN25s27btVv+n861vfaukpCSVSm3n/msa3Gqz6j3WZO+997711lv/+te/Ll26NN+vFf6J6nPNdevWzZkzJ/fOoJxGjRrV8iltsbBzqWYCXnrppaeffnrkyJETJkyoqKiovv2tt97KfTBr1qwmTZoceeSRRx999MKFCxcvXrzVPbRr127RokW5a1Bbqv7XoabB9u3bz5s376uvvsr95+zZs7c9vEmTJpWVlVVVVeX+8/PPP99jjz2aNWtWuy8aaiXvp7TFwk62k670EvpuoC+//LJNmzY33HBD7pWSli1brlq1Kve65oknnrhgwYL333//2GOPHTx4cBzHmzZt6tixY48ePT7++OPFixdff/31rVu3Xrdu3ebNm0844YSLL754+fLlCxcuPP/88y+88MI4jjt16jR8+PBVq1bVNFhVVdWuXbuBAweuWLHi5Zdfbtq06bYv1axdu7Zdu3ZXX311ZWXl3/72t2OOOebyyy+vq4eN3c627wbKyb2umXvhfztroaandPXrmhYLO5dq1t27gaIouuKKK6699trDDjts9erVcRyvXLmydevW11xzTa6at9xyy6GHHrrvvvsOHjx4/fr1ufv56KOPzjvvvL333nufffY566yz3nnnndztCxcuPPvss/fcc8/mzZv3799/5cqVcRz/5je/adKkSZ8+fbYzOH/+/O7du++5557t27cfPHjwN77B4YMPPujZs+c+++zTpk2bYcOGrV27tg4fOXYvgdXc0ad0dTUtFnau1Pa/Ebg2MplMge5517N+/fqJEyd27969adOmSR8L3yybzSayX+uIYpNNaC0Ui7hg0ul03ke1u8327Nkzkf2aLYaVYh2ZrV+z8e7Nu4EAIJRqFoXS0tKkDwGAf041ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAECoVx3FUGJlMpkD3DHUvm80msl/riGKTTWgtFImGBb33ioqK/AbT6XS9nG17d56zH9xcL7/e3Wk2QfXusbKOdu3Z3ZwrtAAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIFQqjuOoMDKZTIHuGepeNptNZL/WEcUmm9BaKBINC3rvFRUV+Q2m0+lazba9O8/ZD26ul/s1W/jZBFlHdbRfswRwhRYAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRKxXEcFUYmkynQPUPdy2aziezXOqLYZBNaC0WiYUHvvaKiIr/BdDpdq9m2d+c5+8HNu91sUn9H9W02QdZRPZitb8/neroWioErtAAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBoDh+oh4AbE8qVeOnCvZj0mtDNQEoplhuu00x5VM1ASiyXn7jSHG0UzUBKNZeFl87vRsIgKJP5k6/n3ypJgAFltqpqUs0nKoJQCGlChC55MKpmgAUTKpgeUsonKm4YK+sZjKZAt0z1L1sNpvIfq0j6vFaSBU+bHX+5qDCvoe2oqIiv8F0Op3YbNu785z94OZ6+fWaLXr17rGyjnbt2eI6F0yl6jicrtACQCjVBKA+v+iYqtMXOFUTAEKpJgD1/N2tqbrbo2oCQCjVBIBQqglA/f+pPak62q/feQJAouI4mjAh2rgxKimJzj038Z/Pvn3ONQFI1OuvRy+9FPXtGz3/fDRjRlTcVBOARC1aFFVVRZ07R0uWfP2nuKkmAEkbPz4aNiyaNCkqeqoJQNIGDIgefTTq3TsqeqoJQKJat44aN46y2a8/aNkyKm7eQwtAok4+Ofrkk6hbt6/fQ9u5c1TcVBOARKWK+ltNtuIKLQD1+NdE1/F+VRMAQqkmAIRKxQU7q81kMgW6Z6h72Ww2kf1aR9TLtZBK7bKXheOCSafTeR+VWbPFNlu4lWIdma1fs3GIKKrTP3XIFVoA6vfJX1SHVBMAQqkmAPX2FDCu6290UU3Y+Y4//vgl//jVDVVVVe3atbv//vs7dux4wgknTJ48OelDgzoUx7ve94aqJux8ffv2ff7556MomjJlyllnnXXnnXdOmzbtySefHD9+fNKHBnUrjnexH6egmrDz9evXb8KECVEUvfDCCxdccEHPnj0vu+yyRYsWjRs3LulDgzoXx7vOTyBSTSiE8vLyFStWrFq1atasWd/+9rcfffTRQYMGjR49esCAAUkfGiQhjneNZPrp7VAo55133ogRI04++eRVq1ade+65r7zySqdOnY444oikjwsSEsc750cfJJpM1YRC6dev33HHHTdlypSysrJzzjmnc+fOmzdv/vGPf5z0cUFy4n8EL+92Jt3LHNWEgigvL6+qqsp9PPQfkj4iqLftjIuilzmqCUCdi/87hNvJZzHFsppqApCcuBjTuB3eQwsAoVQTAEKpJgCEUk0ACKWaABBKNQEgVCou2Lt+M5lMge4Z6l42m01kv9YRxSab0FooFnHBpNPpvI/KrNlimy3cSrGOzNav2Xj35gotAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCUABXXjhhaf/Q5cuXfbff/9vvCXnD3/4Q5cuXc4444zTTjtt+vTpURSNGDGiffv2I0eOjKJo8+bNvXr1qqysTPSr8fs1ASikp556KvfBmDFjPv7442+8JWfgwIFTpkw5/PDD58+f37t377lz5/7iF7947733ysvLhw4dOmbMmD59+jRr1ixKlGoCUHBxHD/wwAO///3vt3NL8+bNV6xYcfjhh69YseKrr76KoqikpOTvf/97aWnp559/PmHChBdffDFKmmoCUHAvvPDCSSeddOCBB27nlgcffLBr165HHXXUvHnznn322SiKhg8ffskll9x111233nrrT37yk1QqFSXN65oAFNzPfvazG2+8cfu3DBky5Iknnpg9e/bjjz/+3HPPRVF06aWXzpgxo7y8PIqiBQsW9OrVK1fTBDnXBKCw/vrXvzZr1iwXv5puiaJo9uzZuV9XcP7551911VW5G+M4vu2228aNG9epU6cZM2Z06dKlb9++UXKcawJQWPfcc89Wp5Vb3bJ69eooisrLy//85z9HUTR9+vTDDjss96lHHnmkd+/ezZs3X7t2bRzHa9asiRLlXBOAAvrggw+WLl3arVu37dxy/vnnT548+cEHH7zuuuu+/h2WqdSYMWOiKKqsrHzmmWcmTpwYRdGgQYN69OixVX3rnmoCUEBt27bNffPldm6ZPHlyFEUdOnSYOnXqlrc3a9Zs0qRJuY9v+Ycoaa7QAkAo1QSAUKoJAKFScRxHhZF7AzHsGrLZbCL7tY4oNtmE1kKxiAsmnU7nfVQJzsZnnJzfn3r69ZpNfKXskuvI7C48G+/eXKEFgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChUnEcR4WRyWQKdM9Q97LZbCL7tY4oNtmE1kKRaFjQe6+oqMhvMJ1O12Y2u3JpfrOZskN2t9mk/o7q3WyC6t1jleCstVAHj9VuzhVaAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQKhXHcVQYmUymQPcMdS+bzSayX+uIYpNNaC0UiYYFvfeKior8BtPpdG1msyuX5jebKTukPu7XbB3MJqjePVZmd+3Z3ZwrtAAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIFQqjuOoMDKZTIHuGepeNptNZL/WEcUmm9BaKBZxwaTT6byPqp7OxmecnN+fevr17lazhVsp1pHZ+jUb795coQWAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFScRxHhZHJZAp0z1D3stls0ocAFIG4YNLpdN5HZdZssc0WbqUA9YgrtAAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIFQqjuPgjQFgt+ZcEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmruUFStWvPvuu0kfBdR7lhI1Uc1CadWqVWob48ePL+hOe/ToMWPGjPDtR40a1blz5+1scM0115x++uk749AgH/vvv3/18iktLT3mmGPuv//+vO+t+glfWVmZSqW200VLiZqoZgHdd9998f90ySWXFHSPa9eu3Yn39tprr/3617/eiXcIeRg9enRu+Xz11VcjR44cMmTI448/Xsv7bNasWRzHRx99dE0bWErURDXr2sMPP9yoUaNFixZFUbR8+fJ99tln7Nixn332WSqVevjhh1u1alVWVjZw4MDqRbts2bK+ffs2adKkdevWgwcPrr59yZIlmUymadOmBxxwwNVXX11VVXX66ae/9957AwYMuPzyy7cz+Pbbb5922mmNGzfu0qXLwoULazrOdevWDRw48MQTT6yTRwX+uZKSknPOOad79+7ZbPaTTz5JpVLDhg0rKyvr37//jj7htzzXtJTYIapZ1wYOHNi1a9cRI0ZEUTR8+PATTzxxwIABuU/dc889kyZNmjVr1htvvHHNNdfkbuzTp0/Tpk0//PDDqVOnzpw5c9CgQVEUbdq06eyzzy4tLZ0/f/706dNnz559++23v/rqq+Xl5WPHjh0zZkxNg+vWrevZs2eHDh2WLl06bNiwsWPH1nSct9122//6X//r/PPPr6sHBoJs3LixSZMmuY/ffffdxYsX33HHHXk/4S0ldthWlxDZWVq2bLnVQ73HHnvkPjVv3rxmzZrde++9ZWVl8+bNi+N4+fLlURRls9ncBpMnTy4tLV29evXUqVP32muvqqqq3O0zZ85s0KDB2rVrp06dWlpaumLFiq12mlvqcRzXNFhRUVFWVrZmzZrc7T/60Y9OOeWUbQ/+9ddfP+CAA5YtW3bXXXd95zvfKdiDBP9E8+bNq6/QVlZWjh07tkGDBi+++OKyZcuiKJo4cWLuUzv6hP/iiy+iKHrnnXcsJXaUc826e11z48aNudvbtm07dOjQwYMH33jjjW3btq3evvrdBMcff/z69evnz58/d+7cNWvWNGrUKPduiJNOOmnz5s0LFix4++23W7Vqtd9++9W065oG586de+SRRzZu3Di3WceOHbed3bBhww9+8IORI0cedNBBO/shgR121VVX5Z7GLVq0GDVq1AMPPNCrV6/cp9q0aVPLJ7ylxI5SzWTMmTMniqI333xzyxtLSkpyH2zatCmKooYNG27cuLFt27Zb/Z/Ot771rZKSklQqtZ37r2lwq82q97il4cOHt2rV6vvf//7O+EKhtqrPNdetWzdnzpwrr7yy+lONGjWq5RPeUmJHqWYCXnrppaeffnrkyJETJkyoqKiovv2tt97KfTBr1qwmTZoceeSRRx999MKFCxcvXrzVPbRr127RokW5q0xbql7/NQ22b99+3rx5X331Ve4/Z8+eve3hPfvss5MmTcr9n/WwYcOmTp2aSqW2vSsoHnk/4S0ldtgOX9MlTMuWLbf9zpM4jr/88ss2bdrccMMNuddCWrZsuWrVqtzrmieeeOKCBQvef//9Y489dvDgwXEcb9q0qWPHjj169Pj4448XL158/fXXt27det26dZs3bz7hhBMuvvji5cuXL1y48Pzzz7/wwgvjOO7UqdPw4cNXrVpV02BVVVW7du0GDhy4YsWKl19+uWnTpt/4Ykw1L8ZQPK9rbin3umbubQHbWSk1PeGrX9e0lNhRzjULaNCgQVv9lIMrr7zyX//1Xxs0aHDnnXdGUTRy5MgGDRr867/+a277Hj16nHHGGaeccsr//t//O/cm2wYNGlRUVOy9997HHHPMt771rffee2/y5Mm5l1h++9vffv75561btz7xxBP32Wefhx56KIqiK6+88q677howYEBNg6WlpS+99NKHH37YsmXLQYMG/fCHP0z6QYKdIO8nvKXEjkrFcRzlK5PJ5D3LltavXz9x4sTu3bs3bdo06WMhH9lsNpH9WoMUm2xCa6HuxLWQTqfz3q9Zs7vSbG3WkTVodleajXd1rtACQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqTiOo3xlMpm8Z2FXks1mE9mvNUixySa0FupMw1rOV1RU5DeYTqcTm217d56zH9xcq9n6+FjVYja7cml+s5myQ2ozm8jXm6D6+NywBnfh2V2eK7QAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASBUKo7jKF+ZTCbvWdiVZLPZRPZrDVJssgmthTrTsJbzFRUV+Q2m0+lazba9O8/ZD25O7JjN1slsduXS/GYzZYfkvd8EWYNmi2p2l+cKLQCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACJWK4zjKVyaTyXsWdiXZbDaR/VqDFJtsQmuhzjSs5XxFRUV+g+l0OrHZtnfnOfvBzbWarY+PVS1msyuX5jebKTukNrOJfL0Jqo/PDWtwF57d5blCCwChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqXiOI7ylclk8p6FXUk2m01kv9YgxSab0FqoMw1rOV9RUZHfYDqdrpezbe/Oc/aDm+vl11uL2ezKpfnNZsoOqXdfb4Lq3WNlDe7as7s8V2gBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkBd/UQ9ACiUVKrGT9Xih6jXhmoCUH9iue02dZtP1QSgXvXyG0fqqp2qCUD97GUS7fRuIADqeTJ3+v3UTDUBSFRqp6auwOFUTQCSkypA5AoZTtUEICGpVL2751Rci9dOM5nMTj0YqK+y2Wwi+7UGqcdrIVXw1yAL8uaguBbS6XTe+zVrdlearc06sgbN7kqzcaAoqqM/O5srtAAQSjUBqFupVP3dl2oCQCjVBGAXPdEswB5VEwBCqSYAhFJNAHbdy7M7e79+5wkARSyOowkToo0bo5KS6NxzE+vuf3OuCUARe/316KWXor59o+efj2bMSPpoVBOAYrZoUVRVFXXuHC1Z8vWfpKkmAMVt/Pho2LBo0qSoCKgmAMVtwIDo0Uej3r2jIqCaABSx1q2jxo2jbPbrD1q2TPpovIcWgGJ28snRJ59E3bp9/R7azp2TPhrVBKCYpRL+VpOtuEILQF2J4/q+X9UEgFCqCQChUnEtzlszmUzes7AryWaziezXGqReroVUqh5fFo5rIZ1O571fs2Z3pdnarCNr0OyuNBuHiKI6/bNTuUILwK77nqB4J+9LNQEglGoCsIuebhZgL6oJde34449f8o9f3VBVVdWuXbv777+/Y8eOJ5xwwuTJk5M+NNiFwhkX5P5VE+pa3759n3/++SiKpkyZctZZZ915553Tpk178sknx48fn/Shwa4SzrhQ96yaUNf69es3YcKEKIpeeOGFCy64oGfPnpdddtmiRYvGjRuX9KFBnYvj+nUWq5pQ18rLy1esWLFq1apZs2Z9+9vffvTRRwcNGjR69OgBAwYkfWiQhDgu3nvbhp/eDgk477zzRowYcfLJJ69atercc8995ZVXOnXqdMQRRyR9XJCQON45P/qg8G8yUk1IQL9+/Y477rgpU6aUlZWdc845nTt33rx5849//OOkjwuSE/8jeHm3s66+B1Q1IQHl5eVVVVW5j4f+Q9JHBPW2nXGd/h4V1QSgyMT/HcLt5DOhXzqmmgAUqzih38dZM++hBYBQqgkAoVQTAEKpJgCEUk0ACKWaABAqFdfifb2ZTCbvWdiVZLPZRPZrDVJssgmthboT10I6nc57v/V09vZ5cX5/6unXa7YO1pE1aHZXmo13da7QAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAkZvPmzdddd92pp57arVu3BQsWRFG0cuXKdDrdtWvXdDq9cuXKbUcmTpzYuHHjKIpGjBjRvn37kSNH5u6nV69elZWVhT5g1QQgMQ8++GDTpk2nT58+aNCgIUOGRFE0fPjwbt26vfbaa6eddtpdd9211fZffvnlnXfeWVJSEkXRL37xi7/85S/33ntvFEVjxozp06dPs2bNCn3AqglAYp544okBAwZEUdSrV6/OnTvnTiUvvPDCKIouvPDC3/3ud1ttf8stt9xwww0NGnwdr5KSkr///e+lpaWff/75hAkTcvdTaKoJQGLef//9559//vTTT//ud797wQUXRFH06aefHnTQQVEUHXzwwZ9++umWG7/22mtLly7NbZY7K73kkkvuuuuuW2+99Sc/+UkqlaqDA1ZNABKzfv36Qw899NVXX73kkksGDhy4nS2rqqqGDBnywAMPVN9y6aWXzpgxo7y8PIqiBQsW9OrV69lnny30ATcs9A4AoCYtWrTI/djbdDp95ZVX5m755JNPDjnkkGXLlrVo0aJ6y9/+9rdffvnlRRddFEXR6tWrL7vssnHjxsVxfNttt40bN65Tp04zZszo0qVL3759o0JyrglAYs4888xp06ZFUTRt2rQOHTpEUdSzZ8+nnnoqiqKnnnqqZ8+euUZGUXTRRRe9/fbbr/5DkyZNxo0bF0XRI4880rt37+bNm69duzaO4zVr1hT6gJ1rApCYO+64Y+DAgXfccUfDhg0feuihKIr+7d/+7fvf//5zzz23//77P/bYY1EUnX/++ZMnT952trKy8plnnpk4cWIURYMGDerRo8eNN95Y6ANWTQASc+CBB77wwgtb3lJWVlZRUbHlLdsmM/d9mc2aNZs0aVLullv+ofDH6wotAARTTQAIpZoAECoVx3GUr0wmk/cs7Eqy2Wwi+7UGKTbZhNZCnantu4G2es02XDqdTmq2w8g8/1L/NjRTm9n6+FiZLX717rEyu2vP7vJcoQWAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFScRxH+cpkMnnPwq4km80msl9rkGKTTWgt1JmGtZyvqKjIbzCdTtdmtsPIPP9i/jY0k9Qxm92FZxNkDe7as/Xucd7luUILAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCpeI4jvKVyWTynoVdSTabTWS/1iDFJpvQWqgzDWs5X1FRkd9gOp1OarbDyDz/Uv82NFOb2fr4WJktfvXusTK7a8/u8lyhBYBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVJxHEf5ymQyec/CriSbzSZ9CECdiGshnU7nvV+zZnel2dqsI6AecYUWAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCESsVxHOUrk8nkPQu7kmw2m/QhAHUiroV0Op33fs2a3ZVma7OOgHrEFVoACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABAqFcdxlK9MJpP3LOxKstls0ocA1Im4FtLpdN77NWt2V5qtzToC6hFXaAEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQKhUHMfBGwPAbs25JgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABAF+v8Ak7o2uarWgmoAAAAASUVORK5CYII="
            },
            {
              "type": "input_text",
              "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
            }
          ],
          "solved_count": 0,
          "total_training_examples": 4,
          "pixel_accuracy": 0.7599309153713298
        },
        "test_result": {
          "correct": false,
          "pixel_accuracy": 0.0,
          "total_pixels": 224,
          "correct_pixels": 0,
          "error": "Grid height mismatch"
        },
        "status": "failed_test",
        "feedback_sent": true
      },
      {
        "turn_number": 6,
        "timestamp": "2025-07-10T10:43:01.842358",
        "input_tokens": 38295,
        "output_tokens": 1859,
        "turn_cost": 0.0182924,
        "program_extracted": true,
        "program": "def transform(grid):\n    import numpy as np\n\n    arr = np.array(grid)\n    target_size = 11\n\n    # Normalize grid size\n    norm = np.zeros((target_size, target_size), dtype=int)\n    norm[:arr.shape[0], :arr.shape[1]] = arr[:target_size, :target_size]\n    arr = norm\n\n    output = np.zeros_like(arr)\n    blue_color = 1\n\n    # Copy blue pixels unchanged\n    output[arr == blue_color] = blue_color\n\n    # Get unique colors other than 0 and blue\n    colors = set(np.unique(arr))\n    colors.discard(0)\n    colors.discard(blue_color)\n\n    # Define quadrants limits (inclusive ranges)\n    quadrants = {\n        'TL': (0, 5, 0, 5),\n        'TR': (0, 5, 6, 10),\n        'BL': (6, 10, 0, 5),\n        'BR': (6, 10, 6, 10)\n    }\n\n    # Map each original quadrant to target quadrant\n    quadrant_map = {\n        'TL': 'TR',\n        'TR': 'BL',\n        'BL': 'BR',\n        'BR': 'TL'\n    }\n\n    def get_quadrant(r, c):\n        for q_name, (r_start, r_end, c_start, c_end) in quadrants.items():\n            if r_start <= r <= r_end and c_start <= c <= c_end:\n                return q_name\n        return None\n\n    for color in colors:\n        positions = np.argwhere(arr == color)\n        if positions.size == 0:\n            continue\n\n        min_r, min_c = positions.min(axis=0)\n        max_r, max_c = positions.max(axis=0)\n\n        # Copy original cluster pixels\n        for r, c in positions:\n            output[r, c] = color\n\n        centroid_r = int(round(positions[:, 0].mean()))\n        centroid_c = int(round(positions[:, 1].mean()))\n        orig_quad = get_quadrant(centroid_r, centroid_c)\n        target_quad = quadrant_map[orig_quad]\n\n        r_start, r_end, c_start, c_end = quadrants[target_quad]\n\n        cluster_height = max_r - min_r + 1\n        cluster_width = max_c - min_c + 1\n\n        orig_r_start, orig_r_end, orig_c_start, orig_c_end = quadrants[orig_quad]\n        offset_r = min_r - orig_r_start\n        offset_c = min_c - orig_c_start\n\n        new_min_r = r_start + offset_r\n        new_min_c = c_start + offset_c\n\n        if new_min_r < r_start:\n            new_min_r = r_start\n        if new_min_c < c_start:\n            new_min_c = c_start\n        if new_min_r + cluster_height - 1 > r_end:\n            new_min_r = r_end - cluster_height + 1\n        if new_min_c + cluster_width - 1 > c_end:\n            new_min_c = c_end - cluster_width + 1\n\n        for r, c in positions:\n            rr = new_min_r + (r - min_r)\n            cc = new_min_c + (c - min_c)\n            if 0 <= rr < target_size and 0 <= cc < target_size:\n                if output[rr, cc] != blue_color:\n                    output[rr, cc] = color\n\n    return output.tolist()",
        "training_feedback": {
          "feedback_messages": [
            {
              "type": "input_text",
              "text": "Training results: 0/4 examples solved, 76.0% pixel accuracy - Good partial progress! Your approach is capturing some patterns. Next, try to identify a transformation that solves at least one of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[1, 1, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 1, 1, 1, 0, 3, 3, 3, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 1, 1, 1, 0, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0]]\nPixel accuracy: 86.0%\n\nTraining Example 2 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 1, 0, 0, 0, 0, 0, 0, 6, 0], [0, 1, 1, 1, 1, 0, 0, 6, 6, 6, 6], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 6, 0], [0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 86.4%\n\nTraining Example 3 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 77.8%\n\nTraining Example 4 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 60.4%\n\n\u26a0\ufe0f  GRID SIZE ERROR: One or more of your output grids are incorrect in size. They should ALL be 11\u00d711 for this task.\n\n"
            },
            {
              "type": "input_image",
              "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAmcAAATYCAIAAADVnPfcAABQcklEQVR4nO3de5RU5Z3o711IN6Jgo6ioXLwhrTkoIl6QIFHhrKMgWiVgjLdAMPEy3kBQmTF64pKIQjQxMegJiiI6OhqrUYMETRBiApFRJoJ4QUDlpkG0QQSa2/4tU7/pxYBNXqqp3tXwPIs/2ur9rb27qJePe1d1dyqO4wgACNAgZCMAQDUBYAeoJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaAFAn1bzmmmtSNbvkkku+cZvS0tKDDjro3HPPffPNN7e9z5dffjmVSu23337r1q3b6lPPPvtsKpUaM2ZM7j/79++fSqVGjhy51WaLFy9OpVK33nprbaZy1q1b99BDD51xxhmHHHJIo0aNDjnkkH79+v3pT3/azmNy66231vSAzJkzZ/sPWo8ePf7pA1u9zeWXX77l7bnD69Onz/Tp07c8nnQ6vdVmhx9++HXXXffFF1/s0IOf89lnn915550dO3YsKyvbe++9Tz755DFjxmz5a3Nyu9tq/I033jjggAOaNm06ZcqU7Tx0AMUvgXPNDRs2fPrppy+88MIZZ5yxYMGCrT77yCOPRFH0xRdfPP300yH3dtttt7377rs7egwhUx9++OGpp5565ZVXvvrqq8uWLVu/fv2yZcueffbZbt263XvvvVGRyR3ec88917Vr1yeeeGI7m3344Ye//OUvzzrrrM2bN+/Qgz99+vQOHTr8+Mc//q//+q9Vq1atWbNm5syZP/zhDwcOHLidA/vjH/94xhlnbNq06ZVXXjnjjDNq8SUC1PNq/upXv4r/2zPPPBNF0dixY6tvGT9+fPWWCxcurL593bp177zzzkUXXbRq1arRo0dveYeVlZUVFRX9+vXbb7/9HnzwwZBjWL9+ff/+/Tdt2rRDR/5PpzZs2NC3b9//+q//6tKly/PPP//ZZ59t2LDh448//vWvf73ffvvddNNNuRPHmsyaNSveRvv27b/xAan2yiuvbHknIdssW7Ysd/vatWs/+OCDW265JY7jH/zgBx999NGWm61du3bLB79Hjx6vv/76yy+/HP7g//3vf89kMkuXLv3e9743Y8aMVatWff755xUVFUccccTYsWMfeuihb3wcstlsz54999prr1dfffWUU07ZziMGUC8kcK7ZqFGjo48++u67746iaKtzzSeffHLdunVXXHHFgAEDZsyY8dZbb/3Te7v22mv/+te//uxnP9uhY/inU4899tgbb7zRo0ePadOm9e7du3nz5g0bNmzduvVVV1313HPPbdq06d///d+jYrLnnnseeeSRd91112233bZ+/fqf//zn23nwb7jhhlxxwx/8e++999NPPx00aNCTTz55yimnNG3adN999z3vvPOmTp26995733vvvdv+evOHH364X79+Bx544J/+9Kfjjjuu+vZHH300lUr96le/2qkPAMAuWs2qqqq333578ODBURS1a9duy0+NHTv2mGOOOfPMM6+66qo99tgj5HTzpz/9adu2bW+77bZ33nkn/Bj+6dSTTz6ZSqX+3//7f3vsscdWn/rOd74zd+7cO++8MypKN95441577fX73//+Gz+7YcOG999///7772/YsOF3vvOd8Af/P/7jPxo3bnzHHXdsdYetWrV67bXXXn311VQqteXt99xzz+WXX37EEUe89tprRx111M77+gB2g2oefvjh1W9I2XPPPdu3b//MM8/sv//+119/ffU2c+bM+c///M+hQ4emUqkjjzyyX79+TzzxxOrVq7d/z3vttdfYsWM3bNiwQ9dp/+nUrFmzjjnmmMMPP/wbx4855pitIrGVjh07bvUuntdee62mB6Taq6++uqPbbKtp06ZHHXXUVifxjRs3zo2XlpaWl5f/+c9/fuyxx7b86rb/4G/YsOHDDz88+eSTmzRpsu0ejz/++IMPPnjLW2666aabb745iqLTTjutTZs2W23fv3//OI6vueaa7X8hAEUome88admy5Q9+8IO//e1vBx10UPWNjzzySMuWLS+++OLcfw4bNuzLL78MuRDatWvX66677vXXXx81alT4MWxnasOGDZWVlS1atNjyxq3e13rYYYdFxap58+ZV/1DTBps2bZoxY8aGDRsCH/zKyso4jps3bx54AL/85S9PPfXUHj16PPLII88991ztvhqA3a+auTe2rF+//qmnnsqdDI0YMeKQQw6p3mDDhg3jx49fsmRJo0aNclnq0KFDHMeB7wn66U9/etRRR91+++1z584NP6qapkpKSpo2bbp8+fIoX9u+G6hr167/9J0+p59++o5u842++OKLkpKSRo0abftuoPXr1y9YsOBf/uVffvnLXw4ZMiTwwd9vv/0aNGgQ/oAMGDDg1VdfHTdu3H777ffDH/5wyZIlgYMARa5OzzVLSkq++93vPv3001OnTj3rrLO2/K6+F1988Rv/UX7zzTdnzpz5T++5cePGeVyn3c7UscceO3fu3I8//vgb3zDcqVOnqFitXr16zpw5xxxzzDd+tqSk5PDDDx81alT79u0fffTRwAd/jz32OOaYY/7zP/9zzZo122521113XXbZZUuXLq2+5de//nVpaenBBx/8q1/96vPPP7/sssu2/S4XgPoogSu0Z5999rXXXvvmm29Wn+vkrhDuueeeK1eu3PK86i9/+UsURTV9V8NWvv3tb19//fUzZ87c9icY5DF18cUXb968+eqrr/7GBm/7ftHicd99923YsOGss87a/mYNGjRYvXr1xo0bAx/8dDq9du3a//t//+9W9/Phhx/ec889L7744jdev/3e977Xt2/fP/7xjzt08RygaCXzuuZPf/rTNm3ajB49+q9//WsURZ988smkSZN69+69zz77bLnZqaeeWl5e/u///u8rV64Mudvhw4cfddRRv/71r3foYL5x6vLLL+/UqdPvfve7k08++T/+4z8++eSTDRs25H7KQa9evd58880GDYrrhxFWVVW99957t956609+8pO99tqrpvfaxHG8ePHioUOHvvXWWx07dmzYsGHggz9o0KDmzZuPHDnysssu+8///M+1a9d++umnTz755Omnn15ZWTl06NAtLwhvafTo0S1atLj11lvfeOONwnzpAHUnmX/6995771/+8pebN2++4oorNm7cOG7cuI0bN1a/FWVL3//+99esWfP444+HX3Hd/rtbA6dKS0srKipOPfXUN99887vf/e7BBx9cWlqa+4l6EydOLC8vD/zRRTX5xvfHplKpLd8zHLLNwQcfXP3O5KOPPnr48OG5Hx/YunXrrb7G3GYNGjRo3br1qFGjGjRokPvmmcAHv3nz5k8//XTTpk0ff/zxk046aa+99jrooIMuvvjijz76KJPJ3HTTTTV9pfvvv/9vfvObDRs2XHTRRV999ZXv1wTqtcROmM4999x0Ov23v/3t5z//+aOPPrrvvvueffbZ22522WWXNWjQIPAibe6Ka+5b+HfIN061atXqT3/60/jx43v27NmqVavS0tIWLVr07NnzsccemzNnzkknnRQVk5KSktatW1944YV//vOfv/e979W02R577HHggQf26tXr5Zdfzl3FDX/wu3fvPmvWrOuuu+7oo49u0qRJ48aNTznllDFjxvz2t7/d9rtat9S7d+/+/fu///77W36jEUB9lCrml+gAoKgU14tzAFDMVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZq7lBUrVrz77rtJHwUUBcuBQlDNQmnVqlVqG+PHjy/oTnv06DFjxozw7UeNGtW5c+eaPltZWXnEEUfs0B3Ctvbff//qJVBaWnrMMcfcf//9ed9b9ZO2srIylUptp4uWA4WgmgV03333xf/TJZdcUtA9rl27dmfd1aJFi3r06LFw4cKddYfszkaPHp1bAl999dXIkSOHDBny+OOP1/I+mzVrFsfx0UcfXdMGlgOFoJp17eGHH27UqNGiRYuiKFq+fPk+++wzduzYzz77LJVKPfzww61atSorKxs4cGD1gl+2bFnfvn2bNGnSunXrwYMHV9++ZMmSTCbTtGnTAw444Oqrr66qqjr99NPfe++9AQMGXH755dsZfPvtt0877bTGjRt36dKlpn8Ffve737Vv375Tp0519aiwuygpKTnnnHO6d++ezWY/+eSTVCo1bNiwsrKy/v377+iTdstzTcuBOqOadW3gwIFdu3YdMWJEFEXDhw8/8cQTBwwYkPvUPffcM2nSpFmzZr3xxhvXXHNN7sY+ffo0bdr0ww8/nDp16syZMwcNGhRF0aZNm84+++zS0tL58+dPnz599uzZt99++6uvvlpeXj527NgxY8bUNLhu3bqePXt26NBh6dKlw4YNGzt27DceZKNGjV555ZUHHnigDh8YdiMbN25s0qRJ7uN333138eLFd9xxR95PWsuBOrXVJUR2lpYtW271UO+xxx65T82bN69Zs2b33ntvWVnZvHnz4jhevnx5FEXZbDa3weTJk0tLS1evXj116tS99tqrqqoqd/vMmTMbNGiwdu3aqVOnlpaWrlixYqud5v6ZiOO4psGKioqysrI1a9bkbv/Rj350yimn1PQlbNiwIYqi6dOnF+DhYTfSvHnz6iu0lZWVY8eObdCgwYsvvrhs2bIoiiZOnJj71I4+ab/44osoit555x3LgbrkXLPuXtfcuHFj7va2bdsOHTp08ODBN954Y9u2bau3r34nwvHHH79+/fr58+fPnTt3zZo1jRo1yr2T4qSTTtq8efOCBQvefvvtVq1a7bfffjXtuqbBuXPnHnnkkY0bN85t1rFjxwI/BvC1q666KvdUbNGixahRox544IFevXrlPtWmTZtaPmktB+qSaiZjzpw5URS9+eabW95YUlKS+2DTpk1RFDVs2HDjxo1t27bd6v90vvWtb5WUlKRSqe3cf02DW21WvUcoqOpzzXXr1s2ZM+fKK6+s/lSjRo1q+aS1HKhLqpmAl1566emnnx45cuSECRMqKiqqb3/rrbdyH8yaNatJkyZHHnnk0UcfvXDhwsWLF291D+3atVu0aFHuCtWWqv/tqGmwffv28+bN++qrr3L/OXv27J39xUGe8n7SWg7UJdWsa6tXr77yyiuvu+66IUOG/PCHP7zmmmu+/PLL3KduuummhQsXzps37+abb/7Rj37UqFGjM88887jjjhswYMCiRYuWLFlyww03tGnTpqqq6rTTTmvfvv2111772Wefffjhh3369Pne974XRdHee++9dOnSL7/8sqbB//N//s/BBx98/fXXf/7556+88sojjzyS9OMB/7+8n7SWA3VqJ70+yj9/N1AURVdcccW111572GGHrV69Oo7jlStXtm7d+pprrsm9G+iWW2459NBD991338GDB69fvz53Px999NF55523995777PPPmedddY777yTu33hwoVnn332nnvu2bx58/79+69cuTKO49/85jdNmjTp06fPdgbnz5/fvXv3Pffcs3379oMHD/b2B+ry3UBbyr0bKPeGuJwdetJWvxvIcqAupeI4jpKQyWQS2W9xWr9+/cSJE7t37960adOkj2X3lc1mE9mvtUCxSWot1AsNE9x3Rdu78xtMf3BzrWa3eClxx2bT6YLO/uEPf0hkv9uZXXBrZX6zR9zZrDaziXy9CbIWzBbVLNvhdU0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABAqFcdxlIRMJpPIfqEm2Ww2kf1a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QqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqnmLmXFihXvvvtu0kcBRcFyoBBUs1BatWqV2sb48eMLutMePXrMmDEjfPtRo0Z17tx529vnzZt3zjnnNGvW7OCDD77iiitWrVq1Uw+T3cv+++9fvQRKS0uPOeaY+++/P+97q37SVlZWplKp7XTRcqAQVLOA7rvvvvh/uuSSSwq6x7Vr19b+TjZs2HDOOeccdthhCxcu/NOf/vTGG29ceeWVO+Po2H2NHj06twS++uqrkSNHDhky5PHHH6/lfTZr1iyO46OPPrqmDSwHCkE169rDDz/cqFGjRYsWRVG0fPnyffbZZ+zYsZ999lkqlXr44YdbtWpVVlY2cODA6gW/bNmyvn37NmnSpHXr1oMHD66+fcmSJZlMpmnTpgcccMDVV19dVVV1+umnv/feewMGDLj88su3M/j222+fdtppjRs37tKly8KFC7c9wpkzZy5YsODee+/dd99927Zte/vtt0+YMCGO4zp8kNhllZSUnHPOOd27d89ms5988kkqlRo2bFhZWVn//v139Em75bmm5UCdUc26NnDgwK5du44YMSKKouHDh5944okDBgzIfeqee+6ZNGnSrFmz3njjjWuuuSZ3Y58+fZo2bfrhhx9OnTp15syZgwYNiqJo06ZNZ599dmlp6fz586dPnz579uzbb7/91VdfLS8vHzt27JgxY2oaXLduXc+ePTt06LB06dJhw4aNHTt22yPs0qXLhg0bSktLc/+5bNmy/fbbL5VK1eGDxC5u48aNTZo0yX387rvvLl68+I477sj7SWs5UKe2uoTIztKyZcutHuo99tgj96l58+Y1a9bs3nvvLSsrmzdvXhzHy5cvj6Iom83mNpg8eXJpaenq1aunTp261157VVVV5W6fOXNmgwYN1q5dO3Xq1NLS0hUrVmy109w/E3Ec1zRYUVFRVla2Zs2a3O0/+tGPTjnllO18FZWVlYcffvjtt9++sx8ediPNmzevvkJbWVk5duzYBg0avPjii8uWLYuiaOLEiblP7eiT9osvvoii6J133rEcqEvONevudc2NGzfmbm/btu3QoUMHDx584403tm3btnr76nciHH/88evXr58/f/7cuXPXrFnTqFGj3DspTjrppM2bNy9YsODtt99u1arVfvvtV9OuaxqcO3fukUce2bhx49xmHTt23M7xf/XVV717927fvv2tt966kx4SdlNXXXVV7qnYokWLUaNGPfDAA7169cp9qk2bNrV80loO1CXVTMacOXOiKHrzzTe3vLGkpCT3waZNm6Ioatiw4caNG9u2bbvV/+l861vfKikp2f41opoGt9qseo/bWrFiRffu3Vu1avXss882bNiwdl8uu7vqc81169bNmTNnyzfUNGrUqJZPWsuBuqSaCXjppZeefvrpkSNHTpgwoaKiovr2t956K/fBrFmzmjRpcuSRRx599NELFy5cvHjxVvfQrl27RYsW5a5Qban6346aBtu3bz9v3ryvvvoq95+zZ8/+xiNcvHhx165du3Xr9sQTT1S/ogMFlfeT1nKgTu2kK71srWXLltt+50kcx19++WWbNm1uuOGG3OsoLVu2XLVqVe51zRNPPHHBggXvv//+scceO3jw4DiON23a1LFjxx49enz88ceLFy++/vrrW7duvW7dus2bN59wwgkXX3zx8uXLFy5ceP7551944YVxHHfq1Gn48OGrVq2qabCqqqpdu3YDBw5csWLFyy+/3LRp021fyPniiy+OOuqom266qa4eKnaj1zW3lHtdM/fS/nae7TU9aatf17QcqEuqWXfvBoqi6Iorrrj22msPO+yw1atXx3G8cuXK1q1bX3PNNblq3nLLLYceeui+++47ePDg9evX5+7no48+Ou+88/bee+999tnnrLPOeuedd3K3L1y48Oyzz95zzz2bN2/ev3//lStXxnH8m9/8pkmTJn369NnO4Pz587t3777nnnu2b99+8ODB2/4zcdddd2175F9++WXdPn7sdtXc0SdtdTUtB+pSKqlvPMpkMonstzitX79+4sSJ3bt3b9q0adLHsvvKZrOJ7NdaoNgktRbqhzgh6XQ672M2a7YQs9aCWbPJroV6wbuBACCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAqFQcx1ESMplMIvuFmmSz2UT2ay1QbJJaC/VDnJB0Op33MZs1W4hZa8Gs2WTXQr3gCi0AhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAiViuM4SkImk0lkv1CTbDabyH6tBYpNUmuhfogTkk6n8z5ms2YLMWstmDWb7FqoF1yhBYBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVJxHEdJyGQyiewXapLNZhPZr7VAsUlqLdQPcULS6XTex2zWbCFmrQWzZpNdC/WCK7QAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASBUw+AtAWDHpVI1fiqhH4ReG6oJQN3Gcttt6k8+VROAOu/lN47Uh3aqJgDJ9bK+tdO7gQAogmTu9PspDNUEoMhSlyrecKomAMUXuVSRhlM1ASjKvKWKMZypOKHXXTOZTCL7hZpks9lE9mstUI/XQqrwYSuyNwcl+R7aioqK/AbT6XRF27vznP3g5lrN1uaYzQbPPjrtuvxm+3e7P+/ZBFkLZotqtrjOBVOpogqnK7QAEEo1ASjuFx1TRfQCp2oCQCjVBKDoT/5SxXK6qZoAEEo1ASCUagJQHy6WporiIq3feQJAgcVxNGFCtHFjVFISnXtukfQvP841ASiw11+PXnop6ts3ev75aMaMqD5TTQAKbNGiqKoq6tw5WrLk6z/1mWoCUHjjx0fDhkWTJkX1nGoCUHgDBkSPPhr17h3Vc6oJQIG1bh01bhxls19/0LJlVJ95Dy0ABXbyydEnn0Tdun39HtrOnaP6TDUBKLBUPf5Wk624QgvAjogT+m2XxfFbNlUTAEKpJgCESsUJnfNmMplE9gs1yWaziezXWqBeroVUaje8PJvwu4EqKiryG0yn07WabXt3nrMf3JzYMe9ms49Ouy6/2f7d7s97vwmyFszWNLu7rYXi5wotAMV98hcXy4mmagLADlBNAIr4FDAuohNN1YQ8HX/88Uv+8asbqqqq2rVrd//993fs2PGEE06YPHly0ocGdSiOd6tkqibkqW/fvs8//3wURVOmTDnrrLPuvPPOadOmPfnkk+PHj0/60KBuxfHuk0zVhDz169dvwoQJURS98MILF1xwQc+ePS+77LJFixaNGzcu6UODOhfHu0kyVRPyVF5evmLFilWrVs2aNevb3/72o48+OmjQoNGjRw8YMCDpQ4MkxPHukEw/vR3yd955540YMeLkk09etWrVueee+8orr3Tq1OmII45I+rggIXG8c370QREnUzUhf/369TvuuOOmTJlSVlZ2zjnndO7cefPmzT/+8Y+TPi5ITvyP4OXdzuLuZY5qQp7Ky8urqqpyHw/9h6SPCOptO+N60Msc1QSgAOL/DuF28ll/YllNNQEopLj+pXE7vIcWAEKpJgCEUk0ACKWaABBKNQEglGoCQKhUnNB7gjOZTCL7hZpks9lE9mstUGySWgv1QpLfr1lRUZHfYDqdrmh7d56zH9xcL2dr81jVYvbRadflN9u/2/31bjZB1kLxr4XdapbtcIUWAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBKBW/vCHP3Tp0uWMM8447bTTpk+fHkXR5s2br7vuulNPPbVbt24LFizYdmTixImNGzeOomjEiBHt27cfOXJkbqpXr16VlZVREfP7NQGolYEDB06ZMuXwww+fP39+7969586d++CDDzZt2nT69OnZbHbIkCHPPffcltt/+eWXd955Z0lJSRRFv/jFL957773y8vKhQ4eOGTOmT58+zZo1i4qYc00AaqV58+YrVqyIomjFihVfffVVFEVPPPHEgAEDoijq1atX586dt9r+lltuueGGGxo0+DpAJSUlf//730tLSz///PMJEybkpoqZagJQKw8++GDXrl2PPfbYbt26PfDAA1EUvf/++88///zpp5/+3e9+94ILLthy49dee23p0qXVNw4fPvySSy656667br311p/85CepVCoqbqoJQK0MGTLkiSeemD179uOPP567GLt+/fpDDz301VdfveSSSwYOHFi9ZVVV1ZAhQ3Jlzbn00ktnzJhRXl4eRdGCBQt69er17LPPRkXM65oA1Mrs2bNzv4Tg/PPPv+qqq6IoatGiRTqdzv043CuvvLJ6y9/+9rdffvnlRRddFEXR6tWrL7vssnHjxsVxfNttt40bN65Tp04zZszo0qVL3759o2LlXBOAWikvL//zn/8cRdH06dMPO+ywKIrOPPPMadOmRVE0bdq0Dh065BoZRdFFF1309ttvv/oPTZo0GTduXBRFjzzySO/evZs3b7527do4jtesWRMVMeeaANTKgw8+eN11X/+uoVQqNWbMmCiK7rjjjoEDB95xxx0NGzZ86KGHcqehkydP3na2srLymWeemThxYhRFgwYN6tGjx4033hgVMdUEoFY6dOgwderULW858MADX3jhhS1v2TaZue/LbNas2aRJk3K33PIPUXFzhRYAQqkmAIRSTQAIlYrjOEpC7m3KUDyy2Wwi+7UWKDZJrYX6IU5I7lt58mPWbCFmrQWzZpNdC/WCK7QAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASBUKo7jKAmZTCaR/UJNstlsIvu1Fig2Sa2F+iFOSDqdzvuYzZotxKy1YNZssmuhXnCFFgBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhErFcRwlIZPJJLJfqEk2m01kv9YCxSaptVA/xAlJp9N5H7NZs4WYtRbMmk12LdQLrtACQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqTiOoyRkMplE9gs1yWaziezXWqDYJLUW6oc4Iel0Ou9jNmu2ELPWwg7NVu73x/z+1NOvd7eaTWot1Auu0AJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCpOI6jJGQymUT2CzXJZrNJHwJQ9OKEpNPpvI/ZrNlCzCa1FoB6xBVaAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQKhXHcfDGALBbc64JAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFLNXcqKFSvefffdpI8C6gGLhfyoZqG0atUqtY3x48cXdKc9evSYMWNG+PajRo3q3Lnztrd/+umnffv23WeffVq3bn3nnXfu1GOE/2H//fevXiClpaXHHHPM/fffn/e9VT+lKysrU6nUdrposZCfhnnOEeC+++674YYb6nKPa9eu3Sn3c9FFF7Vp02bRokXz5s07++yzDzrooMsvv3yn3DNsa/To0VdeeWUURRs2bPj9739//vnn77vvvpdeemlt7rNZs2ZxHG9nA4uF/DjXrGsPP/xwo0aNFi1aFEXR8uXL99lnn7Fjx3722WepVOrhhx9u1apVWVnZwIEDq5f0smXL+vbt26RJk9atWw8ePLj69iVLlmQymaZNmx5wwAFXX311VVXV6aef/t577w0YMCC3aGsafPvtt0877bTGjRt36dJl4cKF2x7h/Pnzp0yZMmrUqLKyshNPPPGMM874y1/+UoePELuvkpKSc845p3v37tls9pNPPkmlUsOGDSsrK+vfv/+OPqW3PNe0WNiZYgqjZcuW99133zd+6swzz7z66qvjOL7++uvPOOOMOI6XL18eRVG7du1mz549f/78Dh06/OAHP8htfOqpp/bv33/58uXz58/v2rXrFVdcEcfxxo0bjz322AsuuODTTz+dN29e165db7755jiOy8vLx44du53BtWvXtmnT5l/+5V8+//zz559/vnHjxqecckpNX8KGDRteeeWV/fbb7/nnny/MgwRx8+bNR48eveUtPXr0uPTSS5ctWxZFUTqdXrVq1UcffbSjT+kvvvgiiqJ33nnHYmHnUs1Cadmy5Vb/g7LHHnvkPjVv3rxmzZrde++9ZWVl8+bNq65mNpvNbTB58uTS0tLVq1dPnTp1r732qqqqyt0+c+bMBg0arF27durUqaWlpStWrNhqp9X/ENQ0WFFRUVZWtmbNmtztP/rRj7bzD0F5eXmjRo1OP/305cuXF+ARgq2rWVlZOXbs2AYNGrz44ou5ak6cODH3qR19SldX02Jh53KFtoC2OtfcuHFj7va2bdsOHTp08ODBN954Y9u2bau3r36vwfHHH79+/fr58+fPnTt3zZo1jRo1yr1X4qSTTtq8efOCBQvefvvtVq1a7bfffjXtuqbBuXPnHnnkkY0bN85t1rFjx+0c/7vvvrtixYq99trrnHPO2UkPCXyDq666KvdEbdGixahRox544IFevXrlPtWmTZtaPqUtFnYu1UzGnDlzoih68803t7yxpKQk98GmTZu+fqdWw4YbN25s27btVv+n861vfaukpCSVSm3n/msa3Gqz6j3WZO+997711lv/+te/Ll26NN+vFf6J6nPNdevWzZkzJ/fOoJxGjRrV8iltsbBzqWYCXnrppaeffnrkyJETJkyoqKiovv2tt97KfTBr1qwmTZoceeSRRx999MKFCxcvXrzVPbRr127RokW5a1Bbqv7XoabB9u3bz5s376uvvsr95+zZs7c9vEmTJpWVlVVVVeX+8/PPP99jjz2aNWtWuy8aaiXvp7TFwk62k670EvpuoC+//LJNmzY33HBD7pWSli1brlq1Kve65oknnrhgwYL333//2GOPHTx4cBzHmzZt6tixY48ePT7++OPFixdff/31rVu3Xrdu3ebNm0844YSLL754+fLlCxcuPP/88y+88MI4jjt16jR8+PBVq1bVNFhVVdWuXbuBAweuWLHi5Zdfbtq06bYv1axdu7Zdu3ZXX311ZWXl3/72t2OOOebyyy+vq4eN3c627wbKyb2umXvhfztroaandPXrmhYLO5dq1t27gaIouuKKK6699trDDjts9erVcRyvXLmydevW11xzTa6at9xyy6GHHrrvvvsOHjx4/fr1ufv56KOPzjvvvL333nufffY566yz3nnnndztCxcuPPvss/fcc8/mzZv3799/5cqVcRz/5je/adKkSZ8+fbYzOH/+/O7du++5557t27cfPHjwN77B4YMPPujZs+c+++zTpk2bYcOGrV27tg4fOXYvgdXc0ad0dTUtFnau1Pa/Ebg2MplMge5517N+/fqJEyd27969adOmSR8L3yybzSayX+uIYpNNaC0Ui7hg0ul03ke1u8327Nkzkf2aLYaVYh2ZrV+z8e7Nu4EAIJRqFoXS0tKkDwGAf041ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAECoVx3FUGJlMpkD3DHUvm80msl/riGKTTWgtFImGBb33ioqK/AbT6XS9nG17d56zH9xcL7/e3Wk2QfXusbKOdu3Z3ZwrtAAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQ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1VcjR44cMmTI448/Xsv7bNasWRzHRx99dE0bWErURDXr2sMPP9yoUaNFixZFUbR8+fJ99tln7Nixn332WSqVevjhh1u1alVWVjZw4MDqRbts2bK+ffs2adKkdevWgwcPrr59yZIlmUymadOmBxxwwNVXX11VVXX66ae/9957AwYMuPzyy7cz+Pbbb5922mmNGzfu0qXLwoULazrOdevWDRw48MQTT6yTRwX+uZKSknPOOad79+7ZbPaTTz5JpVLDhg0rKyvr37//jj7htzzXtJTYIapZ1wYOHNi1a9cRI0ZEUTR8+PATTzxxwIABuU/dc889kyZNmjVr1htvvHHNNdfkbuzTp0/Tpk0//PDDqVOnzpw5c9CgQVEUbdq06eyzzy4tLZ0/f/706dNnz559++23v/rqq+Xl5WPHjh0zZkxNg+vWrevZs2eHDh2WLl06bNiwsWPH1nSct9122//6X//r/PPPr6sHBoJs3LixSZMmuY/ffffdxYsX33HHHXk/4S0ldthWlxDZWVq2bLnVQ73HHnvkPjVv3rxmzZrde++9ZWVl8+bNi+N4+fLlURRls9ncBpMnTy4tLV29evXUqVP32muvqqqq3O0zZ85s0KDB2rVrp06dWlpaumLFiq12mlvqcRzXNFhRUVFWVrZmzZrc7T/60Y9OOeWUbQ/+9ddfP+CAA5YtW3bXXXd95zvfKdiDBP9E8+bNq6/QVlZWjh07tkGDBi+++OKyZcuiKJo4cWLuUzv6hP/iiy+iKHrnnXcsJXaUc826e11z48aNudvbtm07dOjQwYMH33jjjW3btq3evvrdBMcff/z69evnz58/d+7cNWvWNGrUKPduiJNOOmnz5s0LFix4++23W7Vqtd9++9W065oG586de+SRRzZu3Di3WceOHbed3bBhww9+8IORI0cedNBBO/shgR121VVX5Z7GLVq0GDVq1AMPPNCrV6/cp9q0aVPLJ7ylxI5SzWTMmTMniqI333xzyxtLSkpyH2zatCmKooYNG27cuLFt27Zb/Z/Ot771rZKSklQqtZ37r2lwq82q97il4cOHt2rV6vvf//7O+EKhtqrPNdetWzdnzpwrr7yy+lONGjWq5RPeUmJHqWYCXnrppaeffnrkyJETJkyoqKiovv2tt97KfTBr1qwmTZoceeSRRx999MKFCxcvXrzVPbRr127RokW5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"
            },
            {
              "type": "input_text",
              "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
            }
          ],
          "solved_count": 0,
          "total_training_examples": 4,
          "pixel_accuracy": 0.7599309153713298
        },
        "test_result": {
          "correct": false,
          "pixel_accuracy": 0.0,
          "total_pixels": 224,
          "correct_pixels": 0,
          "error": "Grid height mismatch"
        },
        "status": "failed_test",
        "feedback_sent": true
      },
      {
        "turn_number": 7,
        "timestamp": "2025-07-10T10:43:26.406319",
        "input_tokens": 44951,
        "output_tokens": 1900,
        "turn_cost": 0.0210204,
        "program_extracted": true,
        "program": "def transform(grid):\n    import numpy as np\n\n    arr = np.array(grid)\n    target_size = 11\n\n    # Normalize input to 11x11\n    norm = np.zeros((target_size, target_size), dtype=int)\n    norm[:arr.shape[0], :arr.shape[1]] = arr[:target_size, :target_size]\n    arr = norm\n\n    output = np.zeros_like(arr)\n    blue_color = 1\n\n    # Copy blue pixels as is\n    output[arr == blue_color] = blue_color\n\n    # Colors excluding 0 and blue\n    colors = set(np.unique(arr))\n    colors.discard(0)\n    colors.discard(blue_color)\n\n    # Quadrant boundaries inclusive: (row_start, row_end, col_start, col_end)\n    quadrants = {\n        'TL': (0, 5, 0, 5),\n        'TR': (0, 5, 6, 10),\n        'BL': (6, 10, 0, 5),\n        'BR': (6, 10, 6, 10)\n    }\n\n    # Map quadrant to duplication target quadrant\n    quadrant_map = {\n        'TL': 'TR',\n        'TR': 'BL',\n        'BL': 'BR',\n        'BR': 'TL'\n    }\n\n    def get_quadrant(r, c):\n        for q_name, (rs, re, cs, ce) in quadrants.items():\n            if rs <= r <= re and cs <= c <= ce:\n                return q_name\n        return None\n\n    for color in colors:\n        positions = np.argwhere(arr == color)\n        if positions.size == 0:\n            continue\n\n        min_r, min_c = positions.min(axis=0)\n        max_r, max_c = positions.max(axis=0)\n\n        # Copy cluster pixels to output at original positions\n        for r, c in positions:\n            output[r, c] = color\n\n        # Compute cluster centroid for quadrant\n        centroid_r = int(round(positions[:, 0].mean()))\n        centroid_c = int(round(positions[:, 1].mean()))\n        orig_quad = get_quadrant(centroid_r, centroid_c)\n        target_quad = quadrant_map[orig_quad]\n\n        r_start, r_end, c_start, c_end = quadrants[target_quad]\n\n        cluster_height = max_r - min_r + 1\n        cluster_width = max_c - min_c + 1\n\n        orig_r_start, orig_r_end, orig_c_start, orig_c_end = quadrants[orig_quad]\n\n        offset_r = min_r - orig_r_start\n        offset_c = min_c - orig_c_start\n\n        # New top-left for duplicate cluster in target quadrant (with clamping)\n        new_min_r = r_start + offset_r\n        new_min_c = c_start + offset_c\n\n        if new_min_r < r_start:\n            new_min_r = r_start\n        if new_min_c < c_start:\n            new_min_c = c_start\n        if new_min_r + cluster_height - 1 > r_end:\n            new_min_r = r_end - cluster_height + 1\n        if new_min_c + cluster_width - 1 > c_end:\n            new_min_c = c_end - cluster_width + 1\n\n        # Duplicate pixels copied exactly at new location (no overwrite blue)\n        for r, c in positions:\n            rr = new_min_r + (r - min_r)\n            cc = new_min_c + (c - min_c)\n            if 0 <= rr < target_size and 0 <= cc < target_size:\n                if output[rr, cc] != blue_color:\n                    output[rr, cc] = color\n\n    return output.tolist()",
        "training_feedback": {
          "feedback_messages": [
            {
              "type": "input_text",
              "text": "Training results: 0/4 examples solved, 76.0% pixel accuracy - Good partial progress! Your approach is capturing some patterns. Next, try to identify a transformation that solves at least one of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[1, 1, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 1, 1, 1, 0, 3, 3, 3, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 1, 1, 1, 0, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0]]\nPixel accuracy: 86.0%\n\nTraining Example 2 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 1, 0, 0, 0, 0, 0, 0, 6, 0], [0, 1, 1, 1, 1, 0, 0, 6, 6, 6, 6], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 6, 0], [0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 86.4%\n\nTraining Example 3 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 77.8%\n\nTraining Example 4 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 60.4%\n\n\u26a0\ufe0f  GRID SIZE ERROR: One or more of your output grids are incorrect in size. They should ALL be 11\u00d711 for this task.\n\n"
            },
            {
              "type": "input_image",
              "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAmcAAATYCAIAAADVnPfcAABQcklEQVR4nO3de5RU5Z3o711IN6Jgo6ioXLwhrTkoIl6QIFHhrKMgWiVgjLdAMPEy3kBQmTF64pKIQjQxMegJiiI6OhqrUYMETRBiApFRJoJ4QUDlpkG0QQSa2/4tU7/pxYBNXqqp3tXwPIs/2ur9rb27qJePe1d1dyqO4wgACNAgZCMAQDUBYAeoJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaAFAn1bzmmmtSNbvkkku+cZvS0tKDDjro3HPPffPNN7e9z5dffjmVSu23337r1q3b6lPPPvtsKpUaM2ZM7j/79++fSqVGjhy51WaLFy9OpVK33nprbaZy1q1b99BDD51xxhmHHHJIo0aNDjnkkH79+v3pT3/azmNy66231vSAzJkzZ/sPWo8ePf7pA1u9zeWXX77l7bnD69Onz/Tp07c8nnQ6vdVmhx9++HXXXffFF1/s0IOf89lnn915550dO3YsKyvbe++9Tz755DFjxmz5a3Nyu9tq/I033jjggAOaNm06ZcqU7Tx0AMUvgXPNDRs2fPrppy+88MIZZ5yxYMGCrT77yCOPRFH0xRdfPP300yH3dtttt7377rs7egwhUx9++OGpp5565ZVXvvrqq8uWLVu/fv2yZcueffbZbt263XvvvVGRyR3ec88917Vr1yeeeGI7m3344Ye//OUvzzrrrM2bN+/Qgz99+vQOHTr8+Mc//q//+q9Vq1atWbNm5syZP/zhDwcOHLidA/vjH/94xhlnbNq06ZVXXjnjjDNq8SUC1PNq/upXv4r/2zPPPBNF0dixY6tvGT9+fPWWCxcurL593bp177zzzkUXXbRq1arRo0dveYeVlZUVFRX9+vXbb7/9HnzwwZBjWL9+ff/+/Tdt2rRDR/5PpzZs2NC3b9//+q//6tKly/PPP//ZZ59t2LDh448//vWvf73ffvvddNNNuRPHmsyaNSveRvv27b/xAan2yiuvbHknIdssW7Ysd/vatWs/+OCDW265JY7jH/zgBx999NGWm61du3bLB79Hjx6vv/76yy+/HP7g//3vf89kMkuXLv3e9743Y8aMVatWff755xUVFUccccTYsWMfeuihb3wcstlsz54999prr1dfffWUU07ZziMGUC8kcK7ZqFGjo48++u67746iaKtzzSeffHLdunVXXHHFgAEDZsyY8dZbb/3Te7v22mv/+te//uxnP9uhY/inU4899tgbb7zRo0ePadOm9e7du3nz5g0bNmzduvVVV1313HPPbdq06d///d+jYrLnnnseeeSRd91112233bZ+/fqf//zn23nwb7jhhlxxwx/8e++999NPPx00aNCTTz55yimnNG3adN999z3vvPOmTp26995733vvvdv+evOHH364X79+Bx544J/+9Kfjjjuu+vZHH300lUr96le/2qkPAMAuWs2qqqq333578ODBURS1a9duy0+NHTv2mGOOOfPMM6+66qo99tgj5HTzpz/9adu2bW+77bZ33nkn/Bj+6dSTTz6ZSqX+3//7f3vsscdWn/rOd74zd+7cO++8MypKN95441577fX73//+Gz+7YcOG999///7772/YsOF3vvOd8Af/P/7jPxo3bnzHHXdsdYetWrV67bXXXn311VQqteXt99xzz+WXX37EEUe89tprRx111M77+gB2g2oefvjh1W9I2XPPPdu3b//MM8/sv//+119/ffU2c+bM+c///M+hQ4emUqkjjzyyX79+TzzxxOrVq7d/z3vttdfYsWM3bNiwQ9dp/+nUrFmzjjnmmMMPP/wbx4855pitIrGVjh07bvUuntdee62mB6Taq6++uqPbbKtp06ZHHXXUVifxjRs3zo2XlpaWl5f/+c9/fuyxx7b86rb/4G/YsOHDDz88+eSTmzRpsu0ejz/++IMPPnjLW2666aabb745iqLTTjutTZs2W23fv3//OI6vueaa7X8hAEUome88admy5Q9+8IO//e1vBx10UPWNjzzySMuWLS+++OLcfw4bNuzLL78MuRDatWvX66677vXXXx81alT4MWxnasOGDZWVlS1atNjyxq3e13rYYYdFxap58+ZV/1DTBps2bZoxY8aGDRsCH/zKyso4jps3bx54AL/85S9PPfXUHj16PPLII88991ztvhqA3a+auTe2rF+//qmnnsqdDI0YMeKQQw6p3mDDhg3jx49fsmRJo0aNclnq0KFDHMeB7wn66U9/etRRR91+++1z584NP6qapkpKSpo2bbp8+fIoX9u+G6hr167/9J0+p59++o5u842++OKLkpKSRo0abftuoPXr1y9YsOBf/uVffvnLXw4ZMiTwwd9vv/0aNGgQ/oAMGDDg1VdfHTdu3H777ffDH/5wyZIlgYMARa5OzzVLSkq++93vPv3001OnTj3rrLO2/K6+F1988Rv/UX7zzTdnzpz5T++5cePGeVyn3c7UscceO3fu3I8//vgb3zDcqVOnqFitXr16zpw5xxxzzDd+tqSk5PDDDx81alT79u0fffTRwAd/jz32OOaYY/7zP/9zzZo122521113XXbZZUuXLq2+5de//nVpaenBBx/8q1/96vPPP7/sssu2/S4XgPoogSu0Z5999rXXXvvmm29Wn+vkrhDuueeeK1eu3PK86i9/+UsURTV9V8NWvv3tb19//fUzZ87c9icY5DF18cUXb968+eqrr/7GBm/7ftHicd99923YsOGss87a/mYNGjRYvXr1xo0bAx/8dDq9du3a//t//+9W9/Phhx/ec889L7744jdev/3e977Xt2/fP/7xjzt08RygaCXzuuZPf/rTNm3ajB49+q9//WsURZ988smkSZN69+69zz77bLnZqaeeWl5e/u///u8rV64Mudvhw4cfddRRv/71r3foYL5x6vLLL+/UqdPvfve7k08++T/+4z8++eSTDRs25H7KQa9evd58880GDYrrhxFWVVW99957t956609+8pO99tqrpvfaxHG8ePHioUOHvvXWWx07dmzYsGHggz9o0KDmzZuPHDnysssu+8///M+1a9d++umnTz755Omnn15ZWTl06NAtLwhvafTo0S1atLj11lvfeOONwnzpAHUnmX/6995771/+8pebN2++4oorNm7cOG7cuI0bN1a/FWVL3//+99esWfP444+HX3Hd/rtbA6dKS0srKipOPfXUN99887vf/e7BBx9cWlqa+4l6EydOLC8vD/zRRTX5xvfHplKpLd8zHLLNwQcfXP3O5KOPPnr48OG5Hx/YunXrrb7G3GYNGjRo3br1qFGjGjRokPvmmcAHv3nz5k8//XTTpk0ff/zxk046aa+99jrooIMuvvjijz76KJPJ3HTTTTV9pfvvv/9vfvObDRs2XHTRRV999ZXv1wTqtcROmM4999x0Ov23v/3t5z//+aOPPrrvvvueffbZ22522WWXNWjQIPAibe6Ka+5b+HfIN061atXqT3/60/jx43v27NmqVavS0tIWLVr07NnzsccemzNnzkknnRQVk5KSktatW1944YV//vOfv/e979W02R577HHggQf26tXr5Zdfzl3FDX/wu3fvPmvWrOuuu+7oo49u0qRJ48aNTznllDFjxvz2t7/d9rtat9S7d+/+/fu///77W36jEUB9lCrml+gAoKgU14tzAFDMVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZq7lBUrVrz77rtJHwUUBcuBQlDNQmnVqlVqG+PHjy/oTnv06DFjxozw7UeNGtW5c+eaPltZWXnEEUfs0B3Ctvbff//qJVBaWnrMMcfcf//9ed9b9ZO2srIylUptp4uWA4WgmgV03333xf/TJZdcUtA9rl27dmfd1aJFi3r06LFw4cKddYfszkaPHp1bAl999dXIkSOHDBny+OOP1/I+mzVrFsfx0UcfXdMGlgOFoJp17eGHH27UqNGiRYuiKFq+fPk+++wzduzYzz77LJVKPfzww61atSorKxs4cGD1gl+2bFnfvn2bNGnSunXrwYMHV9++ZMmSTCbTtGnTAw444Oqrr66qqjr99NPfe++9AQMGXH755dsZfPvtt0877bTGjRt36dKlpn8Ffve737Vv375Tp0519aiwuygpKTnnnHO6d++ezWY/+eSTVCo1bNiwsrKy/v377+iTdstzTcuBOqOadW3gwIFdu3YdMWJEFEXDhw8/8cQTBwwYkPvUPffcM2nSpFmzZr3xxhvXXHNN7sY+ffo0bdr0ww8/nDp16syZMwcNGhRF0aZNm84+++zS0tL58+dPnz599uzZt99++6uvvlpeXj527NgxY8bUNLhu3bqePXt26NBh6dKlw4YNGzt27DceZKNGjV555ZUHHnigDh8YdiMbN25s0qRJ7uN333138eLFd9xxR95PWsuBOrXVJUR2lpYtW271UO+xxx65T82bN69Zs2b33ntvWVnZvHnz4jhevnx5FEXZbDa3weTJk0tLS1evXj116tS99tqrqqoqd/vMmTMbNGiwdu3aqVOnlpaWrlixYqud5v6ZiOO4psGKioqysrI1a9bkbv/Rj350yimn1PQlbNiwIYqi6dOnF+DhYTfSvHnz6iu0lZWVY8eObdCgwYsvvrhs2bIoiiZOnJj71I4+ab/44osoit555x3LgbrkXLPuXtfcuHFj7va2bdsOHTp08ODBN954Y9u2bau3r34nwvHHH79+/fr58+fPnTt3zZo1jRo1yr2T4qSTTtq8efOCBQvefvvtVq1a7bfffjXtuqbBuXPnHnnkkY0bN85t1rFjxwI/BvC1q666KvdUbNGixahRox544IFevXrlPtWmTZtaPmktB+qSaiZjzpw5URS9+eabW95YUlKS+2DTpk1RFDVs2HDjxo1t27bd6v90vvWtb5WUlKRSqe3cf02DW21WvUcoqOpzzXXr1s2ZM+fKK6+s/lSjRo1q+aS1HKhLqpmAl1566emnnx45cuSECRMqKiqqb3/rrbdyH8yaNatJkyZHHnnk0UcfvXDhwsWLF291D+3atVu0aFHuCtWWqv/tqGmwffv28+bN++qrr3L/OXv27J39xUGe8n7SWg7UJdWsa6tXr77yyiuvu+66IUOG/PCHP7zmmmu+/PLL3KduuummhQsXzps37+abb/7Rj37UqFGjM88887jjjhswYMCiRYuWLFlyww03tGnTpqqq6rTTTmvfvv2111772Wefffjhh3369Pne974XRdHee++9dOnSL7/8sqbB//N//s/BBx98/fXXf/7556+88sojjzyS9OMB/7+8n7SWA3VqJ70+yj9/N1AURVdcccW111572GGHrV69Oo7jlStXtm7d+pprrsm9G+iWW2459NBD991338GDB69fvz53Px999NF55523995777PPPmedddY777yTu33hwoVnn332nnvu2bx58/79+69cuTKO49/85jdNmjTp06fPdgbnz5/fvXv3Pffcs3379oMHD/b2B+ry3UBbyr0bKPeGuJwdetJWvxvIcqAupeI4jpKQyWQS2W9xWr9+/cSJE7t37960adOkj2X3lc1mE9mvtUCxSWot1AsNE9x3Rdu78xtMf3BzrWa3eClxx2bT6YLO/uEPf0hkv9uZXXBrZX6zR9zZrDaziXy9CbIWzBbVLNvhdU0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABAqFcdxlIRMJpPIfqEm2Ww2kf1a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QqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqnmLmXFihXvvvtu0kcBRcFyoBBUs1BatWqV2sb48eMLutMePXrMmDEjfPtRo0Z17tx529vnzZt3zjnnNGvW7OCDD77iiitWrVq1Uw+T3cv+++9fvQRKS0uPOeaY+++/P+97q37SVlZWplKp7XTRcqAQVLOA7rvvvvh/uuSSSwq6x7Vr19b+TjZs2HDOOeccdthhCxcu/NOf/vTGG29ceeWVO+Po2H2NHj06twS++uqrkSNHDhky5PHHH6/lfTZr1iyO46OPPrqmDSwHCkE169rDDz/cqFGjRYsWRVG0fPnyffbZZ+zYsZ999lkqlXr44YdbtWpVVlY2cODA6gW/bNmyvn37NmnSpHXr1oMHD66+fcmSJZlMpmnTpgcccMDVV19dVVV1+umnv/feewMGDLj88su3M/j222+fdtppjRs37tKly8KFC7c9wpkzZy5YsODee+/dd99927Zte/vtt0+YMCGO4zp8kNhllZSUnHPOOd27d89ms5988kkqlRo2bFhZWVn//v139Em75bmm5UCdUc26NnDgwK5du44YMSKKouHDh5944okDBgzIfeqee+6ZNGnSrFmz3njjjWuuuSZ3Y58+fZo2bfrhhx9OnTp15syZgwYNiqJo06ZNZ599dmlp6fz586dPnz579uzbb7/91VdfLS8vHzt27JgxY2oaXLduXc+ePTt06LB06dJhw4aNHTt22yPs0qXLhg0bSktLc/+5bNmy/fbbL5VK1eGDxC5u48aNTZo0yX387rvvLl68+I477sj7SWs5UKe2uoTIztKyZcutHuo99tgj96l58+Y1a9bs3nvvLSsrmzdvXhzHy5cvj6Iom83mNpg8eXJpaenq1aunTp261157VVVV5W6fOXNmgwYN1q5dO3Xq1NLS0hUrVmy109w/E3Ec1zRYUVFRVla2Zs2a3O0/+tGPTjnllO18FZWVlYcffvjtt9++sx8ediPNmzevvkJbWVk5duzYBg0avPjii8uWLYuiaOLEiblP7eiT9osvvoii6J133rEcqEvONevudc2NGzfmbm/btu3QoUMHDx584403tm3btnr76nciHH/88evXr58/f/7cuXPXrFnTqFGj3DspTjrppM2bNy9YsODtt99u1arVfvvtV9OuaxqcO3fukUce2bhx49xmHTt23M7xf/XVV717927fvv2tt966kx4SdlNXXXVV7qnYokWLUaNGPfDAA7169cp9qk2bNrV80loO1CXVTMacOXOiKHrzzTe3vLGkpCT3waZNm6Ioatiw4caNG9u2bbvV/+l861vfKikp2f41opoGt9qseo/bWrFiRffu3Vu1avXss882bNiwdl8uu7vqc81169bNmTNnyzfUNGrUqJZPWsuBuqSaCXjppZeefvrpkSNHTpgwoaKiovr2t956K/fBrFmzmjRpcuSRRx599NELFy5cvHjxVvfQrl27RYsW5a5Qban6346aBtu3bz9v3ryvvvoq95+zZ8/+xiNcvHhx165du3Xr9sQTT1S/ogMFlfeT1nKgTu2kK71srWXLltt+50kcx19++WWbNm1uuOGG3OsoLVu2XLVqVe51zRNPPHHBggXvv//+scceO3jw4DiON23a1LFjxx49enz88ceLFy++/vrrW7duvW7dus2bN59wwgkXX3zx8uXLFy5ceP7551944YVxHHfq1Gn48OGrVq2qabCqqqpdu3YDBw5csWLFyy+/3LRp021fyPniiy+OOuqom266qa4eKnaj1zW3lHtdM/fS/nae7TU9aatf17QcqEuqWXfvBoqi6Iorrrj22msPO+yw1atXx3G8cuXK1q1bX3PNNblq3nLLLYceeui+++47ePDg9evX5+7no48+Ou+88/bee+999tnnrLPOeuedd3K3L1y48Oyzz95zzz2bN2/ev3//lStXxnH8m9/8pkmTJn369NnO4Pz587t3777nnnu2b99+8ODB2/4zcdddd2175F9++WXdPn7sdtXc0SdtdTUtB+pSKqlvPMpkMonstzitX79+4sSJ3bt3b9q0adLHsvvKZrOJ7NdaoNgktRbqhzgh6XQ672M2a7YQs9aCWbPJroV6wbuBACCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAqFQcx1ESMplMIvuFmmSz2UT2ay1QbJJaC/VDnJB0Op33MZs1W4hZa8Gs2WTXQr3gCi0AhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAiViuM4SkImk0lkv1CTbDabyH6tBYpNUmuhfogTkk6n8z5ms2YLMWstmDWb7FqoF1yhBYBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVJxHEdJyGQyiewXapLNZhPZr7VAsUlqLdQPcULS6XTex2zWbCFmrQWzZpNdC/WCK7QAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASBUw+AtAWDHpVI1fiqhH4ReG6oJQN3Gcttt6k8+VROAOu/lN47Uh3aqJgDJ9bK+tdO7gQAogmTu9PspDNUEoMhSlyrecKomAMUXuVSRhlM1ASjKvKWKMZypOKHXXTOZTCL7hZpks9lE9mstUI/XQqrwYSuyNwcl+R7aioqK/AbT6XRF27vznP3g5lrN1uaYzQbPPjrtuvxm+3e7P+/ZBFkLZotqtrjOBVOpogqnK7QAEEo1ASjuFx1TRfQCp2oCQCjVBKDoT/5SxXK6qZoAEEo1ASCUagJQHy6WporiIq3feQJAgcVxNGFCtHFjVFISnXtukfQvP841ASiw11+PXnop6ts3ev75aMaMqD5TTQAKbNGiqKoq6tw5WrLk6z/1mWoCUHjjx0fDhkWTJkX1nGoCUHgDBkSPPhr17h3Vc6oJQIG1bh01bhxls19/0LJlVJ95Dy0ABXbyydEnn0Tdun39HtrOnaP6TDUBKLBUPf5Wk624QgvAjogT+m2XxfFbNlUTAEKpJgCESsUJnfNmMplE9gs1yWaziezXWqBeroVUaje8PJvwu4EqKiryG0yn07WabXt3nrMf3JzYMe9ms49Ouy6/2f7d7s97vwmyFszWNLu7rYXi5wotAMV98hcXy4mmagLADlBNAIr4FDAuohNN1YQ8HX/88Uv+8asbqqqq2rVrd//993fs2PGEE06YPHly0ocGdSiOd6tkqibkqW/fvs8//3wURVOmTDnrrLPuvPPOadOmPfnkk+PHj0/60KBuxfHuk0zVhDz169dvwoQJURS98MILF1xwQc+ePS+77LJFixaNGzcu6UODOhfHu0kyVRPyVF5evmLFilWrVs2aNevb3/72o48+OmjQoNGjRw8YMCDpQ4MkxPHukEw/vR3yd955540YMeLkk09etWrVueee+8orr3Tq1OmII45I+rggIXG8c370QREnUzUhf/369TvuuOOmTJlSVlZ2zjnndO7cefPmzT/+8Y+TPi5ITvyP4OXdzuLuZY5qQp7Ky8urqqpyHw/9h6SPCOptO+N60Msc1QSgAOL/DuF28ll/YllNNQEopLj+pXE7vIcWAEKpJgCEUk0ACKWaABBKNQEglGoCQKhUnNB7gjOZTCL7hZpks9lE9mstUGySWgv1QpLfr1lRUZHfYDqdrmh7d56zH9xcL2dr81jVYvbRadflN9u/2/31bjZB1kLxr4XdapbtcIUWAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBKBW/vCHP3Tp0uWMM8447bTTpk+fHkXR5s2br7vuulNPPbVbt24LFizYdmTixImNGzeOomjEiBHt27cfOXJkbqpXr16VlZVREfP7NQGolYEDB06ZMuXwww+fP39+7969586d++CDDzZt2nT69OnZbHbIkCHPPffcltt/+eWXd955Z0lJSRRFv/jFL957773y8vKhQ4eOGTOmT58+zZo1i4qYc00AaqV58+YrVqyIomjFihVfffVVFEVPPPHEgAEDoijq1atX586dt9r+lltuueGGGxo0+DpAJSUlf//730tLSz///PMJEybkpoqZagJQKw8++GDXrl2PPfbYbt26PfDAA1EUvf/++88///zpp5/+3e9+94ILLthy49dee23p0qXVNw4fPvySSy656667br311p/85CepVCoqbqoJQK0MGTLkiSeemD179uOPP567GLt+/fpDDz301VdfveSSSwYOHFi9ZVVV1ZAhQ3Jlzbn00ktnzJhRXl4eRdGCBQt69er17LPPRkXM65oA1Mrs2bNzv4Tg/PPPv+qqq6IoatGiRTqdzv043CuvvLJ6y9/+9rdffvnlRRddFEXR6tWrL7vssnHjxsVxfNttt40bN65Tp04zZszo0qVL3759o2LlXBOAWikvL//zn/8cRdH06dMPO+ywKIrOPPPMadOmRVE0bdq0Dh065BoZRdFFF1309ttvv/oPTZo0GTduXBRFjzzySO/evZs3b7527do4jtesWRMVMeeaANTKgw8+eN11X/+uoVQqNWbMmCiK7rjjjoEDB95xxx0NGzZ86KGHcqehkydP3na2srLymWeemThxYhRFgwYN6tGjx4033hgVMdUEoFY6dOgwderULW858MADX3jhhS1v2TaZue/LbNas2aRJk3K33PIPUXFzhRYAQqkmAIRSTQAIlYrjOEpC7m3KUDyy2Wwi+7UWKDZJrYX6IU5I7lt58mPWbCFmrQWzZpNdC/WCK7QAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASBUKo7jKAmZTCaR/UJNstlsIvu1Fig2Sa2F+iFOSDqdzvuYzZotxKy1YNZssmuhXnCFFgBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhErFcRwlIZPJJLJfqEk2m01kv9YCxSaptVA/xAlJp9N5H7NZs4WYtRbMmk12LdQLrtACQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqTiOoyRkMplE9gs1yWaziezXWqDYJLUW6oc4Iel0Ou9jNmu2ELPWwg7NVu73x/z+1NOvd7eaTWot1Auu0AJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCpOI6jJGQymUT2CzXJZrNJHwJQ9OKEpNPpvI/ZrNlCzCa1FoB6xBVaAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQKhXHcfDGALBbc64JAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFLNXcqKFSvefffdpI8C6gGLhfyoZqG0atUqtY3x48cXdKc9evSYMWNG+PajRo3q3Lnztrd/+umnffv23WeffVq3bn3nnXfu1GOE/2H//fevXiClpaXHHHPM/fffn/e9VT+lKysrU6nUdrposZCfhnnOEeC+++674YYb6nKPa9eu3Sn3c9FFF7Vp02bRokXz5s07++yzDzrooMsvv3yn3DNsa/To0VdeeWUURRs2bPj9739//vnn77vvvpdeemlt7rNZs2ZxHG9nA4uF/DjXrGsPP/xwo0aNFi1aFEXR8uXL99lnn7Fjx3722WepVOrhhx9u1apVWVnZwIEDq5f0smXL+vbt26RJk9atWw8ePLj69iVLlmQymaZNmx5wwAFXX311VVXV6aef/t577w0YMCC3aGsafPvtt0877bTGjRt36dJl4cKF2x7h/Pnzp0yZMmrUqLKyshNPPPGMM874y1/+UoePELuvkpKSc845p3v37tls9pNPPkmlUsOGDSsrK+vfv/+OPqW3PNe0WNiZYgqjZcuW99133zd+6swzz7z66qvjOL7++uvPOOOMOI6XL18eRVG7du1mz549f/78Dh06/OAHP8htfOqpp/bv33/58uXz58/v2rXrFVdcEcfxxo0bjz322AsuuODTTz+dN29e165db7755jiOy8vLx44du53BtWvXtmnT5l/+5V8+//zz559/vnHjxqecckpNX8KGDRteeeWV/fbb7/nnny/MgwRx8+bNR48eveUtPXr0uPTSS5ctWxZFUTqdXrVq1UcffbSjT+kvvvgiiqJ33nnHYmHnUs1Cadmy5Vb/g7LHHnvkPjVv3rxmzZrde++9ZWVl8+bNq65mNpvNbTB58uTS0tLVq1dPnTp1r732qqqqyt0+c+bMBg0arF27durUqaWlpStWrNhqp9X/ENQ0WFFRUVZWtmbNmtztP/rRj7bzD0F5eXmjRo1OP/305cuXF+ARgq2rWVlZOXbs2AYNGrz44ou5ak6cODH3qR19SldX02Jh53KFtoC2OtfcuHFj7va2bdsOHTp08ODBN954Y9u2bau3r36vwfHHH79+/fr58+fPnTt3zZo1jRo1yr1X4qSTTtq8efOCBQvefvvtVq1a7bfffjXtuqbBuXPnHnnkkY0bN85t1rFjx+0c/7vvvrtixYq99trrnHPO2UkPCXyDq666KvdEbdGixahRox544IFevXrlPtWmTZtaPqUtFnYu1UzGnDlzoih68803t7yxpKQk98GmTZu+fqdWw4YbN25s27btVv+n861vfaukpCSVSm3n/msa3Gqz6j3WZO+997711lv/+te/Ll26NN+vFf6J6nPNdevWzZkzJ/fOoJxGjRrV8iltsbBzqWYCXnrppaeffnrkyJETJkyoqKiovv2tt97KfTBr1qwmTZoceeSRRx999MKFCxcvXrzVPbRr127RokW5a1Bbqv7XoabB9u3bz5s376uvvsr95+zZs7c9vEmTJpWVlVVVVeX+8/PPP99jjz2aNWtWuy8aaiXvp7TFwk62k670EvpuoC+//LJNmzY33HBD7pWSli1brlq1Kve65oknnrhgwYL333//2GOPHTx4cBzHmzZt6tixY48ePT7++OPFixdff/31rVu3Xrdu3ebNm0844YSLL754+fLlCxcuPP/88y+88MI4jjt16jR8+PBVq1bVNFhVVdWuXbuBAweuWLHi5Zdfbtq06bYv1axdu7Zdu3ZXX311ZWXl3/72t2OOOebyyy+vq4eN3c627wbKyb2umXvhfztroaandPXrmhYLO5dq1t27gaIouuKKK6699trDDjts9erVcRyvXLmydevW11xzTa6at9xyy6GHHrrvvvsOHjx4/fr1ufv56KOPzjvvvL333nufffY566yz3nnnndztCxcuPPvss/fcc8/mzZv3799/5cqVcRz/5je/adKkSZ8+fbYzOH/+/O7du++5557t27cfPHjwN77B4YMPPujZs+c+++zTpk2bYcOGrV27tg4fOXYvgdXc0ad0dTUtFnau1Pa/Ebg2MplMge5517N+/fqJEyd27969adOmSR8L3yybzSayX+uIYpNNaC0Ui7hg0ul03ke1u8327Nkzkf2aLYaVYh2ZrV+z8e7Nu4EAIJRqFoXS0tKkDwGAf041ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAECoVx3FUGJlMpkD3DHUvm80msl/riGKTTWgtFImGBb33ioqK/AbT6XS9nG17d56zH9xcL7/e3Wk2QfXusbKOdu3Z3ZwrtAAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQ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1VcjR44cMmTI448/Xsv7bNasWRzHRx99dE0bWErURDXr2sMPP9yoUaNFixZFUbR8+fJ99tln7Nixn332WSqVevjhh1u1alVWVjZw4MDqRbts2bK+ffs2adKkdevWgwcPrr59yZIlmUymadOmBxxwwNVXX11VVXX66ae/9957AwYMuPzyy7cz+Pbbb5922mmNGzfu0qXLwoULazrOdevWDRw48MQTT6yTRwX+uZKSknPOOad79+7ZbPaTTz5JpVLDhg0rKyvr37//jj7htzzXtJTYIapZ1wYOHNi1a9cRI0ZEUTR8+PATTzxxwIABuU/dc889kyZNmjVr1htvvHHNNdfkbuzTp0/Tpk0//PDDqVOnzpw5c9CgQVEUbdq06eyzzy4tLZ0/f/706dNnz559++23v/rqq+Xl5WPHjh0zZkxNg+vWrevZs2eHDh2WLl06bNiwsWPH1nSct9122//6X//r/PPPr6sHBoJs3LixSZMmuY/ffffdxYsX33HHHXk/4S0ldthWlxDZWVq2bLnVQ73HHnvkPjVv3rxmzZrde++9ZWVl8+bNi+N4+fLlURRls9ncBpMnTy4tLV29evXUqVP32muvqqqq3O0zZ85s0KDB2rVrp06dWlpaumLFiq12mlvqcRzXNFhRUVFWVrZmzZrc7T/60Y9OOeWUbQ/+9ddfP+CAA5YtW3bXXXd95zvfKdiDBP9E8+bNq6/QVlZWjh07tkGDBi+++OKyZcuiKJo4cWLuUzv6hP/iiy+iKHrnnXcsJXaUc826e11z48aNudvbtm07dOjQwYMH33jjjW3btq3evvrdBMcff/z69evnz58/d+7cNWvWNGrUKPduiJNOOmnz5s0LFix4++23W7Vqtd9++9W065oG586de+SRRzZu3Di3WceOHbed3bBhww9+8IORI0cedNBBO/shgR121VVX5Z7GLVq0GDVq1AMPPNCrV6/cp9q0aVPLJ7ylxI5SzWTMmTMniqI333xzyxtLSkpyH2zatCmKooYNG27cuLFt27Zb/Z/Ot771rZKSklQqtZ37r2lwq82q97il4cOHt2rV6vvf//7O+EKhtqrPNdetWzdnzpwrr7yy+lONGjWq5RPeUmJHqWYCXnrppaeffnrkyJETJkyoqKiovv2tt97KfTBr1qwmTZoceeSRRx999MKFCxcvXrzVPbRr127RokW5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"
            },
            {
              "type": "input_text",
              "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
            }
          ],
          "solved_count": 0,
          "total_training_examples": 4,
          "pixel_accuracy": 0.7599309153713298
        },
        "test_result": {
          "correct": false,
          "pixel_accuracy": 0.0,
          "total_pixels": 224,
          "correct_pixels": 0,
          "error": "Grid height mismatch"
        },
        "status": "failed_test",
        "feedback_sent": true
      },
      {
        "turn_number": 8,
        "timestamp": "2025-07-10T10:43:52.056315",
        "input_tokens": 51648,
        "output_tokens": 1779,
        "turn_cost": 0.0235056,
        "program_extracted": true,
        "program": "def transform(grid):\n    import numpy as np\n    from scipy.ndimage import label\n\n    arr = np.array(grid)\n    target_size = 11\n\n    norm = np.zeros((target_size, target_size), dtype=int)\n    norm[:arr.shape[0], :arr.shape[1]] = arr[:target_size, :target_size]\n    arr = norm\n\n    output = np.zeros_like(arr)\n    blue_color = 1\n    output[arr == blue_color] = blue_color\n\n    quadrants = {\n        'TL': (0, 5, 0, 5),\n        'TR': (0, 5, 6, 10),\n        'BL': (6, 10, 0, 5),\n        'BR': (6, 10, 6, 10)\n    }\n    quadrant_map = {'TL': 'TR', 'TR': 'BL', 'BL': 'BR', 'BR': 'TL'}\n\n    def get_quadrant(r, c):\n        for q, (rs, re, cs, ce) in quadrants.items():\n            if rs <= r <= re and cs <= c <= ce:\n                return q\n        return None\n\n    colors = set(np.unique(arr))\n    colors.discard(0)\n    colors.discard(blue_color)\n\n    for color in colors:\n        mask = (arr == color)\n        if not np.any(mask):\n            continue\n\n        labeled, num_features = label(mask)\n        for comp_id in range(1, num_features + 1):\n            comp_mask = (labeled == comp_id)\n            rows, cols = np.where(comp_mask)\n            min_r, max_r = rows.min(), rows.max()\n            min_c, max_c = cols.min(), cols.max()\n\n            # Copy original pixels\n            output[rows, cols] = color\n\n            centroid_r = int(round(rows.mean()))\n            centroid_c = int(round(cols.mean()))\n            orig_quad = get_quadrant(centroid_r, centroid_c)\n            target_quad = quadrant_map[orig_quad]\n\n            r_start, r_end, c_start, c_end = quadrants[target_quad]\n            cluster_height = max_r - min_r + 1\n            cluster_width = max_c - min_c + 1\n\n            orig_r_start, orig_r_end, orig_c_start, orig_c_end = quadrants[orig_quad]\n            offset_r = min_r - orig_r_start\n            offset_c = min_c - orig_c_start\n\n            new_min_r = r_start + offset_r\n            new_min_c = c_start + offset_c\n\n            if new_min_r < r_start:\n                new_min_r = r_start\n            if new_min_c < c_start:\n                new_min_c = c_start\n            if new_min_r + cluster_height - 1 > r_end:\n                new_min_r = r_end - cluster_height + 1\n            if new_min_c + cluster_width - 1 > c_end:\n                new_min_c = c_end - cluster_width + 1\n\n            for r, c in zip(rows, cols):\n                rr = new_min_r + (r - min_r)\n                cc = new_min_c + (c - min_c)\n                if 0 <= rr < target_size and 0 <= cc < target_size:\n                    if output[rr, cc] != blue_color:\n                        output[rr, cc] = color\n\n    return output.tolist()",
        "training_feedback": {
          "feedback_messages": [
            {
              "type": "input_text",
              "text": "Training results: 0/4 examples solved, 0.0% pixel accuracy - Keep experimenting! Try a different approach to the transformation.\n\nTraining Example 1 \u2717:\nExpected: [[1, 1, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 1, 1, 1, 0, 3, 3, 3, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 1, 1, 1, 0, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nError: Traceback (most recent call last):\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmp54_5x7ym.py\", line 115, in <module>\n    output = transform(test_input)\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmp54_5x7ym.py\", line 31, in transform\n    from scipy.ndimage import label\nModuleNotFoundError: No module named 'scipy'\n\n\nTraining Example 2 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 1, 0, 0, 0, 0, 0, 0, 6, 0], [0, 1, 1, 1, 1, 0, 0, 6, 6, 6, 6], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nError: Traceback (most recent call last):\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmpnv61in4k.py\", line 115, in <module>\n    output = transform(test_input)\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmpnv61in4k.py\", line 31, in transform\n    from scipy.ndimage import label\nModuleNotFoundError: No module named 'scipy'\n\n\nTraining Example 3 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nError: Traceback (most recent call last):\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmppz4nnhu4.py\", line 115, in <module>\n    output = transform(test_input)\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmppz4nnhu4.py\", line 31, in transform\n    from scipy.ndimage import label\nModuleNotFoundError: No module named 'scipy'\n\n\nTraining Example 4 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nError: Traceback (most recent call last):\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmp7qh6j3bs.py\", line 115, in <module>\n    output = transform(test_input)\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmp7qh6j3bs.py\", line 31, in transform\n    from scipy.ndimage import label\nModuleNotFoundError: No module named 'scipy'\n\n\n"
            },
            {
              "type": "input_image",
              "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZ8AAATYCAIAAABP5V2wAABAW0lEQVR4nO3de1hU9b748e+ogCgISm4vXColsB68IKloaF54noOYOii6Lc0NalqmqbhNK7PTeSTdG4/uLk+eTt5yk1t3ngAr9aAn87KLsnTn3QiokJQQBSRwuK3fU9OeH3FrgBlm5jPv19MftFjfmcWs4e1as4b56jRNUwAgTjtbbwAAWAV1AyATdQMgE3UDIBN1AyATdQMgE3UDIBN1AyATdQMgE3UDIBN1AyATdQMgE3UDIFOr6rZo0SJd42bNmtXgOq6urj179pw0adKpU6fq3+ahQ4d0Ol23bt1u375d51t79+7V6XRbtmwx/m9cXJxOp0tKSqqz2pUrV3Q63erVq1szyuj27dtvvPHGmDFjevfu7ebm1rt372nTph0/fryJx2T16tWNPSDnzp1r+kGLjIz8zQfWtM68efNqLzdu3tSpUz/55JPa26PX6+usdvfddz/11FM3b95s1oNvdP369bVr14aGhnp5eXXu3Hno0KFbtmyp/TEzxrurM/yLL77o3r27p6fnkSNHmnjoAIc/dqusrMzPz3/vvffGjBmTnZ1d57vbtm1TSt28eXPPnj3m3NqaNWsuXbrU3G0wZ9Q333wzfPjwxx9//KOPPrp69WpFRcXVq1f37t07atSojRs3Kjtj3Lx33303IiLi7bffbmK1b7755tVXX42KiqqpqWnWg//JJ58MHDjw+eef/+c//1lSUlJWVnby5MnHHnts7ty5TWzYhx9+OGbMmOrq6sOHD48ZM6YVPyLQhnV77bXXtH955513lFLbt283LUlOTjatmZOTY1p++/btixcvPvLIIyUlJZs3b659g0VFRampqdOmTevWrdt//dd/mbMNFRUVcXFx1dXVzdry3xxVWVkZGxv7z3/+c8SIEfv27bt+/XplZeV33333+uuvd+vW7emnnzYeiDXm9OnTWj0hISENPiAmhw8frn0j5qxz9epV4/Ly8vKvv/561apVmqbNmTPn22+/rb1aeXl57Qc/MjLys88+O3TokPkP/g8//BATE/P9998//PDDGRkZJSUlN27cSE1N7dOnz/bt2994440GH4eUlJTo6OhOnTp99NFHw4YNa+IRAyQcu7m5ufXr1+9Pf/qTUqrOsduuXbtu3769YMGC+Pj4jIyMM2fO/OatLV68+NNPP/3P//zPZm3Db4566623vvjii8jIyGPHjk2cONHHx6dDhw7+/v5PPPHEu+++W11d/be//U3Zk44dO/bt23fdunVr1qypqKj4y1/+0sSDv3TpUmMZzX/wN27cmJ+fv2zZsl27dg0bNszT07Nr166TJ08+evRo586dN27cWP9jULdu3Tpt2rTf/e53x48fHzBggGn5jh07dDrda6+9ZtEHALCDuhkMhvPnzyckJCilgoKCan9r+/bt995779ixY5944on27dubc/j20ksvBQYGrlmz5uLFi+Zvw2+O2rVrl06n++///u/27dvX+daDDz544cKFtWvXKru0fPnyTp06/e///m+D362srPzqq69eeeWVDh06PPjgg+Y/+H//+9/d3d3/4z/+o84N+vn5nThx4qOPPtLpdLWX//nPf543b16fPn1OnDhxzz33WO7nA+ysbnfffbfphe2OHTuGhIS88847d9xxx5IlS0zrnDt37vPPP1+xYoVOp+vbt++0adPefvvt0tLSpm+5U6dO27dvr6ysbNb56W+OOn369L333nv33Xc3OPzee++t88tcR2hoaJ2rASdOnGjsATH56KOPmrtOfZ6envfcc0+dg2J3d3fjcFdX1+Dg4H/84x9vvfVW7Z+u6Qe/srLym2++GTp0qIeHR/17HDRoUK9evWovefrpp1euXKmUGjlyZEBAQJ314+LiNE1btGhR0z8I4JDvCPH19Z0zZ86XX37Zs2dP08Jt27b5+vrOnDnT+L/PPPPMrVu3zDkBjIiIeOqppz777LMNGzaYvw1NjKqsrCwqKurRo0fthXWuY951113KXvn4+Bh+1tgK1dXVGRkZlZWVZj74RUVFmqb5+PiYuQGvvvrq8OHDIyMjt23b9u6777bupwHsu27GF8grKip2795tPLhYv3597969TStUVlYmJyfn5eW5ubkZ8zFw4EBN08y8tvDSSy/dc889L7zwwoULF8zfqsZGubi4eHp6FhQUqJaqf1UhIiLiN68YjB49urnrNOjmzZsuLi5ubm71rypUVFRkZ2c/+eSTr7766h//+EczH/xu3bq1a9fO/AckPj7+o48+2rlzZ7du3R577LG8vDwzBwKOeuzm4uLy+9//fs+ePUePHo2Kiqr9rqj333+/wV+eU6dOnTx58jdv2d3dvQXnp02M6t+//4UL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EwPPnz8/cuRId3f3ESNG5OTk1N/CkydPZmdnb9y4sWvXroGBgS+88EJaWpqmaW34IDmX2jui9rGbObvY1ttu3+ocXMBSfH196x+7GY0dO3bhwoWapi1ZsmTMmDGaphUUFCilgoKCzp49m5WVNXDgwDlz5hhXHj58eFxcXEFBQVZWVkRExIIFCzRNq6qq6t+///Tp0/Pz8zMzMyMiIlauXKlpWnBw8Pbt25sYWF5eHhAQ8OSTT964cWPfvn3u7u7Dhg1r+gd54403/Pz8LP3w4P+rvSNu3ryplLp48aKZu9jW227XqJu1+Pr61vmHpH379sZvZWZment7b9y40cvLKzMz01S3lJQU4wrp6emurq6lpaVHjx7t1KmTwWAwLj958mS7du3Ky8uPHj3q6upaWFhY505NT/3GBqampnp5eZWVlRmXz58/v+m6FRUV3X333S+88IKlHx78imlHmOpm5i620fY6Bs5MrajOsVtVVZVxeWBg4IoVKxISEpYvXx4YGGha3/QC/6BBgyoqKrKysi5cuFBWVubm5ma8KDFkyJCamprs7Ozz58/7+fl169atsbtubOCFCxf69u3r7u5uXC00NLSJ7f/xxx8nTpwYEhKyevVqCz0kaFj9HWHmLrb+pjkw6mYb586dU0qdOnWq9kIXFxfjF9XV1UqpDh06VFVVBQYG1vkX6b777nNxcdHpdE3cfmMD66xmusf6CgsLx40b5+fnt3fv3g4dOrTux8VvqL8jzNzFVt4ux0bdbODAgQN79uxJSkpKS0tLTU01LT9z5ozxi9OnT3t4ePTt27dfv345OTlXrlypcwtBQUG5ubnGs5jaTL8PjQ0MCQnJzMz88ccfjf979uzZBrfwypUrERERo0aNevvtt11dXVv34+K31d8RZu7ittpAx2T9k18n1dhVhVu3bgUEBCxdutT4aouvr29JSYnxdbf7778/Ozv7q6++6t+/f0JCgqZp1dXVoaGhkZGR33333ZUrV5YsWeLv73/79u2amprBgwfPnDmzoKAgJydnypQpM2bM0DQtLCwsMTGxpKSksYEGgyEoKGju3LmFhYWHDh3y9PSs/7rbzZs377nnnqeffrqtHipnV3tHmF53M3MX23rb7Rp1a7urCkqpBQsWLF68+K677iotLdU0rbi42N/ff9GiRca6rVq16s477+zatWtCQkJFRYXx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"
            },
            {
              "type": "input_text",
              "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
            }
          ],
          "solved_count": 0,
          "total_training_examples": 4,
          "pixel_accuracy": 0.0
        },
        "test_result": {
          "execution_error": "Traceback (most recent call last):\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmpybrub6iv.py\", line 115, in <module>\n    output = transform(test_input)\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmpybrub6iv.py\", line 31, in transform\n    from scipy.ndimage import label\nModuleNotFoundError: No module named 'scipy'\n",
          "timed_out": false,
          "predicted_output": null
        },
        "status": "failed_test"
      }
    ],
    "total_turns": 8,
    "conversation_history": [
      {
        "role": "system",
        "content": "You are an expert at solving abstract reasoning puzzles. Write clean, efficient Python code."
      },
      {
        "role": "user",
        "content": [
          {
            "type": "input_text",
            "text": "You are solving an ARC (Abstraction and Reasoning Corpus) task. \nI will show you training examples with input and output grids, plus a test input grid. Your task is to:\n\n1. **Analyze the training examples** to discover patterns that map input grids to output grids\n2. **Write a Python program** that implements your best understanding of the transformation  \n3. **DO NOT predict or generate the test output** - your job is only to write the transformation program\n4. **Attempt a solution** - even if the pattern isn't completely clear, provide your best hypothesis\n5. **Do not repeat the same transformation** - if you have already tried a transformation, do not repeat it.\n\n**IMPORTANT: Your transformation must always produce a 11\u00d711 output grid.**\n\nThe test input is shown for context so you understand what type of grid your program will eventually process. Focus on learning patterns from training examples and writing code that captures your understanding.\n\nTraining Examples:\n\nExample 1:\nInput:\n1 1 0 0 0 0 0 0 0 0 0\n0 1 1 1 0 0 0 0 0 0 0\n0 1 0 0 0 0 0 3 0 0 0\n0 1 1 1 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n8 0 0 0 0 0 0 0 0 0 0\nOutput:\n1 1 0 0 0 0 0 3 3 0 0\n0 1 1 1 0 3 3 3 0 0 0\n0 1 0 0 0 0 0 3 0 0 0\n0 1 1 1 0 3 3 3 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 8 8 8 0 0 0 0 0 0 0\n0 8 0 0 0 0 0 0 0 0 0\n0 8 8 8 0 0 0 0 0 0 0\n8 8 0 0 0 0 0 0 0 0 0\n\nExample 2:\nInput:\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 1 1 0 0 0 0 0 0 0 0\n0 0 1 0 0 0 0 0 0 6 0\n0 1 1 1 1 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\nOutput:\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 1 1 0 0 0 0 0 0 6 6\n0 0 1 0 0 0 0 0 0 6 0\n0 1 1 1 1 0 0 6 6 6 6\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n\nExample 3:\nInput:\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 1 0 0 0 0 0 0 0\n0 0 1 0 1 0 0 0 0 0 0 0\n0 0 1 1 1 1 1 0 0 0 0 0\n0 0 0 1 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 2 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\nOutput:\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 1 0 0 0 0 0 0 0\n0 0 1 0 1 0 0 0 0 0 0 0\n0 0 1 1 1 1 1 0 0 0 0 0\n0 0 0 1 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 2 0 0 0 0 0 0 0 0\n0 0 2 2 2 2 2 0 0 0 0 0\n0 0 2 0 2 0 0 0 0 0 0 0\n0 0 0 0 2 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n\nExample 4:\nInput:\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 1 1 0 0 0 0 0 0 0 0\n0 0 1 0 0 0 0 0 0 0 0 2 0\n0 0 0 1 1 0 0 0 0 0 0 0 0\n0 0 0 0 1 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 8 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\nOutput:\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 1 1 0 0 0 0 2 2 0 0\n0 0 1 0 0 0 0 0 0 0 0 2 0\n0 0 0 1 1 0 0 0 0 2 2 0 0\n0 0 0 0 1 0 0 0 0 2 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 8 0 0 0 0 0 0 0 0\n0 0 0 8 8 0 0 0 0 0 0 0 0\n0 0 8 0 0 0 0 0 0 0 0 0 0\n0 0 0 8 8 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n\nTest Input:\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 1 0 0 0 0 0 0 0 3 0 0 0 0\n0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0\n1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\nAnalyze the patterns in the training examples and write a Python function that performs this transformation.\n\n**Approach Guidelines:**\n- Look for patterns in shapes, colors, positions, sizes, rotations, reflections, etc.\n- Even if you can't solve all training examples perfectly, implement what patterns you do observe\n- A partial solution that captures some aspects is better than returning the input unchanged\n- If the pattern is unclear, make your best educated guess based on what you can see\n\nRequirements:\n- The function takes a 2D list (grid) where grid[row][col] gives the value at that position\n- Values are integers from 0-9\n- Return a new grid (2D list) with the transformation applied\n- You can use numpy if needed - just add 'import numpy as np' at the start of your function\n- Aim to handle the training examples as well as possible, even if not perfectly\n- Your function should attempt some meaningful transformation based on the patterns you observe\n\nYou MUST end your response with the following exact format:\n\nFinal answer:\n```python\ndef transform(grid):\n    # Your transformation logic here (implement your best understanding)\n    return transformed_grid\n```\n"
          },
          {
            "type": "input_image",
            "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAmwAAAYxCAIAAACLqFdIAABG/klEQVR4nO3de5hU9Zng8VPaXOQiSJzxgpGmIYskJGiI1xgvAeOMiXpqgjFRd20ULzMSw3qBJI+aXRMvgDPZxNtgUDTBmKjrqWec8LgTzEM0u2NClGgEW8CggpAoCN6xGzj7zPRsL4KS5q1uqk/z+Tz+0Zyut86vqv311zpdjaU8zxMAYMftFpgBAEQUAOJEFACCRBQAgkQUAIJEFACCRBQAgkQUAIJEFACCRBQAgkQUAIJEFACCRBQAahHRSZMmlT7YWWed9b636dmz57777nvKKac88cQT297nz3/+81KpNGjQoA0bNmz1qfvvv79UKs2aNav1j42NjaVSacaMGVvdbOXKlaVS6YorrqhmqtWGDRtmzpx5/PHH77///r169dp///1PO+20Rx99NPacjBs3LkmStWvX7r///nvttdfKlSu3mv2bv/mbnj17/va3v23nE/LlL3+5VCrV1dW98sor265k1KhRpVKpsbGx9Y8TJ07ccjG77777nnvuefjhh99+++1tI2malkqlbU/UzofWas2aNVOmTDnooIP22GOPgQMHHnXUUbfeeuumTZu286QBFFQNXom2tLT86U9/evDBB48//vg//OEPW332jjvuSJJk3bp1P/3pT9tzb1dddVVTU9OOrqE9U88///yRRx554YUXzp8/f/Xq1c3NzatXr77//vuPOeaYf/iHf0iiPvShD91xxx3r16+fMGHClv8fuptvvjnLsmuvvfZTn/rUDj0hmzZteuCBB7Y6+Pvf/37RokXbWcbmzZvfeOON3/zmNxMnTpw+fXrSQV555ZVDDz10xowZzz777IYNG1577bV//dd//bu/+7vTTjvN/3QP6H6qiuhNN92U/z/33XdfkiSzZ89uOzJnzpy2Wy5fvrzt+IYNG5555pkzzjjj9ddfv/XWW7e8w/Xr11cqldNOO23QoEH/+I//2J41NDc3NzY27ugLnT871dLSMn78+N/97ndHHXXUP/3TP61Zs6alpeXFF1+85ZZbBg0aNGXKlKeffno797/l420zb9681s/+1V/91UUXXTRv3rybbrqp9ciTTz556aWXfu5zn7v00kt36AnZfffdR4wYce+99251/Cc/+cnHPvaxbW+/evXq1sVs3rz5zTff/PGPf9y7d+9rrrnm3Xff3e4T1t6H9v3vf//5558fP378k08++dZbb61fv/4Xv/jFIYcckmXZgw8+2M5TABRFDV6J9urV66CDDpo2bVqSJFu9Ev3xj3+8YcOGCy64YMKECY899thTTz31Z+/tq1/96q9//eu///u/36E1/Nmpu+666/HHHx83btwjjzxy8sknf+hDH6qrq/vwhz/8t3/7tw888MCmTZvuueeepAozZsw46KCDpk6d+uyzz7755ptf+tKXBgwY8MMf/rBUKu3oE/KlL33pl7/85csvv7zlwZ/+9Kenn376dhZQKpX69u37la985ctf/vLrr7++ZMmSpCM0NTXV1dXNmTPnE5/4RJ8+fQYMGHD88ce3vlB+6KGHWm9z5513lkqltv+AACiuGkT03XffXbRo0SWXXJIkyX/6T/9py0/Nnj175MiRn/3sZ//2b/929913b8+L0WuvvXb48OFXXXXVM8880/41/NmpH//4x6VS6bbbbtt99923+tSxxx67ePHi73znO0kV9thjj7vvvnvjxo1nnXXWhRdeuHTp0h/+8If77LPPVjdrzxPypS99aasrur/5zW+ee+65L33pS+1ZSetr0G0fZszo0aM3btyYZdmWB+vr6/M8v+WWWzrkFAC7XESHDh3a9iaU3r17jxo16r777tt7772/9rWvtd3m6aef/u1vf3v55ZeXSqVhw4addtppd99995tvvrn9e+7Tp8/s2bNbWlp26KLun51auHDhyJEjhw4d+r7jI0eO3Ool43Yeb5v58+dveZtPfvKT/+2//bff/va3d9999yWXXHLiiSdudSftfEJGjRr10Y9+tPVyequf/OQnn/rUp4YNG7adFW7atGnVqlXf+9737r333r/8y78cMWLEdm7c/oc2efLko48++itf+UpDQ8PEiRNvu+22bX8029jYmOf5pEmT2nlGgC6rNr/iMnjw4HPOOefJJ5/cd9992w7ecccdgwcPPvPMM1v/+I1vfOONN95oz1XTo48++uKLL/7Nb35zww03tH8N25lqaWlZv379Vq8Lt3pvan19fVK1U089tTXGRx999Lafbf8TsuUV3TzP77333g+6lrvffvu1rr+urm7w4MGTJ0/etGnTtdde21GvRPv16zd//vw5c+aMHj26UqlccMEFo0aNGjp06F133dUh9w+wK0a09d0ozc3NP/nJT/r37/+Rj3zk+uuv33///dtu0NLSMmfOnJdeeqlXr16t3+VHjx6d53k731507bXXfuQjH/nWt761ePHi9q/qg6Z69OjRv3//9/29kWrefXPcccdteZsNGzacccYZAwYM6N+//wUXXLDVDzV36Ak5/fTT267oPvLII6tWrfqz13J32223QYMGjR07tlKpnHvuuR340Hbfffczzzwzy7I1a9YsXbp09uzZ++yzT2Nj43e/+932nwWgEHbqK9EePXqcfvrpP/3pT3/5y1/+1V/91Za/j/jP//zP7xutJ554YsGCBX/2nvfYY4/ARd3tTH384x9fvHjxiy+++L5vRR4zZkxStcmTJz/11FPf/3cvv/zyOeecs+Vnd+gJOeiggz7+8Y+3vkf3pz/96RFHHHHggQe+70nb3p27adOmtWvXzps379RTT006zfDhwxsbG3/1q18dcsghVf4UGaALqsHl3L/+67/+6le/+sQTT1x22WVtB++4447evXu/9tprW76++T//5/8kSTJz5sz23O2nP/3pr33tawsWLNj2L1IITJ155pmbN2/+u7/7u/dNcvW/8njffffNnDnzjDPO+M//+T83NjZ+8Ytf/NnPfrblL/zs6BNy+umnP/LII62/ybr99+V2npdeeqlUKk2cOHGr43V1dR//+MfXr1/f3Nxck4UBdKufiV577bUHHnjgrbfe+utf/zpJkj/+8Y8PPfTQySefvOeee255syOPPHLEiBH33HPPa6+91p67veaaaz7ykY/s6LtA33dq4sSJY8aM+dnPfnbYYYfde++9f/zjH1taWloT9fnPf/6JJ57Ybbf4U7d8+fLzzjtv6NChbdWcOXPmfvvtd+mll7b+FRCBJ6T1iu7kyZPXrFlz2mmnJbUwePDgT37yk3fcccekSZP+9V//9U9/+tOGDRuee+65W2655b777jvssMN69uxZk4UBdKuI9u3b98Ybb9y8efMFF1ywcePGH/7whxs3bmx7B82Wzj777LfffvtHP/pR+y/Pbv99s+2c6tmzZ6VSOfLII5944onTTz99v/3269mzZ+tf+zd37twRI0Zs/y9Uet+3sJZKpTfffLOlpeX0009/66237r777rZGfuhDH7rzzjs3bNhw5plntrS0BJ6Q4cOHH3LIIffee+9nPvOZLX/YHLDHHntstew777yzPQ+t9QX0wIEDb7755qOOOmrffffdY489hg8fftFFF9XV1bX9YqjfEwW6jZr9BfSnnHJKmqZPPvnk//gf/+POO+/ca6+9/vqv/3rbm/2X//Jfdtttt3Ze0W29PDt58uQdXcz7Th1wwAGPPvronDlzTjrppAMOOKBnz5777LPPSSeddNdddz399NOHHnpoEvL1r399wYIF3/rWt4488sgtj3/uc5+bNGnSE088ccUVV8SekNaruO389dBOMnr06EWLFl166aWjRo3ac889e/bsWV9ff/755//+97/vkB8kA3QpJX+jKQDE+F+hAUCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIsrW1a9c2NTXVehXQrbaGbdVdiWixpWna2NjYsfc5bty4xx577IM+u379+oaGhu3cALq+FStWnHfeeYMHD+7du3dDQ8Nll1326quvVrk1qpm1rYpLRNnaO++880GfWrFixbhx45YvX75zVwQdacmSJWPGjFm3bt3cuXNfffXVBx544JlnnhkzZszq1avDW+PPsq26KxHtJtasWVMqlW6++eb6+vrevXufeOKJL730Utvx22+//YADDhgwYMC5557buplXrlxZKpWef/751vEbbrjhiCOOSJLkuOOOe/bZZydMmDBx4sStTvGzn/1s1KhRY8aMqcXjgw4zceLEY4899v777x89enSfPn0OPvjgBx98cN9997344ovbuTVsK9qIaLdy1113Pfzww01NTatWrbr66qvbjk+fPv2hhx5auHDh448/PmnSpO3cw/z580eMGDF79uxZs2Zt9alevXrNmzfv5ptv7rTlQ6d74YUXHn300a12wW677TZ58uRKpbJu3br2bw3bChHtbq688sphw4bV19c3NjYuWLCg7fi0adNGjRrV0NAwY8aMOXPmvPXWW4E7Hzdu3KGHHtqh64WdbfHixUmSjBw5cqvjo0eP3rhx47Jly9p/V7YVItrd1NfXt37Qt2/flpaWtuOt15SSJDn44IObm5ufe+65Gi0QaqxUKiVJsmnTpq2Ov/vuuzt6V7YV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3/Z46/eOurq6rS4Zbfs95X2tXbt27NixBxxwwP33319XV9dxC4edpPU1aOvr0S01NTXV1dUNHz68/VvDtkJEdxVPPfVU6wcLFy7s16/fsGHDWn8M03YB6sUXX2y78Qf9SGblypVHH330Mcccc/fdd7f9FAeKZciQIWPHjr3++uu3PLh58+bp06efcsope+21V/u3hm2FiO4qpkyZsnz58qVLl06dOvX888/v1avX3nvvPXTo0JkzZ7799tvz5s2755572m7ct2/fVatWvfHGG1vew/r16z/72c+ecsop06dP98YHCu22225btGjRWWedtWTJkpaWlsWLF48fP/7ll1++8cYbkyRp/9awrfg3//+NuhT/V1yeeeaZ1uO33nrrxz72sbbjX//614cMGbLXXntdcsklzc3Nrbd5+OGHR44c2atXr2OOOabtvfh5nv/gBz/o16/fF7/4xS1PdN111237L88bb7yx0x8xdIDVq1dfdNFFBx54YK9everr6ydPnrxmzZq2z/7ZrWFb0aa05U/OiqJcLtd6CYXR3Nw8d+7csWPH9u/fv9Zr6c6yLEuKxj4Ks606SVbAfVTIV6JpmoYf7642e9JJJ9XkvLvabF5ARXyezXbv2byA/EwUAIJEtJvzfj+AziOiABAkogAQJKIAECSiABAkogAQJKIAECSiABAkogAQJKIAECSiABAkogAQJKIAECSiABAkogAQJKIAECSiABBUyvM8KZpyuVzrJcB7ZFmWFI19RFeTFXAfJXkBpWkafrxmzXbGbF5ARXyezXbv2byAXM4FgCARBYAgEQWAIBEFgCARBYAgEQWAIBEFgCARBYAgEQWAIBEFgCARBYAgEQWAIBEFgCARBYAgEQWAIBEFgCARBYAgEQWAoFKe50nRlMvlWi8B3iPLsqRo7CO6mqyA+yjJCyhN0/DjNWu2M2bzAiri82y2e8/mBeRyLgAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASV8jxPiqZcLtd6CfAeWZYlRWMf0dVkBdxHSV5AaZqGH69Zs50xmxdQEZ9ns917Ni8gl3MBIEhEASBIRAEgSEQBIEhEASBIRAEgSEQBIEhEASBIRAEgSEQBIEhEASBIRAEgSEQBIEhEASBI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0Rs3bly2bFn778qW3EWIaMHU19e3ftC3b9+Wlpa240cccUTrBwcffHBzc/Nzzz0XPkVTU9PatWv79OnzhS98oer1QpGUSqUkSTZt2rTV8XfffXdH78qW3EWIaMH06NGj7eM8z7c93rr/6+rqWr8dtNn2+8J29O3b94orrvj1r3+9atWqjlg1FEPra9DW16NbampqqqurGz58ePu3lS25ixDRbuKpp55q/WDhwoX9+vUbNmxYz549kyRpu4j04osvtt14q83c6qGHHhowYEDbf3G/+uqru++++8CBA3fK8qFLGDJkyNixY6+//votD27evHn69OmnnHLKXnvt1f5tZUvuIkS0m5gyZcry5cuXLl06derU888/v1evXnvvvffQoUNnzpz59ttvz5s375577mm7cd++fVetWvXGG29seQ/HHXfcvvvue8kll7z22mtPPfXU5ZdfPmHChD59+tTi0UDN3HbbbYsWLTrrrLOWLFnS0tKyePHi8ePHv/zyyzfeeGOSJO3fVrbkrqLWbw9mx37F5Zlnnmk9fuutt37sYx9rO/71r399yJAhe+211yWXXNLc3Nx6m4cffnjkyJG9evU65phj2t5Pn+f5D37wg379+n3xi1/c6lzLli076aST9txzzwMPPPAb3/jGO++8s3MfK3QJq1evvuiiiw488MBevXrV19dPnjy57fdM2rOtbMldSmnLn6vtTN6r3VGam5vnzp07duzY/v3713otu64sy5KisQc7iS25a+3BWtU7TdPwms2a7WqzeQEV8Xk2a/aD1Gof+ZkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABJXyPE9qoVwu1+S80BmyLEuKxh6kO8lqtAfrktqpVCqxwTRNCzk7fFpwdtnUQj7eXWm2oAr3PNuDZrsal3MBIEhEASBIRAEgSEQBIEhEASBIRAEgSEQBIEhEASBIRAEgSEQBIEhEASBIRAEgSEQBIEhEASBIRAEgSEQBIEhEASBIRAEgqJTneVIL5XK5JueFzpBlWVI09iDdSVajPViX1E6lUokNpmla1ezwacHZZVMLeV6znT9bUPbgTjqv2e67B13OBYAgEQWAIBEFgCARBYAgEQWAIBEFgCARBYAgEQWAIBEFgCARBYAgEQWAIBEFgCARBYAgEQWAIBEFgCARBYAgEQWAIBEFgKBSnudJLZTL5ZqcFzpDlmVJ0diDdCdZjfZgXVI7lUolNpimaVWzw6cFZ5dN3eVma/U1KtpsQdmDBZgt2l5Id7E96HIuAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABJXyPE9qoVwu1+S80BmyLEuKxh6kO8lqtAfrktqpVCqxwTRNazY7fFpwdtnUQj5es91a4Z5ne9BsV+NyLgAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASV8jxPaqFcLtfkvNAZsixLisYepDvJarUH8xpJ0zS8ZrNmu9rsTts4HXiuIj7PZs1+kLxGXM6FgimVSrVeAvAfRBSKR0ehixBRAAgSUSgkL0ahK6ir9QJgVxfOYetgrd5gD3glCgBxIgoAQS7nQo3t0PXYLa/9upALNeeVKBSSgkJXIKIAECSiUDxehkIXIaJQMAoKXYeIQpEoKHQpIgoAQSIKAEEiCgBBIgoAQSIKAEGlWr3Zr1wu1+S80BmyLEuKxh6kO8lqtQfzGknTNLxms2a72mxeQEV8ns2a/SC12kcu5wJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkBQKc/zpBbK5XJNzgudIcuypGjsQbqTrFZ7MK+RNE3DazZrtqvN5gVUxOc5TdP8+MNi/xT08Zptp1rtI5dzASBIRAEgSEQBIEhEASBIRAEgSEQBIEhEASBIRAEgSEQBIEhEASBIRAEgSEQBIEhEASBIRAEgSEQBIEhEASBIRAEgSEQBIKiU53lSC+VyuSbnhc6QZVlSNPYg3UlWoz1Yl9ROpVKJDaZpuqvNZq+tis2WB+xfxMdbuNmCKuK/z7vabOH2QrqL7UGXcwEgSEQBIEhEASBIRAEgSEQBIEhEASBIRAEgSEQBIEhEASBIRAEgSEQBIEhEASBIRAEgSEQBIEhEASBIRAEgSEQBIEhEASColOd5Ugvlcrkm54XOkGVZUjT2IN1JVqM9WJfUTqVSiQ2maWrWbJeaLahaPc/Za6tis+UB+xfxvGa78R50ORcAgkQUAIJEFACCRBQAgkQUAIJEFACCRBQAgkQUAIJEFACCRBQAgkQUAIJEFACCRBQAgkQUAIJEFACCRBQAgkQUAIJEFACCSnmeR2erUi6Xa3Je6AxZliVFYw/SnWS12oN5jaRpGl6zWbNdbTYvoCI+z1XO5scfFvunoI93l5rNa8TlXAAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgq5Xme1EK5XK7JeaEzZFmWFI09SHeS1WoP5jWSpml4zWbNdrXZvICK+DybNftBarWPXM4FgCARBYAgEQWAIBEFgCARBYAgEQWAIBEFgCARBYAgEQWAIBEFgCARBYAgEQWAIBEFgCARBYAgEQWAIBEFgCARBYAgEQWAoFKe59FZANileSUKAEEiCgBBIgoAQSIKAEEiCgBBIgoAQSIKAEEiCgBBIgoAQSIKAEEiCgBBIgoAQSIKAEEiCgBBIgoAQSIKAEEiCgBBIgoAQSIKAEEiCgBBIgoAQSIKAEEiCgBBIgoAQSIKAEEiCgBBIgoAQSIKAEEiCgBBIgoAQSIKAEEiCgBBIgoAQSIKAEEiCgBBIgoAQSIKAEEiCgBBIgoAQSIKAEEiCgBBIgoAQSIKAEEi2j2tXbu2qamp1qsAOmBL2s5dmYjWXpqmjY2NHXuf48aNe+yxx7Zzg0mTJh133HEde1LYFaxYseK8884bPHhw7969GxoaLrvssldffbX6LVnNrO1cQyLaPb3zzjvb+eyvfvWrW265ZScuB7qJJUuWjBkzZt26dXPnzn311VcfeOCBZ555ZsyYMatXr65mS1YzazvXloh2IWvWrCmVSjfffHN9fX3v3r1PPPHEl156qe347bfffsABBwwYMODcc89t3VQrV64slUrPP/986/gNN9xwxBFHJEly3HHHPfvssxMmTJg4ceK2Z9mwYcO55577qU99aqc/Pii8iRMnHnvssffff//o0aP79Olz8MEHP/jgg/vuu+/FF1/czi1pO3czItrl3HXXXQ8//HBTU9OqVauuvvrqtuPTp09/6KGHFi5c+Pjjj0+aNGk79zB//vwRI0bMnj171qxZ2372qquu+tjHPvY3f/M3nbN86LZeeOGFRx99dKvdt9tuu02ePLlSqaxbt679W9J27jZEtMu58sorhw0bVl9f39jYuGDBgrbj06ZNGzVqVENDw4wZM+bMmfPWW28F7nzBggV33nmniz8QsHjx4iRJRo4cudXx0aNHb9y4cdmyZe2/K9u52xDRLqe+vr71g759+7a0tLQdb722kyTJwQcf3Nzc/Nxzz+3oPbe0tJxzzjkzZszYd999O269sKsolUpJkmzatGmr4+++++6O3pXt3G2IaJfTo0ePto/zPN/2eOserqura93Sbbbd21u55pprDjjggLPPPrujlwy7hNbXoK2vR7fU1NRUV1c3fPjw9m9J27nbqKv1Amivp5566vjjj0+SZOHChf369Rs2bNjrr7+eJEnbhaAXX3yx7cZbbchW999//6JFi7b8VKlUWrFixQEHHLBTHgEU25AhQ8aOHXv99dePHTu27eDmzZunT59+yimn7LXXXhs3bmznlrSduw2vRAtjypQpy5cvX7p06dSpU88///xevXrtvffeQ4cOnTlz5ttvvz1v3rx77rmn7cZ9+/ZdtWrVG2+8seU9PP300/n/c9111x177LF5ntty0H633XbbokWLzjrrrCVLlrS0tCxevHj8+PEvv/zyjTfemCRJ+7ek7dxtiGhhjBs37vjjjz/88MNPOOGE66+/vvU/PGfNmjVv3rxBgwZ9+9vf/uY3v9l24wsvvPC6666bMGFCTZcM3U1DQ8MTTzwxcODAE044oX///p///OeHDBnyu9/9bv/999+hLWk7dxulLX/qtqPK5XKHLob319zcPHfu3LFjx/bv37/Wa+H9ZVmWFI39WxO2c3fbv3kV0jQNn9ds+5100kk1Oa/ZnbOPaqWIz7NZs11t/7qcCwBBIloAPXv2rPUSAHgfIgoAQSIKAEEiCgBBIgoAQSIKAEEiCgBBIgoAQSIKAEEiCgBBIgoAQSIKAEEiCgBBIgoAQSIKAEEiCgBBIgoAQaU8z6OzSblcDs9Cd5JlWVI09i9Uv3/rkupUKpXYYJqmNZsdPi04u2xqVbNFfK7MdmuFe57t3502m722KjZbHrB/NbOF278u5wJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkBQKc/z6GxSLpfDs9CdZFmWFI39C9Xv37qkOpVKJTaYpmlVs8OnBWeXTa3Zms3ulNnstVWx2fKA/cPnLSj712xXm82Ktn9dzgWAIBEFgCARBYAgEQWAIBEFgCARBYAgEQWAIBEFgCARBYAgEQWAIBEFgCARBYAgEQWAIBEFgCARBYAgEQWAIBEFgCARBYCgUp7n0dmkXC6HZ6E7ybIsKRr7F6rfv3VJdSqVSmwwTdOazQ6fFpxdNrWq2SI+V2a7tcI9z/bvTpvNXlsVmy0P2L+a2cLtX5dzASBIRAEgSEQBIEhEASBIRAEgSEQBIEhEASBIRAEgSEQBIEhEASBIRAEgSEQBIEhEASBIRAEgSEQBIEhEASBIRAEgSEQBIKiU53l0NimXy+FZ6E6yLEuKxv6F6vdvXVKdSqUSG0zTtJCzw6cFZ5dNLeTjNdutFe55tn932mz22qrYbHnA/oV7vNVwORcAgkQUAIJEFACCRBQAgkQUAIJEFACCRBQAgkQUAIJEFACCRBQAgkQUAIJEFACCRBQAgkQUAIJEFACCRBQAgkQUAIJEFACCSnmeR2eTcrkcnoXuJMuypGjsX+iA/ZtXIU3T8HnNmu1Os3kBFfF5Nmu2q+1fl3MBIEhEASBIRAEgSEQBIEhEASBIRAEgSEQBIEhEASBIRAEgSEQBIEhEASBIRAEgSEQBIEhEASBIRAEgSEQBIEhEASBIRAEgqJTneXQ2KZfL4VnoTrIsS4rG/oUO2L95FdI0DZ/XrNnuNJvvLB14riI+z2bNdrX963IuFEypVKr1EoD/IKJQPDoKXYSIAkCQiEIheTEKXUFdrRcAu7pwDlsHq3mDPVAlr0QBIEhEASDI5VyosR26HrvltV8XcqHmvBKFQlJQ6ApEFACCRBSKx8tQ6CJEFApGQaHrEFEoEgWFLkVEASBIRAEgSEQBIEhEASBIRAEgqFTNm/3K5XJ4FrqTLMuSorF/oQP2b16FNE3D5zVrtjvN5gVUxOe5ytlvLc1j/xT08Zptp2r2kcu5ABAkogAQJKIAECSiABAkogAQJKIAECSiABAkogAQJKIAECSiABAkogAQJKIAECSiABAkogAQJKIAECSiABAkogAQJKIAEFTK8zw6m5TL5fAsdCdZliVFY/9C9fu3LqlOpVKJDaZpatZst5ktqMI9z2majp4R/H735OXlamaL+FyZ3QlczgWAIBEFgCARBYAgEQWAIBEFgCARBYAgEQWAIBEFgCARBYAgEQWAIBEFgCARBYAgEQWAIBEFgCARBYAgEQWAIBEFgCARBYCgUp7n0dmkXC6HZ6E7ybIsKRr7F6rfv3VJdSqVSmwwTdNqZkfPCD7mJy8v12rNZrvxbEHZv2bNVsnlXAAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgq5XkenU3K5XJ4FrqTLMuSorF/ofr9W5dUp1KpxAbTNDVrttvMFlThnuc0TUfPCH6/e/LycjWzRXyuzO4ELucCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAUCnP8+hsUi6Xw7PQnWRZlhSN/QsdsH/zKqRpGj6vWbPdaTYvoCI+z2bNdrX963IuAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABJXyPI/OJuVyOTwL3UmWZUnR2L/QAfs3r0KapuHzmjXbnWbzAiri82zWbFfbvy7nAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQFApz/PobFIul8Oz0J1kWZYUjf0LHbB/8yqkaRo+r1mz3Wk2L6AiPs9mzXa1/etyLgAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASV8jyPzgLALs0rUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAKhFRCdNmlT6YGedddb2bzNu3Li2u1qzZs2UKVMOOuigPfbYY+DAgUcdddStt966adOm9p9oK/fff3+pVJo1a1brHxsbG0ul0owZM7a62cqVK0ul0hVXXNH6x4kTJ255z7vvvvuee+55+OGH33777Vs96ueff36ru2pqaiqVSpdddllswQAUTl3SBbzyyiuHHXZYW5Y2bNjwr//u5z//+f/8n/+zVCp11Imuuuqqk08++aCDDmrn7Tdv3vzGG2/85t+tXbt2ypQpHbUSAHb1V6I33XRT/v/cd999SZLMnj277cicOXPabrl8+fJ8G/PmzWv97Pe///3nn39+/PjxTz755FtvvbV+/fpf/OIXhxxySJZlDz744A6daPuam5sbGxvbXuB+kNWrV7fe8+bNm998880f//jHvXv3vuaaa959990Of2YAKK4u8TPRpqamurq6OXPmfOITn+jTp8+AAQOOP/74Bx54IEmShx56qANP9NWvfvXXv/713//937fz9qVSqW/fvl/5yle+/OUvv/7660uWLOnAxdx5552lUummm27qwPsEYJeL6OjRozdu3Jhl2ZYH6+vr8zy/5ZZbOvBE11577fDhw6+66qpnnnlmhwZbX4PuvvvuHbgYAIpuJ0V06NCh276/Zv78+a2fnTx58tFHH/2Vr3yloaFh4sSJt91226JFizpjGX369Jk9e3ZLS0t7LuomSbJp06ZVq1Z973vfu/fee//yL/9yxIgRHbiYxsbGPM8nTZrUgfcJwC73SrRfv37z58+fM2fO6NGjK5XKBRdcMGrUqKFDh951110dfq6jjz764osv/s1vfnPDDTd80G3222+/1szX1dUNHjx48uTJmzZtuvbaa70SBaAGEX3fNxYdd9xxbTfYfffdzzzzzCzL1qxZs3Tp0tmzZ++zzz6NjY3f/e53O3wx11577Uc+8pFvfetbixcv3v4td9ttt0GDBo0dO7ZSqZx77rmtB+vq/u0tzS0tLVvduPVI62cB2BV0iVeiWxk+fHhjY+OvfvWrQw455Dvf+U6H3/8ee+yx/Yu6be/O3bRp09q1a+fNm3fqqae2fXbAgAFJkrz88stbTf3xj39s+ywAu4LaR/Sll14qlUoTJ07c6nhdXd3HP/7x9evXNzc3d/hJP/3pT3/ta19bsGDBtn/9wp81dOjQ933bcOuRhoaGjlsmAF1a7a89Dh48+JOf/OQdd9zRu3fvM888s6GhYcCAAS+99NL/+l//67777jvssMN69uzZGee95ppr/vmf/znw7t8TTjihR48e06dPHzBgwJlnnvkXf/EXf/rTn37yk5/ceOONffr0+exnP9sZqwWgC6rlu3NLpdKbb76ZJMkdd9wxcODAm2+++aijjtp333332GOP4cOHX3TRRXV1dZ33a5StF3UDfx3S4MGD//t//+/Nzc2XX375/vvv36NHjwMOOOCyyy7buHHjP/zDP/zFX/xFO+/H74kCFF1X+T3RRYsWXXrppaNGjdpzzz179uxZX19//vnn//73vx8zZkznnffTn/705MmTA4Pf+MY3KpXKiSeeuM8++/To0WO//fY7+eST582bd8EFF3TCMgHookp5ntd6DQBQSF3ilSgAFJGIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIhCV7F27dqmpqbudy7oxkQUqjJ+/PjS+5k3b96O3tW4ceMee+yxbY+nadrY2NhB6/0z5wJ2iIhCVe6///78382ePbtv376tH+d5Pm7cuB29q3feeadz1ljjc0E3JqLQiVavXj1+/Ph+/fp9+MMfvuSSS9rS9Y//+I8NDQ39+/c/9NBDH3jggSRJjjvuuGeffXbChAkTJ078oHtbs2ZNqVS6+eab6+vre/fufeKJJ7700kttx2+//fYDDjhgwIAB5557buuJVq5cWSqVnn/++dbxG2644YgjjmjnuYD2EFHoRF/84hf79+///PPP//KXv1ywYMF//a//NUmSp556asqUKffff/+aNWu+9rWvnXHGGevWrZs/f/6IESNmz549a9as7d/nXXfd9fDDDzc1Na1aterqq69uOz59+vSHHnpo4cKFjz/++KRJk7ZzD+0/F7B9Igqd5ZFHHnnyySdnzpy59957NzQ0fPe73/3BD36wYcOGF154IUmSvn379urV66yzztqwYcNee+3V/ru98sorhw0bVl9f39jYuGDBgrbj06ZNGzVqVENDw4wZM+bMmfPWW291zsMC/j8Rhc6yePHit99+u1evXq1vNTr00EM3b978hz/84YQTTjjssMNGjhx52GGHffvb3165cuUO3W19fX3rB3379m1paWk73nqpNkmSgw8+uLm5+bnn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"
          },
          {
            "type": "input_text",
            "text": "Above is a visual representation of all the training examples and the test input. Each grid cell is colored according to its value (0-9), with clear labels and arrows showing input\u2192output transformations. Use both the textual and visual information to understand the pattern."
          }
        ]
      },
      {
        "type": "message",
        "role": "assistant",
        "content": [
          "Let's analyze the training examples carefully:\n\n- The grids are always 11\u00d711.\n- There are colored shapes formed by nonzero numbers.\n- Each example has at least two distinctive colors (numbers).\n- The blue shape(s) remains mostly unchanged on the output.\n- The colored single or small cluster points of different colors in input appear to be \"grown\" or \"duplicated\" spatially in output in distinct areas, often reflected or repositioned.\n- The newly created shape (of the second color) in the output:\n  - Matches the shape of the original colored cluster but is rotated or translated to a different location.\n  - Appears in a different corner or side of the grid relative to input positions.\n- In the last example, a small light blue cluster in Input (lower left) grows and appears in output too.\n- Essentially, the transformation seems to:\n  1. Keep original blue figures as is.\n  2. Identify secondary colored shapes (single-color or cluster).\n  3. Copy or replicate these secondary shapes with possible simple transforms (translation, flipping) to a different quadrant.\n  4. Color the copies with same or different colors.\n  \nAlso, from the colors and examples:\n\n- Blue shapes keep the same color.\n- Secondary shapes (green, pink, red, light blue) recreate or partially replicate elsewhere.\n- Sometimes single points get extended into multi-point shapes in output.\n- The extra shapes appear usually in corners opposite or other quadrant.\n\nBecause these datasets are ARC-style, transformations are often geometric (translation, 90\u00b0 rotations, quarters flips).\n\n---\n\n### Hypothesis for the transformation:\n\n- Keep all original blue pixels (color 1).\n- For each secondary color cluster distinct from blue:\n  - Find its shape.\n  - Place a translated or flipped copy of that shape somewhere else on the grid:\n    - Usually near the opposite corner or a clear predefined quadrant.\n  - Color of the copy can be the same or closely related.\n- Some pixels that appear isolated in input become replicated as mini shapes in output.\n\n---\n\n### Implementation plan:\n\n1. Identify main blue shape and keep it.\n2. Find the other colored clusters (nonzero and not blue).\n3. Extract the bounding box of these clusters.\n4. Mirror horizontally or vertically this bounding box.\n5. Translate mirrored shape to a new location (opposite quadrant).\n6. Paste it back in output grid.\n7. Also keep original secondary cluster as is (or make copy only).\n8. Output always 11\u00d711 grid.\n\n---\n\n### Since the problem wants an 11\u00d711 output grid and inputs can be 11\u00d711 or bigger, we need to normalize sizes:\n\n- Clip or pad input to 11\u00d711 before processing.\n- Output is always 11\u00d711.\n\n---\n\n### Simplifications based on examples:\n\n- Blue shapes unchanged.\n- For the other colors:\n  - find their bounding boxes,\n  - flip horizontally,\n  - place near bottom-left or top-right quadrant,\n  - color in output remains same color for simplicity.\n- Do this for all secondary colors.\n\n---\n\nNow I will write code that implements these steps.\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n\n    # Normalize input to 11x11 (pad or crop)\n    rows = len(grid)\n    cols = len(grid[0])\n    target_size = 11\n    arr = np.zeros((target_size, target_size), dtype=int)\n    # Crop or pad top-left corner\n    min_rows = min(rows, target_size)\n    min_cols = min(cols, target_size)\n    arr[:min_rows, :min_cols] = np.array(grid)[:min_rows, :min_cols]\n\n    output = np.zeros_like(arr)\n\n    # Blue color is considered 1 (based on examples)\n    # Keep all blue pixels as is\n    blue_mask = (arr == 1)\n    output[blue_mask] = 1\n\n    # Find all colors present except 0 and blue(1)\n    colors = set(np.unique(arr))\n    colors.discard(0)\n    if 1 in colors:\n        colors.discard(1)\n\n    # For each secondary color cluster, find bounding boxes, then flip horizontally and place near opposite corner\n    for color in colors:\n        mask = (arr == color)\n        if not np.any(mask):\n            continue\n\n        # Find bounding box of cluster for this color\n        rows_idx, cols_idx = np.where(mask)\n        min_r, max_r = rows_idx.min(), rows_idx.max()\n        min_c, max_c = cols_idx.min(), cols_idx.max()\n\n        cluster = arr[min_r:max_r+1, min_c:max_c+1]\n        # Only keep this cluster pixels equal to color, others zeroed\n        cluster_mask = (cluster == color)\n        cluster_shape = np.where(cluster_mask, color, 0)\n\n        # Flip cluster horizontally\n        flipped = np.fliplr(cluster_shape)\n\n        # Decide placement for flipped cluster:\n        # Place it in bottom-left quadrant or top-right quadrant depending on where original cluster is.\n        # If original is in top half, place in bottom half; else top half\n        # If original is in left half, place in right half; else left half\n\n        original_center_r = (min_r + max_r)//2\n        original_center_c = (min_c + max_c)//2\n        hr, hc = flipped.shape\n\n        if original_center_r < target_size // 2:\n            # place in bottom half\n            new_r = target_size - hr - 1\n        else:\n            # top half\n            new_r = 1\n\n        if original_center_c < target_size // 2:\n            # place in right half\n            new_c = target_size - hc - 1\n        else:\n            # left half\n            new_c = 1\n\n        # Bound check to avoid overflow\n        new_r = max(0, min(new_r, target_size - hr))\n        new_c = max(0, min(new_c, target_size - hc))\n\n        # Paste flipped cluster into output (overlay, preserve existing blue)\n        for rr in range(hr):\n            for cc in range(hc):\n                val = flipped[rr, cc]\n                if val != 0:\n                    output[new_r + rr, new_c + cc] = val\n\n        # Also keep original secondary cluster pixels as is:\n        for rr in range(min_r, max_r+1):\n            for cc in range(min_c, max_c+1):\n                if arr[rr, cc]==color:\n                    output[rr, cc] = color\n\n    return output.tolist()\n```\n"
        ]
      },
      {
        "role": "user",
        "content": [
          {
            "type": "input_text",
            "text": "Please analyze the training feedback and programs from all prior turns, and write an improved transformation.\n\n**Important**:\n1. Always start by attempting to find a complete rule that solves all training examples and should generalize to the test input.\n2. If you cannot find a perfect solution, provide your best attempt at a transformation that solves as many training examples as possible - ideally more than in the best previous turn.\n3. Even if your solution doesn't solve all examples perfectly, ensure it demonstrates meaningful pattern recognition and provides reasonable outputs that minimize pixel-level errors.\n\nFinal answer:\n```python\ndef transform(grid):\n    # Your improved transformation logic here (even if partial)\n    return transformed_grid\n```"
          },
          {
            "type": "input_text",
            "text": "Training results: 0/4 examples solved, 76.2% pixel accuracy - Good partial progress! Your approach is capturing some patterns. Next, try to identify a transformation that solves at least one of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[1, 1, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 1, 1, 1, 0, 3, 3, 3, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 1, 1, 1, 0, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0, 0, 0, 8, 0], [0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 86.0%\n\nTraining Example 2 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 1, 0, 0, 0, 0, 0, 0, 6, 0], [0, 1, 1, 1, 1, 0, 0, 6, 6, 6, 6], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 6, 0], [0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 86.4%\n\nTraining Example 3 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 77.8%\n\nTraining Example 4 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 8, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 61.0%\n\n\u26a0\ufe0f  GRID SIZE ERROR: One or more of your output grids are incorrect in size. They should ALL be 11\u00d711 for this task.\n\n"
          },
          {
            "type": "input_image",
            "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAmcAAATYCAIAAADVnPfcAABQQ0lEQVR4nO3de5RU5Z3o711IN6Jgo6ioXLwhrTkoIl4Qkahw1kEQrRIwJl4CwcTLeANBZcboiUsiCtHExKAnKIro6GisRg0SNEGICURGmQjiBQEVEA2iDSLQ3PZvmfpNLwZs8lJN9a6G51n80Vbvb+3dRb183Luqu1NxHEcAQIAGIRsBAKoJADtANQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIA6qebVV1+dqtnFF1/8jduUlpYedNBB55577htvvLHtfb700kupVGq//fZbt27dVp965plnUqnU2LFjc/85YMCAVCo1atSorTZbsmRJKpW65ZZbajOVs27dugcffPDMM8885JBDGjVqdMghh/Tv3/9Pf/rTdh6TW265paYHZO7cudt/0Hr06PFPH9jqbS677LItb88dXt++fWfMmLHl8aTT6a02O/zww6+99tovvvhihx78nM8+++yOO+7o2LFjWVnZ3nvvffLJJ48dO3bLX5uT291W46+//voBBxzQtGnTqVOnbuehAyh+CZxrbtiw4dNPP33++efPPPPMhQsXbvXZhx9+OIqiL7744qmnngq5t1tvvfWdd97Z0WMImfrggw9OPfXUK6644pVXXlm2bNn69euXLVv2zDPPdOvW7Z577omKTO7wnn322a5duz7++OPb2eyDDz745S9/2bNnz82bN+/Qgz9jxowOHTr8+Mc//q//+q9Vq1atWbNm1qxZP/zhDwcNGrSdA/vjH/945plnbtq06eWXXz7zzDNr8SUC1PNq/upXv4r/29NPPx1F0bhx46pvmTBhQvWWixYtqr593bp1b7/99ve+971Vq1aNGTNmyzusrKysqKjo37//fvvt98ADD4Qcw/r16wcMGLBp06YdOvJ/OrVhw4Z+/fr913/9V5cuXZ577rnPPvtsw4YNH3300a9//ev99tvvxhtvzJ041mT27NnxNtq3b/+ND0i1l19+ecs7Cdlm2bJludvXrl37/vvv33zzzXEc/+AHP/jwww+33Gzt2rVbPvg9evR47bXXXnrppfAH/+9//3smk/n444+/+93vzpw5c9WqVZ9//nlFRcURRxwxbty4Bx988Bsfh2w226tXr7322uuVV1455ZRTtvOIAdQLCZxrNmrU6Oijj77rrruiKNrqXPOJJ55Yt27d5ZdfPnDgwJkzZ7755pv/9N6uueaav/71rz/72c926Bj+6dSjjz76+uuv9+jRY/r06X369GnevHnDhg1bt2595ZVXPvvss5s2bfr3f//3qJjsueeeRx555J133nnrrbeuX7/+5z//+XYe/Ouvvz5X3PAH/5577vn0008HDx78xBNPnHLKKU2bNt13333PO++8adOm7b333vfcc8+2v978oYce6t+//4EHHvinP/3puOOOq779kUceSaVSv/rVr3bqAwCwi1azqqrqrbfeGjJkSBRF7dq12/JT48aNO+aYY84666wrr7xyjz32CDnd/OlPf9q2bdtbb7317bffDj+Gfzr1xBNPpFKp//f//t8ee+yx1ae+/e1vz5s374477oiK0g033LDXXnv9/ve//8bPbtiw4b333rvvvvsaNmz47W9/O/zB/4//+I/GjRvffvvtW91hq1atXn311VdeeSWVSm15+913333ZZZcdccQRr7766lFHHbXzvj6A3aCahx9+ePUbUvbcc8/27ds//fTT+++//3XXXVe9zdy5c//zP/9z2LBhqVTqyCOP7N+//+OPP7569ert3/Nee+01bty4DRs27NB12n86NXv27GOOOebwww//xvFjjjlmq0hspWPHjlu9i+fVV1+t6QGp9sorr+zoNttq2rTpUUcdtdVJfOPGjXPjpaWl5eXlf/7znx999NEtv7rtP/gbNmz44IMPTj755CZNmmy7x+OPP/7ggw/e8pYbb7zxpptuiqLo9NNPb9OmzVbbDxgwII7jq6++evtfCEARSuY7T1q2bPmDH/zgb3/720EHHVR948MPP9yyZcuLLroo95/Dhw//8ssvQy6Edu3a9dprr33ttddGjx4dfgzbmdqwYUNlZWWLFi22vHGr97UedthhUbFq3rx51T/UtMGmTZtmzpy5YcOGwAe/srIyjuPmzZsHHsAvf/nLU089tUePHg8//PCzzz5bu68GYPerZu6NLevXr3/yySdzJ0MjR4485JBDqjfYsGHDhAkTli5d2qhRo1yWOnToEMdx4HuCfvrTnx511FG33XbbvHnzwo+qpqmSkpKmTZsuX748yte27wbq2rXrP32nzxlnnLGj23yjL774oqSkpFGjRtu+G2j9+vULFy78l3/5l1/+8pdDhw4NfPD322+/Bg0ahD8gAwcOfOWVV8aPH7/ffvv98Ic/XLp0aeAgQJGr03PNkpKS73znO0899dS0adN69uy55Xf1vfDCC9/4j/Ibb7wxa9asf3rPjRs3zuM67Xamjj322Hnz5n300Uff+IbhTp06RcVq9erVc+fOPeaYY77xsyUlJYcffvjo0aPbt2//yCOPBD74e+yxxzHHHPOf//mfa9as2XazO++889JLL/3444+rb/n1r39dWlp68MEH/+pXv/r8888vvfTSbb/LBaA+SuAK7dlnn33NNde88cYb1ec6uSuEe+6558qVK7c8r/rLX/4SRVFN39WwldNOO+26666bNWvWtj/BII+piy66aPPmzVddddU3Nnjb94sWj3vvvXfDhg09e/bc/mYNGjRYvXr1xo0bAx/8dDq9du3a//t//+9W9/PBBx/cfffdL7zwwjdev/3ud7/br1+/P/7xjzt08RygaCXzuuZPf/rTNm3ajBkz5q9//WsURZ988snkyZP79Omzzz77bLnZqaeeWl5e/u///u8rV64MudsRI0YcddRRv/71r3foYL5x6rLLLuvUqdPvfve7k08++T/+4z8++eSTDRs25H7KQe/evd94440GDYrrhxFWVVW9++67t9xyy09+8pO99tqrpvfaxHG8ZMmSYcOGvfnmmx07dmzYsGHggz948ODmzZuPGjXq0ksv/c///M+1a9d++umnTzzxxBlnnFFZWTls2LAtLwhvacyYMS1atLjllltef/31wnzpAHUnmX/6995771/+8pebN2++/PLLN27cOH78+I0bN1a/FWVL3//+99esWfPYY4+FX3Hd/rtbA6dKS0srKipOPfXUN9544zvf+c7BBx9cWlqa+4l6kyZNKi8vD/zRRTX5xvfHplKpLd8zHLLNwQcfXP3O5KOPPnrEiBG5Hx/YunXrrb7G3GYNGjRo3br16NGjGzRokPvmmcAHv3nz5k899VTTpk0fe+yxk046aa+99jrooIMuuuiiDz/8MJPJ3HjjjTV9pfvvv/9vfvObDRs2fO973/vqq698vyZQryV2wnTuueem0+m//e1vP//5zx955JF999337LPP3nazSy+9tEGDBoEXaXNXXHPfwr9DvnGqVatWf/rTnyZMmNCrV69WrVqVlpa2aNGiV69ejz766Ny5c0866aSomJSUlLRu3frCCy/885///N3vfremzfbYY48DDzywd+/eL730Uu4qbviD371799mzZ1977bVHH310kyZNGjdufMopp4wdO/a3v/3ttt/VuqU+ffoMGDDgvffe2/IbjQDqo1Qxv0QHAEWluF6cA4BippoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNXcpaxYseKdd95J+iigKFgOFIJqFkqrVq1S25gwYUJBd9qjR4+ZM2eGbz969OjOnTvX9NnKysojjjhih+4QtrX//vtXL4HS0tJjjjnmvvvuy/veqp+0lZWVqVRqO120HCgE1Syge++9N/6fLr744oLuce3atTvrrhYvXtyjR49FixbtrDtkdzZmzJjcEvjqq69GjRo1dOjQxx57rJb32axZsziOjz766Jo2sBwoBNWsaw899FCjRo0WL14cRdHy5cv32WefcePGffbZZ6lU6qGHHmrVqlVZWdmgQYOqF/yyZcv69evXpEmT1q1bDxkypPr2pUuXZjKZpk2bHnDAAVdddVVVVdUZZ5zx7rvvDhw48LLLLtvO4FtvvXX66ac3bty4S5cuNf0r8Lvf/a59+/adOnWqq0eF3UVJSck555zTvXv3bDb7ySefpFKp4cOHl5WVDRgwYEeftFuea1oO1BnVrGuDBg3q2rXryJEjoygaMWLEiSeeOHDgwNyn7r777smTJ8+ePfv111+/+uqrczf27du3adOmH3zwwbRp02bNmjV48OAoijZt2nT22WeXlpYuWLBgxowZc+bMue2221555ZXy8vJx48aNHTu2psF169b16tWrQ4cOH3/88fDhw8eNG/eNB9moUaOXX375/vvvr8MHht3Ixo0bmzRpkvv4nXfeWbJkye233573k9ZyoE5tdQmRnaVly5ZbPdR77LFH7lPz589v1qzZPffcU1ZWNn/+/DiOly9fHkVRNpvNbTBlypTS0tLVq1dPmzZtr732qqqqyt0+a9asBg0arF27dtq0aaWlpStWrNhqp7l/JuI4rmmwoqKirKxszZo1udt/9KMfnXLKKTV9CRs2bIiiaMaMGQV4eNiNNG/evPoKbWVl5bhx4xo0aPDCCy8sW7YsiqJJkyblPrWjT9ovvvgiiqK3337bcqAuOdesu9c1N27cmLu9bdu2w4YNGzJkyA033NC2bdvq7avfiXD88cevX79+wYIF8+bNW7NmTaNGjXLvpDjppJM2b968cOHCt956q1WrVvvtt19Nu65pcN68eUceeWTjxo1zm3Xs2LHAjwF87corr8w9FVu0aDF69Oj777+/d+/euU+1adOmlk9ay4G6pJrJmDt3bhRFb7zxxpY3lpSU5D7YtGlTFEUNGzbcuHFj27Ztt/o/nW9961slJSWpVGo791/T4FabVe8RCqr6XHPdunVz58694oorqj/VqFGjWj5pLQfqkmom4MUXX3zqqadGjRo1ceLEioqK6tvffPPN3AezZ89u0qTJkUceefTRRy9atGjJkiVb3UO7du0WL16cu0K1pep/O2oabN++/fz587/66qvcf86ZM2dnf3GQp7yftJYDdUk169rq1auvuOKKa6+9dujQoT/84Q+vvvrqL7/8MvepG2+8cdGiRfPnz7/pppt+9KMfNWrU6KyzzjruuOMGDhy4ePHipUuXXn/99W3atKmqqjr99NPbt29/zTXXfPbZZx988EHfvn2/+93vRlG09957f/zxx19++WVNg//n//yfgw8++Lrrrvv8889ffvnlhx9+OOnHA/5/eT9pLQfq1E56fZR//m6gKIouv/zya6655rDDDlu9enUcxytXrmzduvXVV1+dezfQzTfffOihh+67775DhgxZv3597n4+/PDD8847b++9995nn3169uz59ttv525ftGjR2WefveeeezZv3nzAgAErV66M4/g3v/lNkyZN+vbtu53BBQsWdO/efc8992zfvv2QIUO8/YG6fDfQlnLvBsq9IS5nh5601e8GshyoS6k4jqMkZDKZRPZbnNavXz9p0qTu3bs3bdo06WPZfWWz2UT2ay1QbJJaC/VCwwT3XdH2rvwG0+/fVKvZLV5K3LHZdLqgs3/4wx8S2e92ZhfeUpnf7BF3NKvNbCJfb4KsBbNFNct2eF0TAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCESsVxHCUhk8kksl+oSTabTWS/1gLFJqm1UC80THDfFRUV+Q2m0+mKtnflOfv+TYnN1uLrXXhLZX6zR9zRLKnZWv39JjGbIGuhyJ8bCc52GJVnwP42LFMf10Lxc4UWAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCESsVxHCUhk8kksl+oSTabTWS/1gLFJqm1UC80THDfFRUV+Q2m0+mKtnflOfv+TbXa7242u/CWyvxmj7ijWb37ehNkLRT/rLVAjiu0ABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEgVCqO4ygJmUwmkf1CTbLZbCL7tRYoNkmthXqhYYL7rqioyG8wnU5XtL0rz9n3b0psthZf78JbKvObPeKOZknN1urvN4nZBFkLRf7c2N1mKdJqArDrS6Vq/FRCFztrQzUBqNtYbrtN/cmnagJQ5738xpH60E7VBCC5Xta3dvrOEwB2hlomc6ffT2GoJgBFlrpU8YZTNQEovsilijScqglAUeYtVYzhVE0AijVsqaILp2oCUMRJSxVXOFUTAEKpJgDFfQqYKqLTTdUEgFCqCUDRn/yliuV0UzUBIJRqAkAo1QSgPlwsTRXFRVq/8wSAAovjaOLEaOPGqKQkOvfcIulfflJxQr+TJZPJJLJfqEk2m01kv9YC9WwtpHa8eX/9a/Tww9GDD0aDBkWXXRademqeR1YMv0QsTkg6nc77mM2aLcSstWDWbM4/ecpG0Q7/eeaZeMCAuHPnuGfPrz/O4x5yf4qA1zUBKLwJE6Lhw6PJk6N6TjUBKLyBA6NHHon69InqOdUEoMBat44aN46y2a8/aNkyqs+8hxaAAjv55OiTT6Ju3b5+D23nzlF9ppoAFFiqHn+ryVZcoQWgPnz7R1wE33aimgAQTjUBIJRqAlD0F0vjorg8q5oAsANUE4DiPvmLi+VEUzUBYAeoJgBFfAoYF9GJpmpCno4//vilS5dGUVRVVdWuXbv77ruvY8eOJ5xwwpQpU5I+NKhDcbxbJVM1IU/9+vV77rnnoiiaOnVqz54977jjjunTpz/xxBMTJkxI+tCgbsXx7pNM1YQ89e/ff+LEiVEUPf/88xdccEGvXr0uvfTSxYsXjx8/PulDgzoXx7tJMlUT8lReXr5ixYpVq1bNnj37tNNOe+SRRwYPHjxmzJiBAwcmfWiQhDjeHZLpp7dD/s4777yRI0eefPLJq1atOvfcc19++eVOnTodccQRSR8XJCSOd85PaS/iZH79g+jjhI4vk8kksl+oSTab3aHt33333eOOO27q1KldunQZNWrUk08+uXnz5kGDBl199dU7dD/WAvV9LWwt73YWdy//f3FC0ul03sds1mwhZq0Fs2Zzds4zO4p24E/94QotAAUQx//81LNenFz+T6oJQCHF9S+N2+E9tAAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAtfKHP/yhS5cuZ5555umnnz5jxowoijZv3nzttdeeeuqp3bp1W7hwYfWWK1euTKfTXbt2TafTK1eujKJo5MiR7du3HzVqVG6qd+/elZWVURFTTQBqZdCgQY8//vjUqVMfeeSRQYMGRVH0wAMPNG3adMaMGYMHDx46dGj1liNGjOjWrdurr756+umn33nnnVEU/eIXv/jLX/5yzz33RFE0duzYvn37NmvWLCpiqTih3xeayWQS2S/UJJvNJrJfa4H6vhY6der04IMPnnjiia+99lr//v0//PDD00477dFHH23btu369et//vOf33jjjbkt27dvP2XKlEMOOWTp0qU9e/acM2dOmzZt/vjHP3bv3n327NmXXHLJCy+8kEqlomIWJySdTud9zGbNFmLWWjBrNmdHn8OvvfZao0aN2rdv36hRo+effz6O4/333/9nP/vZt7/97XQ6vWjRouot999//02bNsVxvGnTpgMOOCCO4/Hjx59yyimPP/74lVdeOWvWrLjouUILQK0MHTr08ccfnzNnzmOPPfbss89GUbR+/fpDDz30lVdeufjii3PXbGtyySWXzJw5s7y8PIqihQsX9u7d+5lnnomKWMOkDwCA+m3OnDm5FxrOP//8K6+8MoqiFi1a5E520+n0FVdcUb1lixYtPvnkk0MOOWTZsmUtWrTI3RjH8a233jp+/PhOnTrNnDmzS5cu/fr1i4qVc00AaqW8vPzPf/5zFEUzZsw47LDDoig666yzpk+fHkXR9OnTO3ToEEXR6tWroyjq1avXk08+GUXRk08+2atXr9z4ww8/3KdPn+bNm69duzaO4zVr1kRFzLkmALXywAMPXHvttV+/vzSVGjt2bBRFt99++6BBg26//faGDRs++OCDudPQKVOm/Nu//dv3v//9Z599dv/993/00UejKKqsrHz66acnTZoURdHgwYN79Ohxww03REVMNQGolQ4dOkybNm3LWw488MDnn39+y1umTJkSRVFZWVlFRcWWtzdr1mzy5Mm5j2/+h6i4uUILAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQKhXHcZSE3K8wheKRzWYT2a+1QLFJai3UC0n+prCtfl9MuHQ63WFUnn+pfxuWSWq2Nl+v2TqYTVC9e6zM7tqzbIcrtAAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIFQqjuMoCZlMJpH9Qk2y2Wwi+7UWKDZJrYX6IU5IOp3O+5jT6fRt8+P8/tRyv2Z34dl6uhbMmt1l1kK94AotAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIlYrjOEpCJpNJZL9Qk2w2m8h+rQWKTVJroV5omOC+Kyoq8htMp9MdRuX5l/q3YZmkZmvz9Zqtg9kE1ebrXXhLZX6zR9zRrN79HZmtm1m2wxVaAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQKhXHcZSETCaTyH6hJtlsNpH9WgsUm6TWQr3QMMF9dxiV51/M34ZlajNbUVGR32w6nTa7C88myPPZbFHNsh2u0AJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCpOI6DNwaA3ZpzTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUau5SVqxY8c477yR9FFAULAcKQTULpVWrVqltTJgwoaA77dGjx8yZM8O3Hz16dOfOnbe9ff78+eecc06zZs0OPvjgyy+/fNWqVTv1MNm97L///tVLoLS09JhjjrnvvvvyvrfqJ21lZWUqldpOFy0HCkE1C+jee++N/6eLL764oHtcu3Zt7e9kw4YN55xzzmGHHbZo0aI//elPr7/++hVXXLEzjo7d15gxY3JL4Kuvvho1atTQoUMfe+yxWt5ns2bN4jg++uija9rAcqAQVLOuPfTQQ40aNVq8eHEURcuXL99nn33GjRv32WefpVKphx56qFWrVmVlZYMGDape8MuWLevXr1+TJk1at249ZMiQ6tuXLl2ayWSaNm16wAEHXHXVVVVVVWeccca77747cODAyy67bDuDb7311umnn964ceMuXbosWrRo2yOcNWvWwoUL77nnnn333bdt27a33XbbxIkT4ziuwweJXVZJSck555zTvXv3bDb7ySefpFKp4cOHl5WVDRgwYEeftFuea1oO1BnVrGuDBg3q2rXryJEjoygaMWLEiSeeOHDgwNyn7r777smTJ8+ePfv111+/+uqrczf27du3adOmH3zwwbRp02bNmjV48OAoijZt2nT22WeXlpYuWLBgxowZc+bMue2221555ZXy8vJx48aNHTu2psF169b16tWrQ4cOH3/88fDhw8eNG7ftEXbp0mXDhg2lpaW5/1y2bNl+++2XSqXq8EFiF7dx48YmTZrkPn7nnXeWLFly++235/2ktRyoU1tdQmRnadmy5VYP9R577JH71Pz585s1a3bPPfeUlZXNnz8/juPly5dHUZTNZnMbTJkypbS0dPXq1dOmTdtrr72qqqpyt8+aNatBgwZr166dNm1aaWnpihUrttpp7p+JOI5rGqyoqCgrK1uzZk3u9h/96EennHLKdr6KysrKww8//LbbbtvZDw+7kebNm1dfoa2srBw3blyDBg1eeOGFZcuWRVE0adKk3Kd29En7xRdfRFH09ttvWw7UJeeadfe65saNG3O3t23bdtiwYUOGDLnhhhvatm1bvX31OxGOP/749evXL1iwYN68eWvWrGnU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atUqtY0JEyYUdKc9evSYOXNm+PajR4/u3Lnztrd/+umn/fr122effVq3bn3HHXfs1GOE/2H//fevXiClpaXHHHPMfffdl/e9VT+lKysrU6nUdrposZCfhnnOEeDee++9/vrr63KPa9eu3Sn3873vfa9NmzaLFy+eP3/+2WeffdBBB1122WU75Z5hW2PGjLniiiuiKNqwYcPvf//7888/f999973kkktqc5/NmjWL43g7G1gs5Me5Zl176KGHGjVqtHjx4iiKli9fvs8++4wbN+6zzz5LpVIPPfRQq1atysrKBg0aVL2kly1b1q9fvyZNmrRu3XrIkCHVty9dujSTyTRt2vSAAw646qqrqqqqzjjjjHfffXfgwIG5RVvT4FtvvXX66ac3bty4S5cuixYt2vYIFyxYMHXq1NGjR5eVlZ144olnnnnmX/7ylzp8hNh9lZSUnHPOOd27d89ms5988kkqlRo+fHhZWdmAAQN29Cm95bmmxcLOFFMYLVu2vPfee7/xU2edddZVV10Vx/F111135plnxnG8fPnyKIratWs3Z86cBQsWdOjQ4Qc/+EFu41NPPXXAgAHLly9fsGBB165dL7/88jiON27ceOyxx15wwQWffvrp/Pnzu3btetNNN8VxXF5ePm7cuO0Mrl27tk2bNv/yL//y+eefP/fcc40bNz7llFNq+hI2bNjw8ssv77fffs8991xhHiSImzdvPmbMmC1v6dGjxyWXXLJs2bIoitLp9KpVqz788MMdfUp/8cUXURS9/fbbFgs7l2oWSsuWLbf6H5Q99tgj96n58+c3a9bsnnvuKSsrmz9/fnU1s9lsboMpU6aUlpauXr162rRpe+21V1VVVe72WbNmNWjQYO3atdOmTSstLV2xYsVWO63+h6CmwYqKirKysjVr1uRu/9GPfrSdfwjKy8sbNWp0xhlnLF++vACPEGxdzcrKynHjxjVo0OCFF17IVXPSpEm5T+3oU7q6mhYLO5crtAW01bnmxo0bc7e3bdt22LBhQ4YMueGGG9q2bVu9ffV7DY4//vj169cvWLBg3rx5a9asadSoUe69EieddNLmzZsXLlz41ltvtWrVar/99qtp1zUNzps378gjj2zcuHFus44dO27n+N95550VK1bstdde55xzzk56SOAbXHnllbknaosWLUaPHn3//ff37t0796k2bdrU8iltsbBzqWYy5s6dG0XRG2+8seWNJSUluQ82bdr09Tu1GjbcuHFj27Ztt/o/nW9961slJSWpVGo791/T4FabVe+xJnvvvfctt9zy17/+9eOPP873a4V/ovpcc926dXPnzs29MyinUaNGtXxKWyzsXKqZgBdffPGpp54aNWrUxIkTKyoqqm9/8803cx/Mnj27SZMmRx555NFHH71o0aIlS5ZsdQ/t2rVbvHhx7hrUlqr/dahpsH379vPnz//qq69y/zlnzpxtD2/y5MllZWVVVVW5//z888/32GOPZs2a1e6LhlrJ+yltsbCT7aQrvYS+G+jLL79s06bN9ddfn3ulpGXLlqtWrcq9rnniiScuXLjwvffeO/bYY4cMGRLH8aZNmzp27NijR4+PPvpoyZIl1113XevWrdetW7d58+YTTjjhoosuWr58+aJFi84///wLL7wwjuNOnTqNGDFi1apVNQ1WVVW1a9du0KBBK1aseOmll5o2bbrtSzVr165t167dVVddVVlZ+be//e2YY4657LLL6uphY7ez7buBcnKva+Ze+N/OWqjpKV39uqbFws6lmnX3bqAoii6//PJrrrnmsMMOW716dRzHK1eubN269dVXX52r5s0333zooYfuu+++Q4YMWb9+fe5+Pvzww/POO2/vvffeZ599evbs+fbbb+duX7Ro0dlnn73nnns2b958wIABK1eujOP4N7/5TZMmTfr27budwQULFnTv3n3PPfds3779kCFDvvENDu+//36vXr322WefNm3aDB8+fO3atXX4yLF7Cazmjj6lq6tpsbBzpbb/jcC1kclkCnTPu57169dPmjSpe/fuTZs2TfpY+GbZbDaR/VpHFJtsQmuhWMQFk06n8z6q3W22V69eiezXbDGsFOvIbP2ajXdv3g0EAKFUsyiUlpYmfQgA/HOqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCpOI6jwshkMgW6Z6h72Ww2kf1aRxSbbEJroUg0LOi9V1RU5DeYTqfr5Wzbu/Kcff+mevn17k6zCarN15td+XF+s5myQ6wjs2zLFVoACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABAqFcdxVBiZTKZA9wx1L5vNJrJf64hik01oLRSJhgW994qKivwG0+l0rWbb3pXn7Ps31cv9mi38bIKsozrar1kCuEILAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCpeI4jgojk8kU6J6h7mWz2UT2ax1RbLIJrYUi0bCg915RUZHfYDqdrtVs27vynH3/pt1uNqm/o/o2myDrqB7M1rfncz1dC8XAFVoACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaAFAcP1EPALYnlarxUwX7Mem1oZoAFFMst92mmPKpmgAUWS+/caQ42qmaABRrL4uvnd4NBEDRJ3On30++VBOAAkvt1NQlGk7VBKCQUgWIXHLhVE0ACiZVsLwlFM5UXLBXVjOZTIHuGepeNptNZL/WEfV4LaQKH7Y6f3NQYd9DW1FRkd9gOp1ObLbtXXnOvn9Tvfx6zRa9evdYWUe79mxxnQumUnUcTldoASCUagJQn190TNXpC5yqCQChVBOAev7u1lTd7VE1ASCUagJAKNUEoP7/1J5UHe3X7zwBIFFxHE2cGG3cGJWUROeem/jPZ98+55oAJOq116IXX4z69Yueey6aOTMqbqoJQKIWL46qqqLOnaOlS7/+U9xUE4CkTZgQDR8eTZ4cFT3VBCBpAwdGjzwS9ekTFT3VBCBRrVtHjRtH2ezXH7RsGRU376EFIFEnnxx98knUrdvX76Ht3DkqbqoJQKJSRf2tJltxhRaAevxrout4v6oJAKFUEwBCpeKCndVmMpkC3TPUvWw2m8h+rSPq5VpIpXbZy8JxwaTT6byPyqzZYpst3EqxjszWr9k4RBTV6Z865AotAPX75C+qQ6oJAKFUE4B6ewoY1/U3uqgm7HzHH3/80n/86oaqqqp27drdd999HTt2POGEE6ZMmZL0oUEdiuNd73tDVRN2vn79+j333HNRFE2dOrVnz5533HHH9OnTn3jiiQkTJiR9aFC34ngX+3EKqgk7X//+/SdOnBhF0fPPP3/BBRf06tXr0ksvXbx48fjx45M+NKhzcbzr/AQi1YRCKC8vX7FixapVq2bPnn3aaac98sgjgwcPHjNmzMCBA5M+NEhCHO8ayfTT26FQzjvvvJEjR5588smrVq0699xzX3755U6dOh1xxBFJHxckJI53zo8+SDSZqgmF0r9//+OOO27q1KllZWXnnHNO586dN2/e/OMf/zjp44LkxP8IXt7tTLqXOaoJBVFeXl5VVZX7eNg/JH1EUG/bGRdFL3NUE4A6F/93CLeTz2KKZTXVBCA5cTGmcTu8hxYAQqkmAIRSTQAIpZoAEEo1ASCUagJAqFRcsHf9ZjKZAt0z1L1sNpvIfq0jik02obVQLOKCSafTeR+VWbPFNlu4lWIdma1fs/HuzRVaAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUE4ACuvDCC8/4hy5duuy///7feEvOH/7why5dupx55pmnn376jBkzoigaOXJk+/btR40aFUXR5s2be/fuXVlZmehX4/drAlBITz75ZO6DsWPHfvTRR994S86gQYOmTp16+OGHL1iwoE+fPvPmzfvFL37x7rvvlpeXDxs2bOzYsX379m3WrFmUKNUEoODiOL7//vt///vfb+eW5s2br1ix4vDDD1+xYsVXX30VRVFJScnf//730tLSzz//fOLEiS+88EKUNNUEoOCef/75k0466cADD9zOLQ888EDXrl2POuqo+fPnP/PMM1EUjRgx4uKLL77zzjtvueWWn/zkJ6lUKkqa1zUBKLif/exnN9xww/ZvGTp06OOPPz5nzpzHHnvs2WefjaLokksumTlzZnl5eRRFCxcu7N27d66mCXKuCUBh/fWvf23WrFkufjXdEkXRnDlzcr+u4Pzzz7/yyitzN8ZxfOutt44fP75Tp04zZ87s0qVLv379ouQ41wSgsO6+++6tTiu3umX16tVRFJWXl//5z3+OomjGjBmHHXZY7lMPP/xwnz59mjdvvnbt2jiO16xZEyXKuSYABfT+++9//PHH3bp1284t559//pQpUx544IFrr732699hmUqNHTs2iqLKysqnn3560qRJURQNHjy4R48eW9W37qkmAAXUtm3b3DdfbueWKVOmRFHUoUOHadOmbXl7s2bNJk+enPv45n+IkuYKLQCEUk0ACKWaABAqFcdxVBi5NxDDriGbzSayX+uIYpNNaC0Ui7hg0ul03keV4Gx85sn5/amnX6/ZxFfKLrmOzO7Cs/HuzRVaAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQKhXHcVQYmUymQPcMdS+bzSayX+uIYpNNaC0UiYYFvfeKior8BtPpdG1msys/zm82U3bI7jab1N9RvZtNUL17rBKctRbqYHY35wotAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIlYrjOCqMTCZToHuGupfNZhPZr3VEsckmtBaKRMOC3ntFRUV+g+l0ujaz2ZUf5zebKTukPu7XbB3MJqjePVZmd+3Z3ZwrtAAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIFQqjuOoMDKZTIHuGepeNptNZL/WEcUmm9BaKBZxwaTT6byPqp7OxmeenN+fevr17lazhVsp1pHZ+jUb795coQWAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFScRxHhZHJZAp0z1D3stls0ocAFIG4YNLpdN5HZdZssc0WbqUA9YgrtAAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIFQqjuPgjQFgt+ZcEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmruUFStWvPPOO0kfBdR7lhI1Uc1CadWqVWobEyZMKOhOe/ToMXPmzPDtR48e3blz5+1scPXVV59xxhk749AgH/vvv3/18iktLT3mmGPuu+++vO+t+glfWVmZSqW200VLiZqoZgHde++98f908cUXF3SPa9eu3Yn39uqrr/7617/eiXcIeRgzZkxu+Xz11VejRo0aOnToY489Vsv7bNasWRzHRx99dE0bWErURDXr2kMPPdSoUaPFixdHUbR8+fJ99tln3Lhxn332WSqVeuihh1q1alVWVjZo0KDqRbts2bJ+/fo1adKkdevWQ4YMqb596dKlmUymadOmBxxwwFVXXVVVVXXGGWe8++67AwcOvOyyy7Yz+NZbb51++umNGzfu0qXLokWLajrOdevWDRo06MQTT6yTRwX+uZKSknPOOad79+7ZbPaTTz5JpVLDhw8vKysbMGDAjj7htzzXtJTYIapZ1wYNGtS1a9eRI0dGUTRixIgTTzxx4MCBuU/dfffdkydPnj179uuvv3711Vfnbuzbt2/Tpk0/+OCDadOmzZo1a/DgwVEUbdq06eyzzy4tLV2wYMGMGTPmzJlz2223vfLKK+Xl5ePGjRs7dmxNg+vWrevVq1eHDh0+/vjj4cOHjxs3rqbjvPXWW//X//pf559/fl09MBBk48aNTZo0yX38zjvvLFmy5Pbbb8/7CW8pscO2uoTIztKyZcutHuo99tgj96n58+c3a9bsnnvuKSsrmz9/fhzHy5cvj6Iom83mNpgyZUppaenq1aunTZu21157VVVV5W6fNWtWgwYN1q5dO23atNLS0hUrVmy109xSj+O4psGKioqysrI1a9bkbv/Rj350yimnbHvwr7322gEHHLBs2bI777zz29/+dsEeJPgnmjdvXn2FtrKycty4cQ0aNHjhhReWLVsWRdGkSZNyn9rRJ/wXX3wRRdHbb79tKbGjnGvW3euaGzduzN3etm3bYcOGDRky5IYbbmjbtm319tXvJjj++OPXr1+/YMGCefPmrVmzplGjRrl3Q5x00kmbN29euHDhW2+91apVq/3226+mXdc0OG/evCOPPLJx48a5zTp27Ljt7IYNG37wgx+MGjXqoIMO2tkPCeywK6+8Mvc0btGixejRo++///7evXvnPtWmTZtaPuEtJXaUaiZj7ty5URS98cYbW95YUlKS+2DTpk1RFDVs2HDjxo1t27bd6v90vvWtb5WUlKRSqe3cf02DW21WvcctjRgxolWrVt///vd3xhcKtVV9rrlu3bq5c+deccUV1Z9q1KhRLZ/wlhI7SjUT8OKLLz711FOjRo2aOHFiRUVF9e1vvvlm7oPZs2c3adLkyCOPPProoxctWrRkyZKt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"
          },
          {
            "type": "input_text",
            "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
          }
        ]
      },
      {
        "type": "message",
        "role": "assistant",
        "content": [
          "Let's analyze carefully based on the feedback and visuals:\n\n1. The blue shape always remains fixed at its original location in output.\n2. The secondary colors (3, 6, 2, 8, etc.) are always *replicated* into a *new region* spatially separated from the original, sometimes with a transformation like reflection or rotation.\n3. These replications are contiguous \"clusters\" matching the secondary shape's size and form but shifted to the opposite side of the grid.\n4. There is no deletion of the original secondary shapes.\n5. The new \"secondary cluster\" is placed near another corner/quadrant of the grid, with some flipping.\n\nFrom visual feedback:\n\n- In example 1: Secondary color 3 (green) cluster appears enlarged near the top-right corner. Secondary color 8 cluster appears enlarged toward bottom-left corner.\n- In example 2: Secondary color 6 cluster is copied and expanded near bottom right.\n- In example 3: Secondary color 2 cluster is copied and expanded near bottom-left.\n- In example 4: Secondary color 2 cluster is copied and expanded near top-right with additional duplication of secondary light blue cluster near bottom-left.\n\n### Conjecture for the general transform:\n\n- Blue shape(s) copied unchanged.\n- For each non-blue secondary color cluster:\n  - Identify cluster bounding box.\n  - Reflect cluster horizontally (flip left-right).\n  - Place the flipped copy in the opposite half of the grid (if original in top-left quadrant -> copied in bottom-right quadrant, etc.).\n  - Also expand the cluster somewhat by including neighbor pixels if they exist (to roughly mimic the \"extension\"/\"enlargement\").\n  - Same color is used.\n- Leave original clusters as is.\n\n---\n\n### Details to implement:\n\n- The grid is always 11\u00d711.\n- Define quadrants:\n  - Top-left: rows < 5, cols < 5\n  - Top-right: rows < 5, cols \u2265 5\n  - Bottom-left: rows \u2265 5, cols < 5\n  - Bottom-right: rows \u2265 5, cols \u2265 5\n- For each cluster, determine which quadrant it occupies mostly by center of mass.\n- Target placement quadrant should be \"opposite\":\n  - TL -> BR\n  - TR -> BL\n  - BL -> TR\n  - BR -> TL\n- Horizontally flip the cluster.\n- Place carefully to avoid overflow (stay within 11\u00d711).\n- In case the cluster is larger, use the bounding box size for placement.\n- Preserve blue shapes and original clusters.\n\n---\n\n### This should fit all examples reasonably well.\n\nNow, let's implement this.\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n\n    arr = np.array(grid)\n    h, w = arr.shape\n    target_size = 11\n\n    # Normalize grid to 11x11 size with cropping or padding\n    canvas = np.zeros((target_size, target_size), dtype=int)\n    rr = min(h, target_size)\n    cc = min(w, target_size)\n    canvas[:rr, :cc] = arr[:rr, :cc]\n    arr = canvas\n\n    output = np.zeros_like(arr)\n\n    # Define center line for quadrant split\n    mid_row = target_size // 2\n    mid_col = target_size // 2\n\n    # Blue color is 1, copy all blue pixels unchanged\n    blue_mask = (arr == 1)\n    output[blue_mask] = 1\n\n    # Find all nonzero colors except blue\n    colors = set(np.unique(arr))\n    colors.discard(0)\n    if 1 in colors:\n        colors.discard(1)\n\n    def find_quadrant(r, c):\n        # return 'TL','TR','BL','BR'\n        if r < mid_row and c < mid_col:\n            return 'TL'\n        elif r < mid_row and c >= mid_col:\n            return 'TR'\n        elif r >= mid_row and c < mid_col:\n            return 'BL'\n        else:\n            return 'BR'\n\n    def opposite_quadrant(q):\n        # Map to opposite quadrant\n        return {'TL':'BR', 'TR':'BL', 'BL':'TR', 'BR':'TL'}[q]\n\n    def quadrant_top_left(q):\n        if q == 'TL':\n            return (0, 0)\n        elif q == 'TR':\n            return (0, mid_col)\n        elif q == 'BL':\n            return (mid_row, 0)\n        else:  # BR\n            return (mid_row, mid_col)\n\n    for color in colors:\n        mask = (arr == color)\n        if not np.any(mask):\n            continue\n        rows_idx, cols_idx = np.where(mask)\n        min_r, max_r = rows_idx.min(), rows_idx.max()\n        min_c, max_c = cols_idx.min(), cols_idx.max()\n\n        cluster = arr[min_r:max_r+1, min_c:max_c+1]\n        # Binary mask of cluster pixels of this color\n        cluster_mask = (cluster == color)\n\n        # Find cluster center approx\n        center_r = int(np.mean(rows_idx))\n        center_c = int(np.mean(cols_idx))\n        orig_quad = find_quadrant(center_r, center_c)\n        targ_quad = opposite_quadrant(orig_quad)\n        targ_r0, targ_c0 = quadrant_top_left(targ_quad)\n\n        # Flip cluster horizontally\n        cluster_flipped = np.fliplr(cluster * cluster_mask)\n\n        # size of cluster\n        ch, cw = cluster.shape\n\n        # Place flipped cluster in target quadrant so that cluster fits inside quadrant boundaries:\n        # Quadrants are 5\u00d75 or 6\u00d76 blocks. Target quadrant may have variable size:\n        # For 11x11, top-left quadrants rows 0-5 or cols 0-5 except that mid line is at 5\n        max_r_place = targ_r0 + mid_row if targ_r0 == 0 else target_size\n        max_c_place = targ_c0 + mid_col if targ_c0 == 0 else target_size\n\n        # Adjust to fit cluster inside quadrant at top-left corner placement:\n        place_r = targ_r0\n        place_c = targ_c0\n        if (place_r + ch) > max_r_place:\n            place_r = max_r_place - ch\n        if (place_c + cw) > max_c_place:\n            place_c = max_c_place - cw\n\n        # Place the flipped cluster in output\n        for rr in range(ch):\n            for cc in range(cw):\n                if cluster_flipped[rr, cc] == color:\n                    output[place_r+rr, place_c+cc] = color\n\n        # Also keep original cluster pixels as is\n        output[min_r:max_r+1, min_c:max_c+1][cluster_mask] = color\n\n    return output.tolist()\n```\n"
        ]
      },
      {
        "role": "user",
        "content": [
          {
            "type": "input_text",
            "text": "Please analyze the training feedback and programs from all prior turns, and write an improved transformation.\n\n**Important**:\n1. Always start by attempting to find a complete rule that solves all training examples and should generalize to the test input.\n2. If you cannot find a perfect solution, provide your best attempt at a transformation that solves as many training examples as possible - ideally more than in the best previous turn.\n3. Even if your solution doesn't solve all examples perfectly, ensure it demonstrates meaningful pattern recognition and provides reasonable outputs that minimize pixel-level errors.\n\nFinal answer:\n```python\ndef transform(grid):\n    # Your improved transformation logic here (even if partial)\n    return transformed_grid\n```"
          },
          {
            "type": "input_text",
            "text": "Training results: 0/4 examples solved, 75.8% pixel accuracy - Good partial progress! Your approach is capturing some patterns. Next, try to identify a transformation that solves at least one of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[1, 1, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 1, 1, 1, 0, 3, 3, 3, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 1, 1, 1, 0, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[1, 1, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 85.1%\n\nTraining Example 2 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 1, 0, 0, 0, 0, 0, 0, 6, 0], [0, 1, 1, 1, 1, 0, 0, 6, 6, 6, 6], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 6, 0], [0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 86.4%\n\nTraining Example 3 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 77.8%\n\nTraining Example 4 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 60.4%\n\n\u26a0\ufe0f  GRID SIZE ERROR: One or more of your output grids are incorrect in size. They should ALL be 11\u00d711 for this task.\n\n"
          },
          {
            "type": "input_image",
            "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAmcAAATYCAIAAADVnPfcAABQGUlEQVR4nO3deZhU9Z3o/1NIN6Jgo2hcWOKCtOaiiLggotHAfa6CaJWAMW6BoHEZNxBU5hq98UpEYXRiYtAbFIPoxNFYjRokaIIYM6BEmQjigoAKAgbRBhFotvN7tH7TDwM2+VJN9amC1+vhj6a6PnVOl/Xl7Tl1ujsVx3EEAARoFHInAEA1AWA7qCYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgDQINW8+uqrU3W76KKLvvE+5eXlBxxwwNlnn/3GG29s/ZgvvPBCKpXaZ5991q5du8WnnnrqqVQqNWbMmNxf+/fvn0qlRo4cucXdFi1alEqlbrnllvpM5axdu/bBBx88/fTTDzrooCZNmhx00EH9+vX785//vI3n5JZbbqnrCZk9e/a2n7QePXr8wye29j6XXnrp5rfndq9Pnz7Tpk3bfH/S6fQWdzvkkEOuvfbazz//fLue/JxPP/30jjvu6NSpU0VFxZ577nnCCSeMGTNm81+bk9vcFuOvv/76fvvt17x58ylTpmzjqQMofgkca65fv/6TTz559tlnTz/99Pnz52/x2YcffjiKos8///yJJ54IebRbb731nXfe2d59CJn64IMPTjrppCuuuOKll15asmTJunXrlixZ8tRTT5166qn33HNPVGRyu/f0009369btscce28bdPvjgg1/84hdnnHHGpk2btuvJnzZtWseOHX/yk5/853/+58qVK1evXj1jxozLLrts4MCB29ixP/3pT6effvrGjRtffPHF008/vR5fIkCJV/OXv/xl/F+efPLJKIrGjh1be8v48eNr77lgwYLa29euXfv2229fcMEFK1euHD169OYPWF1dXVVV1a9fv3322eeBBx4I2Yd169b1799/48aN27Xn/3Bq/fr1ffv2/c///M+uXbs+88wzn3766fr16z/66KNf/epX++yzz4033pg7cKzLzJkz46106NDhG5+QWi+++OLmDxJynyVLluRuX7Nmzfvvv3/zzTfHcfyjH/3oww8/3Pxua9as2fzJ79Gjx2uvvfbCCy+EP/l///vfM5nM4sWLf/CDH0yfPn3lypWfffZZVVXVoYceOnbs2AcffPAbn4dsNtuzZ8899tjjpZdeOvHEE7fxjAGUhASONZs0aXLEEUfcddddURRtcaz5+OOPr1279vLLLx8wYMD06dPffPPNf/ho11xzzauvvvov//Iv27UP/3DqN7/5zeuvv96jR4+XX365d+/eLVu2bNy4cZs2ba688sqnn35648aN//Zv/xYVk9133/2www678847b7311nXr1v3rv/7rNp7866+/Plfc8Cf/nnvu+eSTTwYNGvT444+feOKJzZs333vvvc8555ypU6fuueee99xzz9a/3vyhhx7q16/ft771rT//+c9HH3107e2PPPJIKpX65S9/uUOfAICdtJo1NTVvvfXW4MGDoyhq37795p8aO3bskUce+b3vfe/KK6/cbbfdQg43f/azn7Vr1+7WW299++23w/fhH049/vjjqVTq//2//7fbbrtt8anvfve7c+bMueOOO6KidMMNN+yxxx5/+MMfvvGz69evf++99+67777GjRt/97vfDX/y//3f/71p06a33377Fg/YunXrV1555aWXXkqlUpvffvfdd1966aWHHnroK6+8cvjhh++4rw9gF6jmIYccUntByu67796hQ4cnn3xy3333ve6662rvM3v27L/+9a9Dhw5NpVKHHXZYv379HnvssVWrVm37kffYY4+xY8euX79+u87T/sOpmTNnHnnkkYcccsg3jh955JFbRGILnTp12uIqnldeeaWuJ6TWSy+9tL332Vrz5s0PP/zwLQ7imzZtmhsvLy+vrKz8y1/+8pvf/Gbzr27bT/769es/+OCDE044oVmzZltv8ZhjjjnwwAM3v+XGG2+86aaboig65ZRT2rZtu8X9+/fvH8fx1Vdfve0vBKAIJfOdJ61atfrRj370t7/97YADDqi98eGHH27VqtWFF16Y++uwYcO++OKLkBOh3bp1u/baa1977bVRo0aF78M2ptavX19dXb3//vtvfuMW17UefPDBUbFq2bJlzdfqusPGjRunT5++fv36wCe/uro6juOWLVsG7sAvfvGLk046qUePHg8//PDTTz9dv68GYNerZu7ClnXr1v32t7/NHQyNGDHioIMOqr3D+vXrx48f//HHHzdp0iSXpY4dO8ZxHHhN0M9+9rPDDz/8tttumzNnTvhe1TVVVlbWvHnzZcuWRfna+mqgbt26/cMrfU477bTtvc83+vzzz8vKypo0abL11UDr1q2bP3/+P/3TP/3iF78YMmRI4JO/zz77NGrUKPwJGTBgwEsvvTRu3Lh99tnnsssu+/jjjwMHAYpcgx5rlpWVff/733/iiSemTp16xhlnbP5dfc8999w3/qP8xhtvzJgx4x8+ctOmTfM4T7uNqaOOOmrOnDkfffTRN14w3Llz56hYrVq1avbs2UceeeQ3frasrOyQQw4ZNWpUhw4dHnnkkcAnf7fddjvyyCP/+te/rl69euu73XnnnZdccsnixYtrb/nVr35VXl5+4IEH/vKXv/zss88uueSSrb/LBaAUJXCG9swzz7zmmmveeOON2mOd3BnC3XfffcWKFZsfV/3Hf/xHFEV1fVfDFk4++eTrrrtuxowZW/8EgzymLrzwwk2bNl111VXf2OCtrxctHvfee+/69evPOOOMbd+tUaNGq1at2rBhQ+CTn06n16xZ83/+z//Z4nE++OCDu++++7nnnvvG87c/+MEP+vbt+6c//Wm7Tp4DFK1k3tf82c9+1rZt29GjR7/66qtRFC1dunTSpEm9e/fea6+9Nr/bSSedVFlZ+W//9m8rVqwIedjhw4cffvjhv/rVr7ZrZ75x6tJLL+3cufPvf//7E0444d///d+XLl26fv363E856NWr1xtvvNGoUXH9MMKampp33333lltu+elPf7rHHnvUda1NHMeLFi0aOnTom2++2alTp8aNGwc++YMGDWrZsuXIkSMvueSSv/71r2vWrPnkk08ef/zx0047rbq6eujQoZufEN7c6NGj999//1tuueX1118vzJcO0HCS+ad/zz33/MUvfrFp06bLL798w4YN48aN27BhQ+2lKJv74Q9/uHr16kcffTT8jOu2r24NnCovL6+qqjrppJPeeOON73//+wceeGB5eXnuJ+pNnDixsrIy8EcX1eUbr49NpVKbXzMccp8DDzyw9srkI444Yvjw4bkfH9imTZstvsbc3Ro1atSmTZtRo0Y1atQo980zgU9+y5Ytn3jiiebNmz/66KPHH3/8HnvsccABB1x44YUffvhhJpO58cYb6/pK991331//+tfr16+/4IILvvzyS9+vCZS0xA6Yzj777HQ6/be//e1f//VfH3nkkb333vvMM8/c+m6XXHJJo0aNAk/S5s645r6Ff7t841Tr1q3//Oc/jx8/vmfPnq1bty4vL99///179uz5m9/8Zvbs2ccff3xUTMrKytq0aXP++ef/5S9/+cEPflDX3XbbbbdvfetbvXr1euGFF3JnccOf/O7du8+cOfPaa6894ogjmjVr1rRp0xNPPHHMmDG/+93vtv6u1s317t27f//+77333ubfaARQilLF/BYdABSV4npzDgCKmWoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVRzp7J8+fJ33nkn6b2AomA5UAiqWSitW7dObWX8+PEF3WiPHj2mT58efv9Ro0Z16dKlrs9WV1cfeuih2/WAsLV99923dgmUl5cfeeSR9913X96PVvuira6uTqVS2+ii5UAhqGYB3XvvvfF/d9FFFxV0i2vWrNlRD7Vw4cIePXosWLBgRz0gu7LRo0fnlsCXX345cuTIIUOGPProo/V8zBYtWsRxfMQRR9R1B8uBQlDNhvbQQw81adJk4cKFURQtW7Zsr732Gjt27KeffppKpR566KHWrVtXVFQMHDiwdsEvWbKkb9++zZo1a9OmzeDBg2tv//jjjzOZTPPmzffbb7+rrrqqpqbmtNNOe/fddwcMGHDppZduY/Ctt9465ZRTmjZt2rVr17r+Ffj973/foUOHzp07N9Szwq6irKzsrLPO6t69ezabXbp0aSqVGjZsWEVFRf/+/bf3Rbv5sablQINRzYY2cODAbt26jRgxIoqi4cOHH3fccQMGDMh96u677540adLMmTNff/31q6++Ondjnz59mjdv/sEHH0ydOnXGjBmDBg2Komjjxo1nnnlmeXn5vHnzpk2bNmvWrNtuu+2ll16qrKwcO3bsmDFj6hpcu3Ztz549O3bsuHjx4mHDho0dO/Ybd7JJkyYvvvji/fff34BPDLuQDRs2NGvWLPfxO++8s2jRottvvz3vF63lQIPa4hQiO0qrVq22eKp322233Kfmzp3bokWLe+65p6KiYu7cuXEcL1u2LIqibDabu8PkyZPLy8tXrVo1derUPfbYo6amJnf7jBkzGjVqtGbNmqlTp5aXly9fvnyLjeb+mYjjuK7BqqqqioqK1atX527/8Y9/fOKJJ9b1Jaxfvz6KomnTphXg6WEX0rJly9oztNXV1WPHjm3UqNFzzz23ZMmSKIomTpyY+9T2vmg///zzKIrefvtty4GG5Fiz4d7X3LBhQ+72du3aDR06dPDgwTfccEO7du1q7197JcIxxxyzbt26efPmzZkzZ/Xq1U2aNMldSXH88cdv2rRp/vz5b731VuvWrffZZ5+6Nl3X4Jw5cw477LCmTZvm7tapU6cCPwfwlSuvvDL3Utx///1HjRp1//339+rVK/eptm3b1vNFaznQkFQzGbNnz46i6I033tj8xrKystwHGzdujKKocePGGzZsaNeu3Rb/p/Od73ynrKwslUpt4/HrGtzibrVbhIKqPdZcu3bt7Nmzr7jiitpPNWnSpJ4vWsuBhqSaCXj++eefeOKJkSNHTpgwoaqqqvb2N998M/fBzJkzmzVrdthhhx1xxBELFixYtGjRFo/Qvn37hQsX5s5Qba723466Bjt06DB37twvv/wy99dZs2bt6C8O8pT3i9ZyoCGpZkNbtWrVFVdcce211w4ZMuSyyy67+uqrv/jii9ynbrzxxgULFsydO/emm2768Y9/3KRJk+9973tHH330gAEDFi5c+PHHH19//fVt27atqak55ZRTOnTocM0113z66acffPBBnz59fvCDH0RRtOeeey5evPiLL76oa/B//a//deCBB1533XWfffbZiy+++PDDDyf9fMD/L+8XreVAg9pB74/yj68GiqLo8ssvv+aaaw4++OBVq1bFcbxixYo2bdpcffXVuauBbr755m9/+9t777334MGD161bl3ucDz/88Jxzztlzzz332muvM8444+23387dvmDBgjPPPHP33Xdv2bJl//79V6xYEcfxr3/962bNmvXp02cbg/Pmzevevfvuu+/eoUOHwYMHu/yBhrwaaHO5q4FyF8TlbNeLtvZqIMuBhpSK4zhKQiaTSWS7xWndunUTJ07s3r178+bNk96XXVc2m01ku9YCxSaptVASGie47ap2d+U3mH7/pnrNbvZW4vbNptMFnf3jH/+YyHa3MTv/lur8Zg+9o0V9ZhP5ehNkLYTPdhyZ5z/ofxuaKcWvd1dbC8XP+5oAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASBUKo7jKAmZTCaR7UJdstlsItu1Fig2Sa2FktA4wW1XVVXlN5hOp6va3ZXn7Ps3JTZbj693/i3V+c0eekeLpGbr9d83idkEWQtF/trY1WbZBmdoASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAqFQcx1ESMplMItuFumSz2US2ay1QbJJaCyWhcYLbrqqqym8wnU5Xtbsrz9n3b6rXdnex2fm3VOc3e+gdLUru602QtVD8s9YCOc7QAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKk4jqMkZDKZRLYLdclms4ls11qg2CS1FkpC4wS3XVVVld9gOp2uandXnrPv35TYbD2+3vm3VOc3e+gdLZKardd/3yRmE2QtFPlrY1ebpUirCcDOL5Wq81MJneysD9UEoGFjufV9SiefqglAg/fyG0dKoZ2qCUByvSy1dvrOEwB2hHomc4c/TmGoJgBFlrpU8YZTNQEovsilijScqglAUeYtVYzhVE0AijVsqaILp2oCUMRJSxVXOFUTAEKpJgDFfQiYKqLDTdUEgFCqCUDRH/yliuVwUzUBIJRqAkAo1QSgFE6WporiJK3feQJAgcVxNGFCtGFDVFYWnX12kfQvP6k4od/JkslkEtku1CWbzSayXWuBElsLqe1v3quvRg8/HD34YDRwYHTppdFJJ+W5Z8XwS8TihKTT6bz32azZQsxaC2bN5vyDl2wUbfefp56K+/ePu3SJzzjjq4/zeITcnyLgfU0ACm/8+GjYsGjSpKjEqSYAhTdgQPTII1Hv3lGJU00ACqxNm6hp0yib/eqDVq2iUuYaWgAK7IQToqVLo1NP/eoa2i5dolKmmgAUWKqEv9VkC87QAlAK3/4RF8G3nagmAIRTTQAIpZoAFP3J0rgoTs+qJgBsB9UEoLgP/uJiOdBUTQDYDqoJQBEfAsZFdKCpmpCnY4455uOPP46iqKampn379vfdd1+nTp2OPfbYyZMnJ71r0IDieJdKpmpCnvr27fvMM89EUTRlypQzzjjjjjvuePnllx9//PHx48cnvWvQsOJ410mmakKe+vXrN2HChCiKnn322fPOO69nz56XXHLJwoULx40bl/SuQYOL410kmaoJeaqsrFy+fPnKlStnzpx58sknP/LII4MGDRo9evSAAQOS3jVIQhzvCsn009shf+ecc86IESNOOOGElStXnn322S+++GLnzp0PPfTQpPcLEhLHO+antBdxMr/6QfRxQvuXyWQS2S7UJZvNbtf933333aOPPnrKlCldu3YdOXLkb3/7202bNg0cOPDqq6/ersexFij1tbClvNtZ3L38/8UJSafTee+zWbOFmE1wLRz919Py+1OKz7PZ4p/dMa/sKNqOP6XDGVoACiCO//GhZ0kcXP53qglAIcWll8ZtcA0tAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCUC9/PGPf+zatevpp59+yimnTJs2LYqiF1544dBDDz3ta7fccsvmd66uru7fv39FRUXuryNGjOjQocPIkSOjKNq0aVOvXr2qq6ujIub3awJQLwMHDpwyZcohhxwyb9683r17z5kzZ+nSpTfeeOMVV1yx9Z179+593nnnVVVV5f7685///N13362srBw6dOiYMWP69OnTokWLqIil4oR+X2gmk0lku1CXbDabyHatBUp9LXTu3PnBBx887rjjXnvttX79+n344Yd33313ZWXlOeecs/Wdly5desABB7Ro0SJ3TNm2bds//elP3bt3nzlz5sUXX/zcc8+lUqmomMUJSafTee+zWbOFmLUWzJrN2d7X8GuvvdakSZMOHTo0adLk2WefjeP4+uuvv+yyy04++eTevXu///77W49UVFTkPhg3btyJJ5742GOPXXnllTNmzIiLnvc1AaiXIUOGPPbYY7NmzXr00Ueffvrpr05jplIdO3Z85ZVX+vfvf9lll21j9uKLL54+fXplZWUURfPnz+/Vq9dTTz0VFTHvawJQL7Nmzcq90XDuuedeeeWVURRde+21bdq0iaLonHPOufzyy7c9HsfxrbfeOm7cuM6dO0+fPr1r1659+/aNipVjTQDqpbKy8i9/+UsURdOmTTv44IOjKLr55pufe+65KIpeffXVo446KoqiVatW1TX+8MMP9+7du2XLlmvWrInjePXq1VERc6wJQL088MAD1157be7E7JgxY6Io+r//9/8OGDDg3nvv3X333X/961/nDkMn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9uwoit54443NbywrK8t9sHHjxiiKGjduvGHDhnbt2m3xfzrf+c53ysrKtn2OqK7BLe5Wu8WtLV++vHv37q1bt37qqacaN25cvy+XXV3tsebatWtnz569+QU1TZo0qeeL1nKgIalmAp5//vknnnhi5MiREyZMqKqqqr39zTffzH0wc+bMZs2aHXbYYUccccSCBQsWLVq0xSO0b99+4cKFuTNUm6v9t6OuwQ4dOsydO/fLL7/M/XXWrFnfuIeLFi3q1q3bqaee+thjj9W+owMFlfeL1nKgQe2gM71sqVWrVlt/50kcx1988UXbtm2vv/763PsorVq1WrlyZe59zeOOO27+/PnvvffeUUcdNXjw4DiON27c2KlTpx49enz00UeLFi267rrr2rRps3bt2k2bNh177LEXXnjhsmXLFixYcO65555//vlxHHfu3Hn48OErV66sa7CmpqZ9+/YDBw5cvnz5Cy+80Lx5863fyPn8888PP/zwG2+8saGeKnah9zU3l3tfM/fW/jZe7XW9aGvf17QcaEiq2XBXA0VRdPnll19zzTUHH3zwqlWr4jhesWJFmzZtrr766lw1b7755m9/+9t777334MGD161bl3ucDz/88Jxzztlzzz332muvM8444+23387dvmDBgjPPPHP33Xdv2bJl//79V6xYEcfxr3/962bNmvXp02cbg/Pmzevevfvuu+/eoUOHwYMHb/3PxJ133rn1nn/xxRcN+/yxy1Vze1+0tdW0HGhIqaS+8SiTySSy3eK0bt26iRMndu/evXnz5knvy64rm80msl1rgWKT1FooDXFC0ul03vts1mwhZhNcC9X7/Cm/P6X4PJst/tmk1kJJcDUQAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIlYrjOEpCJpNJZLtQl2w2m8h2rQWKTVJroTTECUmn03nvs1mzhZi1FsyaTXYtlARnaAEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQKhUHMdREjKZTCLbhbpks9lEtmstUGySWgulIU5IOp3Oe5/Nmi3ErLVg1myya6EkOEMLAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCpeI4jpKQyWQS2S7UJZvNJrJda4Fik9RaKA1xQtLpdN77bNZsIWatBbNmk10LJcEZWgAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEKpx8D0BYPulUnV+KqEfhF4fqglAw8Zy6/uUTj5VE4AG7+U3jpRCO1UTgOR6WWrtdDUQAEWQzB3+OIWhmgAUWepSxRtO1QSg+CKXKtJwqiYARZm3VDGGMxUn9L5rJpNJZLtQl2w2m8h2rQVKeC2kCh+2Irs4KMlraKuqqvIbTKfTVe3uynP2/ZvqNVuffTYbPPvIy9fmN9v/1Pvynk2QtWC2qGaL61gwlSqqcDpDCwChVBOA4n7TMVVEb3CqJgCEUk0Aiv7gL1Ush5uqCQChVBMAQqkmAKVwsjRVFCdp/c4TAAosjqMJE6ING6Kysujss4ukf/lxrAlAgb32WvT881HfvtEzz0TTp0elTDUBKLCFC6OamqhLl+jjj7/6U8pUE4DCGz8+GjYsmjQpKnGqCUDhDRgQPfJI1Lt3VOJUE4ACa9Mmato0yma/+qBVq6iUuYYWgAI74YRo6dLo1FO/uoa2S5eolKkmAAWWKuFvNdmCM7QAbI84od92WRy/ZVM1ASCUagJAqFSc0DFvJpNJZLtQl2w2m8h2rQVKci2kUrvg6dmErwaqqqrKbzCdTtdrtt1dec6+f1Ni+7yLzT7y8rX5zfY/9b68t5sga8FsXbO72loofs7QAlDcB39xsRxoqiYAbAfVBKCIDwHjIjrQVE3I0zHHHPPx17+6oaampn379vfdd1+nTp2OPfbYyZMnJ71r0IDieJdKpmpCnvr27fvMM89EUTRlypQzzjjjjjvuePnllx9//PHx48cnvWvQsOJ410mmakKe+vXrN2HChCiKnn322fPOO69nz56XXHLJwoULx40bl/SuQYOL410kmaoJeaqsrFy+fPnKlStnzpx58sknP/LII4MGDRo9evSAAQOS3jVIQhzvCsn009shf+ecc86IESNOOOGElStXnn322S+++GLnzp0PPfTQpPcLEhLHO+ZHHxRxMlUT8tevX7+jjz56ypQpFRUVZ511VpcuXTZt2vSTn/wk6f2C5MRfBy/vdhZ3L3NUE/JUWVlZU1OT+3jo15LeIyjZdsYl0Msc1QSgAOL/CuE28lk6saylmgAUUlx6adwG19ACQCjVBIBQqgkAoVQTAEKpJgCEUk0ACJWKE7omOJPJJLJdqEs2m01ku9YCxSaptVASkvx+zaqqqvwG0+l0Vbu78px9/6aSnK3Pc1WP2Udevja/2f6n3ldyswmyFop/LexSs2yDM7QAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAPXyxz/+sWvXrqeffvopp5wybdq0KIo2bdp07bXXnnTSSaeeeur8+fO3Hpk4cWLTpk2jKBoxYkSHDh1GjhyZm+rVq1d1dXVUxPx+TQDqZeDAgVOmTDnkkEPmzZvXu3fvOXPmPPDAA82bN582bVo2mx0yZMjTTz+9+f2/+OKLO+64o6ysLIqin//85++++25lZeXQoUPHjBnTp0+fFi1aREXMsSYA9dKyZcvly5dHUbR8+fIvv/wyiqLHHntswIABURT16tWrS5cuW9z/5ptvvv766xs1+ipAZWVlf//738vLyz/77LMJEybkpoqZagJQLw888EC3bt2OOuqoU0899f7774+i6L333nvmmWdOO+2073//++edd97md37llVcWL15ce+Pw4cMvuuiiO++885ZbbvnpT3+aSqWi4qaaANTLkCFDHnvssVmzZj366KO5k7Hr1q379re//dJLL1100UUDBw6svWdNTc2QIUNyZc25+OKLp0+fXllZGUXR/Pnze/Xq9dRTT0VFzPuaANTLrFmzcr+E4Nxzz73yyiujKNp///3T6XTux+FeccUVtff83e9+98UXX1xwwQVRFK1ateqSSy4ZN25cHMe33nrruHHjOnfuPH369K5du/bt2zcqVo41AaiXysrKv/zlL1EUTZs27eCDD46i6Hvf+97LL78cRdHLL7/csWPHXCOjKLrgggveeuutl77WrFmzcePGRVH08MMP9+7du2XLlmvWrInjePXq1VERc6wJQL088MAD11771e8aSqVSY8aMiaLo9ttvHzhw4O233964ceMHH3wwdxg6efLkrWerq6uffPLJiRMnRlE0aNCgHj163HDDDVERU00A6qVjx45Tp07d/JZvfetbzz777Oa3bJ3M3PdltmjRYtKkSblbbv5aVNycoQWAUKoJAKFUEwBCpeI4jpKQu0wZikc2m01ku9YCxSaptVAa4oTkvpUnP2bNFmLWWjBrNtm1UBKcoQWAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFScRxHSchkMolsF+qSzWYT2a61QLFJai2Uhjgh6XQ67302a7YQs9aCWbPJroWS4AwtAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIlYrjOEpCJpNJZLtQl2w2m8h2rQWKTVJroTTECUmn03nvs1mzhZi1FsyaTXYtlARnaAEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQKhUHMdREjKZTCLbhbpks9lEtmstUGySWgulIU5IOp3Oe5/Nmi3ErLVg1myya6EkOEMLAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCpeI4jpKQyWQS2S7UJZvNJr0LQNGLE5JOp/PeZ7NmCzGb1FoASogztAAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIFQqjuPgOwPALs2xJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNXcqy5cvf+edd5LeCygBFgv5Uc1Cad26dWor48ePL+hGe/ToMX369PD7jxo1qkuXLlvf/sknn/Tt23evvfZq06bNHXfcsUP3Ef6bfffdt3aBlJeXH3nkkffdd1/ej1b7kq6urk6lUtvoosVCfhrnOUeAe++99/rrr2/ILa5Zs2aHPM4FF1zQtm3bhQsXzp0798wzzzzggAMuvfTSHfLIsLXRo0dfccUVURStX7/+D3/4w7nnnrv33ntffPHF9XnMFi1axHG8jTtYLOTHsWZDe+ihh5o0abJw4cIoipYtW7bXXnuNHTv2008/TaVSDz30UOvWrSsqKgYOHFi7pJcsWdK3b99mzZq1adNm8ODBtbd//PHHmUymefPm++2331VXXVVTU3Paaae9++67AwYMyC3augbfeuutU045pWnTpl27dl2wYMHWezhv3rwpU6aMGjWqoqLiuOOOO/300//jP/6jAZ8hdl1lZWVnnXVW9+7ds9ns0qVLU6nUsGHDKioq+vfvv70v6c2PNS0WdqSYwmjVqtW99977jZ/63ve+d9VVV8VxfN11151++ulxHC9btiyKovbt28+aNWvevHkdO3b80Y9+lLvzSSed1L9//2XLls2bN69bt26XX355HMcbNmw46qijzjvvvE8++WTu3LndunW76aab4jiurKwcO3bsNgbXrFnTtm3bf/qnf/rss8+eeeaZpk2bnnjiiXV9CevXr3/xxRf32WefZ555pjBPEsQtW7YcPXr05rf06NHj4osvXrJkSRRF6XR65cqVH3744fa+pD///PMoit5++22LhR1LNQulVatWW/wPym677Zb71Ny5c1u0aHHPPfdUVFTMnTu3tprZbDZ3h8mTJ5eXl69atWrq1Kl77LFHTU1N7vYZM2Y0atRozZo1U6dOLS8vX758+RYbrf2HoK7BqqqqioqK1atX527/8Y9/vI1/CCorK5s0aXLaaactW7asAM8QbFnN6urqsWPHNmrU6LnnnstVc+LEiblPbe9LuraaFgs7ljO0BbTFseaGDRtyt7dr127o0KGDBw++4YYb2rVrV3v/2msNjjnmmHXr1s2bN2/OnDmrV69u0qRJ7lqJ448/ftOmTfPnz3/rrbdat269zz771LXpugbnzJlz2GGHNW3aNHe3Tp06bWP/33nnneXLl++xxx5nnXXWDnpK4BtceeWVuRfq/vvvP2rUqPvvv79Xr165T7Vt27aeL2mLhR1LNZMxe/bsKIreeOONzW8sKyvLfbBx48avrtRq3HjDhg3t2rXb4v90vvOd75SVlaVSqW08fl2DW9ytdot12XPPPW+55ZZXX3118eLF+X6t8A/UHmuuXbt29uzZuSuDcpo0aVLPl7TFwo6lmgl4/vnnn3jiiZEjR06YMKGqqqr29jfffDP3wcyZM5s1a3bYYYcdccQRCxYsWLRo0RaP0L59+4ULF+bOQW2u9l+HugY7dOgwd+7cL7/8MvfXWbNmbb17kyZNqqioqKmpyf31s88+22233Vq0aFG/LxrqJe+XtMXCDraDzvQSejXQF1980bZt2+uvvz73TkmrVq1WrlyZe1/zuOOOmz9//nvvvXfUUUcNHjw4juONGzd26tSpR48eH3300aJFi6677ro2bdqsXbt206ZNxx577IUXXrhs2bIFCxace+65559/fhzHnTt3Hj58+MqVK+sarKmpad++/cCBA5cvX/7CCy80b95867dq1qxZ0759+6uuuqq6uvpvf/vbkUceeemllzbU08YuZ+urgXJy72vm3vjfxlqo6yVd+76mxcKOpZoNdzVQFEWXX375Nddcc/DBB69atSqO4xUrVrRp0+bqq6/OVfPmm2/+9re/vffeew8ePHjdunW5x/nwww/POeecPffcc6+99jrjjDPefvvt3O0LFiw488wzd99995YtW/bv33/FihVxHP/6179u1qxZnz59tjE4b9687t2777777h06dBg8ePA3XuDw/vvv9+zZc6+99mrbtu2wYcPWrFnTgM8cu5bAam7vS7q2mhYLO1Zq298IXB+ZTKZAj7zzWbdu3cSJE7t37968efOk94Vvls1mE9mudUSxySa0FopFXDDpdDrvvdrVZnv27JnIds0Ww0r5h+soPv2E/P6U4vNstvhn412bq4EAIJRqFoXy8vKkdwGAf0w1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAECoVx3FUGJlMpkCPDA0vm80msl3riGKTTWgtFInGBX30qqqq/AbT6XRJzra7K8/Z928qya93V5pNUMk9V9bRzj27i3OGFgBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhErFcRwVRiaTKdAjQ8PLZrOJbNc6othkE1oLRaJxQR+9qqoqv8F0Ol2v2XZ35Tn7/k0luV2zhZ9NkHXUQNs1SwBnaAEglGoCQCjVBIBQqgkAoVQTAEKpJgCE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pZoAEEo1ASCUagJAKNUEgFCpuB7X9WYymbxnYWeSzWYT2a41SLHJJrQWGk5cD+l0Ou/tlujsbXPj/P6U6NdrtgHWkTVodmeajXd2ztACQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaACRm06ZN11577UknnXTqqafOnz8/iqIVK1ak0+lu3bql0+kVK1ZsPTJx4sSmTZtGUTRixIgOHTqMHDky9zi9evWqrq4u9A6rJgCJeeCBB5o3bz5t2rRBgwYNGTIkiqLhw4efeuqpr7zyyimnnHLnnXducf8vvvjijjvuKCsri6Lo5z//+X/8x3/cc889URSNGTOmT58+LVq0KPQOqyYAiXnssccGDBgQRVGvXr26dOmSO5Q8//zzoyg6//zzf//7329x/5tvvvn6669v1OireJWVlf39738vLy//7LPPJkyYkHucQlNNABLz3nvvPfPMM6eddtr3v//98847L4qiTz755IADDoii6MADD/zkk082v/Mrr7yyePHi3N1yR6UXXXTRnXfeecstt/z0pz9NpVINsMOqCUBi1q1b9+1vf/ull1666KKLBg4cuI171tTUDBky5P7776+95eKLL54+fXplZWUURfPnz+/Vq9dTTz1V6B1uXOgNAEBd9t9//9yPvU2n01dccUXulqVLlx500EFLlizZf//9a+/5u9/97osvvrjggguiKFq1atUll1wybty4OI5vvfXWcePGde7cefr06V27du3bt29USI41AUjM9773vZdffjmKopdffrljx45RFPXs2fO3v/1tFEW//e1ve/bsmWtkFEUXXHDBW2+99dLXmjVrNm7cuCiKHn744d69e7ds2XLNmjVxHK9evbrQO+xYE4DE3H777QMHDrz99tsbN2784IMPRlH0v//3//7hD3/49NNP77vvvr/5zW+iKDr33HMnT5689Wx1dfWTTz45ceLEKIoGDRrUo0ePG264odA7rJoAJOZb3/rWs88+u/ktFRUVVVVVm9+ydTJz35fZokWLSZMm5W65+WuF319naAEgmGoCQCjVBIBQqTiOo3xlMpm8Z2Fnks1mE9muNUixySa0FhpMfa8G2uI923DpdDqp2Y4j8/yP+rehmfrMluJzZbb4ldxzZXbnnt3pOUMLAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCpeI4jvKVyWTynoWdSTabTWS71iDFJpvQWmgwjes5X1VVld9gOp2uz2zHkXn+h/nb0ExS+2x2J55NkDVotqhmd3rO0AJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCpOI6jfGUymbxnYWeSzWYT2a41SLHJJrQWGkzjes5XVVXlN5hOp5Oa7Tgyz/+ofxuaqc9sKT5XZotfyT1XZnfu2Z2eM7QAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASBUKo7jKF+ZTCbvWdiZZLPZpHcBaBBxPaTT6by3a9bszjRbn3UElBBnaAEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQKhUHMdRvjKZTN6zsDPJZrNJ7wLQIOJ6SKfTeW/XrNmdabY+6wgoIc7QAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKk4jqN8ZTKZvGdhZ5LNZpPeBaBBxPWQTqfz3q5ZszvTbH3WEVBCnKEFgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChUnEcB98ZAHZpjjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAKND/BzKkf5JaRj+SAAAAAElFTkSuQmCC"
          },
          {
            "type": "input_text",
            "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
          }
        ]
      },
      {
        "type": "message",
        "role": "assistant",
        "content": [
          "Let's analyze the examples further with the feedback in mind:\n\n1. The blue shape (value 1) is always kept unchanged as a fixed figure in the output.\n2. The duplicated secondary shapes tend to appear in output as an *expanded* cluster in a different location, not just flipped or moved simply.\n3. The \"green\" cluster (value 3), \"pink\" cluster (value 6), \"red\" cluster (value 2), or \"light blue\" cluster (value 8) in the input are:\n   - Recreated in output in a **different corner or edge**,\n   - The duplicates often form small rectangles or block shapes that approximate or extend the input cluster shape, often 3\u00d73 or similar small solid blobs.\n   - The duplicated clusters fill more area than their input counterpart (they tend to be expanded versions of those clusters).\n4. Original colored clusters (non-blue) remain at their input positions \u2014 no removal.\n5. The output is always 11\u00d711.\n\n---\n\n### Hypothesis refined:\n\n- Keep blue cluster unchanged.\n- For each non-blue color cluster:\n   - Copy the cluster pixels unchanged to output at their input positions.\n   - Create a **new solid block region** of roughly the same general size, scaled up or enlarged to a rectangular shape, placed in a specific \"other\" quadrant/corner.\n   - This new solid block uses the same color as the cluster and covers more space than original cluster.\n   - The placement corner depends on input cluster position (generally opposite corner or adjacent edge).\n- The lower-left cluster in example 1 (color 8) is a 3\u00d73 block that appears enlarged into a roughly 3\u00d73 block in output, but shifted left or bottom.\n- The green cluster (3) in example 1 is expanded into a roughly 3\u00d73 block in output, positioned top right.\n\n---\n\n### Implementation Plan:\n\n- Identify clusters (connected sets) of unique colors aside from blue.\n- For each cluster:\n  - Determine bounding box.\n  - Copy original cluster pixels as is.\n  - Compute a target quadrant/corner for duplication:\n    - If cluster mostly top-left, duplicate to top-right or bottom-left.\n    - If cluster mostly top-right, duplicate to bottom-left or bottom-right.\n    - Choose a rectangle in target to place a filled solid rectangle of cluster's color.\n  - The duplicated block size is max(width, height) of the bounding box, or at least 3\u00d73 if smaller.\n  - Place duplicated block with some padding from edges so it does not overlap original.\n- Preserve blue cluster pixels at all times.\n\n---\n\n### This approach improves handling of cluster expansion and placement shown clearly in training examples.\n\n---\n\n### Code follows:\n\n```python\ndef transform(grid):\n    import numpy as np\n\n    arr = np.array(grid)\n    h, w = arr.shape\n    target_size = 11\n    # Normalize size to 11 x 11 (crop or pad as needed)\n    norm = np.zeros((target_size, target_size), dtype=int)\n    norm[:h, :w] = arr[:target_size, :target_size]\n    arr = norm\n\n    output = np.zeros_like(arr)\n\n    # Blue cluster color\n    blue_color = 1\n\n    # Copy blue cluster pixels directly\n    blue_mask = (arr == blue_color)\n    output[blue_mask] = blue_color\n\n    # Find all colors excluding 0 and blue\n    colors = set(np.unique(arr))\n    colors.discard(0)\n    if blue_color in colors:\n        colors.discard(blue_color)\n\n    def get_quadrant(r, c):\n        # quadrants by midline indices (0-based)\n        mid = target_size // 2\n        if r < mid and c < mid:\n            return 'TL'\n        elif r < mid and c >= mid:\n            return 'TR'\n        elif r >= mid and c < mid:\n            return 'BL'\n        else:\n            return 'BR'\n\n    def opposite_quadrant(q):\n        mapping = {'TL': 'BR', 'TR': 'BL', 'BL': 'TR', 'BR': 'TL'}\n        return mapping[q]\n\n    def quadrant_bounds(q):\n        mid = target_size // 2\n        if q == 'TL':\n            return (0, mid), (0, mid)\n        elif q == 'TR':\n            return (0, mid), (mid, target_size)\n        elif q == 'BL':\n            return (mid, target_size), (0, mid)\n        else:  # BR\n            return (mid, target_size), (mid, target_size)\n\n    for color in colors:\n        mask = (arr == color)\n        if not np.any(mask):\n            continue\n        rows, cols = np.where(mask)\n        min_r, max_r = rows.min(), rows.max()\n        min_c, max_c = cols.min(), cols.max()\n\n        # Copy original cluster pixels as is\n        output[min_r:max_r+1, min_c:max_c+1][arr[min_r:max_r+1, min_c:max_c+1] == color] = color\n\n        # Determine cluster center to assign quadrant\n        center_r = int(np.mean(rows))\n        center_c = int(np.mean(cols))\n        orig_quad = get_quadrant(center_r, center_c)\n        targ_quad = opposite_quadrant(orig_quad)\n\n        # Compute bounds of target quadrant\n        (r_start, r_end), (c_start, c_end) = quadrant_bounds(targ_quad)\n\n        # Decide rectangle size for duplicate block:\n        height = max_r - min_r +1\n        width = max_c - min_c +1\n        block_size = max(height, width)\n        if block_size < 3:\n            block_size = 3\n\n        # Place duplication block inside target quadrant with padding of 1\n        block_r_start = r_start + 1\n        block_c_start = c_start + 1\n\n        # Ensure block doesn't overflow quadrant\n        if block_r_start + block_size > r_end:\n            block_r_start = r_end - block_size\n        if block_c_start + block_size > c_end:\n            block_c_start = c_end - block_size\n\n        # Draw solid block of color in output\n        for rr in range(block_r_start, block_r_start + block_size):\n            for cc in range(block_c_start, block_c_start + block_size):\n                output[rr, cc] = color\n\n    return output.tolist()\n```\n\nThis improved solution:\n\n- Keeps blue cluster intact.\n- Duplicates each secondary cluster as a solid block in the opposite quadrant.\n- Duplication block size expands original cluster roughly but minimally 3\u00d73.\n- Block placed safely to avoid overlap outside quadrant.\n- Preserves original clusters in output.\n\nThis covers all training examples better, capturing spatial duplication and expansion. It should generalize well to test inputs with similar structure.\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n\n    arr = np.array(grid)\n    h, w = arr.shape\n    target_size = 11\n    # Normalize size to 11 x 11 (crop or pad as needed)\n    norm = np.zeros((target_size, target_size), dtype=int)\n    norm[:h, :w] = arr[:target_size, :target_size]\n    arr = norm\n\n    output = np.zeros_like(arr)\n\n    # Blue cluster color\n    blue_color = 1\n\n    # Copy blue cluster pixels directly\n    blue_mask = (arr == blue_color)\n    output[blue_mask] = blue_color\n\n    # Find all colors excluding 0 and blue\n    colors = set(np.unique(arr))\n    colors.discard(0)\n    if blue_color in colors:\n        colors.discard(blue_color)\n\n    def get_quadrant(r, c):\n        # quadrants by midline indices (0-based)\n        mid = target_size // 2\n        if r < mid and c < mid:\n            return 'TL'\n        elif r < mid and c >= mid:\n            return 'TR'\n        elif r >= mid and c < mid:\n            return 'BL'\n        else:\n            return 'BR'\n\n    def opposite_quadrant(q):\n        mapping = {'TL': 'BR', 'TR': 'BL', 'BL': 'TR', 'BR': 'TL'}\n        return mapping[q]\n\n    def quadrant_bounds(q):\n        mid = target_size // 2\n        if q == 'TL':\n            return (0, mid), (0, mid)\n        elif q == 'TR':\n            return (0, mid), (mid, target_size)\n        elif q == 'BL':\n            return (mid, target_size), (0, mid)\n        else:  # BR\n            return (mid, target_size), (mid, target_size)\n\n    for color in colors:\n        mask = (arr == color)\n        if not np.any(mask):\n            continue\n        rows, cols = np.where(mask)\n        min_r, max_r = rows.min(), rows.max()\n        min_c, max_c = cols.min(), cols.max()\n\n        # Copy original cluster pixels as is\n        output[min_r:max_r+1, min_c:max_c+1][arr[min_r:max_r+1, min_c:max_c+1] == color] = color\n\n        # Determine cluster center to assign quadrant\n        center_r = int(np.mean(rows))\n        center_c = int(np.mean(cols))\n        orig_quad = get_quadrant(center_r, center_c)\n        targ_quad = opposite_quadrant(orig_quad)\n\n        # Compute bounds of target quadrant\n        (r_start, r_end), (c_start, c_end) = quadrant_bounds(targ_quad)\n\n        # Decide rectangle size for duplicate block:\n        height = max_r - min_r +1\n        width = max_c - min_c +1\n        block_size = max(height, width)\n        if block_size < 3:\n            block_size = 3\n\n        # Place duplication block inside target quadrant with padding of 1\n        block_r_start = r_start + 1\n        block_c_start = c_start + 1\n\n        # Ensure block doesn't overflow quadrant\n        if block_r_start + block_size > r_end:\n            block_r_start = r_end - block_size\n        if block_c_start + block_size > c_end:\n            block_c_start = c_end - block_size\n\n        # Draw solid block of color in output\n        for rr in range(block_r_start, block_r_start + block_size):\n            for cc in range(block_c_start, block_c_start + block_size):\n                output[rr, cc] = color\n\n    return output.tolist()\n```"
        ]
      },
      {
        "role": "user",
        "content": [
          {
            "type": "input_text",
            "text": "Please analyze the training feedback and programs from all prior turns, and write an improved transformation.\n\n**Important**:\n1. Always start by attempting to find a complete rule that solves all training examples and should generalize to the test input.\n2. If you cannot find a perfect solution, provide your best attempt at a transformation that solves as many training examples as possible - ideally more than in the best previous turn.\n3. Even if your solution doesn't solve all examples perfectly, ensure it demonstrates meaningful pattern recognition and provides reasonable outputs that minimize pixel-level errors.\n\nFinal answer:\n```python\ndef transform(grid):\n    # Your improved transformation logic here (even if partial)\n    return transformed_grid\n```"
          },
          {
            "type": "input_text",
            "text": "Training results: 0/4 examples solved, 70.3% pixel accuracy - Good partial progress! Your approach is capturing some patterns. Next, try to identify a transformation that solves at least one of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[1, 1, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 1, 1, 1, 0, 3, 3, 3, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 1, 1, 1, 0, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 0, 8, 8, 8, 0, 0], [0, 1, 0, 0, 0, 0, 8, 8, 8, 0, 0], [0, 1, 1, 1, 0, 0, 8, 8, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 78.5%\n\nTraining Example 2 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 1, 0, 0, 0, 0, 0, 0, 6, 0], [0, 1, 1, 1, 1, 0, 0, 6, 6, 6, 6], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 6, 0], [0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 80.3%\n\nTraining Example 3 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 1, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 1, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 72.2%\n\nTraining Example 4 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 8, 8, 8, 0, 0], [0, 0, 1, 0, 0, 0, 8, 8, 8, 0, 0], [0, 0, 0, 1, 1, 0, 8, 8, 8, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 56.0%\n\n\u26a0\ufe0f  GRID SIZE ERROR: One or more of your output grids are incorrect in size. They should ALL be 11\u00d711 for this task.\n\n"
          },
          {
            "type": "input_image",
            "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAmcAAATYCAIAAADVnPfcAABROElEQVR4nO3de5RU5Z3o710IjSjYCCoql3hBWnNQRLwgQaOBs46CaJWAMfEGQeMlqAFFZYboiYGIQnRiYtAjCio6OjpWowQJmiDGBNQooyBeEFBBwCDaIALNbf9WrN/0YsAmL9VU72p4nsUfbfX+1t5d1MvHvau6OxXHcQQABKgXshEAoJoAsANUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAKiVag4cODBVvQsvvPAbtykpKTnwwAPPPvvsN954Y9v7fP7551OpVLNmzdatW7fVp5566qlUKjV27Njcf/br1y+VSo0aNWqrzRYvXpxKpYYNG1aTqZx169bdd999p59++sEHH9ywYcODDz64b9++f/7zn7fzmAwbNqy6B2TOnDnbf9C6d+/+Tx/Yqm0uvfTSLW/PHV7v3r1nzJix5fGk0+mtNjv00EOvueaaL774Yoce/JzPPvts+PDhHTt2LC0t3XvvvU888cSxY8du+Wtzcrvbavz111/ff//9mzRpMm3atO08dADFL4FzzQ0bNnz66afPPvvs6aefvmDBgq0+++CDD0ZR9MUXXzzxxBMh93bzzTe/++67O3oMIVMffvjhySeffMUVV7z44otLly5dv3790qVLn3rqqVNPPfXOO++Mikzu8J5++umuXbs++uij29nsww8//M1vfnPGGWds3rx5hx78GTNmdOjQ4Wc/+9l//dd/rVq1as2aNa+99tpll102YMCA7RzYn/70p9NPP33Tpk0vvPDC6aefXoMvEaCOV/O3v/1t/N+efPLJKIrGjRtXdcuECROqtly4cGHV7evWrXvnnXd++MMfrlq1asyYMVveYUVFRXl5ed++fZs1a3bvvfeGHMP69ev79eu3adOmHTryfzq1YcOGPn36/Nd//VeXLl2eeeaZzz77bMOGDR9//PHvfve7Zs2a3XDDDbkTx+rMmjUr3kb79u2/8QGp8sILL2x5JyHbLF26NHf72rVrP/jgg5tuuimO4x/96EcfffTRlputXbt2ywe/e/fur7766vPPPx/+4P/973/PZDJLliz5wQ9+MHPmzFWrVn3++efl5eWHHXbYuHHj7rvvvm98HLLZbI8ePfbaa68XX3zxpJNO2s4jBlAnJHCu2bBhwyOPPPL222+Pomirc83HHnts3bp1l19+ef/+/WfOnPnWW2/903u7+uqrX3nllV/96lc7dAz/dOqhhx56/fXXu3fv/tJLL/Xq1at58+b169dv3br1lVde+fTTT2/atOnf//3fo2Ky5557Hn744bfddtvNN9+8fv36f/u3f9vOg//Tn/40V9zwB//OO+/89NNPBw0a9Nhjj5100klNmjTZd999zznnnOnTp++999533nnntr/e/IEHHujbt+8BBxzw5z//+Zhjjqm6ffz48alU6re//e1OfQAAdtFqVlZWvv3224MHD46iqF27dlt+aty4cUcdddT3vve9K6+8co899gg53fzlL3/Ztm3bm2+++Z133gk/hn869dhjj6VSqf/3//7fHnvssdWnvvvd786dO3f48OFRUbruuuv22muvP/zhD9/42Q0bNrz//vt33313/fr1v/vd74Y/+P/xH//RqFGjW2+9das7bNWq1csvv/ziiy+mUqktb7/jjjsuvfTSww477OWXXz7iiCN23tcHsBtU89BDD616Q8qee+7Zvn37J598cr/99rv22murtpkzZ87f/va3IUOGpFKpww8/vG/fvo8++ujq1au3f8977bXXuHHjNmzYsEPXaf/p1KxZs4466qhDDz30G8ePOuqorSKxlY4dO271Lp6XX365ugekyosvvrij22yrSZMmRxxxxFYn8Y0aNcqNl5SUlJWV/eUvf3nooYe2/Oq2/+Bv2LDhww8/PPHEExs3brztHo899tiDDjpoy1tuuOGGG2+8MYqiU045pU2bNltt369fvziOBw4cuP0vBKAIJfOdJy1btvzRj3705ptvHnjggVU3Pvjggy1btrzgggty/zl06NAvv/wy5EJo165dr7nmmldffXX06NHhx7CdqQ0bNlRUVLRo0WLLG7d6X+shhxwSFavmzZtXfq26DTZt2jRz5swNGzYEPvgVFRVxHDdv3jzwAH7zm9+cfPLJ3bt3f/DBB59++umafTUAu181c29sWb9+/eOPP547GRo5cuTBBx9ctcGGDRsmTJjwySefNGzYMJelDh06xHEc+J6gX/7yl0ccccQtt9wyd+7c8KOqbqpBgwZNmjRZvnx5lK9t3w3UtWvXf/pOn9NOO21Ht/lGX3zxRYMGDRo2bLjtu4HWr1+/YMGCn/zkJ7/5zW+uv/76wAe/WbNm9erVC39A+vfv/+KLLz788MPNmjW77LLLPvnkk8BBgCJXq+eaDRo0+P73v//EE09Mnz79jDPO2PK7+iZNmvSN/yi/8cYbr7322j+950aNGuVxnXY7U0cfffTcuXM//vjjb3zDcKdOnaJitXr16jlz5hx11FHf+NkGDRoceuiho0ePbt++/fjx4wMf/D322OOoo47629/+tmbNmm03u+222y6++OIlS5ZU3fK73/2upKTkoIMO+u1vf/v5559ffPHF236XC0BdlMAV2jPPPPPqq69+4403qs51clcI99xzz5UrV255XvXXv/41iqLqvqthK9/5zneuvfba1157bdufYJDH1AUXXLB58+arrrrqGxu87ftFi8ddd921YcOGM844Y/ub1atXb/Xq1Rs3bgx88NPp9Nq1a//v//2/W93Phx9+eMcdd0yaNOkbr9/+4Ac/6NOnz5/+9KcdungOULSSeV3zl7/8ZZs2bcaMGfPKK69EUbRs2bIpU6b06tVrn3322XKzk08+uays7N///d9XrlwZcrcjRow44ogjfve73+3QwXzj1KWXXtqpU6ff//73J5544n/8x38sW7Zsw4YNuZ9y0LNnzzfeeKNeveL6YYSVlZXvvffesGHDfv7zn++1117VvdcmjuPFixcPGTLkrbfe6tixY/369QMf/EGDBjVv3nzUqFEXX3zx3/72t7Vr13766aePPfbYaaedVlFRMWTIkC0vCG9pzJgxLVq0GDZs2Ouvv16YLx2g9iTzT//ee+/9m9/8ZvPmzZdffvnGjRsffvjhjRs3Vr0VZUuXXHLJmjVrHnnkkfArrtt/d2vgVElJSXl5+cknn/zGG298//vfP+igg0pKSnI/UW/y5MllZWWBP7qoOt/4/thUKrXle4ZDtjnooIOq3pl85JFHjhgxIvfjA1u3br3V15jbrF69eq1btx49enS9evVy3zwT+OA3b978iSeeaNKkySOPPHLCCSfstddeBx544AUXXPDRRx9lMpkbbrihuq90v/32u//++zds2PDDH/7wq6++8v2aQJ2W2AnT2WefnU6n33zzzX/7t38bP378vvvue+aZZ2672cUXX1yvXr3Ai7S5K665b+HfId841apVqz//+c8TJkzo0aNHq1atSkpKWrRo0aNHj4ceemjOnDknnHBCVEwaNGjQunXr888//y9/+csPfvCD6jbbY489DjjggJ49ez7//PO5q7jhD363bt1mzZp1zTXXHHnkkY0bN27UqNFJJ500duzY//zP/9z2u1q31KtXr379+r3//vtbfqMRQF2UKuaX6ACgqBTXi3MAUMxUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmruUFStWvPvuu0kfBRQFy4FCUM1CadWqVWobEyZMKOhOu3fvPnPmzPDtR48e3blz5+o+W1FRcdhhh+3QHcK29ttvv6olUFJSctRRR919991531vVk7aioiKVSm2ni5YDhaCaBXTXXXfF/9OFF15Y0D2uXbt2Z93VokWLunfvvnDhwp11h+zOxowZk1sCX3311ahRo66//vpHHnmkhvfZtGnTOI6PPPLI6jawHCgE1axtDzzwQMOGDRctWhRF0fLly/fZZ59x48Z99tlnqVTqgQceaNWqVWlp6YABA6oW/NKlS/v06dO4cePWrVsPHjy46vZPPvkkk8k0adJk//33v+qqqyorK0877bT33nuvf//+l1566XYG33777VNOOaVRo0ZdunSp7l+B3//+9+3bt+/UqVNtPSrsLho0aHDWWWd169Ytm80uW7YslUoNHTq0tLS0X79+O/qk3fJc03Kg1qhmbRswYEDXrl1HjhwZRdGIESOOP/74/v375z51xx13TJkyZdasWa+//vrAgQNzN/bu3btJkyYffvjh9OnTX3vttUGDBkVRtGnTpjPPPLOkpGT+/PkzZsyYPXv2Lbfc8uKLL5aVlY0bN27s2LHVDa5bt65Hjx4dOnRYsmTJ0KFDx40b940H2bBhwxdeeOGee+6pxQeG3cjGjRsbN26c+/jdd99dvHjxrbfemveT1nKgVm11CZGdpWXLlls91HvssUfuU/PmzWvatOmdd95ZWlo6b968OI6XL18eRVE2m81tMHXq1JKSktWrV0+fPn2vvfaqrKzM3f7aa6/Vq1dv7dq106dPLykpWbFixVY7zf0zEcdxdYPl5eWlpaVr1qzJ3f7jH//4pJNOqu5L2LBhQxRFM2bMKMDDw26kefPmVVdoKyoqxo0bV69evUmTJi1dujSKosmTJ+c+taNP2i+++CKKonfeecdyoDY516y91zU3btyYu71t27ZDhgwZPHjwdddd17Zt26rtq96JcOyxx65fv37+/Plz585ds2ZNw4YNc++kOOGEEzZv3rxgwYK33367VatWzZo1q27X1Q3OnTv38MMPb9SoUW6zjh07FvgxgH+48sorc0/FFi1ajB49+p577unZs2fuU23atKnhk9ZyoDapZjLmzJkTRdEbb7yx5Y0NGjTIfbBp06YoiurXr79x48a2bdtu9X863/72txs0aJBKpbZz/9UNbrVZ1R6hoKrONdetWzdnzpwrrrii6lMNGzas4ZPWcqA2qWYCnnvuuSeeeGLUqFETJ04sLy+vuv2tt97KfTBr1qzGjRsffvjhRx555MKFCxcvXrzVPbRr127RokW5K1Rbqvq3o7rB9u3bz5s376uvvsr95+zZs3f2Fwd5yvtJazlQm1Sztq1evfqKK6645pprrr/++ssuu2zgwIFffvll7lM33HDDwoUL582bd+ONN/74xz9u2LDh9773vWOOOaZ///6LFi365JNPfvrTn7Zp06aysvKUU05p37791Vdf/dlnn3344Ye9e/f+wQ9+EEXR3nvvvWTJki+//LK6wf/zf/7PQQcddO21137++ecvvPDCgw8+mPTjAf+/vJ+0lgO1aie9Pso/fzdQFEWXX3751Vdffcghh6xevTqO45UrV7Zu3XrgwIG5dwPddNNN3/rWt/bdd9/BgwevX78+dz8fffTROeecs/fee++zzz5nnHHGO++8k7t94cKFZ5555p577tm8efN+/fqtXLkyjuP777+/cePGvXv33s7g/Pnzu3Xrtueee7Zv337w4MHe/kBtvhtoS7l3A+XeEJezQ0/aqncDWQ7UplQcx1ESMplMIvstTuvXr588eXK3bt2aNGmS9LHsvrLZbCL7tRYoNkmthTqhfoL7Lm97e36D6Q9urNHsFi8l7thsOl3Q2T/+8Y+J7Hc7swuGVeQ3e9jwpjWZTeTrTZC1YLaoZtkOr2sCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqTiOoyRkMplE9gvVyWaziezXWqDY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AIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUau5SVqxY8e677yZ9FFAULAcKQTULpVWrVqltTJgwoaA77d69+8yZM8O3Hz16dOfOnbe9fd68eWeddVbTpk0POuigyy+/fNWqVTv1MNm97LffflVLoKSk5Kijjrr77rvzvreqJ21FRUUqldpOFy0HCkE1C+iuu+6K/6cLL7ywoHtcu3Ztze9kw4YNZ5111iGHHLJw4cI///nPr7/++hVXXLEzjo7d15gxY3JL4Kuvvho1atT111//yCOP1PA+mzZtGsfxkUceWd0GlgOFoJq17YEHHmjYsOGiRYuiKFq+fPk+++wzbty4zz77LJVKPfDAA61atSotLR0wYEDVgl+6dGmfPn0aN27cunXrwYMHV93+ySefZDKZJk2a7L///ldddVVlZeVpp5323nvv9e/f/9JLL93O4Ntvv33KKac0atSoS5cuCxcu3PYIX3vttQULFtx555377rtv27Ztb7nllokTJ8ZxXIsPErusBg0anHXWWd26dctms8uWLUulUkOHDi0tLe3Xr9+OPmm3PNe0HKg1qlnbBgwY0LVr15EjR0ZRNGLEiOOPP75///65T91xxx1TpkyZNWvW66+/PnDgwNyNvXv3btKkyYcffjh9+vTXXntt0KBBURRt2rTpzDPPLCkpmT9//owZM2bPnn3LLbe8+OKLZWVl48aNGzt2bHWD69at69GjR4cOHZYsWTJ06NBx48Zte4RdunTZsGFDSUlJ7j+XLl3arFmzVCpViw8Su7iNGzc2btw49/G77767ePHiW2+9Ne8nreVArdrqEiI7S8uWLbd6qPfYY4/cp+bNm9e0adM777yztLR03rx5cRwvX748iqJsNpvbYOrUqSUlJatXr54+ffpee+1VWVmZu/21116rV6/e2rVrp0+fXlJSsmLFiq12mvtnIo7j6gbLy8tLS0vXrFmTu/3HP/7xSSedtJ2voqKi4tBDD73lllt29sPDbqR58+ZVV2grKirGjRtXr169SZMmLV26NIqiyZMn5z61o0/aL774Ioqid955x3KgNjnXrL3XNTdu3Ji7vW3btkOGDBk8ePB1113Xtm3bqu2r3olw7LHHrl+/fv78+XPnzl2zZk3Dhg1z76Q44YQTNm/evGDBgrfffrtVq1bNmjWrbtfVDc6dO/fwww9v1KhRbrOOHTtu5/i/+uqrXr16tW/fftiwYTvpIWE3deWVV+aeii1atBg9evQ999zTs2fP3KfatGlTwyet5UBtUs1kzJkzJ4qiN954Y8sbGzRokPtg06ZNURTVr19/48aNbdu23er/dL797W83aNBg+9eIqhvcarOqPW5rxYoV3bp1a9Wq1VNPPVW/fv2afbns7qrONdetWzdnzpwt31DTsGHDGj5pLQdqk2om4LnnnnviiSdGjRo1ceLE8vLyqtvfeuut3AezZs1q3Ljx4YcffuSRRy5cuHDx4sVb3UO7du0WLVqUu0K1pap/O6obbN++/bx587766qvcf86ePfsbj3Dx4sVdu3Y99dRTH3300apXdKCg8n7SWg7Uqp10pZettWzZctvvPInj+Msvv2zTps1Pf/rT3OsoLVu2XLVqVe51zeOPP37BggXvv//+0UcfPXjw4DiON23a1LFjx+7du3/88ceLFy++9tprW7duvW7dus2bNx933HEXXHDB8uXLFy5ceO65555//vlxHHfq1GnEiBGrVq2qbrCysrJdu3YDBgxYsWLF888/36RJk21fyPniiy+OOOKIG264obYeKnaj1zW3lHtdM/fS/nae7dU9aate17QcqE2qWXvvBoqi6PLLL7/66qsPOeSQ1atXx3G8cuXK1q1bDxw4MFfNm2666Vvf+ta+++47ePDg9evX5+7no48+Ouecc/bee+999tnnjDPOeOedd3K3L1y48Mwzz9xzzz2bN2/er1+/lStXxnF8//33N27cuHfv3tsZnD9/frdu3fbcc8/27dsPHjx4238mbrvttm2P/Msvv6zdx4/drpo7+qStqqblQG1KJfWNR5lMJpH9Fqf169dPnjy5W7duTZo0SfpYdl/ZbDaR/VoLFJuk1kLdECcknU7nfcxmzRZi1lowazbZtVAneDcQAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIlYrjOEpCJpNJZL9QnWw2m8h+rQWKTVJroU6on+C+y8vL8xtMp9Nmze702QTV5Osd/9I1+c32O/XupGbr3HNjd5tlO1yhBYBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVJxHEdJyGQyiewXqpPNZhPZr7VAsUlqLdQJ9RPcd3l5eX6D6XTarNmdPpugmny941+6Jr/ZfqfendRsnXtu7G6zbIcrtAAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIFQqjuMoCZlMJpH9QnWy2Wwi+7UWKDZJrYU6oX6C+y4vL89vMJ1OmzW702cTVJOvd/xL1+Q32+/Uu5OarXPPjd1tlu1whRYAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmANSFn6gHwK4vlar2Uwn9IPSaUE0AajeW225Td/KpmgDUei+/caQutFM1AUiul3Wtnd4NBEARJHOn309hqCYARZa6VPGGUzUBKL7IpYo0nKoJQFHmLVWM4UzFCb3umslkEtkvVCebzSayX2uBOrwWUoUPW5G9OSjJ99CWl5fnN5hOp8vb3p7n7Ac31mi2JsdsNnh2/EvX5Dfb79S7855NkLVgtqhmi+tcMJUqqnC6QgsAoVQTgOJ+0TFVRC9wqiYAhFJNAIr+5C9VLKebqgkAoVQTAEKpJgB14WJpqigu0vqdJwAUWBxHEydGGzdGDRpEZ59dJP3Lj3NNAArs1Vej556L+vSJnnkmmjkzqstUE4ACW7QoqqyMOneOPvnkH3/qMtUEoPAmTIiGDo2mTInqONUEoPD694/Gj4969YrqONUEoMBat44aNYqy2X980LJlVJd5Dy0ABXbiidGyZdGpp/7jPbSdO0d1mWoCUGCpOvytJltxhRaAHREn9Nsui+O3bKomAIRSTQAIlYoTOufNZDKJ7Beqk81mE9mvtUCdXAup1G54eTbhdwOVl5fnN5hOp2s02/b2PGc/uDGxY97NZse/dE1+s/1OvTvv/SbIWjBb3ezuthaKnyu0ABT3yV9cLCeaqgkAO0A1ASjiU8C4iE40VRPydOyxx37y9a9uqKysbNeu3d13392xY8fjjjtu6tSpSR8a1KI43q2SqZqQpz59+jzzzDNRFE2bNu2MM84YPnz4Sy+99Nhjj02YMCHpQ4PaFce7TzJVE/LUt2/fiRMnRlH07LPPnnfeeT169Lj44osXLVr08MMPJ31oUOvieDdJpmpCnsrKylasWLFq1apZs2Z95zvfGT9+/KBBg8aMGdO/f/+kDw2SEMe7QzL99HbI3znnnDNy5MgTTzxx1apVZ5999gsvvNCpU6fDDjss6eOChMTxzvnRB0WcTNWE/PXt2/eYY46ZNm1aaWnpWWed1blz582bN//sZz9L+rggOfHXwcu7ncXdyxzVhDyVlZVVVlbmPh7ytaSPCOpsO+M60Msc1QSgAOL/DuF28ll3YllFNQEopLjupXE7vIcWAEKpJgCEUk0ACKWaABBKNQEglGoCQKhUnNB7gjOZTCL7hepks9lE9mstUGySWgt1QpLfr1leXp7fYDqdLm97e56zH9xYJ2dr8ljVYHb8S9fkN9vv1Lvr3GyCrIXiXwu71Szb4QotAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCUCN/PGPf+zSpcvpp59+yimnzJgxI4qilStXptPprl27ptPplStXVm25Zs2a73//+6eddlqnTp1+//vfR1E0cuTI9u3bjxo1KoqizZs39+zZs6KiIipiqglAjQwYMODRRx+dNm3a+PHjBwwYEEXRiBEjTj311JdffvmUU0657bbbqrb87W9/e8IJJ7z44ouTJk36yU9+EkXRr3/967/+9a933nlnFEVjx47t3bt306ZNoyKmmgDUSPPmzVesWBFF0YoVK7766qsoiiZPnnz++edHUXT++efnzilzLrvssmuu+cfPIXn77bcbNGgQRVGDBg3+/ve/l5SUfP755xMnTuzfv39U3JL82UAA7ALuvfferl27HnHEEfPmzXvqqaeiKPr0008PPPDAKIoOOuigTz/9tGrLfffdN4qiiy666Omnn37mmWdyZ6UXXnjhbbfdNmzYsJ///OepVCoqbs41AaiR66+//tFHH509e/Yjjzzy9NNP/9PtH3nkkccee+yhhx7KFXTmzJllZWVRFC1YsKBnz5657hYt1QSgRmbPnp37JQTnnntu7gyyRYsWy5Yti6Jo6dKlLVq0qNry6quv3rhxYxRFZ511VtWV2ziOb7755l/84hc33HDDAw88cMMNN0RFTDUBqJGysrK//OUvURTNmDHjkEMOiaKoR48ejz/+eBRFjz/+eI8ePaIoWr16de69tbmfKf/Xv/41d34ZRdGDDz7Yq1ev5s2br127No7jNWvWREXM65oA1Mi9996be49PKpUaO3ZsFEX/+q//eskllzz99NP77bdf7krsueeeO3Xq1OHDh19yySW/+c1vSkpKHnzwwSiKKioqnnzyycmTJ0dRNGjQoO7du1933XVREVNNAGqkQ4cO06dP3/KW0tLSrX5P2dSpU6MoatOmzbRp07a8vWnTplOmTMl9fNPXouLmCi0AhFJNAAilmgAQKhXHcZSE3NuUoXhks9lE9mstUGySWgt1Q5yQdDqd9zGbNVuIWWvBrNlk10Kd4AotAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIlYrjOEpCJpNJZL9QnWw2m8h+rQWKTVJroW6IE5JOp/M+ZrNmCzFrLZg1m+xaqBNcoQWAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFScRxHSchkMonsF6qTzWYT2a+1QLFJai3UDXFC0ul03sds1mwhZq0Fs2aTXQt1giu0ABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEgVCqO4ygJmUwmkf1CdbLZbCL7tRYoNkmthbohTkg6nc77mM2aLcSstWDWbLJroU5whRYAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRKxXEcJSGTySSyX6hONptN+hCAohcnJJ1O533MZs0WYjaptQDUIa7QAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKk4joM3BoDdmnNNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRq7lJWrFjx7rvvJn0UUAdYLORHNQulVatWqW1MmDChoDvt3r37zJkzw7cfPXp0586dt739008/7dOnzz777NO6devhw4fv1GOE/2G//farWiAlJSVHHXXU3Xffnfe9VT2lKyoqUqnUdrposZCf+nnOEeCuu+766U9/Wpt7XLt27U65nx/+8Idt2rRZtGjRvHnzzjzzzAMPPPDSSy/dKfcM2xozZswVV1wRRdGGDRv+8Ic/nHvuufvuu+9FF11Uk/ts2rRpHMfb2cBiIT/ONWvbAw880LBhw0WLFkVRtHz58n322WfcuHGfffZZKpV64IEHWrVqVVpaOmDAgKolvXTp0j59+jRu3Lh169aDBw+uuv2TTz7JZDJNmjTZf//9r7rqqsrKytNOO+29997r379/btFWN/j222+fcsopjRo16tKly8KFC7c9wvnz50+bNm306NGlpaXHH3/86aef/te//rUWHyF2Xw0aNDjrrLO6deuWzWaXLVuWSqWGDh1aWlrar1+/HX1Kb3muabGwM8UURsuWLe+6665v/NT3vve9q666Ko7ja6+99vTTT4/jePny5VEUtWvXbvbs2fPnz+/QocOPfvSj3MYnn3xyv379li9fPn/+/K5du15++eVxHG/cuPHoo48+77zzPv3003nz5nXt2vXGG2+M47isrGzcuHHbGVy7dm2bNm1+8pOffP75588880yjRo1OOumk6r6EDRs2vPDCC82aNXvmmWcK8yBB3Lx58zFjxmx5S/fu3S+66KKlS5dGUZROp1etWvXRRx/t6FP6iy++iKLonXfesVjYuVSzUFq2bLnV/6DsscceuU/NmzevadOmd955Z2lp6bx586qqmc1mcxtMnTq1pKRk9erV06dP32uvvSorK3O3v/baa/Xq1Vu7du306dNLSkpWrFix1U6r/iGobrC8vLy0tHTNmjW523/84x9v5x+CsrKyhg0bnnbaacuXLy/AIwRbV7OiomLcuHH16tWbNGlSrpqTJ0/OfWpHn9JV1bRY2LlcoS2grc41N27cmLu9bdu2Q4YMGTx48HXXXde2bduq7avea3DssceuX79+/vz5c+fOXbNmTcOGDXPvlTjhhBM2b968YMGCt99+u1WrVs2aNatu19UNzp079/DDD2/UqFFus44dO27n+N99990VK1bstddeZ5111k56SOAbXHnllbknaosWLUaPHn3PPff07Nkz96k2bdrU8CltsbBzqWYy5syZE0XRG2+8seWNDRo0yH2wadOmf7xTq379jRs3tm3bdqv/0/n2t7/doEGDVCq1nfuvbnCrzar2WJ2999572LBhr7zyypIlS/L9WuGfqDrXXLdu3Zw5c3LvDMpp2LBhDZ/SFgs7l2om4LnnnnviiSdGjRo1ceLE8vLyqtvfeuut3AezZs1q3Ljx4YcffuSRRy5cuHDx4sVb3UO7du0WLVqUuwa1pap/HaobbN++/bx587766qvcf86ePXvbw5syZUppaWllZWXuPz///PM99tijadOmNfuioUbyfkpbLOxkO+lKL6HvBvryyy/btGnz05/+NPdKScuWLVetWpV7XfP4449fsGDB+++/f/TRRw8ePDiO402bNnXs2LF79+4ff/zx4sWLr7322tatW69bt27z5s3HHXfcBRdcsHz58oULF5577rnnn39+HMedOnUaMWLEqlWrqhusrKxs167dgAEDVqxY8fzzzzdp0mTbl2rWrl3brl27q666qqKi4s033zzqqKMuvfTS2nrY2O1s+26gnNzrmrkX/rezFqp7Sle9rmmxsHOpZu29GyiKossvv/zqq68+5JBDVq9eHcfxypUrW7duPXDgwFw1b7rppm9961v77rvv4MGD169fn7ufjz766Jxzztl777332WefM84445133sndvnDhwjPPPHPPPfds3rx5v379Vq5cGcfx/fff37hx4969e29ncP78+d26ddtzzz3bt28/ePDgb3yDwwcffNCjR4999tmnTZs2Q4cOXbt2bS0+cuxeAqu5o0/pqmpaLOxcqe1/I3BNZDKZAt3zrmf9+vWTJ0/u1q1bkyZNkj4Wvlk2m01kv9YRxSab0FooFnHBpNPpvI9qd5vt0aNHIvs1WwwrxToyW7dm492bdwMBQCjVLAolJSVJHwIA/5xqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIFQqjuOoMDKZTIHuGWpfNptNZL/WEcUmm9BaKBL1C3rv5eXl+Q2m0+k6Odv29jxnP7ixTn69u9Nsgmry9WZXLslvNlN6cFKz1lGRz+7mXKEFgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChUnEcR4WRyWQKdM9Q+7LZbCL7tY4oNtmE1kKRqF/Qey8vL89vMJ1O12i27e15zn5wY53cr9nCzyaoJl9vduWS/GYzpQcnNWsdFfnsbs4VWgAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAECoVx3FUGJlMpkD3DLUvm80msl/riGKTTWgtFIn6Bb338vLy/AbT6XSNZtvenufsBzfudrNJ/R3VtdkE1eTrza5ckt9spvTgpGatoyKf3c25QgsAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAIrjJ+oBwPakUtV+qmA/Jr0mVBOAYorlttsUUz5VE4Ai6+U3jhRHO1UTgGLtZfG107uBACj6ZO70+8mXagJQYKmdmrpEw6maABRSqgCRSy6cqglAwaQKlreEwpmKC/bKaiaTKdA9Q+3LZrOJ7Nc6og6vhVThw1brbw4q7Htoy8vL8xtMp9OJzba9Pc/ZD26sk1+v2aJX5x4r62jXni2uc8FUqpbD6QotAIRSTQDq8ouOqVp9gVM1ASCUagJQx9/dmqq9PaomAIRSTQAIpZoA1P2f2pOqpf36nScAJCqOo4kTo40bowYNorPPTvzns2+fc00AEvXqq9Fzz0V9+kTPPBPNnBkVN9UEIFGLFkWVlVHnztEnn/zjT3FTTQCSNmFCNHRoNGVKVPRUE4Ck9e8fjR8f9eoVFT3VBCBRrVtHjRpF2ew/PmjZMipu3kMLQKJOPDFatiw69dR/vIe2c+eouKkmAIlKFfW3mmzFFVoA6vCvia7l/aomAIRSTQAIlYoLdlabyWQKdM9Q+7LZbCL7tY6ok2shldplLwvHBZNOp/M+KrNmi222cCvFOjJbt2bjEFFUq39qkSu0ANTtk7+oFqkmAIRSTQDq7ClgXNvf6KKasPMde+yxn3z9qxsqKyvbtWt39913d+zY8bjjjps6dWrShwa1KI53ve8NVU3Y+fr06fPMM89EUTRt2rQzzjhj+PDhL7300mOPPTZhwoSkDw1qVxzvYj9OQTVh5+vbt+/EiROjKHr22WfPO++8Hj16XHzxxYsWLXr44YeTPjSodXG86/wEItWEQigrK1uxYsWqVatmzZr1ne98Z/z48YMGDRozZkz//v2TPjRIQhzvGsn009uhUM4555yRI0eeeOKJq1atOvvss1944YVOnToddthhSR8XJCSOd86PPkg0maoJhdK3b99jjjlm2rRppaWlZ511VufOnTdv3vyzn/0s6eOC5MRfBy/vdibdyxzVhIIoKyurrKzMfTzka0kfEdTZdsZF0csc1QSg1sX/HcLt5LOYYllFNQFITlyMadwO76EFgFCqCQChVBMAQqkmAIRSTQAIpZoAECoVF+xdv5lMpkD3DLUvm80msl/riGKTTWgtFIu4YNLpdN5HZdZssc0WbqVYR2br1my8e3OFFgBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSggM4///zTvtalS5f99tsvd+ODDz54yimnHHvssVOnTt1y461uHzlyZPv27UeNGhVF0ebNm3v27FlRURElyu/XBKCAHn/88dwHY8eO/fjjj6MoWr58+UMPPTR9+vT3338/k8m88847uQ22vf3Xv/71e++9V1ZWNmTIkLFjx/bu3btp06aJfjWqCUDhxXF8zz33/OEPf4iiaMWKFQMHDqxXr17r1q1XrFhRtc22tzdo0ODvf/97SUnJ559/PnHixEmTJkVJU00ACu7ZZ5894YQTDjjggCiKjvxaFEVPPfVUr169qrbZ9vYRI0ZceOGFt91227Bhw37+85+nUqkoaV7XBKDgfvWrX1133XVb3jJ//vxRo0aNHDlyqy23vP2iiy6aOXNmWVlZFEULFizo2bPnU089FSXKuSYAhfXKK680bdo0F7+c1atXf//733/ggQf233//Lbfc9vY4jm+++eaHH364U6dOM2fO7NKlS58+faLkONcEoLDuuOOOLU804zi+5JJLrrvuupNOOil3y+rVq7/x9ty7anv16tW8efO1a9fGcbxmzZooUc41ASigDz74YMmSJaeeemrVLePHj//DH/6wYsWK++67r3HjxpMmTTr33HOnTp267e0VFRVPPvnk5MmToygaNGhQ9+7dt7rMW/tUE4ACatu27YwZM7a8pf/Xtrwl992Z297etGnTKVOm5D6+6WtR0lyhBYBQqgkAoVQTAEKl4jiOCiOTyRTonqH2ZbPZRPZrHVFssgmthWIRF0w6nc77qBKcjU8/Mb8/dfTrNZv4Stkl15HZXXg23r25QgsAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKl4jiOCiOTyRTonqH2ZbPZRPZrHVFssgmthSJRv6D3Xl5ent9gOp2uyWx25ZL8ZjOlB+9us0n9HdW52QTVuccqwVlroRZmd3Ou0AJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCpOI6jwshkMgW6Z6h92Ww2kf1aRxSbbEJroUjUL+i9l5eX5zeYTqdrMptduSS/2UzpwXVxv2ZrYTZBde6xMrtrz+7mXKEFgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChUnEcR4WRyWQKdM9Q+7LZbCL7tY4oNtmE1kKxiAsmnU7nfVR1dDY+/cT8/tTRr3e3mi3cSrGOzNat2Xj35gotAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIlYrjOCqMTCZToHuG2pfNZpM+BKAIxAWTTqfzPiqzZotttnArBahDXKEFgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChUnEcB28MALs155oAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNXcpaxYseLdd99N+iigzrOUqI5qFkqrVq1S25gwYUJBd9q9e/eZM2eGbz969OjOnTtvZ4OBAweedtppO+PQIB/77bdf1fIpKSk56qij7r777rzvreoJX1FRkUqlttNFS4nqqGYB3XXXXfH/dOGFFxZ0j2vXrt2J9/byyy//7ne/24l3CHkYM2ZMbvl89dVXo0aNuv766x955JEa3mfTpk3jOD7yyCOr28BSojqqWdseeOCBhg0bLlq0KIqi5cuX77PPPuPGjfvss89SqdQDDzzQqlWr0tLSAQMGVC3apUuX9unTp3Hjxq1btx48eHDV7Z988kkmk2nSpMn+++9/1VVXVVZWnnbaae+9917//v0vvfTS7Qy+/fbbp5xySqNGjbp06bJw4cLqjnPdunUDBgw4/vjja+VRgX+uQYMGZ511Vrdu3bLZ7LJly1Kp1NChQ0tLS/v167ejT/gtzzUtJXaIata2AQMGdO3adeTIkVEUjRgx4vjjj+/fv3/uU3fccceUKVNmzZr1+uuvDxw4MHdj7969mzRp8uGHH06fPv21114bNGhQFEWbNm0688wzS0pK5s+fP2PGjNmzZ99yyy0vvvhiWVnZuHHjxo4dW93gunXrevTo0aFDhyVLlgwdOnTcuHHVHefNN9/8v/7X/zr33HNr64GBIBs3bmzcuHHu43fffXfx4sW33npr3k94S4kdttUlRHaWli1bbvVQ77HHHrlPzZs3r2nTpnfeeWdpaem8efPiOF6+fHkURdlsNrfB1KlTS0pKVq9ePX369L322quysjJ3+2uvvVavXr21a9dOnz69pKRkxYoVW+00t9TjOK5usLy8vLS0dM2aNbnbf/zjH5900knbHvyrr766//77L1269Lbbbvvud79bsAcJ/onmzZtXXaGtqKgYN25cvXr1Jk2atHTp0iiKJk+enPvUjj7hv/jiiyiK3nnnHUuJHeVcs/Ze19y4cWPu9rZt2w4ZMmTw4MHXXXdd27Ztq7avejfBscceu379+vnz58+dO3fNmjUNGzbMvRvihBNO2Lx584IFC95+++1WrVo1a9asul1XNzh37tzDDz+8UaNGuc06duy47eyGDRt+9KMfjRo16sADD9zZDwnssCuvvDL3NG7RosXo0aPvueeenj175j7Vpk2bGj7hLSV2lGomY86cOVEUvfHGG1ve2KBBg9wHmzZtiqKofv36GzdubNu27Vb/p/Ptb3+7QYMGqVRqO/df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7dt34sSJURQ9++yz5513Xo8ePS6++OJFixY9/PDDSR8a1Lo4rltnsaoJta2srGzFihWrVq2aNWvWd77znfHjxw8aNGjMmDH9+/dP+tAgCXFcvPe2DT+9HRJwzjnnjBw58sQTT1y1atXZZ5/9wgsvdOrU6bDDDkv6uCAhcbxzfvRB4d9kpJqQgL59+x5zzDHTpk0rLS0966yzOnfuvHnz5p/97GdJHxckJ/46eHm3s7a+B1Q1IQFlZWWVlZW5j4d8LekjgjrbzrhWf4+KagJQZOL/DuF28pnQLx1TTQCKVZzQ7+OsnvfQAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAiVimvwvt5MJpP3LOxKstlsIvu1Bik22YTWQu2JayCdTue93zo6e8u8OL8/dfTrNVsL68gaNLsrzca7OldoASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAS8/zzzx922GGnfW3YsGFRFG3evPmaa645+eSTTz311AULFlRtuXLlynQ63bVr13Q6vXLlyiiKRo4c2b59+1GjRuWmevbsWVFRUegDVk0AErNs2bIbbrjhxa8NHz48iqJ77723SZMmM2bMGDRo0PXXX1+15YgRI0499dSXX375lFNOue2226Io+vWvf/3Xv/71zjvvjKJo7NixvXv3btq0aaEPWDUBSMzSpUsPOuigLW959NFH+/fvH0VRz549O3fuXHX75MmTzz///CiKzj///N///vdRFDVo0ODvf/97SUnJ559/PnHixNxUoakmAIlZunTp73//+65du5599tnz58+Pouj9999/5plnTjvttO9///vnnXde1ZaffvrpgQceGEXRQQcd9Omnn+bOPi+88MLbbrtt2LBhP//5z1OpVC0csGoCkJhUKtWhQ4eXX365X79+l112WRRF69ev/9a3vvXiiy9eeOGFAwYM2M7sRRddNHPmzLKysiiKFixY0LNnz6eeeqrQB1y/0DsAgOpcc801rVu3jqLonHPOufzyy6MoatGiRe4H4abT6SuuuKJqyxYtWixbtuzggw9eunRpixYtcjfGcXzzzTc//PDDnTp1mjlzZpcuXfr06RMVknNNABJz0003TZo0KYqiV1555eijj46i6Hvf+95LL70URdFLL73UoUOHKIpWr14dRVGPHj0ef/zxKIoef/zxHj165MYffPDBXr16NW/efO3atXEcr1mzptAH7FwTgMT84he/6N+//1133bXnnnvef//9URTdeuutAwYMuPXWW+vXr3/fffdFUXTuuedOnTr1X//1Xy+55JKnn356v/32e+ihh6IoqqioePLJJydPnhxF0aBBg7p3737dddcV+oBVE4DEHHHEES+//PKWtxxwwAHPPvvslrdMnTo1iqLS0tLy8vItb2/atOmUKVNyH9/0tVo4YFdoASCUagJAKNUEgFCpOI6jfGUymbxnYVeSzWYT2a81SLHJJrQWak1N3w201Wuz4dLpdFKzHUbl+Zf65pBMTWbr4mNltvjVucfK7K49u8tzhRYAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRKxXEc5SuTyeQ9C7uSbDabyH6tQYpNNqG1UGvq13C+vLw8v8F0Ol2T2Q6j8vyLeXNIJqljNrsLzybIGjRbVLO7PFdoASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAqFQcx1G+MplM3rOwK8lms4ns1xqk2GQTWgu1pn4N58vLy/MbTKfTSc12GJXnX+qbQzI1ma2Lj5XZ4lfnHiuzu/bsLs8VWgAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAECoVx3GUr0wmk/cs7Eqy2WzShwDUirgG0ul03vs1a3ZXmq3JOgLqEFdoASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAqFQcx1G+MplM3rOwK8lms0kfAlAr4hpIp9N579es2V1ptibrCKhDXKEFgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChUnEcR/nKZDJ5z8KuJJvNJn0IQK2IayCdTue9X7Nmd6XZmqwjoA5xhRYAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRKxXEcvDEA7NacawJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQBRoP8PwaLZjK9YN0sAAAAASUVORK5CYII="
          },
          {
            "type": "input_text",
            "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
          }
        ]
      },
      {
        "type": "message",
        "role": "assistant",
        "content": [
          "Analyzing the feedback and the examples once again:\n\n- The blue shapes remain precisely unchanged.\n- The transformation creates a **secondary shape of the cluster color** that is:\n  - Positioned in a different quadrant than the original cluster,\n  - Not an arbitrary block but **matches the exact shape** of the cluster itself, i.e., a copy of the cluster,\n  - This copy is **translated (shifted)** to another quadrant, without flipping or rotation.\n- The new position of the copy is determined by moving clusters to a distinct quadrant that doesn't overlap with original clusters:\n  - E.g., if cluster is top-left, the duplicate goes to top-right or bottom-left.\n- The duplicate is the **same shape and color** as the original cluster.\n- The original cluster remains in place.\n- All output grids are 11\u00d711.\n- No flipping or resizing; direct copy and translation of each cluster to a distinct quadrant.\n\n---\n\n### Improved approach:\n\n1. Identify all distinct colors except 0 and blue (blue=1).\n2. Copy blue pixels unchanged.\n3. For each remaining cluster:\n   - Extract its pixels and bounding box.\n   - Copy its pixels unchanged to output at the original position.\n   - Determine the cluster's \"main quadrant\" based on centroid.\n   - Define a mapping from each cluster quadrant to a specific **target quadrant** to copy the cluster to.\n   - Calculate translation needed to place cluster into the target quadrant at approximately the same relative position inside that quadrant.\n   - Write the duplicated cluster pixels to the target location, ensuring no overlap with original cluster.\n4. This tile-based quadrant movement better matches examples visually.\n5. The quadrant partition is: 11x11 grid \u2192 quadrants split at 6th row and col (index 5, since 0-based):\n   - Rows 0-5 and cols 0-5: top-left (TL)\n   - Rows 0-5 and cols 6-10: top-right (TR)\n   - Rows 6-10 and cols 0-5: bottom-left (BL)\n   - Rows 6-10 and cols 6-10: bottom-right (BR)\n6. Use fixed quadrant-to-quadrant mappings:\n   - TL \u2192 TR\n   - TR \u2192 BL\n   - BL \u2192 BR\n   - BR \u2192 TL\n\n---\n\n### Let's implement this carefully:\n\n```python\ndef transform(grid):\n    import numpy as np\n\n    arr = np.array(grid)\n    target_size = 11\n\n    # Normalize input size\n    norm = np.zeros((target_size, target_size), dtype=int)\n    rows, cols = arr.shape\n    norm[:min(rows, target_size), :min(cols, target_size)] = arr[:target_size, :target_size]\n    arr = norm\n\n    output = np.zeros_like(arr)\n\n    blue_color = 1\n\n    # Copy blue pixels unchanged\n    blue_mask = (arr == blue_color)\n    output[blue_mask] = blue_color\n\n    # Identify colors excluding 0 and blue\n    colors = set(np.unique(arr))\n    colors.discard(0)\n    if blue_color in colors:\n        colors.discard(blue_color)\n\n    # Define quadrant boundaries ((row_start, row_end), (col_start, col_end))\n    # Split at row=6, col=6 (0-based indices)\n    def get_quadrant(r, c):\n        if r < 6 and c < 6:\n            return 'TL'\n        elif r < 6 and c >= 6:\n            return 'TR'\n        elif r >= 6 and c < 6:\n            return 'BL'\n        else:\n            return 'BR'\n\n    quadrant_to_pos = {\n        'TL': (0, 0),\n        'TR': (0, 6),\n        'BL': (6, 0),\n        'BR': (6, 6)\n    }\n\n    # Define quadrant copies mapping\n    quadrant_copy_map = {\n        'TL': 'TR',\n        'TR': 'BL',\n        'BL': 'BR',\n        'BR': 'TL'\n    }\n\n    for color in colors:\n        mask = (arr == color)\n        if not np.any(mask):\n            continue\n        rows_c, cols_c = np.where(mask)\n        min_r, max_r = rows_c.min(), rows_c.max()\n        min_c, max_c = cols_c.min(), cols_c.max()\n\n        # Copy original cluster pixels unchanged\n        for (r, c) in zip(rows_c, cols_c):\n            output[r, c] = color\n\n        # Calculate cluster centroid to find quadrant\n        mean_r = int(np.round(np.mean(rows_c)))\n        mean_c = int(np.round(np.mean(cols_c)))\n        orig_quad = get_quadrant(mean_r, mean_c)\n        target_quad = quadrant_copy_map[orig_quad]\n\n        # Get top-left corner of orig and target quadrants\n        orig_r0, orig_c0 = quadrant_to_pos[orig_quad]\n        targ_r0, targ_c0 = quadrant_to_pos[target_quad]\n\n        # Compute cluster offset relative to orig quadrant\n        offset_r = min_r - orig_r0\n        offset_c = min_c - orig_c0\n\n        # Compute target cluster top-left position in target quadrant\n        new_min_r = targ_r0 + offset_r\n        new_min_c = targ_c0 + offset_c\n\n        # Ensure cluster fits into output bounds\n        cluster_height = max_r - min_r + 1\n        cluster_width = max_c - min_c + 1\n\n        # Adjust new_min_r, new_min_c to stay within quadrant limits (0-5 for cols/rows)\n        max_row = targ_r0 + 5\n        max_col = targ_c0 + 5\n\n        if new_min_r < targ_r0:\n            new_min_r = targ_r0\n        if new_min_c < targ_c0:\n            new_min_c = targ_c0\n\n        if new_min_r + cluster_height -1 > max_row:\n            new_min_r = max_row - cluster_height +1\n        if new_min_c + cluster_width -1 > max_col:\n            new_min_c = max_col - cluster_width +1\n\n        # Write duplicated cluster pixels into output at computed positions\n        for r, c in zip(rows_c, cols_c):\n            rr = r - min_r + new_min_r\n            cc = c - min_c + new_min_c\n            if 0 <= rr < target_size and 0 <= cc < target_size:\n                # Avoid overwriting blue pixels, but overwrite others\n                if output[rr, cc] != blue_color:\n                    output[rr, cc] = color\n\n    return output.tolist()\n```\n\n---\n\nThis code:\n\n- Preserves blue cluster exactly.\n- For each non-blue cluster, duplicates it exactly with shape preserved \u2014 no flip, no resize.\n- Positions duplicate in a fixed different quadrant depending on original quadrant.\n- Keeps duplicate well inside quadrant bounds.\n- Avoids overwriting blue pixels.\n- Keeps output grid size 11\u00d711 exactly.\n\n---\n\nThis solution should solve or closely approximate all training examples, correctly handling spatial cluster replication and quadrant repositioning, without resizing or flipping.\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n\n    arr = np.array(grid)\n    target_size = 11\n\n    # Normalize input size\n    norm = np.zeros((target_size, target_size), dtype=int)\n    rows, cols = arr.shape\n    norm[:min(rows, target_size), :min(cols, target_size)] = arr[:target_size, :target_size]\n    arr = norm\n\n    output = np.zeros_like(arr)\n\n    blue_color = 1\n\n    # Copy blue pixels unchanged\n    blue_mask = (arr == blue_color)\n    output[blue_mask] = blue_color\n\n    # Identify colors excluding 0 and blue\n    colors = set(np.unique(arr))\n    colors.discard(0)\n    if blue_color in colors:\n        colors.discard(blue_color)\n\n    # Define quadrant boundaries ((row_start, row_end), (col_start, col_end))\n    # Split at row=6, col=6 (0-based indices)\n    def get_quadrant(r, c):\n        if r < 6 and c < 6:\n            return 'TL'\n        elif r < 6 and c >= 6:\n            return 'TR'\n        elif r >= 6 and c < 6:\n            return 'BL'\n        else:\n            return 'BR'\n\n    quadrant_to_pos = {\n        'TL': (0, 0),\n        'TR': (0, 6),\n        'BL': (6, 0),\n        'BR': (6, 6)\n    }\n\n    # Define quadrant copies mapping\n    quadrant_copy_map = {\n        'TL': 'TR',\n        'TR': 'BL',\n        'BL': 'BR',\n        'BR': 'TL'\n    }\n\n    for color in colors:\n        mask = (arr == color)\n        if not np.any(mask):\n            continue\n        rows_c, cols_c = np.where(mask)\n        min_r, max_r = rows_c.min(), rows_c.max()\n        min_c, max_c = cols_c.min(), cols_c.max()\n\n        # Copy original cluster pixels unchanged\n        for (r, c) in zip(rows_c, cols_c):\n            output[r, c] = color\n\n        # Calculate cluster centroid to find quadrant\n        mean_r = int(np.round(np.mean(rows_c)))\n        mean_c = int(np.round(np.mean(cols_c)))\n        orig_quad = get_quadrant(mean_r, mean_c)\n        target_quad = quadrant_copy_map[orig_quad]\n\n        # Get top-left corner of orig and target quadrants\n        orig_r0, orig_c0 = quadrant_to_pos[orig_quad]\n        targ_r0, targ_c0 = quadrant_to_pos[target_quad]\n\n        # Compute cluster offset relative to orig quadrant\n        offset_r = min_r - orig_r0\n        offset_c = min_c - orig_c0\n\n        # Compute target cluster top-left position in target quadrant\n        new_min_r = targ_r0 + offset_r\n        new_min_c = targ_c0 + offset_c\n\n        # Ensure cluster fits into output bounds\n        cluster_height = max_r - min_r + 1\n        cluster_width = max_c - min_c + 1\n\n        max_row = targ_r0 + 5\n        max_col = targ_c0 + 5\n\n        if new_min_r < targ_r0:\n            new_min_r = targ_r0\n        if new_min_c < targ_c0:\n            new_min_c = targ_c0\n\n        if new_min_r + cluster_height -1 > max_row:\n            new_min_r = max_row - cluster_height +1\n        if new_min_c + cluster_width -1 > max_col:\n            new_min_c = max_col - cluster_width +1\n\n        # Write duplicated cluster pixels into output at computed positions\n        for r, c in zip(rows_c, cols_c):\n            rr = r - min_r + new_min_r\n            cc = c - min_c + new_min_c\n            if 0 <= rr < target_size and 0 <= cc < target_size:\n                # Avoid overwriting blue pixels, but overwrite others\n                if output[rr, cc] != blue_color:\n                    output[rr, cc] = color\n\n    return output.tolist()\n```"
        ]
      },
      {
        "role": "user",
        "content": [
          {
            "type": "input_text",
            "text": "Please analyze the training feedback and programs from all prior turns, and write an improved transformation.\n\n**Important**:\n1. Always start by attempting to find a complete rule that solves all training examples and should generalize to the test input.\n2. If you cannot find a perfect solution, provide your best attempt at a transformation that solves as many training examples as possible - ideally more than in the best previous turn.\n3. Even if your solution doesn't solve all examples perfectly, ensure it demonstrates meaningful pattern recognition and provides reasonable outputs that minimize pixel-level errors.\n\nFinal answer:\n```python\ndef transform(grid):\n    # Your improved transformation logic here (even if partial)\n    return transformed_grid\n```"
          },
          {
            "type": "input_text",
            "text": "Training results: 0/4 examples solved, 76.3% pixel accuracy - Good partial progress! Your approach is capturing some patterns. Next, try to identify a transformation that solves at least one of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[1, 1, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 1, 1, 1, 0, 3, 3, 3, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 1, 1, 1, 0, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0]]\nPixel accuracy: 86.0%\n\nTraining Example 2 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 1, 0, 0, 0, 0, 0, 0, 6, 0], [0, 1, 1, 1, 1, 0, 0, 6, 6, 6, 6], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 6, 0], [0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 87.1%\n\nTraining Example 3 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 78.5%\n\nTraining Example 4 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 60.4%\n\n\u26a0\ufe0f  GRID SIZE ERROR: One or more of your output grids are incorrect in size. They should ALL be 11\u00d711 for this task.\n\n"
          },
          {
            "type": "input_image",
            "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAmcAAATYCAIAAADVnPfcAABQf0lEQVR4nO3de3hU9b3o4TVIgigYFBSVS70g0R4UES+ISLVwnqMgOiNgbb0Uiq2XjRdQVPa2euqRikK1tbXoKYoiunVrnaAWKdoi1haUKruCeEFA5aZFNCAC4bbOY+fsPGww9MeEyZrA+z78ESfrO2tlmB8f15pJkorjOAIAAjQI2QgAUE0A2AGqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmANRJNQcPHpyq2YUXXvi125SWlh544IFnn332G2+8se19vvDCC6lUar/99lu3bt1Wn3rqqadSqdTYsWNz/zlgwIBUKjVq1KitNlu8eHEqlbrppptqM5Wzbt26+++///TTTz/44IMbNWp08MEH9+/f/09/+tN2HpObbrqppgdkzpw523/Qevbs+U8f2OptLrnkki1vzx1e3759p0+fvuXxpNPprTY79NBDr7rqqs8//3yHHvycTz/99LbbbuvUqVNZWdnee+994oknjh07dstfm5Pb3Vbjr7/++v7779+0adOpU6du56EDKH4JnGtu2LDhk08+efbZZ08//fQFCxZs9dkHH3wwiqLPP//8iSeeCLm3m2+++Z133tnRYwiZ+uCDD04++eTLLrvspZdeWrZs2fr165ctW/bUU0917979rrvuiopM7vCefvrpbt26Pfroo9vZ7IMPPvjlL395xhlnbN68eYce/OnTp3fs2PHHP/7xf/7nf65atWrNmjUzZ8784Q9/OGjQoO0c2B//+MfTTz9906ZNL7744umnn16LLxGgnlfzV7/6VfxfnnzyySiKxo0bV33LhAkTqrdcuHBh9e3r1q17++23v/e9761atWrMmDFb3mFlZWVFRUX//v3322+/++67L+QY1q9fP2DAgE2bNu3Qkf/TqQ0bNvTr1+8///M/u3bt+swzz3z66acbNmz46KOPfv3rX++3337XX3997sSxJrNmzYq30aFDh699QKq9+OKLW95JyDbLli3L3b527dr333//xhtvjOP4Bz/4wYcffrjlZmvXrt3ywe/Zs+drr732wgsvhD/4f//73zOZzNKlS7/73e/OmDFj1apVn332WUVFxWGHHTZu3Lj777//ax+HbDbbq1evvfba66WXXjrppJO284gB1AsJnGs2atToyCOPvOOOO6Io2upc87HHHlu3bt2ll146cODAGTNmvPnmm//03q688spXX331Zz/72Q4dwz+devjhh19//fWePXu+/PLLffr0ad68ecOGDdu0aXP55Zc//fTTmzZt+vd///eomOy5556HH3747bfffvPNN69fv/7nP//5dh78a665Jlfc8Af/rrvu+uSTT4YMGfLYY4+ddNJJTZs23Xfffc8555xp06btvffed91117a/3vyBBx7o37//AQcc8Kc//emYY46pvv2hhx5KpVK/+tWvduoDALCLVrOqquqtt94aOnRoFEXt27ff8lPjxo076qijvv3tb19++eV77LFHyOnmT3/603bt2t18881vv/12+DH806nHHnsslUr93//7f/fYY4+tPvWtb31r7ty5t912W1SUrr322r322uv3v//91352w4YN77333j333NOwYcNvfetb4Q/+f/zHfzRu3PjWW2/d6g5bt279yiuvvPTSS6lUasvb77zzzksuueSwww575ZVXjjjiiJ339QHsBtU89NBDq9+Qsueee3bo0OHJJ59s0aLF1VdfXb3NnDlz/vrXvw4bNiyVSh1++OH9+/d/9NFHV69evf173muvvcaNG7dhw4Yduk77T6dmzZp11FFHHXrooV87ftRRR20Via106tRpq3fxvPLKKzU9INVeeumlHd1mW02bNj3iiCO2Oolv3Lhxbry0tLS8vPzPf/7zww8/vOVXt/0Hf8OGDR988MGJJ57YpEmTbfd47LHHHnTQQVvecv31199www1RFJ166qlt27bdavsBAwbEcTx48ODtfyEARSiZ7zxp1arVD37wg7/97W8HHnhg9Y0PPvhgq1atLrjggtx/Dh8+/Isvvgi5ENqtW7errrrqtddeGz16dPgxbGdqw4YNlZWVLVu23PLGrd7Xesghh0TFqnnz5lX/UNMGmzZtmjFjxoYNGwIf/MrKyjiOmzdvHngAv/zlL08++eSePXs++OCDTz/9dO2+GoDdr5q5N7asX7/+8ccfz50MjRw58uCDD67eYMOGDRMmTFiyZEmjRo1yWerYsWMcx4HvCfrpT396xBFH3HLLLXPnzg0/qpqmSkpKmjZtunz58ihf274bqFu3bv/0nT6nnXbajm7ztT7//POSkpJGjRpt+26g9evXL1iw4F/+5V9++ctfXnfddYEP/n777degQYPwB2TgwIEvvfTS+PHj99tvvx/+8IdLliwJHAQocnV6rllSUvKd73zniSeemDZt2hlnnLHld/U999xzX/uP8htvvDFz5sx/es+NGzfO4zrtdqaOPvrouXPnfvTRR1/7huHOnTtHxWr16tVz5sw56qijvvazJSUlhx566OjRozt06PDQQw8FPvh77LHHUUcd9de//nXNmjXbbnb77bdffPHFS5curb7l17/+dWlp6UEHHfSrX/3qs88+u/jii7f9LheA+iiBK7RnnnnmlVde+cYbb1Sf6+SuEO65554rV67c8rzqL3/5SxRFNX1Xw1ZOOeWUq6++eubMmdv+BIM8pi644ILNmzdfccUVX9vgbd8vWjzuvvvuDRs2nHHGGdvfrEGDBqtXr964cWPgg59Op9euXfu///f/3up+PvjggzvvvPO555772uu33/3ud/v16/fHP/5xhy6eAxStZF7X/OlPf9q2bdsxY8a8+uqrURR9/PHHkydP7tOnzz777LPlZieffHJ5efm///u/r1y5MuRuR4wYccQRR/z617/eoYP52qlLLrmkc+fOv/vd70488cT/+I//+Pjjjzds2JD7KQe9e/d+4403GjQorh9GWFVV9e677950000/+clP9tprr5reaxPH8eLFi4cNG/bmm2926tSpYcOGgQ/+kCFDmjdvPmrUqIsvvvivf/3r2rVrP/nkk8cee+y0006rrKwcNmzYlheEtzRmzJiWLVvedNNNr7/+emG+dIC6k8w//Xvvvfcvf/nLzZs3X3rppRs3bhw/fvzGjRur34qype9///tr1qx55JFHwq+4bv/drYFTpaWlFRUVJ5988htvvPGd73znoIMOKi0tzf1EvUmTJpWXlwf+6KKafO37Y1Op1JbvGQ7Z5qCDDqp+Z/KRRx45YsSI3I8PbNOmzVZfY26zBg0atGnTZvTo0Q0aNMh980zgg9+8efMnnniiadOmjzzyyAknnLDXXnsdeOCBF1xwwYcffpjJZK6//vqavtIWLVr85je/2bBhw/e+970vv/zS92sC9VpiJ0xnn312Op3+29/+9vOf//yhhx7ad999zzzzzG03u/jiixs0aBB4kTZ3xTX3Lfw75GunWrdu/ac//WnChAm9evVq3bp1aWlpy5Yte/Xq9fDDD8+ZM+eEE06IiklJSUmbNm3OP//8P//5z9/97ndr2myPPfY44IADevfu/cILL+Su4oY/+D169Jg1a9ZVV1115JFHNmnSpHHjxieddNLYsWN/+9vfbvtdrVvq06fPgAED3nvvvS2/0QigPkoV80t0AFBUiuvFOQAoZqoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFLNXcqKFSveeeedpI8CioLlQCGoZqG0bt06tY0JEyYUdKc9e/acMWNG+PajR4/u0qVLTZ+trKw87LDDdugOYVstWrSoXgKlpaVHHXXUPffck/e9VT9pKysrU6nUdrpoOVAIqllAd999d/zfXXjhhQXd49q1a3fWXS1atKhnz54LFy7cWXfI7mzMmDG5JfDll1+OGjXquuuue+SRR2p5n82aNYvj+Mgjj6xpA8uBQlDNuvbAAw80atRo0aJFURQtX758n332GTdu3KeffppKpR544IHWrVuXlZUNGjSoesEvW7asX79+TZo0adOmzdChQ6tvX7JkSSaTadq06f7773/FFVdUVVWddtpp77777sCBAy+55JLtDL711lunnnpq48aNu3btWtO/Ar/73e86dOjQuXPnunpU2F2UlJScddZZPXr0yGazH3/8cSqVGj58eFlZ2YABA3b0SbvluablQJ1Rzbo2aNCgbt26jRw5MoqiESNGHH/88QMHDsx96s4775w8efKsWbNef/31wYMH527s27dv06ZNP/jgg2nTps2cOXPIkCFRFG3atOnMM88sLS2dP3/+9OnTZ8+efcstt7z00kvl5eXjxo0bO3ZsTYPr1q3r1atXx44dly5dOnz48HHjxn3tQTZq1OjFF1+899576/CBYTeycePGJk2a5D5+5513Fi9efOutt+b9pLUcqFNbXUJkZ2nVqtVWD/Uee+yR+9S8efOaNWt21113lZWVzZs3L47j5cuXR1GUzWZzG0yZMqW0tHT16tXTpk3ba6+9qqqqcrfPnDmzQYMGa9eunTZtWmlp6YoVK7baae6fiTiOaxqsqKgoKytbs2ZN7vYf/ehHJ510Uk1fwoYNG6Iomj59egEeHnYjzZs3r75CW1lZOW7cuAYNGjz33HPLli2LomjSpEm5T+3ok/bzzz+Poujtt9+2HKhLzjXr7nXNjRs35m5v167dsGHDhg4deu2117Zr1656++p3Ihx77LHr16+fP3/+3Llz16xZ06hRo9w7KU444YTNmzcvWLDgrbfeat269X777VfTrmsanDt37uGHH964cePcZp06dSrwYwBfufzyy3NPxZYtW44ePfree+/t3bt37lNt27at5ZPWcqAuqWYy5syZE0XRG2+8seWNJSUluQ82bdoURVHDhg03btzYrl27rf5P55vf/GZJSUkqldrO/dc0uNVm1XuEgqo+11y3bt2cOXMuu+yy6k81atSolk9ay4G6pJoJeP7555944olRo0ZNnDixoqKi+vY333wz98GsWbOaNGly+OGHH3nkkQsXLly8ePFW99C+fftFixblrlBtqfrfjpoGO3ToMG/evC+//DL3n7Nnz97ZXxzkKe8nreVAXVLNurZ69erLLrvsqquuuu666374wx8OHjz4iy++yH3q+uuvX7hw4bx582644YYf/ehHjRo1+va3v33MMccMHDhw0aJFS5Ysueaaa9q2bVtVVXXqqad26NDhyiuv/PTTTz/44IO+fft+97vfjaJo7733Xrp06RdffFHT4P/6X//roIMOuvrqqz/77LMXX3zxwQcfTPrxgP8v7yet5UCd2kmvj/LP3w0URdGll1565ZVXHnLIIatXr47jeOXKlW3atBk8eHDu3UA33njjN77xjX333Xfo0KHr16/P3c+HH354zjnn7L333vvss88ZZ5zx9ttv525fuHDhmWeeueeeezZv3nzAgAErV66M4/g3v/lNkyZN+vbtu53B+fPn9+jRY8899+zQocPQoUO9/YG6fDfQlnLvBsq9IS5nh5601e8GshyoS6k4jqMkZDKZRPZbnNavXz9p0qQePXo0bdo06WPZfWWz2UT2ay1QbJJaC/VCwwT3XdHujvwG0+/fUKvZLV5K3LHZdLqgs3/4wx8S2e92ZhfcVJnf7GG3NavNbCJfb4KsBbNFNct2eF0TAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCESsVxHCUhk8kksl+oSTabTWS/1gLFJqm1UC80THDfFRUV+Q2m0+mKdnfkOfv+DYnN1uLrXXBTZX6zh93WLKnZWv39JjGbIGuhyJ8bu9ss2+EKLQCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACJWK4zhKQiaTSWS/UJNsNpvIfq0Fik1Sa6FeaJjgvisqKvIbTKfTFe3uyHP2/Rtqtd/dbHbBTZX5zR52W7N69/UmyFoo/llrgRxXaAEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQKhUHMdREjKZTCL7hZpks9lE9mstUGySWgv1QsME911RUZHfYDqdrmh3R56z79+Q2Gwtvt4FN1XmN3vYbc2Smq3V328SswmyFor8ubG7zVKk1QRg15dK1fiphC521oZqAlC3sdx2m/qTT9UEoM57+bUj9aGdqglAcr2sb+30nScA7Ay1TOZOv5/CUE0Aiix1qeINp2oCUHyRSxVpOFUTgKLMW6oYw6maABRr2FJFF07VBKCIk5YqrnCqJgCEUk0AivsUMFVEp5uqCQChVBOAoj/5SxXL6aZqAkAo1QSAUKoJQH24WJoqiou0fucJAAUWx9HEidHGjVFJSXT22UXSv/yk4oR+J0smk0lkv1CTbDabyH6tBerZWkjtePNefTV68MHo/vujQYOiSy6JTj45zyMrhl8iFicknU7nfcxmzRZi1lowazbnnzxlo2iH/zz1VDxgQNylS3zGGV99nMc95P4UAa9rAlB4EyZEw4dHkydH9ZxqAlB4AwdGDz0U9ekT1XOqCUCBtWkTNW4cZbNffdCqVVSfeQ8tAAV24onRxx9H3bt/9R7aLl2i+kw1ASiwVD3+VpOtuEILQH349o+4CL7tRDUBIJxqAkAo1QSg6C+WxkVxeVY1AWAHqCYAxX3yFxfLiaZqAsAOUE0AivgUMC6iE03VhDwde+yxS5YsiaKoqqqqffv299xzT6dOnY477rgpU6YkfWhQh+J4t0qmakKe+vXr98wzz0RRNHXq1DPOOOO22257+eWXH3vssQkTJiR9aFC34nj3SaZqQp769+8/ceLEKIqeffbZ8847r1evXhdffPGiRYvGjx+f9KFBnYvj3SSZqgl5Ki8vX7FixapVq2bNmnXKKac89NBDQ4YMGTNmzMCBA5M+NEhCHO8OyfTT2yF/55xzzsiRI0888cRVq1adffbZL774YufOnQ877LCkjwsSEsc756e0F3Eyv/pB9HFCx5fJZBLZL9Qkm83u0PbvvvvuMcccM3Xq1K5du44aNerxxx/fvHnzoEGDBg8evEP3Yy1Q39fC1vJuZ3H38v+LE5JOp/M+ZrNmCzFrLZg1m7NzntlRtAN/6g9XaAEogDj+56ee9eLk8r9TTQAKKa5/adwO76EFgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1AaiVP/zhD127dj399NNPPfXU6dOnR1G0efPmq6666uSTT+7evfuCBQuqt1y5cmU6ne7WrVs6nV65cmUURSNHjuzQocOoUaNyU717966srIyKmGoCUCuDBg169NFHp06d+tBDDw0aNCiKovvuu69p06bTp08fMmTIddddV73liBEjunfv/sorr5x66qm33357FEW/+MUv/vKXv9x1111RFI0dO7Zv377NmjWLilgqTuj3hWYymUT2CzXJZrOJ7NdaoL6vhc6dO99///3HH3/8a6+91r9//w8//PCUU055+OGH27Vrt379+p///OfXX399bssOHTpMmTLl4IMPXrJkyRlnnDF79uy2bdv+8Y9/7NGjx6xZsy666KLnnnsulUpFxSxOSDqdzvuYzZotxKy1YNZszo4+h1977bVGjRp16NChUaNGzz77bBzHLVq0+NnPfvatb30rnU4vXLiwessWLVps2rQpjuNNmzbtv//+cRyPHz/+pJNOevTRRy+//PKZM2fGRc8VWgBq5brrrnv00Udnz579yCOPPP3001EUrV+//hvf+MZLL7104YUX5q7Z1uSiiy6aMWNGeXl5FEULFizo3bv3U089FRWxhkkfAAD12+zZs3MvNJx77rmXX355FEUtW7bMneym0+nLLrusesuWLVt+/PHHBx988LJly1q2bJm7MY7jm2++efz48Z07d54xY0bXrl379esXFSvnmgDUSnl5+Z///OcoiqZPn37IIYdEUfTtb3/75ZdfjqLo5Zdf7tixYxRFq1evjqKoV69ejz/+eBRFjz/+eK9evXLjDz74YJ8+fZo3b752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fWiQhDjeHZLpp7dD/s4555yRI0eeeOKJq1atOvvss1988cXOnTsfdthhSR8XJCSOd86PPijiZKom5K9///7HHHPM1KlTy8rKzjrrrC5dumzevPnHP/5x0scFyYn/Eby821ncvcxRTchTeXl5VVVV7uNh/5D0EUG9bWdcD3qZo5oAFED8XyHcTj7rTyyrqSYAhRTXvzRuh/fQAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAiVihN6T3Amk0lkv1CTbDabyH6tBYpNUmuhXkjy+zUrKiryG0yn0xXt7shz9v0b6uVsbR6rWsw+9PJV+c0O6H5PvZtNkLVQ/Gtht5plO1yhBYBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQGolT/84Q9du3Y9/fTTTz311OnTp0dRdP7555/2D127dm3RosWWG1dWVg4YMKCsrCz3nyNHjuzQocOoUaOiKNq8eXPv3r0rKyujIub3awJQK4MGDZo6deqhhx46f/78Pn36zJ079/HHH899auzYsR999NGWG/fp0+e8886r/l7SX/ziF++++255efmwYcPGjh3bt2/fZs2aRUXMuSYAtdK8efMVK1ZEUbRixYovv/yy+vY4ju+9997BgwdvufGTTz555ZVXVv9nSUnJ3//+99LS0s8++2zixIkDBw6MiptzTQBq5b777uvWrdsRRxwxb968p556qvr2Z5999oQTTjjggAO23PjAAw/c8j9HjBhx4YUX3n777TfddNNPfvKTVCoVFTfnmgDUynXXXffoo4/Onj37kUceefrpp6tv/9nPfnbttdduf/aiiy6aMWNGeXl5FEULFizo3bv3lt0tQs41AaiV2bNn534Jwbnnnnv55Zfnbnz11VebNWuWy+H2xXF88803jx8/vnPnzjNmzOjatWu/fv2iYuVcE4BaKS8v//Of/xxF0fTp0w855JDcjXfeeeeWJ5qrV6+uafzBBx/s06dP8+bN165dG8fxmjVroiLmXBOAWrnvvvuuuuqr3zWUSqXGjh0bRdH777+/dOnS7t27V29z7rnnTpkyZdvZysrKJ598ctKkSVEUDRkypGfPnv/0om6yVBOAWunYseO0adO2vKVdu3a5b9ystlUyq78ps1mzZpMnT859fOM/RMXNFVoACKWaABBKNQEgVCqO4ygJubcpQ/HIZrOJ7NdaoNgktRbqhzgh6XQ672M2a7YQs9aCWbPJroV6wRVaAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQKhXHcZSETCaTyH6hJtlsNpH9WgsUm6TWQv0QJySdTud9zGbNFmLWWjBrNtm1UC+4QgsAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKl4jiOkpDJZBLZL9Qkm80msl9rgWKT1FqoH+KEpNPpvI/ZrNlCzFoLZs0muxbqBVdoASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAqFQcx1ESMplMIvuFmmSz2UT2ay1QbJJaC/VDnJB0Op33MZs1W4hZa8Gs2WTXQr3gCi0AhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAiViuM4SkImk0lkv1CTbDab9CEARS9OSDqdzvuYzZotxGxSawGoR1yhBYBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVJxHAdvDAC7NeeaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjV3KWsWLHinXfeSfoooB6wWMiPahZK69atU9uYMGFCQXfas2fPGTNmhG8/evToLl26bHv7J5980q9fv3322adNmza33XbbTj1G+G9atGhRvUBKS0uPOuqoe+65J+97q35KV1ZWplKp7XTRYiE/DfOcI8Ddd999zTXX1OUe165du1Pu53vf+17btm0XLVo0b968M88888ADD7zkkkt2yj3DtsaMGXPZZZdFUbRhw4bf//7355577r777nvRRRfV5j6bNWsWx/F2NrBYyI9zzbr2wAMPNGrUaNGiRVEULV++fJ999hk3btynn36aSqUeeOCB1q1bl5WVDRo0qHpJL1u2rF+/fk2aNGnTps3QoUOrb1+yZEkmk2natOn+++9/xRVXVFVVnXbaae++++7AgQNzi7amwbfeeuvUU09t3Lhx165dFy5cuO0Rzp8/f+rUqaNHjy4rKzv++ONPP/30v/zlL3X4CLH7KikpOeuss3r06JHNZj/++ONUKjV8+PCysrIBAwbs6FN6y3NNi4WdKaYwWrVqdffdd3/tp7797W9fccUVcRxfffXVp59+ehzHy5cvj6Koffv2s2fPnj9/fseOHX/wgx/kNj755JMHDBiwfPny+fPnd+vW7dJLL43jeOPGjUcfffR55533ySefzJs3r1u3bjfccEMcx+Xl5ePGjdvO4Nq1a9u2bfsv//Ivn3322TPPPNO4ceOTTjqppi9hw4YNL7744n777ffMM88U5kGCuHnz5mPGjNnylp49e1500UXLli2LoiidTq9aterDDz/c0af0559/HkXR22+/bbGwc6lmobRq1Wqr/0HZY489cp+aN29es2bN7rrrrrKysnnz5lVXM5vN5jaYMmVKaWnp6tWrp02bttdee1VVVeVunzlzZoMGDdauXTtt2rTS0tIVK1ZstdPqfwhqGqyoqCgrK1uzZk3u9h/96Efb+YegvLy8UaNGp5122vLlywvwCMHW1aysrBw3blyDBg2ee+65XDUnTZqU+9SOPqWrq2mxsHO5QltAW51rbty4MXd7u3bthg0bNnTo0GuvvbZdu3bV21e/1+DYY49dv379/Pnz586du2bNmkaNGuXeK3HCCSds3rx5wYIFb731VuvWrffbb7+adl3T4Ny5cw8//PDGjRvnNuvUqdN2jv+dd95ZsWLFXnvtddZZZ+2khwS+xuWXX557orZs2XL06NH33ntv7969c59q27ZtLZ/SFgs7l2omY86cOVEUvfHGG1veWFJSkvtg06ZNX71Tq2HDjRs3tmvXbqv/0/nmN79ZUlKSSqW2c/81DW61WfUea7L33nvfdNNNr7766tKlS/P9WuGfqD7XXLdu3Zw5c3LvDMpp1KhRLZ/SFgs7l2om4Pnnn3/iiSdG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DiEPY8aMyS2fL7/8ctSoUdddd90jjzxSy/ts1qxZHMdHHnlkTRtYStRENevaAw880KhRo0WLFkVRtHz58n322WfcuHGffvppKpV64IEHWrduXVZWNmjQoOpFu2zZsn79+jVp0qRNmzZDhw6tvn3JkiWZTKZp06b777//FVdcUVVVddppp7377rsDBw685JJLtjP41ltvnXrqqY0bN+7atevChQtrOs5169YNGjTo+OOPr5NHBf65kpKSs846q0ePHtls9uOPP06lUsOHDy8rKxswYMCOPuG3PNe0lNghqlnXBg0a1K1bt5EjR0ZRNGLEiOOPP37gwIG5T915552TJ0+eNWvW66+/Pnjw4NyNffv2bdq06QcffDBt2rSZM2cOGTIkiqJNmzadeeaZpaWl8+fPnz59+uzZs2+55ZaXXnqpvLx83LhxY8eOrWlw3bp1vXr16tix49KlS4cPHz5u3LiajvPmm2/+H//jf5x77rl19cBAkI0bNzZp0iT38TvvvLN48eJbb7017ye8pcQO2+oSIjtLq1attnqo99hjj9yn5s2b16xZs7vuuqusrGzevHlxHC9fvjyKomw2m9tgypQppaWlq1evnjZt2l577VVVVZW7febMmQ0aNFi7du20adNKS0tXrFix1U5zSz2O45oGKyoqysrK1qxZk7v9Rz/60UknnbTtwb/22mv777//smXLbr/99m9961sFe5Dgn2jevHn1FdrKyspx48Y1aNDgueeeW7ZsWRRFkyZNyn1qR5/wn3/+eRRFb7/9tqXEjnKuWXeva27cuDF3e7t27YYNGzZ06NBrr722Xbt21dtXv5vg2GOPXb9+/fz58+fOnbtmzZpGjRrl3g1xwgknbN68ecGCBW+99Vbr1q3322+/mnZd0+DcuXMPP/zwxo0b5zbr1KnTtrMbNmz4wQ9+MGrUqAMPPHBnPySwwy6//PLc07hly5ajR4++9957e/funftU27Zta/mEt5TYUaqZjDlz5kRR9MYbb2x5Y0lJSe6DTZs2RVHUsGHDjRs3tmvXbqv/0/nmN79ZUlKSSqW2c/81DW61WfUetzRixIjWrVt///vf3xlfKNRW9bnmunXr5syZc9lll1V/qlGjRrV8wltK7CjVTMDzzz//xBNPjBo1auLEiRUVFdW3v/nmm7kPZs2a1aRJk8MPP/zII49cuHDh4sWLt7qH9u3bL1q0KHeVaUvV67+mwQ4dOsybN+/LL7/M/efs2bO3Pbynnnpq8uTJuf+zHj58+LRp01Kp1LZ3BcUj7ye8pcQO2+FruoRp1arVtt95EsfxF1980bZt22uuuSb3WkirVq1WrVqVe13z+OOPX7BgwXvvvXf00UcPHTo0juNNmzZ16tSpZ8+eH3300eLFi6+++uo2bdqsW7du8+bNxx133AUXXLB8+fKFCxeee+65559/fhzHnTt3HjFixKpVq2oarKqqat++/aBBg1asWPHCCy80bdr0a1+MqebFGIrndc0t5V7XzL0tYDsrpaYnfPXrmpYSO8q5ZgENGTJkq59ycNlll/3rv/5rgwYNbrvttiiKRo0a1aBBg3/913/Nbd+zZ8/TTz/9pJNO+p//83/m3mTboEGDioqKvffe+6ijjvrmN7/57rvvTpkyJfcSy29/+9vPPvusTZs2xx9//D777HP//fdHUXTZZZfdfvvtAwcOrGmwtLT0+eef/+CDD1q1ajVkyJAf/vCHST9IsBPk/YS3lNhRqTiOo3xlMpm8Z9nS+vXrJ02a1KNHj6ZNmyZ9LOQjm80msl9rkGKTTWgt1J24FtLpdN77NWt2V5qtzTqyBs3uSrPxrs4VWgAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAECoVx3GUr0wmk/cs7Eqy2Wwi+7UGKTbZhNZCnWlYy/mKior8BtPpdGKz7e7Ic/b9G2o1Wx8fq1rMZlcuzW82U3ZwbWYT+XoTVB+fG9bgLjy7y3OFFgBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhErFcRzlK5PJ5D0Lu5JsNpvIfq1Bik02obVQZxrWcr6ioiK/wXQ6XavZdnfkOfv+DYkds9k6mc2uXJrfbKbs4Lz3myBr0GxRze7yXKEFgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChUnEcR/nKZDJ5z8KuJJvNJrJfa5Bik01oLdSZhrWcr6ioyG8wnU4nNtvujjxn37+hVrP18bGqxWx25dL8ZjNlB9dmNpGvN0H18blhDe7Cs7s8V2gBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkCoVBzHUb4ymUzes7AryWaziezXGqTYZBNaC3WmYS3nKyoq8htMp9P1crbdHXnOvn9Dvfx6azGbXbk0v9lM2cH17utNUL17rKzBXXt2l+cKLQCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0AqKufqAcAhZJK1fipWvwQ9dpQTQDqTyy33aZu86maANSrXn7tSF21UzUBqJ+9TKKd3g0EQD1P5k6/n5qpJgCJSu3U1BU4nKoJQHJSBYhcIcOpmgAkJJWqd/ecimvx2mkmk9mpBwP1VTabTWS/1iD1eC2kCv4aZEHeHBTXQjqdznu/Zs3uSrO1WUfWoNldaTYOFEV19Gdnc4UWAEKpJgB1K5Wqv/tSTQAIpZoA7KInmgXYo2oCQCjVBIBQqgnArnt5dmfv1+88AaCIxXE0cWK0cWNUUhKdfXZi3f0vzjUBKGKvvRY9/3zUr1/0zDPRjBlJH41qAlDMFi2KqqqiLl2iJUu++pM01QSguE2YEA0fHk2eHBUB1QSguA0cGD30UNSnT1QEVBOAItamTdS4cZTNfvVBq1ZJH4330AJQzE48Mfr446h796/eQ9ulS9JHo5oAFLNUwt9qshVXaAGoK3Fc3/ermgAQSjUBIFQqrsV5ayaTyXsWdiXZbDaR/VqD1Mu1kErV48vCcS2k0+m892vW7K40W5t1ZA2a3ZVm4xBRVKd/dipXaAHYdd8TFO/kfakmAIRSTQB20dPNAuxFNaGuHXvssUv+8asbqqqq2rdvf88993Tq1Om4446bMmVK0ocGu1A444Lcv2pCXevXr98zzzwTRdHUqVPPOOOM22677eWXX37ssccmTJiQ9KHBrhLOuFD3rJpQ1/r37z9x4sQoip599tnzzjuvV69eF1988aJFi8aPH5/0oUGdi+P6dRarmlDXysvLV6xYsWrVqlmzZp1yyikPPfTQkCFDxowZM3DgwKQPDZIQx8V7b9vw09shAeecc87IkSNPPPHEVatWnX322S+++GLnzp0PO+ywpI8LEhLHO+dHHxT+TUaqCQno37//McccM3Xq1LKysrPOOqtLly6bN2/+8Y9/nPRxQXLifwQv73bW1feAqiYkoLy8vKqqKvfxsH9I+oig3rYzrtPfo6KaABSZ+L9CuJ18JvRLx1QTgGIVJ/T7OGvmPbQAEEo1ASCUagJAKNUEgFCqCQChVBMAQqXiWryvN5PJ5D0Lu5JsNpvIfq1Bik02obVQd+JaSKfTee+3ns7eMi/O7089/XrN1sE6sgbN7kqz8a7OFVoACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTgMRs3rz5qquuOvnkk7t3775gwYIoilauXJlOp7t165ZOp1euXLntyKRJkxo3bhxF0ciRIzt06DBq1Kjc/fTu3buysrLQB6yaACTmvvvua9q06fTp04cMGXLddddFUTRixIju3bu/8sorp5566u23377V9l988cVtt91WUlISRdEvfvGLv/zlL3fddVcURWPHju3bt2+zZs0KfcCqCUBiHn300YEDB0ZR1Lt37y5duuROJc8///wois4///zf/e53W21/4403XnPNNQ0afBWvkpKSv//976WlpZ999tnEiRNz91NoqglAYt57771nnnnmtNNO+853vnPeeedFUfTJJ58ceOCBURQddNBBn3zyyZYbv/LKK0uXLs1tljsrvfDCC2+//fabbrrpJz/5SSqVqoMDVk0AErN+/fpvfOMbL7300oUXXjho0KDtbFlVVXXdddfde++91bdcdNFFM2bMKC8vj6JowYIFvXv3fuqppwp9wA0LvQMAqEnLli1zP/Y2nU5fdtlluVs+/vjjgw8+eNmyZS1btqze8re//e0XX3zxve99L4qi1atXX3zxxePHj4/j+Oabbx4/fnznzp1nzJjRtWvXfv36RYXkXBOAxHz7299++eWXoyh6+eWXO3bsGEVRr169Hn/88SiKHn/88V69euUaGUXR9773vbfeeuulf2jSpMn48eOjKHrwwQf79OnTvHnztWvXxnG8Zs2aQh+wc00AEnPrrbcOGjTo1ltvbdiw4f333x9F0b/92799//vff/rpp1u0aPHwww9HUXTuuedOmTJl29nKysonn3xy0qRJURQNGTKkZ8+e1157baEPWDUBSMwBBxzw7LPPbnlLWVlZRUXFlrdsm8zc92U2a9Zs8uTJuVtu/IfCH68rtAAQTDUBIJRqAkCoVBzHUb4ymUzes7AryWaziezXGqTYZBNaC3Wmtu8G2uo123DpdDqp2Y6j8vxL/duwTG1m6+NjZbb41bvHyuyuPbvLc4UWAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCESsVxHOUrk8nkPQu7kmw2m8h+rUGKTTahtVBnGtZyvqKiIr/BdDpdm9mOo/L8i/nbsExSx2x2F55NkDW4a8/Wu8d5l+cKLQCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACJWK4zjKVyaTyXsWdiXZbDaR/VqDFJtsQmuhzjSs5XxFRUV+g+l0OqnZjqPy/Ev927BMbWbr42NltvjVu8fK7K49u8tzhRYAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRKxXEc5SuTyeQ9C7uSbDab9CEAdSKuhXQ6nfd+zZrdlWZrs46AesQVWgAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAECoVx3GUr0wmk/cs7Eqy2WzShwDUibgW0ul03vs1a3ZXmq3NOgLqEVdoASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAqFQcx1G+MplM3rOwK8lms0kfAlAn4lpIp9N579es2V1ptjbrCKhHXKEFgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChUnEcB28MALs155oAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAFOj/AVqO7FMlQqDYAAAAAElFTkSuQmCC"
          },
          {
            "type": "input_text",
            "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
          }
        ]
      },
      {
        "type": "message",
        "role": "assistant",
        "content": [
          "The main insight is that the output copies the blue shapes identically, and duplicates each other color cluster exactly\u2014but places the duplicate in a different quadrant without resizing or flipping, maintaining the original shape.\n\nAlso, duplicates do not overlap originals and are placed roughly in the corresponding relative position in the target quadrant.\n\n---\n\n### Key improvements to fix:\n\n- Use quadrant boundaries exactly as per 11x11 indexing (0\u201310).\n- Place duplicates inside the target quadrant **with careful bounds** (max indices inclusive).\n- Fix padding and clamp offsets to ensure entire duplicated cluster fits inside target quadrant.\n- Avoid overwriting blue pixels during duplication.\n- Make sure output size is always 11x11.\n\n---\n\nHere's an improved and clarified implementation reflecting these ideas:\n\n```python\ndef transform(grid):\n    import numpy as np\n\n    arr = np.array(grid)\n    target_size = 11\n\n    # Normalize input size to 11\u00d711\n    norm = np.zeros((target_size, target_size), dtype=int)\n    rows, cols = arr.shape\n    norm[:min(rows, target_size), :min(cols, target_size)] = arr[:target_size, :target_size]\n    arr = norm\n\n    output = np.zeros_like(arr)\n\n    blue_color = 1\n\n    output[arr == blue_color] = blue_color  # Copy blue pixels directly\n\n    # Identify non-blue, non-zero colors\n    colors = set(np.unique(arr))\n    colors.discard(0)\n    colors.discard(blue_color)\n\n    # Quadrants defined by split at row=6, col=6 (indexes 0..10)\n    quadrant_limits = {\n        'TL': (0, 5, 0, 5),\n        'TR': (0, 5, 6, 10),\n        'BL': (6, 10, 0, 5),\n        'BR': (6, 10, 6, 10)\n    }\n\n    quadrant_copy_map = {\n        'TL': 'TR',\n        'TR': 'BL',\n        'BL': 'BR',\n        'BR': 'TL'\n    }\n\n    def get_quadrant(r, c):\n        if r <= 5 and c <= 5:\n            return 'TL'\n        elif r <= 5 and c >= 6:\n            return 'TR'\n        elif r >= 6 and c <= 5:\n            return 'BL'\n        else:\n            return 'BR'\n\n    for color in colors:\n        mask = (arr == color)\n        if not np.any(mask):\n            continue\n\n        rows_c, cols_c = np.where(mask)\n        min_r, max_r = rows_c.min(), rows_c.max()\n        min_c, max_c = cols_c.min(), cols_c.max()\n\n        # Copy original cluster pixels unchanged\n        output[rows_c, cols_c] = color\n\n        # Calculate center to determine original quadrant\n        mean_r = int(round(np.mean(rows_c)))\n        mean_c = int(round(np.mean(cols_c)))\n        orig_quad = get_quadrant(mean_r, mean_c)\n        target_quad = quadrant_copy_map[orig_quad]\n\n        r_start, r_end, c_start, c_end = quadrant_limits[target_quad]\n        quad_row_span = r_end - r_start + 1\n        quad_col_span = c_end - c_start + 1\n\n        cluster_height = max_r - min_r + 1\n        cluster_width = max_c - min_c + 1\n\n        # Relative offset inside original quadrant\n        orig_r_start, orig_r_end, orig_c_start, orig_c_end = quadrant_limits[orig_quad]\n\n        offset_r = min_r - orig_r_start\n        offset_c = min_c - orig_c_start\n\n        # Compute tentative new top-left in target quadrant\n        new_min_r = r_start + offset_r\n        new_min_c = c_start + offset_c\n\n        # Clamp to fit cluster inside target quadrant\n        if new_min_r < r_start:\n            new_min_r = r_start\n        if new_min_c < c_start:\n            new_min_c = c_start\n\n        if new_min_r + cluster_height - 1 > r_end:\n            new_min_r = r_end - cluster_height + 1\n        if new_min_c + cluster_width - 1 > c_end:\n            new_min_c = c_end - cluster_width + 1\n\n        # Copy the cluster pixels to the duplicate position without overwriting blue pixels\n        for r_, c_ in zip(rows_c, cols_c):\n            rr = new_min_r + (r_ - min_r)\n            cc = new_min_c + (c_ - min_c)\n            if 0 <= rr < target_size and 0 <= cc < target_size:\n                if output[rr, cc] != blue_color:\n                    output[rr, cc] = color\n\n    return output.tolist()\n```\n\n---\n\nThis should:\n\n- Preserve blue cluster exactly.\n- Duplicate precisely each non-blue cluster in the appropriate target quadrant.\n- Keep cluster shape intact.\n- Fit duplicates fully inside the target quadrant.\n- Avoid overlapping or overriding blue pixels.\n- Always produce a 11\u00d711 grid output.\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n\n    arr = np.array(grid)\n    target_size = 11\n\n    # Normalize input size to 11\u00d711\n    norm = np.zeros((target_size, target_size), dtype=int)\n    rows, cols = arr.shape\n    norm[:min(rows, target_size), :min(cols, target_size)] = arr[:target_size, :target_size]\n    arr = norm\n\n    output = np.zeros_like(arr)\n\n    blue_color = 1\n\n    output[arr == blue_color] = blue_color  # Copy blue pixels directly\n\n    # Identify non-blue, non-zero colors\n    colors = set(np.unique(arr))\n    colors.discard(0)\n    colors.discard(blue_color)\n\n    # Quadrants defined by split at row=6, col=6 (indexes 0..10)\n    quadrant_limits = {\n        'TL': (0, 5, 0, 5),\n        'TR': (0, 5, 6, 10),\n        'BL': (6, 10, 0, 5),\n        'BR': (6, 10, 6, 10)\n    }\n\n    quadrant_copy_map = {\n        'TL': 'TR',\n        'TR': 'BL',\n        'BL': 'BR',\n        'BR': 'TL'\n    }\n\n    def get_quadrant(r, c):\n        if r <= 5 and c <= 5:\n            return 'TL'\n        elif r <= 5 and c >= 6:\n            return 'TR'\n        elif r >= 6 and c <= 5:\n            return 'BL'\n        else:\n            return 'BR'\n\n    for color in colors:\n        mask = (arr == color)\n        if not np.any(mask):\n            continue\n\n        rows_c, cols_c = np.where(mask)\n        min_r, max_r = rows_c.min(), rows_c.max()\n        min_c, max_c = cols_c.min(), cols_c.max()\n\n        # Copy original cluster pixels unchanged\n        output[rows_c, cols_c] = color\n\n        # Calculate center to determine original quadrant\n        mean_r = int(round(np.mean(rows_c)))\n        mean_c = int(round(np.mean(cols_c)))\n        orig_quad = get_quadrant(mean_r, mean_c)\n        target_quad = quadrant_copy_map[orig_quad]\n\n        r_start, r_end, c_start, c_end = quadrant_limits[target_quad]\n        quad_row_span = r_end - r_start + 1\n        quad_col_span = c_end - c_start + 1\n\n        cluster_height = max_r - min_r + 1\n        cluster_width = max_c - min_c + 1\n\n        # Relative offset inside original quadrant\n        orig_r_start, orig_r_end, orig_c_start, orig_c_end = quadrant_limits[orig_quad]\n\n        offset_r = min_r - orig_r_start\n        offset_c = min_c - orig_c_start\n\n        # Compute tentative new top-left in target quadrant\n        new_min_r = r_start + offset_r\n        new_min_c = c_start + offset_c\n\n        # Clamp to fit cluster inside target quadrant\n        if new_min_r < r_start:\n            new_min_r = r_start\n        if new_min_c < c_start:\n            new_min_c = c_start\n\n        if new_min_r + cluster_height - 1 > r_end:\n            new_min_r = r_end - cluster_height + 1\n        if new_min_c + cluster_width - 1 > c_end:\n            new_min_c = c_end - cluster_width + 1\n\n        # Copy the cluster pixels to the duplicate position without overwriting blue pixels\n        for r_, c_ in zip(rows_c, cols_c):\n            rr = new_min_r + (r_ - min_r)\n            cc = new_min_c + (c_ - min_c)\n            if 0 <= rr < target_size and 0 <= cc < target_size:\n                if output[rr, cc] != blue_color:\n                    output[rr, cc] = color\n\n    return output.tolist()\n```"
        ]
      },
      {
        "role": "user",
        "content": [
          {
            "type": "input_text",
            "text": "Please analyze the training feedback and programs from all prior turns, and write an improved transformation.\n\n**Important**:\n1. Always start by attempting to find a complete rule that solves all training examples and should generalize to the test input.\n2. If you cannot find a perfect solution, provide your best attempt at a transformation that solves as many training examples as possible - ideally more than in the best previous turn.\n3. Even if your solution doesn't solve all examples perfectly, ensure it demonstrates meaningful pattern recognition and provides reasonable outputs that minimize pixel-level errors.\n\nFinal answer:\n```python\ndef transform(grid):\n    # Your improved transformation logic here (even if partial)\n    return transformed_grid\n```"
          },
          {
            "type": "input_text",
            "text": "Training results: 0/4 examples solved, 76.0% pixel accuracy - Good partial progress! Your approach is capturing some patterns. Next, try to identify a transformation that solves at least one of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[1, 1, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 1, 1, 1, 0, 3, 3, 3, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 1, 1, 1, 0, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0]]\nPixel accuracy: 86.0%\n\nTraining Example 2 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 1, 0, 0, 0, 0, 0, 0, 6, 0], [0, 1, 1, 1, 1, 0, 0, 6, 6, 6, 6], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 6, 0], [0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 86.4%\n\nTraining Example 3 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 77.8%\n\nTraining Example 4 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 60.4%\n\n\u26a0\ufe0f  GRID SIZE ERROR: One or more of your output grids are incorrect in size. They should ALL be 11\u00d711 for this task.\n\n"
          },
          {
            "type": "input_image",
            "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAmcAAATYCAIAAADVnPfcAABQcklEQVR4nO3de5RU5Z3o711IN6Jgo6ioXLwhrTkoIl6QIFHhrKMgWiVgjLdAMPEy3kBQmTF64pKIQjQxMegJiiI6OhqrUYMETRBiApFRJoJ4QUDlpkG0QQSa2/4tU7/pxYBNXqqp3tXwPIs/2ur9rb27qJePe1d1dyqO4wgACNAgZCMAQDUBYAeoJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaAFAn1bzmmmtSNbvkkku+cZvS0tKDDjro3HPPffPNN7e9z5dffjmVSu23337r1q3b6lPPPvtsKpUaM2ZM7j/79++fSqVGjhy51WaLFy9OpVK33nprbaZy1q1b99BDD51xxhmHHHJIo0aNDjnkkH79+v3pT3/azmNy66231vSAzJkzZ/sPWo8ePf7pA1u9zeWXX77l7bnD69Onz/Tp07c8nnQ6vdVmhx9++HXXXffFF1/s0IOf89lnn915550dO3YsKyvbe++9Tz755DFjxmz5a3Nyu9tq/I033jjggAOaNm06ZcqU7Tx0AMUvgXPNDRs2fPrppy+88MIZZ5yxYMGCrT77yCOPRFH0xRdfPP300yH3dtttt7377rs7egwhUx9++OGpp5565ZVXvvrqq8uWLVu/fv2yZcueffbZbt263XvvvVGRyR3ec88917Vr1yeeeGI7m3344Ye//OUvzzrrrM2bN+/Qgz99+vQOHTr8+Mc//q//+q9Vq1atWbNm5syZP/zhDwcOHLidA/vjH/94xhlnbNq06ZVXXjnjjDNq8SUC1PNq/upXv4r/2zPPPBNF0dixY6tvGT9+fPWWCxcurL593bp177zzzkUXXbRq1arRo0dveYeVlZUVFRX9+vXbb7/9HnzwwZBjWL9+ff/+/Tdt2rRDR/5PpzZs2NC3b9//+q//6tKly/PPP//ZZ59t2LDh448//vWvf73ffvvddNNNuRPHmsyaNSveRvv27b/xAan2yiuvbHknIdssW7Ysd/vatWs/+OCDW265JY7jH/zgBx999NGWm61du3bLB79Hjx6vv/76yy+/HP7g//3vf89kMkuXLv3e9743Y8aMVatWff755xUVFUccccTYsWMfeuihb3wcstlsz54999prr1dfffWUU07ZziMGUC8kcK7ZqFGjo48++u67746iaKtzzSeffHLdunVXXHHFgAEDZsyY8dZbb/3Te7v22mv/+te//uxnP9uhY/inU4899tgbb7zRo0ePadOm9e7du3nz5g0bNmzduvVVV1313HPPbdq06d///d+jYrLnnnseeeSRd91112233bZ+/fqf//zn23nwb7jhhlxxwx/8e++999NPPx00aNCTTz55yimnNG3adN999z3vvPOmTp26995733vvvdv+evOHH364X79+Bx544J/+9Kfjjjuu+vZHH300lUr96le/2qkPAMAuWs2qqqq333578ODBURS1a9duy0+NHTv2mGOOOfPMM6+66qo99tgj5HTzpz/9adu2bW+77bZ33nkn/Bj+6dSTTz6ZSqX+3//7f3vsscdWn/rOd74zd+7cO++8MypKN95441577fX73//+Gz+7YcOG999///7772/YsOF3vvOd8Af/P/7jPxo3bnzHHXdsdYetWrV67bXXXn311VQqteXt99xzz+WXX37EEUe89tprRx111M77+gB2g2oefvjh1W9I2XPPPdu3b//MM8/sv//+119/ffU2c+bM+c///M+hQ4emUqkjjzyyX79+TzzxxOrVq7d/z3vttdfYsWM3bNiwQ9dp/+nUrFmzjjnmmMMPP/wbx4855pitIrGVjh07bvUuntdee62mB6Taq6++uqPbbKtp06ZHHXXUVifxjRs3zo2XlpaWl5f/+c9/fuyxx7b86rb/4G/YsOHDDz88+eSTmzRpsu0ejz/++IMPPnjLW2666aabb745iqLTTjutTZs2W23fv3//OI6vueaa7X8hAEUome88admy5Q9+8IO//e1vBx10UPWNjzzySMuWLS+++OLcfw4bNuzLL78MuRDatWvX66677vXXXx81alT4MWxnasOGDZWVlS1atNjyxq3e13rYYYdFxap58+ZV/1DTBps2bZoxY8aGDRsCH/zKyso4jps3bx54AL/85S9PPfXUHj16PPLII88991ztvhqA3a+auTe2rF+//qmnnsqdDI0YMeKQQw6p3mDDhg3jx49fsmRJo0aNclnq0KFDHMeB7wn66U9/etRRR91+++1z584NP6qapkpKSpo2bbp8+fIoX9u+G6hr167/9J0+p59++o5u842++OKLkpKSRo0abftuoPXr1y9YsOBf/uVffvnLXw4ZMiTwwd9vv/0aNGgQ/oAMGDDg1VdfHTdu3H777ffDH/5wyZIlgYMARa5OzzVLSkq++93vPv3001OnTj3rrLO2/K6+F1988Rv/UX7zzTdnzpz5T++5cePGeVyn3c7UscceO3fu3I8//vgb3zDcqVOnqFitXr16zpw5xxxzzDd+tqSk5PDDDx81alT79u0fffTRwAd/jz32OOaYY/7zP/9zzZo122521113XXbZZUuXLq2+5de//nVpaenBBx/8q1/96vPPP7/sssu2/S4XgPoogSu0Z5999rXXXvvmm29Wn+vkrhDuueeeK1eu3PK86i9/+UsURTV9V8NWvv3tb19//fUzZ87c9icY5DF18cUXb968+eqrr/7GBm/7ftHicd99923YsOGss87a/mYNGjRYvXr1xo0bAx/8dDq9du3a//t//+9W9/Phhx/ec889L7744jdev/3e977Xt2/fP/7xjzt08RygaCXzuuZPf/rTNm3ajB49+q9//WsURZ988smkSZN69+69zz77bLnZqaeeWl5e/u///u8rV64Mudvhw4cfddRRv/71r3foYL5x6vLLL+/UqdPvfve7k08++T/+4z8++eSTDRs25H7KQa9evd58880GDYrrhxFWVVW99957t956609+8pO99tqrpvfaxHG8ePHioUOHvvXWWx07dmzYsGHggz9o0KDmzZuPHDnysssu+8///M+1a9d++umnTz755Omnn15ZWTl06NAtLwhvafTo0S1atLj11lvfeOONwnzpAHUnmX/6995771/+8pebN2++4oorNm7cOG7cuI0bN1a/FWVL3//+99esWfP444+HX3Hd/rtbA6dKS0srKipOPfXUN99887vf/e7BBx9cWlqa+4l6EydOLC8vD/zRRTX5xvfHplKpLd8zHLLNwQcfXP3O5KOPPnr48OG5Hx/YunXrrb7G3GYNGjRo3br1qFGjGjRokPvmmcAHv3nz5k8//XTTpk0ff/zxk046aa+99jrooIMuvvjijz76KJPJ3HTTTTV9pfvvv/9vfvObDRs2XHTRRV999ZXv1wTqtcROmM4999x0Ov23v/3t5z//+aOPPrrvvvueffbZ22522WWXNWjQIPAibe6Ka+5b+HfIN061atXqT3/60/jx43v27NmqVavS0tIWLVr07NnzsccemzNnzkknnRQVk5KSktatW1944YV//vOfv/e979W02R577HHggQf26tXr5Zdfzl3FDX/wu3fvPmvWrOuuu+7oo49u0qRJ48aNTznllDFjxvz2t7/d9rtat9S7d+/+/fu///77W36jEUB9lCrml+gAoKgU14tzAFDMVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZq7lBUrVrz77rtJHwUUBcuBQlDNQmnVqlVqG+PHjy/oTnv06DFjxozw7UeNGtW5c+eaPltZWXnEEUfs0B3Ctvbff//qJVBaWnrMMcfcf//9ed9b9ZO2srIylUptp4uWA4WgmgV03333xf/TJZdcUtA9rl27dmfd1aJFi3r06LFw4cKddYfszkaPHp1bAl999dXIkSOHDBny+OOP1/I+mzVrFsfx0UcfXdMGlgOFoJp17eGHH27UqNGiRYuiKFq+fPk+++wzduzYzz77LJVKPfzww61atSorKxs4cGD1gl+2bFnfvn2bNGnSunXrwYMHV9++ZMmSTCbTtGnTAw444Oqrr66qqjr99NPfe++9AQMGXH755dsZfPvtt0877bTGjRt36dKlpn8Ffve737Vv375Tp0519aiwuygpKTnnnHO6d++ezWY/+eSTVCo1bNiwsrKy/v377+iTdstzTcuBOqOadW3gwIFdu3YdMWJEFEXDhw8/8cQTBwwYkPvUPffcM2nSpFmzZr3xxhvXXHNN7sY+ffo0bdr0ww8/nDp16syZMwcNGhRF0aZNm84+++zS0tL58+dPnz599uzZt99++6uvvlpeXj527NgxY8bUNLhu3bqePXt26NBh6dKlw4YNGzt27DceZKNGjV555ZUHHnigDh8YdiMbN25s0qRJ7uN333138eLFd9xxR95PWsuBOrXVJUR2lpYtW271UO+xxx65T82bN69Zs2b33ntvWVnZvHnz4jhevnx5FEXZbDa3weTJk0tLS1evXj116tS99tqrqqoqd/vMmTMbNGiwdu3aqVOnlpaWrlixYqud5v6ZiOO4psGKioqysrI1a9bkbv/Rj350yimn1PQlbNiwIYqi6dOnF+DhYTfSvHnz6iu0lZWVY8eObdCgwYsvvrhs2bIoiiZOnJj71I4+ab/44osoit555x3LgbrkXLPuXtfcuHFj7va2bdsOHTp08ODBN954Y9u2bau3r34nwvHHH79+/fr58+fPnTt3zZo1jRo1yr2T4qSTTtq8efOCBQvefvvtVq1a7bfffjXtuqbBuXPnHnnkkY0bN85t1rFjxwI/BvC1q666KvdUbNGixahRox544IFevXrlPtWmTZtaPmktB+qSaiZjzpw5URS9+eabW95YUlKS+2DTpk1RFDVs2HDjxo1t27bd6v90vvWtb5WUlKRSqe3cf02DW21WvUcoqOpzzXXr1s2ZM+fKK6+s/lSjRo1q+aS1HKhLqpmAl1566emnnx45cuSECRMqKiqqb3/rrbdyH8yaNatJkyZHHnnk0UcfvXDhwsWLF291D+3atVu0aFHuCtWWqv/tqGmwffv28+bN++qrr3L/OXv27J39xUGe8n7SWg7UJdWsa6tXr77yyiuvu+66IUOG/PCHP7zmmmu+/PLL3KduuummhQsXzps37+abb/7Rj37UqFGjM88887jjjhswYMCiRYuWLFlyww03tGnTpqqq6rTTTmvfvv2111772Wefffjhh3369Pne974XRdHee++9dOnSL7/8sqbB//N//s/BBx98/fXXf/7556+88sojjzyS9OMB/7+8n7SWA3VqJ70+yj9/N1AURVdcccW111572GGHrV69Oo7jlStXtm7d+pprrsm9G+iWW2459NBD991338GDB69fvz53Px999NF55523995777PPPmedddY777yTu33hwoVnn332nnvu2bx58/79+69cuTKO49/85jdNmjTp06fPdgbnz5/fvXv3Pffcs3379oMHD/b2B+ry3UBbyr0bKPeGuJwdetJWvxvIcqAupeI4jpKQyWQS2W9xWr9+/cSJE7t37960adOkj2X3lc1mE9mvtUCxSWot1AsNE9x3Rdu78xtMf3BzrWa3eClxx2bT6YLO/uEPf0hkv9uZXXBrZX6zR9zZrDaziXy9CbIWzBbVLNvhdU0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABAqFcdxlIRMJpPIfqEm2Ww2kf1a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QqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqnmLmXFihXvvvtu0kcBRcFyoBBUs1BatWqV2sb48eMLutMePXrMmDEjfPtRo0Z17tx529vnzZt3zjnnNGvW7OCDD77iiitWrVq1Uw+T3cv+++9fvQRKS0uPOeaY+++/P+97q37SVlZWplKp7XTRcqAQVLOA7rvvvvh/uuSSSwq6x7Vr19b+TjZs2HDOOeccdthhCxcu/NOf/vTGG29ceeWVO+Po2H2NHj06twS++uqrkSNHDhky5PHHH6/lfTZr1iyO46OPPrqmDSwHCkE169rDDz/cqFGjRYsWRVG0fPnyffbZZ+zYsZ999lkqlXr44YdbtWpVVlY2cODA6gW/bNmyvn37NmnSpHXr1oMHD66+fcmSJZlMpmnTpgcccMDVV19dVVV1+umnv/feewMGDLj88su3M/j222+fdtppjRs37tKly8KFC7c9wpkzZy5YsODee+/dd99927Zte/vtt0+YMCGO4zp8kNhllZSUnHPOOd27d89ms5988kkqlRo2bFhZWVn//v139Em75bmm5UCdUc26NnDgwK5du44YMSKKouHDh5944okDBgzIfeqee+6ZNGnSrFmz3njjjWuuuSZ3Y58+fZo2bfrhhx9OnTp15syZgwYNiqJo06ZNZ599dmlp6fz586dPnz579uzbb7/91VdfLS8vHzt27JgxY2oaXLduXc+ePTt06LB06dJhw4aNHTt22yPs0qXLhg0bSktLc/+5bNmy/fbbL5VK1eGDxC5u48aNTZo0yX387rvvLl68+I477sj7SWs5UKe2uoTIztKyZcutHuo99tgj96l58+Y1a9bs3nvvLSsrmzdvXhzHy5cvj6Iom83mNpg8eXJpaenq1aunTp261157VVVV5W6fOXNmgwYN1q5dO3Xq1NLS0hUrVmy109w/E3Ec1zRYUVFRVla2Zs2a3O0/+tGPTjnllO18FZWVlYcffvjtt9++sx8ediPNmzevvkJbWVk5duzYBg0avPjii8uWLYuiaOLEiblP7eiT9osvvoii6J133rEcqEvONevudc2NGzfmbm/btu3QoUMHDx584403tm3btnr76nciHH/88evXr58/f/7cuXPXrFnTqFGj3DspTjrppM2bNy9YsODtt99u1arVfvvtV9OuaxqcO3fukUce2bhx49xmHTt23M7xf/XVV717927fvv2tt966kx4SdlNXXXVV7qnYokWLUaNGPfDAA7169cp9qk2bNrV80loO1CXVTMacOXOiKHrzzTe3vLGkpCT3waZNm6Ioatiw4caNG9u2bbvV/+l861vfKikp2f41opoGt9qseo/bWrFiRffu3Vu1avXss882bNiwdl8uu7vqc81169bNmTNnyzfUNGrUqJZPWsuBuqSaCXjppZeefvrpkSNHTpgwoaKiovr2t956K/fBrFmzmjRpcuSRRx599NELFy5cvHjxVvfQrl27RYsW5a5Qban6346aBtu3bz9v3ryvvvoq95+zZ8/+xiNcvHhx165du3Xr9sQTT1S/ogMFlfeT1nKgTu2kK71srWXLltt+50kcx19++WWbNm1uuOGG3OsoLVu2XLVqVe51zRNPPHHBggXvv//+scceO3jw4DiON23a1LFjxx49enz88ceLFy++/vrrW7duvW7dus2bN59wwgkXX3zx8uXLFy5ceP7551944YVxHHfq1Gn48OGrVq2qabCqqqpdu3YDBw5csWLFyy+/3LRp021fyPniiy+OOuqom266qa4eKnaj1zW3lHtdM/fS/nae7TU9aatf17QcqEuqWXfvBoqi6Iorrrj22msPO+yw1atXx3G8cuXK1q1bX3PNNblq3nLLLYceeui+++47ePDg9evX5+7no48+Ou+88/bee+999tnnrLPOeuedd3K3L1y48Oyzz95zzz2bN2/ev3//lStXxnH8m9/8pkmTJn369NnO4Pz587t3777nnnu2b99+8ODB2/4zcdddd2175F9++WXdPn7sdtXc0SdtdTUtB+pSKqlvPMpkMonstzitX79+4sSJ3bt3b9q0adLHsvvKZrOJ7NdaoNgktRbqhzgh6XQ672M2a7YQs9aCWbPJroV6wbuBACCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAqFQcx1ESMplMIvuFmmSz2UT2ay1QbJJaC/VDnJB0Op33MZs1W4hZa8Gs2WTXQr3gCi0AhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAiViuM4SkImk0lkv1CTbDabyH6tBYpNUmuhfogTkk6n8z5ms2YLMWstmDWb7FqoF1yhBYBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVJxHEdJyGQyiewXapLNZhPZr7VAsUlqLdQPcULS6XTex2zWbCFmrQWzZpNdC/WCK7QAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASBUw+AtAWDHpVI1fiqhH4ReG6oJQN3Gcttt6k8+VROAOu/lN47Uh3aqJgDJ9bK+tdO7gQAogmTu9PspDNUEoMhSlyrecKomAMUXuVSRhlM1ASjKvKWKMZypOKHXXTOZTCL7hZpks9lE9mstUI/XQqrwYSuyNwcl+R7aioqK/AbT6XRF27vznP3g5lrN1uaYzQbPPjrtuvxm+3e7P+/ZBFkLZotqtrjOBVOpogqnK7QAEEo1ASjuFx1TRfQCp2oCQCjVBKDoT/5SxXK6qZoAEEo1ASCUagJQHy6WporiIq3feQJAgcVxNGFCtHFjVFISnXtukfQvP841ASiw11+PXnop6ts3ev75aMaMqD5TTQAKbNGiqKoq6tw5WrLk6z/1mWoCUHjjx0fDhkWTJkX1nGoCUHgDBkSPPhr17h3Vc6oJQIG1bh01bhxls19/0LJlVJ95Dy0ABXbyydEnn0Tdun39HtrOnaP6TDUBKLBUPf5Wk624QgvAjogT+m2XxfFbNlUTAEKpJgCESsUJnfNmMplE9gs1yWaziezXWqBeroVUaje8PJvwu4EqKiryG0yn07WabXt3nrMf3JzYMe9ms49Ouy6/2f7d7s97vwmyFszWNLu7rYXi5wotAMV98hcXy4mmagLADlBNAIr4FDAuohNN1YQ8HX/88Uv+8asbqqqq2rVrd//993fs2PGEE06YPHly0ocGdSiOd6tkqibkqW/fvs8//3wURVOmTDnrrLPuvPPOadOmPfnkk+PHj0/60KBuxfHuk0zVhDz169dvwoQJURS98MILF1xwQc+ePS+77LJFixaNGzcu6UODOhfHu0kyVRPyVF5evmLFilWrVs2aNevb3/72o48+OmjQoNGjRw8YMCDpQ4MkxPHukEw/vR3yd955540YMeLkk09etWrVueee+8orr3Tq1OmII45I+rggIXG8c370QREnUzUhf/369TvuuOOmTJlSVlZ2zjnndO7cefPmzT/+8Y+TPi5ITvyP4OXdzuLuZY5qQp7Ky8urqqpyHw/9h6SPCOptO+N60Msc1QSgAOL/DuF28ll/YllNNQEopLj+pXE7vIcWAEKpJgCEUk0ACKWaABBKNQEglGoCQKhUnNB7gjOZTCL7hZpks9lE9mstUGySWgv1QpLfr1lRUZHfYDqdrmh7d56zH9xcL2dr81jVYvbRadflN9u/2/31bjZB1kLxr4XdapbtcIUWAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBKBW/vCHP3Tp0uWMM8447bTTpk+fHkXR5s2br7vuulNPPbVbt24LFizYdmTixImNGzeOomjEiBHt27cfOXJkbqpXr16VlZVREfP7NQGolYEDB06ZMuXwww+fP39+7969586d++CDDzZt2nT69OnZbHbIkCHPPffcltt/+eWXd955Z0lJSRRFv/jFL957773y8vKhQ4eOGTOmT58+zZo1i4qYc00AaqV58+YrVqyIomjFihVfffVVFEVPPPHEgAEDoijq1atX586dt9r+lltuueGGGxo0+DpAJSUlf//730tLSz///PMJEybkpoqZagJQKw8++GDXrl2PPfbYbt26PfDAA1EUvf/++88///zpp5/+3e9+94ILLthy49dee23p0qXVNw4fPvySSy656667br311p/85CepVCoqbqoJQK0MGTLkiSeemD179uOPP567GLt+/fpDDz301VdfveSSSwYOHFi9ZVVV1ZAhQ3Jlzbn00ktnzJhRXl4eRdGCBQt69er17LPPRkXM65oA1Mrs2bNzv4Tg/PPPv+qqq6IoatGiRTqdzv043CuvvLJ6y9/+9rdffvnlRRddFEXR6tWrL7vssnHjxsVxfNttt40bN65Tp04zZszo0qVL3759o2LlXBOAWikvL//zn/8cRdH06dMPO+ywKIrOPPPMadOmRVE0bdq0Dh065BoZRdFFF1309ttvv/oPTZo0GTduXBRFjzzySO/evZs3b7527do4jtesWRMVMeeaANTKgw8+eN11X/+uoVQqNWbMmCiK7rjjjoEDB95xxx0NGzZ86KGHcqehkydP3na2srLymWeemThxYhRFgwYN6tGjx4033hgVMdUEoFY6dOgwderULW858MADX3jhhS1v2TaZue/LbNas2aRJk3K33PIPUXFzhRYAQqkmAIRSTQAIlYrjOEpC7m3KUDyy2Wwi+7UWKDZJrYX6IU5I7lt58mPWbCFmrQWzZpNdC/WCK7QAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASBUKo7jKAmZTCaR/UJNstlsIvu1Fig2Sa2F+iFOSDqdzvuYzZotxKy1YNZssmuhXnCFFgBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhErFcRwlIZPJJLJfqEk2m01kv9YCxSaptVA/xAlJp9N5H7NZs4WYtRbMmk12LdQLrtACQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqTiOoyRkMplE9gs1yWaziezXWqDYJLUW6oc4Iel0Ou9jNmu2ELPWwg7NVu73x/z+1NOvd7eaTWot1Auu0AJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCpOI6jJGQymUT2CzXJZrNJHwJQ9OKEpNPpvI/ZrNlCzCa1FoB6xBVaAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQKhXHcfDGALBbc64JAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFLNXcqKFSvefffdpI8C6gGLhfyoZqG0atUqtY3x48cXdKc9evSYMWNG+PajRo3q3Lnztrd/+umnffv23WeffVq3bn3nnXfu1GOE/2H//fevXiClpaXHHHPM/fffn/e9VT+lKysrU6nUdrposZCfhnnOEeC+++674YYb6nKPa9eu3Sn3c9FFF7Vp02bRokXz5s07++yzDzrooMsvv3yn3DNsa/To0VdeeWUURRs2bPj9739//vnn77vvvpdeemlt7rNZs2ZxHG9nA4uF/DjXrGsPP/xwo0aNFi1aFEXR8uXL99lnn7Fjx3722WepVOrhhx9u1apVWVnZwIEDq5f0smXL+vbt26RJk9atWw8ePLj69iVLlmQymaZNmx5wwAFXX311VVXV6aef/t577w0YMCC3aGsafPvtt0877bTGjRt36dJl4cKF2x7h/Pnzp0yZMmrUqLKyshNPPPGMM874y1/+UoePELuvkpKSc845p3v37tls9pNPPkmlUsOGDSsrK+vfv/+OPqW3PNe0WNiZYgqjZcuW99133zd+6swzz7z66qvjOL7++uvPOOOMOI6XL18eRVG7du1mz549f/78Dh06/OAHP8htfOqpp/bv33/58uXz58/v2rXrFVdcEcfxxo0bjz322AsuuODTTz+dN29e165db7755jiOy8vLx44du53BtWvXtmnT5l/+5V8+//zz559/vnHjxqecckpNX8KGDRteeeWV/fbb7/nnny/MgwRx8+bNR48eveUtPXr0uPTSS5ctWxZFUTqdXrVq1UcffbSjT+kvvvgiiqJ33nnHYmHnUs1Cadmy5Vb/g7LHHnvkPjVv3rxmzZrde++9ZWVl8+bNq65mNpvNbTB58uTS0tLVq1dPnTp1r732qqqqyt0+c+bMBg0arF27durUqaWlpStWrNhqp9X/ENQ0WFFRUVZWtmbNmtztP/rRj7bzD0F5eXmjRo1OP/305cuXF+ARgq2rWVlZOXbs2AYNGrz44ou5ak6cODH3qR19SldX02Jh53KFtoC2OtfcuHFj7va2bdsOHTp08ODBN954Y9u2bau3r36vwfHHH79+/fr58+fPnTt3zZo1jRo1yr1X4qSTTtq8efOCBQvefvvtVq1a7bfffjXtuqbBuXPnHnnkkY0bN85t1rFjx+0c/7vvvrtixYq99trrnHPO2UkPCXyDq666KvdEbdGixahRox544IFevXrlPtWmTZtaPqUtFnYu1UzGnDlzoih68803t7yxpKQk98GmTZu+fqdWw4YbN25s27btVv+n861vfaukpCSVSm3n/msa3Gqz6j3WZO+997711lv/+te/Ll26NN+vFf6J6nPNdevWzZkzJ/fOoJxGjRrV8iltsbBzqWYCXnrppaeffnrkyJETJkyoqKiovv2tt97KfTBr1qwmTZoceeSRRx999MKFCxcvXrzVPbRr127RokW5a1Bbqv7XoabB9u3bz5s376uvvsr95+zZs7c9vEmTJpWVlVVVVeX+8/PPP99jjz2aNWtWuy8aaiXvp7TFwk62k670EvpuoC+//LJNmzY33HBD7pWSli1brlq1Kve65oknnrhgwYL333//2GOPHTx4cBzHmzZt6tixY48ePT7++OPFixdff/31rVu3Xrdu3ebNm0844YSLL754+fLlCxcuPP/88y+88MI4jjt16jR8+PBVq1bVNFhVVdWuXbuBAweuWLHi5Zdfbtq06bYv1axdu7Zdu3ZXX311ZWXl3/72t2OOOebyyy+vq4eN3c627wbKyb2umXvhfztroaandPXrmhYLO5dq1t27gaIouuKKK6699trDDjts9erVcRyvXLmydevW11xzTa6at9xyy6GHHrrvvvsOHjx4/fr1ufv56KOPzjvvvL333nufffY566yz3nnnndztCxcuPPvss/fcc8/mzZv3799/5cqVcRz/5je/adKkSZ8+fbYzOH/+/O7du++5557t27cfPHjwN77B4YMPPujZs+c+++zTpk2bYcOGrV27tg4fOXYvgdXc0ad0dTUtFnau1Pa/Ebg2MplMge5517N+/fqJEyd27969adOmSR8L3yybzSayX+uIYpNNaC0Ui7hg0ul03ke1u8327Nkzkf2aLYaVYh2ZrV+z8e7Nu4EAIJRqFoXS0tKkDwGAf041ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAECoVx3FUGJlMpkD3DHUvm80msl/riGKTTWgtFImGBb33ioqK/AbT6XS9nG17d56zH9xcL7/e3Wk2QfXusbKOdu3Z3ZwrtAAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQ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1VcjR44cMmTI448/Xsv7bNasWRzHRx99dE0bWErURDXr2sMPP9yoUaNFixZFUbR8+fJ99tln7Nixn332WSqVevjhh1u1alVWVjZw4MDqRbts2bK+ffs2adKkdevWgwcPrr59yZIlmUymadOmBxxwwNVXX11VVXX66ae/9957AwYMuPzyy7cz+Pbbb5922mmNGzfu0qXLwoULazrOdevWDRw48MQTT6yTRwX+uZKSknPOOad79+7ZbPaTTz5JpVLDhg0rKyvr37//jj7htzzXtJTYIapZ1wYOHNi1a9cRI0ZEUTR8+PATTzxxwIABuU/dc889kyZNmjVr1htvvHHNNdfkbuzTp0/Tpk0//PDDqVOnzpw5c9CgQVEUbdq06eyzzy4tLZ0/f/706dNnz559++23v/rqq+Xl5WPHjh0zZkxNg+vWrevZs2eHDh2WLl06bNiwsWPH1nSct9122//6X//r/PPPr6sHBoJs3LixSZMmuY/ffffdxYsX33HHHXk/4S0ldthWlxDZWVq2bLnVQ73HHnvkPjVv3rxmzZrde++9ZWVl8+bNi+N4+fLlURRls9ncBpMnTy4tLV29evXUqVP32muvqqqq3O0zZ85s0KDB2rVrp06dWlpaumLFiq12mlvqcRzXNFhRUVFWVrZmzZrc7T/60Y9OOeWUbQ/+9ddfP+CAA5YtW3bXXXd95zvfKdiDBP9E8+bNq6/QVlZWjh07tkGDBi+++OKyZcuiKJo4cWLuUzv6hP/iiy+iKHrnnXcsJXaUc826e11z48aNudvbtm07dOjQwYMH33jjjW3btq3evvrdBMcff/z69evnz58/d+7cNWvWNGrUKPduiJNOOmnz5s0LFix4++23W7Vqtd9++9W065oG586de+SRRzZu3Di3WceOHbed3bBhww9+8IORI0cedNBBO/shgR121VVX5Z7GLVq0GDVq1AMPPNCrV6/cp9q0aVPLJ7ylxI5SzWTMmTMniqI333xzyxtLSkpyH2zatCmKooYNG27cuLFt27Zb/Z/Ot771rZKSklQqtZ37r2lwq82q97il4cOHt2rV6vvf//7O+EKhtqrPNdetWzdnzpwrr7yy+lONGjWq5RPeUmJHqWYCXnrppaeffnrkyJETJkyoqKiovv2tt97KfTBr1qwmTZoceeSRRx999MKFCxcvXrzVPbRr127RokW5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"
          },
          {
            "type": "input_text",
            "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
          }
        ]
      },
      {
        "type": "message",
        "role": "assistant",
        "content": [
          "The main challenge remains reproducing the secondary colored clusters in a shifted quadrant correctly, preserving their shape and relative arrangement, while leaving the blue cluster intact.\n\nThe previous approach mostly got the duplication and placement logic correct but suffered from scatter/partial placement (some pixels moved incorrectly or missed), and possibly some quadrant offset or cluster bounding box handling errors that caused inaccuracies.\n\n---\n\n**Improvement plan:**\n\n- Carefully extract each cluster using its exact bounding box and positions (not just centroid).\n- Duplicate *all* cluster pixels exactly to the target quadrant using *offset relative to quadrant origin*, preserving shape perfectly.\n- Make sure the duplicated cluster fits entirely inside the target quadrant and adjust placement if needed.\n- Keep blue cluster unchanged.\n- Avoid overwriting blue pixels in output.\n- Ensure output size is exactly 11x11.\n\n---\n\nHere's the refined implementation:\n\n```python\ndef transform(grid):\n    import numpy as np\n\n    arr = np.array(grid)\n    target_size = 11\n\n    # Normalize grid size\n    norm = np.zeros((target_size, target_size), dtype=int)\n    norm[:arr.shape[0], :arr.shape[1]] = arr[:target_size, :target_size]\n    arr = norm\n\n    output = np.zeros_like(arr)\n    blue_color = 1\n\n    # Copy blue pixels unchanged\n    output[arr == blue_color] = blue_color\n\n    # Get unique colors other than 0 and blue\n    colors = set(np.unique(arr))\n    colors.discard(0)\n    colors.discard(blue_color)\n\n    # Define quadrants limits (inclusive ranges)\n    # Rows and cols split at 6 (0-based indexing: 0 to 10, split at index 6)\n    quadrants = {\n        'TL': (0, 5, 0, 5),\n        'TR': (0, 5, 6, 10),\n        'BL': (6, 10, 0, 5),\n        'BR': (6, 10, 6, 10)\n    }\n\n    # Map each original quadrant to target quadrant\n    quadrant_map = {\n        'TL': 'TR',\n        'TR': 'BL',\n        'BL': 'BR',\n        'BR': 'TL'\n    }\n\n    def get_quadrant(r, c):\n        for q_name, (r_start, r_end, c_start, c_end) in quadrants.items():\n            if r_start <= r <= r_end and c_start <= c <= c_end:\n                return q_name\n        return None  # Should never happen here\n\n    for color in colors:\n        positions = np.argwhere(arr == color)\n        if positions.size == 0:\n            continue\n\n        min_r, min_c = positions.min(axis=0)\n        max_r, max_c = positions.max(axis=0)\n\n        # Copy original cluster pixels\n        for r, c in positions:\n            output[r, c] = color\n\n        # Compute centroid of cluster pixels to find original quadrant\n        centroid_r = int(round(positions[:, 0].mean()))\n        centroid_c = int(round(positions[:, 1].mean()))\n        orig_quad = get_quadrant(centroid_r, centroid_c)\n        target_quad = quadrant_map[orig_quad]\n\n        # Quadrant bounds\n        r_start, r_end, c_start, c_end = quadrants[target_quad]\n\n        cluster_height = max_r - min_r + 1\n        cluster_width = max_c - min_c + 1\n\n        # Compute offset within original quadrant top-left corner\n        orig_r_start, orig_r_end, orig_c_start, orig_c_end = quadrants[orig_quad]\n        offset_r = min_r - orig_r_start\n        offset_c = min_c - orig_c_start\n\n        # Calculate tentative top-left target position\n        new_min_r = r_start + offset_r\n        new_min_c = c_start + offset_c\n\n        # Clamp to fit cluster fully inside target quadrant\n        if new_min_r < r_start:\n            new_min_r = r_start\n        if new_min_c < c_start:\n            new_min_c = c_start\n        if new_min_r + cluster_height - 1 > r_end:\n            new_min_r = r_end - cluster_height + 1\n        if new_min_c + cluster_width - 1 > c_end:\n            new_min_c = c_end - cluster_width + 1\n\n        # Place duplicated cluster pixels preserving shape & relative pos\n        for r, c in positions:\n            rr = new_min_r + (r - min_r)\n            cc = new_min_c + (c - min_c)\n            if 0 <= rr < target_size and 0 <= cc < target_size:\n                # Don't overwrite blue pixels\n                if output[rr, cc] != blue_color:\n                    output[rr, cc] = color\n\n    return output.tolist()\n```\n\n---\n\nThis solution strictly:\n\n- Preserves blue pixels identically.\n- Duplicates all non-blue clusters exactly, preserving shape and relative arrangement.\n- Places duplicates in mapped quadrant, preserving relative offset w.r.t. quadrant origin.\n- Clamps duplicate to fit inside quadrant.\n- Avoids overwriting blue pixels.\n- Outputs 11\u00d711 grid.\n\nThis should improve pixel-level agreement and solve more training cases correctly, better matching the clusters' spatial arrangement in outputs.\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n\n    arr = np.array(grid)\n    target_size = 11\n\n    # Normalize grid size\n    norm = np.zeros((target_size, target_size), dtype=int)\n    norm[:arr.shape[0], :arr.shape[1]] = arr[:target_size, :target_size]\n    arr = norm\n\n    output = np.zeros_like(arr)\n    blue_color = 1\n\n    # Copy blue pixels unchanged\n    output[arr == blue_color] = blue_color\n\n    # Get unique colors other than 0 and blue\n    colors = set(np.unique(arr))\n    colors.discard(0)\n    colors.discard(blue_color)\n\n    # Define quadrants limits (inclusive ranges)\n    quadrants = {\n        'TL': (0, 5, 0, 5),\n        'TR': (0, 5, 6, 10),\n        'BL': (6, 10, 0, 5),\n        'BR': (6, 10, 6, 10)\n    }\n\n    # Map each original quadrant to target quadrant\n    quadrant_map = {\n        'TL': 'TR',\n        'TR': 'BL',\n        'BL': 'BR',\n        'BR': 'TL'\n    }\n\n    def get_quadrant(r, c):\n        for q_name, (r_start, r_end, c_start, c_end) in quadrants.items():\n            if r_start <= r <= r_end and c_start <= c <= c_end:\n                return q_name\n        return None\n\n    for color in colors:\n        positions = np.argwhere(arr == color)\n        if positions.size == 0:\n            continue\n\n        min_r, min_c = positions.min(axis=0)\n        max_r, max_c = positions.max(axis=0)\n\n        # Copy original cluster pixels\n        for r, c in positions:\n            output[r, c] = color\n\n        centroid_r = int(round(positions[:, 0].mean()))\n        centroid_c = int(round(positions[:, 1].mean()))\n        orig_quad = get_quadrant(centroid_r, centroid_c)\n        target_quad = quadrant_map[orig_quad]\n\n        r_start, r_end, c_start, c_end = quadrants[target_quad]\n\n        cluster_height = max_r - min_r + 1\n        cluster_width = max_c - min_c + 1\n\n        orig_r_start, orig_r_end, orig_c_start, orig_c_end = quadrants[orig_quad]\n        offset_r = min_r - orig_r_start\n        offset_c = min_c - orig_c_start\n\n        new_min_r = r_start + offset_r\n        new_min_c = c_start + offset_c\n\n        if new_min_r < r_start:\n            new_min_r = r_start\n        if new_min_c < c_start:\n            new_min_c = c_start\n        if new_min_r + cluster_height - 1 > r_end:\n            new_min_r = r_end - cluster_height + 1\n        if new_min_c + cluster_width - 1 > c_end:\n            new_min_c = c_end - cluster_width + 1\n\n        for r, c in positions:\n            rr = new_min_r + (r - min_r)\n            cc = new_min_c + (c - min_c)\n            if 0 <= rr < target_size and 0 <= cc < target_size:\n                if output[rr, cc] != blue_color:\n                    output[rr, cc] = color\n\n    return output.tolist()\n```"
        ]
      },
      {
        "role": "user",
        "content": [
          {
            "type": "input_text",
            "text": "Please analyze the training feedback and programs from all prior turns, and write an improved transformation.\n\n**Important**:\n1. Always start by attempting to find a complete rule that solves all training examples and should generalize to the test input.\n2. If you cannot find a perfect solution, provide your best attempt at a transformation that solves as many training examples as possible - ideally more than in the best previous turn.\n3. Even if your solution doesn't solve all examples perfectly, ensure it demonstrates meaningful pattern recognition and provides reasonable outputs that minimize pixel-level errors.\n\nFinal answer:\n```python\ndef transform(grid):\n    # Your improved transformation logic here (even if partial)\n    return transformed_grid\n```"
          },
          {
            "type": "input_text",
            "text": "Training results: 0/4 examples solved, 76.0% pixel accuracy - Good partial progress! Your approach is capturing some patterns. Next, try to identify a transformation that solves at least one of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[1, 1, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 1, 1, 1, 0, 3, 3, 3, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 1, 1, 1, 0, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0]]\nPixel accuracy: 86.0%\n\nTraining Example 2 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 1, 0, 0, 0, 0, 0, 0, 6, 0], [0, 1, 1, 1, 1, 0, 0, 6, 6, 6, 6], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 6, 0], [0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 86.4%\n\nTraining Example 3 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 77.8%\n\nTraining Example 4 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 60.4%\n\n\u26a0\ufe0f  GRID SIZE ERROR: One or more of your output grids are incorrect in size. They should ALL be 11\u00d711 for this task.\n\n"
          },
          {
            "type": "input_image",
            "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAmcAAATYCAIAAADVnPfcAABQcklEQVR4nO3de5RU5Z3o711IN6Jgo6ioXLwhrTkoIl6QIFHhrKMgWiVgjLdAMPEy3kBQmTF64pKIQjQxMegJiiI6OhqrUYMETRBiApFRJoJ4QUDlpkG0QQSa2/4tU7/pxYBNXqqp3tXwPIs/2ur9rb27qJePe1d1dyqO4wgACNAgZCMAQDUBYAeoJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaAFAn1bzmmmtSNbvkkku+cZvS0tKDDjro3HPPffPNN7e9z5dffjmVSu23337r1q3b6lPPPvtsKpUaM2ZM7j/79++fSqVGjhy51WaLFy9OpVK33nprbaZy1q1b99BDD51xxhmHHHJIo0aNDjnkkH79+v3pT3/azmNy66231vSAzJkzZ/sPWo8ePf7pA1u9zeWXX77l7bnD69Onz/Tp07c8nnQ6vdVmhx9++HXXXffFF1/s0IOf89lnn915550dO3YsKyvbe++9Tz755DFjxmz5a3Nyu9tq/I033jjggAOaNm06ZcqU7Tx0AMUvgXPNDRs2fPrppy+88MIZZ5yxYMGCrT77yCOPRFH0xRdfPP300yH3dtttt7377rs7egwhUx9++OGpp5565ZVXvvrqq8uWLVu/fv2yZcueffbZbt263XvvvVGRyR3ec88917Vr1yeeeGI7m3344Ye//OUvzzrrrM2bN+/Qgz99+vQOHTr8+Mc//q//+q9Vq1atWbNm5syZP/zhDwcOHLidA/vjH/94xhlnbNq06ZVXXjnjjDNq8SUC1PNq/upXv4r/2zPPPBNF0dixY6tvGT9+fPWWCxcurL593bp177zzzkUXXbRq1arRo0dveYeVlZUVFRX9+vXbb7/9HnzwwZBjWL9+ff/+/Tdt2rRDR/5PpzZs2NC3b9//+q//6tKly/PPP//ZZ59t2LDh448//vWvf73ffvvddNNNuRPHmsyaNSveRvv27b/xAan2yiuvbHknIdssW7Ysd/vatWs/+OCDW265JY7jH/zgBx999NGWm61du3bLB79Hjx6vv/76yy+/HP7g//3vf89kMkuXLv3e9743Y8aMVatWff755xUVFUccccTYsWMfeuihb3wcstlsz54999prr1dfffWUU07ZziMGUC8kcK7ZqFGjo48++u67746iaKtzzSeffHLdunVXXHHFgAEDZsyY8dZbb/3Te7v22mv/+te//uxnP9uhY/inU4899tgbb7zRo0ePadOm9e7du3nz5g0bNmzduvVVV1313HPPbdq06d///d+jYrLnnnseeeSRd91112233bZ+/fqf//zn23nwb7jhhlxxwx/8e++999NPPx00aNCTTz55yimnNG3adN999z3vvPOmTp26995733vvvdv+evOHH364X79+Bx544J/+9Kfjjjuu+vZHH300lUr96le/2qkPAMAuWs2qqqq333578ODBURS1a9duy0+NHTv2mGOOOfPMM6+66qo99tgj5HTzpz/9adu2bW+77bZ33nkn/Bj+6dSTTz6ZSqX+3//7f3vsscdWn/rOd74zd+7cO++8MypKN95441577fX73//+Gz+7YcOG999///7772/YsOF3vvOd8Af/P/7jPxo3bnzHHXdsdYetWrV67bXXXn311VQqteXt99xzz+WXX37EEUe89tprRx111M77+gB2g2oefvjh1W9I2XPPPdu3b//MM8/sv//+119/ffU2c+bM+c///M+hQ4emUqkjjzyyX79+TzzxxOrVq7d/z3vttdfYsWM3bNiwQ9dp/+nUrFmzjjnmmMMPP/wbx4855pitIrGVjh07bvUuntdee62mB6Taq6++uqPbbKtp06ZHHXXUVifxjRs3zo2XlpaWl5f/+c9/fuyxx7b86rb/4G/YsOHDDz88+eSTmzRpsu0ejz/++IMPPnjLW2666aabb745iqLTTjutTZs2W23fv3//OI6vueaa7X8hAEUome88admy5Q9+8IO//e1vBx10UPWNjzzySMuWLS+++OLcfw4bNuzLL78MuRDatWvX66677vXXXx81alT4MWxnasOGDZWVlS1atNjyxq3e13rYYYdFxap58+ZV/1DTBps2bZoxY8aGDRsCH/zKyso4jps3bx54AL/85S9PPfXUHj16PPLII88991ztvhqA3a+auTe2rF+//qmnnsqdDI0YMeKQQw6p3mDDhg3jx49fsmRJo0aNclnq0KFDHMeB7wn66U9/etRRR91+++1z584NP6qapkpKSpo2bbp8+fIoX9u+G6hr167/9J0+p59++o5u842++OKLkpKSRo0abftuoPXr1y9YsOBf/uVffvnLXw4ZMiTwwd9vv/0aNGgQ/oAMGDDg1VdfHTdu3H777ffDH/5wyZIlgYMARa5OzzVLSkq++93vPv3001OnTj3rrLO2/K6+F1988Rv/UX7zzTdnzpz5T++5cePGeVyn3c7UscceO3fu3I8//vgb3zDcqVOnqFitXr16zpw5xxxzzDd+tqSk5PDDDx81alT79u0fffTRwAd/jz32OOaYY/7zP/9zzZo122521113XXbZZUuXLq2+5de//nVpaenBBx/8q1/96vPPP7/sssu2/S4XgPoogSu0Z5999rXXXvvmm29Wn+vkrhDuueeeK1eu3PK86i9/+UsURTV9V8NWvv3tb19//fUzZ87c9icY5DF18cUXb968+eqrr/7GBm/7ftHicd99923YsOGss87a/mYNGjRYvXr1xo0bAx/8dDq9du3a//t//+9W9/Phhx/ec889L7744jdev/3e977Xt2/fP/7xjzt08RygaCXzuuZPf/rTNm3ajB49+q9//WsURZ988smkSZN69+69zz77bLnZqaeeWl5e/u///u8rV64Mudvhw4cfddRRv/71r3foYL5x6vLLL+/UqdPvfve7k08++T/+4z8++eSTDRs25H7KQa9evd58880GDYrrhxFWVVW99957t956609+8pO99tqrpvfaxHG8ePHioUOHvvXWWx07dmzYsGHggz9o0KDmzZuPHDnysssu+8///M+1a9d++umnTz755Omnn15ZWTl06NAtLwhvafTo0S1atLj11lvfeOONwnzpAHUnmX/6995771/+8pebN2++4oorNm7cOG7cuI0bN1a/FWVL3//+99esWfP444+HX3Hd/rtbA6dKS0srKipOPfXUN99887vf/e7BBx9cWlqa+4l6EydOLC8vD/zRRTX5xvfHplKpLd8zHLLNwQcfXP3O5KOPPnr48OG5Hx/YunXrrb7G3GYNGjRo3br1qFGjGjRokPvmmcAHv3nz5k8//XTTpk0ff/zxk046aa+99jrooIMuvvjijz76KJPJ3HTTTTV9pfvvv/9vfvObDRs2XHTRRV999ZXv1wTqtcROmM4999x0Ov23v/3t5z//+aOPPrrvvvueffbZ22522WWXNWjQIPAibe6Ka+5b+HfIN061atXqT3/60/jx43v27NmqVavS0tIWLVr07NnzsccemzNnzkknnRQVk5KSktatW1944YV//vOfv/e979W02R577HHggQf26tXr5Zdfzl3FDX/wu3fvPmvWrOuuu+7oo49u0qRJ48aNTznllDFjxvz2t7/d9rtat9S7d+/+/fu///77W36jEUB9lCrml+gAoKgU14tzAFDMVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZq7lBUrVrz77rtJHwUUBcuBQlDNQmnVqlVqG+PHjy/oTnv06DFjxozw7UeNGtW5c+eaPltZWXnEEUfs0B3Ctvbff//qJVBaWnrMMcfcf//9ed9b9ZO2srIylUptp4uWA4WgmgV03333xf/TJZdcUtA9rl27dmfd1aJFi3r06LFw4cKddYfszkaPHp1bAl999dXIkSOHDBny+OOP1/I+mzVrFsfx0UcfXdMGlgOFoJp17eGHH27UqNGiRYuiKFq+fPk+++wzduzYzz77LJVKPfzww61atSorKxs4cGD1gl+2bFnfvn2bNGnSunXrwYMHV9++ZMmSTCbTtGnTAw444Oqrr66qqjr99NPfe++9AQMGXH755dsZfPvtt0877bTGjRt36dKlpn8Ffve737Vv375Tp0519aiwuygpKTnnnHO6d++ezWY/+eSTVCo1bNiwsrKy/v377+iTdstzTcuBOqOadW3gwIFdu3YdMWJEFEXDhw8/8cQTBwwYkPvUPffcM2nSpFmzZr3xxhvXXHNN7sY+ffo0bdr0ww8/nDp16syZMwcNGhRF0aZNm84+++zS0tL58+dPnz599uzZt99++6uvvlpeXj527NgxY8bUNLhu3bqePXt26NBh6dKlw4YNGzt27DceZKNGjV555ZUHHnigDh8YdiMbN25s0qRJ7uN333138eLFd9xxR95PWsuBOrXVJUR2lpYtW271UO+xxx65T82bN69Zs2b33ntvWVnZvHnz4jhevnx5FEXZbDa3weTJk0tLS1evXj116tS99tqrqqoqd/vMmTMbNGiwdu3aqVOnlpaWrlixYqud5v6ZiOO4psGKioqysrI1a9bkbv/Rj350yimn1PQlbNiwIYqi6dOnF+DhYTfSvHnz6iu0lZWVY8eObdCgwYsvvrhs2bIoiiZOnJj71I4+ab/44osoit555x3LgbrkXLPuXtfcuHFj7va2bdsOHTp08ODBN954Y9u2bau3r34nwvHHH79+/fr58+fPnTt3zZo1jRo1yr2T4qSTTtq8efOCBQvefvvtVq1a7bfffjXtuqbBuXPnHnnkkY0bN85t1rFjxwI/BvC1q666KvdUbNGixahRox544IFevXrlPtWmTZtaPmktB+qSaiZjzpw5URS9+eabW95YUlKS+2DTpk1RFDVs2HDjxo1t27bd6v90vvWtb5WUlKRSqe3cf02DW21WvUcoqOpzzXXr1s2ZM+fKK6+s/lSjRo1q+aS1HKhLqpmAl1566emnnx45cuSECRMqKiqqb3/rrbdyH8yaNatJkyZHHnnk0UcfvXDhwsWLF291D+3atVu0aFHuCtWWqv/tqGmwffv28+bN++qrr3L/OXv27J39xUGe8n7SWg7UJdWsa6tXr77yyiuvu+66IUOG/PCHP7zmmmu+/PLL3KduuummhQsXzps37+abb/7Rj37UqFGjM88887jjjhswYMCiRYuWLFlyww03tGnTpqqq6rTTTmvfvv2111772Wefffjhh3369Pne974XRdHee++9dOnSL7/8sqbB//N//s/BBx98/fXXf/7556+88sojjzyS9OMB/7+8n7SWA3VqJ70+yj9/N1AURVdcccW111572GGHrV69Oo7jlStXtm7d+pprrsm9G+iWW2459NBD991338GDB69fvz53Px999NF55523995777PPPmedddY777yTu33hwoVnn332nnvu2bx58/79+69cuTKO49/85jdNmjTp06fPdgbnz5/fvXv3Pffcs3379oMHD/b2B+ry3UBbyr0bKPeGuJwdetJWvxvIcqAupeI4jpKQyWQS2W9xWr9+/cSJE7t37960adOkj2X3lc1mE9mvtUCxSWot1AsNE9x3Rdu78xtMf3BzrWa3eClxx2bT6YLO/uEPf0hkv9uZXXBrZX6zR9zZrDaziXy9CbIWzBbVLNvhdU0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABAqFcdxlIRMJpPIfqEm2Ww2kf1a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QqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqnmLmXFihXvvvtu0kcBRcFyoBBUs1BatWqV2sb48eMLutMePXrMmDEjfPtRo0Z17tx529vnzZt3zjnnNGvW7OCDD77iiitWrVq1Uw+T3cv+++9fvQRKS0uPOeaY+++/P+97q37SVlZWplKp7XTRcqAQVLOA7rvvvvh/uuSSSwq6x7Vr19b+TjZs2HDOOeccdthhCxcu/NOf/vTGG29ceeWVO+Po2H2NHj06twS++uqrkSNHDhky5PHHH6/lfTZr1iyO46OPPrqmDSwHCkE169rDDz/cqFGjRYsWRVG0fPnyffbZZ+zYsZ999lkqlXr44YdbtWpVVlY2cODA6gW/bNmyvn37NmnSpHXr1oMHD66+fcmSJZlMpmnTpgcccMDVV19dVVV1+umnv/feewMGDLj88su3M/j222+fdtppjRs37tKly8KFC7c9wpkzZy5YsODee+/dd99927Zte/vtt0+YMCGO4zp8kNhllZSUnHPOOd27d89ms5988kkqlRo2bFhZWVn//v139Em75bmm5UCdUc26NnDgwK5du44YMSKKouHDh5944okDBgzIfeqee+6ZNGnSrFmz3njjjWuuuSZ3Y58+fZo2bfrhhx9OnTp15syZgwYNiqJo06ZNZ599dmlp6fz586dPnz579uzbb7/91VdfLS8vHzt27JgxY2oaXLduXc+ePTt06LB06dJhw4aNHTt22yPs0qXLhg0bSktLc/+5bNmy/fbbL5VK1eGDxC5u48aNTZo0yX387rvvLl68+I477sj7SWs5UKe2uoTIztKyZcutHuo99tgj96l58+Y1a9bs3nvvLSsrmzdvXhzHy5cvj6Iom83mNpg8eXJpaenq1aunTp261157VVVV5W6fOXNmgwYN1q5dO3Xq1NLS0hUrVmy109w/E3Ec1zRYUVFRVla2Zs2a3O0/+tGPTjnllO18FZWVlYcffvjtt9++sx8ediPNmzevvkJbWVk5duzYBg0avPjii8uWLYuiaOLEiblP7eiT9osvvoii6J133rEcqEvONevudc2NGzfmbm/btu3QoUMHDx584403tm3btnr76nciHH/88evXr58/f/7cuXPXrFnTqFGj3DspTjrppM2bNy9YsODtt99u1arVfvvtV9OuaxqcO3fukUce2bhx49xmHTt23M7xf/XVV717927fvv2tt966kx4SdlNXXXVV7qnYokWLUaNGPfDAA7169cp9qk2bNrV80loO1CXVTMacOXOiKHrzzTe3vLGkpCT3waZNm6Ioatiw4caNG9u2bbvV/+l861vfKikp2f41opoGt9qseo/bWrFiRffu3Vu1avXss882bNiwdl8uu7vqc81169bNmTNnyzfUNGrUqJZPWsuBuqSaCXjppZeefvrpkSNHTpgwoaKiovr2t956K/fBrFmzmjRpcuSRRx599NELFy5cvHjxVvfQrl27RYsW5a5Qban6346aBtu3bz9v3ryvvvoq95+zZ8/+xiNcvHhx165du3Xr9sQTT1S/ogMFlfeT1nKgTu2kK71srWXLltt+50kcx19++WWbNm1uuOGG3OsoLVu2XLVqVe51zRNPPHHBggXvv//+scceO3jw4DiON23a1LFjxx49enz88ceLFy++/vrrW7duvW7dus2bN59wwgkXX3zx8uXLFy5ceP7551944YVxHHfq1Gn48OGrVq2qabCqqqpdu3YDBw5csWLFyy+/3LRp021fyPniiy+OOuqom266qa4eKnaj1zW3lHtdM/fS/nae7TU9aatf17QcqEuqWXfvBoqi6Iorrrj22msPO+yw1atXx3G8cuXK1q1bX3PNNblq3nLLLYceeui+++47ePDg9evX5+7no48+Ou+88/bee+999tnnrLPOeuedd3K3L1y48Oyzz95zzz2bN2/ev3//lStXxnH8m9/8pkmTJn369NnO4Pz587t3777nnnu2b99+8ODB2/4zcdddd2175F9++WXdPn7sdtXc0SdtdTUtB+pSKqlvPMpkMonstzitX79+4sSJ3bt3b9q0adLHsvvKZrOJ7NdaoNgktRbqhzgh6XQ672M2a7YQs9aCWbPJroV6wbuBACCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAqFQcx1ESMplMIvuFmmSz2UT2ay1QbJJaC/VDnJB0Op33MZs1W4hZa8Gs2WTXQr3gCi0AhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAiViuM4SkImk0lkv1CTbDabyH6tBYpNUmuhfogTkk6n8z5ms2YLMWstmDWb7FqoF1yhBYBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVJxHEdJyGQyiewXapLNZhPZr7VAsUlqLdQPcULS6XTex2zWbCFmrQWzZpNdC/WCK7QAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASBUw+AtAWDHpVI1fiqhH4ReG6oJQN3Gcttt6k8+VROAOu/lN47Uh3aqJgDJ9bK+tdO7gQAogmTu9PspDNUEoMhSlyrecKomAMUXuVSRhlM1ASjKvKWKMZypOKHXXTOZTCL7hZpks9lE9mstUI/XQqrwYSuyNwcl+R7aioqK/AbT6XRF27vznP3g5lrN1uaYzQbPPjrtuvxm+3e7P+/ZBFkLZotqtrjOBVOpogqnK7QAEEo1ASjuFx1TRfQCp2oCQCjVBKDoT/5SxXK6qZoAEEo1ASCUagJQHy6WporiIq3feQJAgcVxNGFCtHFjVFISnXtukfQvP841ASiw11+PXnop6ts3ev75aMaMqD5TTQAKbNGiqKoq6tw5WrLk6z/1mWoCUHjjx0fDhkWTJkX1nGoCUHgDBkSPPhr17h3Vc6oJQIG1bh01bhxls19/0LJlVJ95Dy0ABXbyydEnn0Tdun39HtrOnaP6TDUBKLBUPf5Wk624QgvAjogT+m2XxfFbNlUTAEKpJgCESsUJnfNmMplE9gs1yWaziezXWqBeroVUaje8PJvwu4EqKiryG0yn07WabXt3nrMf3JzYMe9ms49Ouy6/2f7d7s97vwmyFszWNLu7rYXi5wotAMV98hcXy4mmagLADlBNAIr4FDAuohNN1YQ8HX/88Uv+8asbqqqq2rVrd//993fs2PGEE06YPHly0ocGdSiOd6tkqibkqW/fvs8//3wURVOmTDnrrLPuvPPOadOmPfnkk+PHj0/60KBuxfHuk0zVhDz169dvwoQJURS98MILF1xwQc+ePS+77LJFixaNGzcu6UODOhfHu0kyVRPyVF5evmLFilWrVs2aNevb3/72o48+OmjQoNGjRw8YMCDpQ4MkxPHukEw/vR3yd955540YMeLkk09etWrVueee+8orr3Tq1OmII45I+rggIXG8c370QREnUzUhf/369TvuuOOmTJlSVlZ2zjnndO7cefPmzT/+8Y+TPi5ITvyP4OXdzuLuZY5qQp7Ky8urqqpyHw/9h6SPCOptO+N60Msc1QSgAOL/DuF28ll/YllNNQEopLj+pXE7vIcWAEKpJgCEUk0ACKWaABBKNQEglGoCQKhUnNB7gjOZTCL7hZpks9lE9mstUGySWgv1QpLfr1lRUZHfYDqdrmh7d56zH9xcL2dr81jVYvbRadflN9u/2/31bjZB1kLxr4XdapbtcIUWAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBKBW/vCHP3Tp0uWMM8447bTTpk+fHkXR5s2br7vuulNPPbVbt24LFizYdmTixImNGzeOomjEiBHt27cfOXJkbqpXr16VlZVREfP7NQGolYEDB06ZMuXwww+fP39+7969586d++CDDzZt2nT69OnZbHbIkCHPPffcltt/+eWXd955Z0lJSRRFv/jFL957773y8vKhQ4eOGTOmT58+zZo1i4qYc00AaqV58+YrVqyIomjFihVfffVVFEVPPPHEgAEDoijq1atX586dt9r+lltuueGGGxo0+DpAJSUlf//730tLSz///PMJEybkpoqZagJQKw8++GDXrl2PPfbYbt26PfDAA1EUvf/++88///zpp5/+3e9+94ILLthy49dee23p0qXVNw4fPvySSy656667br311p/85CepVCoqbqoJQK0MGTLkiSeemD179uOPP567GLt+/fpDDz301VdfveSSSwYOHFi9ZVVV1ZAhQ3Jlzbn00ktnzJhRXl4eRdGCBQt69er17LPPRkXM65oA1Mrs2bNzv4Tg/PPPv+qqq6IoatGiRTqdzv043CuvvLJ6y9/+9rdffvnlRRddFEXR6tWrL7vssnHjxsVxfNttt40bN65Tp04zZszo0qVL3759o2LlXBOAWikvL//zn/8cRdH06dMPO+ywKIrOPPPMadOmRVE0bdq0Dh065BoZRdFFF1309ttvv/oPTZo0GTduXBRFjzzySO/evZs3b7527do4jtesWRMVMeeaANTKgw8+eN11X/+uoVQqNWbMmCiK7rjjjoEDB95xxx0NGzZ86KGHcqehkydP3na2srLymWeemThxYhRFgwYN6tGjx4033hgVMdUEoFY6dOgwderULW858MADX3jhhS1v2TaZue/LbNas2aRJk3K33PIPUXFzhRYAQqkmAIRSTQAIlYrjOEpC7m3KUDyy2Wwi+7UWKDZJrYX6IU5I7lt58mPWbCFmrQWzZpNdC/WCK7QAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASBUKo7jKAmZTCaR/UJNstlsIvu1Fig2Sa2F+iFOSDqdzvuYzZotxKy1YNZssmuhXnCFFgBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhErFcRwlIZPJJLJfqEk2m01kv9YCxSaptVA/xAlJp9N5H7NZs4WYtRbMmk12LdQLrtACQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqTiOoyRkMplE9gs1yWaziezXWqDYJLUW6oc4Iel0Ou9jNmu2ELPWwg7NVu73x/z+1NOvd7eaTWot1Auu0AJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCpOI6jJGQymUT2CzXJZrNJHwJQ9OKEpNPpvI/ZrNlCzCa1FoB6xBVaAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQKhXHcfDGALBbc64JAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFLNXcqKFSvefffdpI8C6gGLhfyoZqG0atUqtY3x48cXdKc9evSYMWNG+PajRo3q3Lnztrd/+umnffv23WeffVq3bn3nnXfu1GOE/2H//fevXiClpaXHHHPM/fffn/e9VT+lKysrU6nUdrposZCfhnnOEeC+++674YYb6nKPa9eu3Sn3c9FFF7Vp02bRokXz5s07++yzDzrooMsvv3yn3DNsa/To0VdeeWUURRs2bPj9739//vnn77vvvpdeemlt7rNZs2ZxHG9nA4uF/DjXrGsPP/xwo0aNFi1aFEXR8uXL99lnn7Fjx3722WepVOrhhx9u1apVWVnZwIEDq5f0smXL+vbt26RJk9atWw8ePLj69iVLlmQymaZNmx5wwAFXX311VVXV6aef/t577w0YMCC3aGsafPvtt0877bTGjRt36dJl4cKF2x7h/Pnzp0yZMmrUqLKyshNPPPGMM874y1/+UoePELuvkpKSc845p3v37tls9pNPPkmlUsOGDSsrK+vfv/+OPqW3PNe0WNiZYgqjZcuW99133zd+6swzz7z66qvjOL7++uvPOOOMOI6XL18eRVG7du1mz549f/78Dh06/OAHP8htfOqpp/bv33/58uXz58/v2rXrFVdcEcfxxo0bjz322AsuuODTTz+dN29e165db7755jiOy8vLx44du53BtWvXtmnT5l/+5V8+//zz559/vnHjxqecckpNX8KGDRteeeWV/fbb7/nnny/MgwRx8+bNR48eveUtPXr0uPTSS5ctWxZFUTqdXrVq1UcffbSjT+kvvvgiiqJ33nnHYmHnUs1Cadmy5Vb/g7LHHnvkPjVv3rxmzZrde++9ZWVl8+bNq65mNpvNbTB58uTS0tLVq1dPnTp1r732qqqqyt0+c+bMBg0arF27durUqaWlpStWrNhqp9X/ENQ0WFFRUVZWtmbNmtztP/rRj7bzD0F5eXmjRo1OP/305cuXF+ARgq2rWVlZOXbs2AYNGrz44ou5ak6cODH3qR19SldX02Jh53KFtoC2OtfcuHFj7va2bdsOHTp08ODBN954Y9u2bau3r36vwfHHH79+/fr58+fPnTt3zZo1jRo1yr1X4qSTTtq8efOCBQvefvvtVq1a7bfffjXtuqbBuXPnHnnkkY0bN85t1rFjx+0c/7vvvrtixYq99trrnHPO2UkPCXyDq666KvdEbdGixahRox544IFevXrlPtWmTZtaPqUtFnYu1UzGnDlzoih68803t7yxpKQk98GmTZu+fqdWw4YbN25s27btVv+n861vfaukpCSVSm3n/msa3Gqz6j3WZO+997711lv/+te/Ll26NN+vFf6J6nPNdevWzZkzJ/fOoJxGjRrV8iltsbBzqWYCXnrppaeffnrkyJETJkyoqKiovv2tt97KfTBr1qwmTZoceeSRRx999MKFCxcvXrzVPbRr127RokW5a1Bbqv7XoabB9u3bz5s376uvvsr95+zZs7c9vEmTJpWVlVVVVeX+8/PPP99jjz2aNWtWuy8aaiXvp7TFwk62k670EvpuoC+//LJNmzY33HBD7pWSli1brlq1Kve65oknnrhgwYL333//2GOPHTx4cBzHmzZt6tixY48ePT7++OPFixdff/31rVu3Xrdu3ebNm0844YSLL754+fLlCxcuPP/88y+88MI4jjt16jR8+PBVq1bVNFhVVdWuXbuBAweuWLHi5Zdfbtq06bYv1axdu7Zdu3ZXX311ZWXl3/72t2OOOebyyy+vq4eN3c627wbKyb2umXvhfztroaandPXrmhYLO5dq1t27gaIouuKKK6699trDDjts9erVcRyvXLmydevW11xzTa6at9xyy6GHHrrvvvsOHjx4/fr1ufv56KOPzjvvvL333nufffY566yz3nnnndztCxcuPPvss/fcc8/mzZv3799/5cqVcRz/5je/adKkSZ8+fbYzOH/+/O7du++5557t27cfPHjwN77B4YMPPujZs+c+++zTpk2bYcOGrV27tg4fOXYvgdXc0ad0dTUtFnau1Pa/Ebg2MplMge5517N+/fqJEyd27969adOmSR8L3yybzSayX+uIYpNNaC0Ui7hg0ul03ke1u8327Nkzkf2aLYaVYh2ZrV+z8e7Nu4EAIJRqFoXS0tKkDwGAf041ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAECoVx3FUGJlMpkD3DHUvm80msl/riGKTTWgtFImGBb33ioqK/AbT6XS9nG17d56zH9xcL7/e3Wk2QfXusbKOdu3Z3ZwrtAAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQ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1VcjR44cMmTI448/Xsv7bNasWRzHRx99dE0bWErURDXr2sMPP9yoUaNFixZFUbR8+fJ99tln7Nixn332WSqVevjhh1u1alVWVjZw4MDqRbts2bK+ffs2adKkdevWgwcPrr59yZIlmUymadOmBxxwwNVXX11VVXX66ae/9957AwYMuPzyy7cz+Pbbb5922mmNGzfu0qXLwoULazrOdevWDRw48MQTT6yTRwX+uZKSknPOOad79+7ZbPaTTz5JpVLDhg0rKyvr37//jj7htzzXtJTYIapZ1wYOHNi1a9cRI0ZEUTR8+PATTzxxwIABuU/dc889kyZNmjVr1htvvHHNNdfkbuzTp0/Tpk0//PDDqVOnzpw5c9CgQVEUbdq06eyzzy4tLZ0/f/706dNnz559++23v/rqq+Xl5WPHjh0zZkxNg+vWrevZs2eHDh2WLl06bNiwsWPH1nSct9122//6X//r/PPPr6sHBoJs3LixSZMmuY/ffffdxYsX33HHHXk/4S0ldthWlxDZWVq2bLnVQ73HHnvkPjVv3rxmzZrde++9ZWVl8+bNi+N4+fLlURRls9ncBpMnTy4tLV29evXUqVP32muvqqqq3O0zZ85s0KDB2rVrp06dWlpaumLFiq12mlvqcRzXNFhRUVFWVrZmzZrc7T/60Y9OOeWUbQ/+9ddfP+CAA5YtW3bXXXd95zvfKdiDBP9E8+bNq6/QVlZWjh07tkGDBi+++OKyZcuiKJo4cWLuUzv6hP/iiy+iKHrnnXcsJXaUc826e11z48aNudvbtm07dOjQwYMH33jjjW3btq3evvrdBMcff/z69evnz58/d+7cNWvWNGrUKPduiJNOOmnz5s0LFix4++23W7Vqtd9++9W065oG586de+SRRzZu3Di3WceOHbed3bBhww9+8IORI0cedNBBO/shgR121VVX5Z7GLVq0GDVq1AMPPNCrV6/cp9q0aVPLJ7ylxI5SzWTMmTMniqI333xzyxtLSkpyH2zatCmKooYNG27cuLFt27Zb/Z/Ot771rZKSklQqtZ37r2lwq82q97il4cOHt2rV6vvf//7O+EKhtqrPNdetWzdnzpwrr7yy+lONGjWq5RPeUmJHqWYCXnrppaeffnrkyJETJkyoqKiovv2tt97KfTBr1qwmTZoceeSRRx999MKFCxcvXrzVPbRr127RokW5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"
          },
          {
            "type": "input_text",
            "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
          }
        ]
      },
      {
        "type": "message",
        "role": "assistant",
        "content": [
          "After carefully reviewing the examples and previous attempts, the key insights remain:\n\n- The **blue shape (color 1) stays unchanged**.\n- Each **non-blue cluster** is copied **exactly and fully** in the output both at its original position and an **additional position in a different quadrant**, preserving shape and relative position inside quadrants.\n- The quadrants are defined by splitting the 11\u00d711 grid at row 6 and column 6 (indices 0\u20135 and 6\u201310).\n- The cluster gets duplicated into a **mapped opposite quadrant**, keeping its shape intact, and positioned with the same offset from the quadrant top-left corner (clamped to fit quadrant).\n- Blue pixels are never overwritten in output duplication.\n\n---\n\n### What needs fixing from last attempt:\n\n- The output size must always be exactly 11\u00d711 (was correct).\n- Ensure careful clamping of duplicated cluster position to not go outside quadrant.\n- Avoid overwriting blue or previously written pixels only when duplicating (already done).\n- Place duplicate cluster with exact relative offset from target quadrant's top-left corner.\n- Fully copy all cluster pixels.\n\nThis approach will give best fit with training data.\n\n---\n\n### Final improved code:\n\n```python\ndef transform(grid):\n    import numpy as np\n\n    arr = np.array(grid)\n    target_size = 11\n\n    # Normalize input to 11x11\n    norm = np.zeros((target_size, target_size), dtype=int)\n    norm[:arr.shape[0], :arr.shape[1]] = arr[:target_size, :target_size]\n    arr = norm\n\n    output = np.zeros_like(arr)\n    blue_color = 1\n\n    # Copy blue pixels as is\n    output[arr == blue_color] = blue_color\n\n    # Colors excluding 0 and blue\n    colors = set(np.unique(arr))\n    colors.discard(0)\n    colors.discard(blue_color)\n\n    # Quadrant boundaries inclusive: (row_start, row_end, col_start, col_end)\n    quadrants = {\n        'TL': (0, 5, 0, 5),\n        'TR': (0, 5, 6, 10),\n        'BL': (6, 10, 0, 5),\n        'BR': (6, 10, 6, 10)\n    }\n\n    # Map quadrant to duplication target quadrant\n    quadrant_map = {\n        'TL': 'TR',\n        'TR': 'BL',\n        'BL': 'BR',\n        'BR': 'TL'\n    }\n\n    def get_quadrant(r, c):\n        for q_name, (rs, re, cs, ce) in quadrants.items():\n            if rs <= r <= re and cs <= c <= ce:\n                return q_name\n        return None\n\n    for color in colors:\n        positions = np.argwhere(arr == color)\n        if positions.size == 0:\n            continue\n\n        min_r, min_c = positions.min(axis=0)\n        max_r, max_c = positions.max(axis=0)\n\n        # Copy cluster pixels to output at original positions\n        for r, c in positions:\n            output[r, c] = color\n\n        # Compute cluster centroid for quadrant\n        centroid_r = int(round(positions[:, 0].mean()))\n        centroid_c = int(round(positions[:, 1].mean()))\n        orig_quad = get_quadrant(centroid_r, centroid_c)\n        target_quad = quadrant_map[orig_quad]\n\n        r_start, r_end, c_start, c_end = quadrants[target_quad]\n\n        cluster_height = max_r - min_r + 1\n        cluster_width = max_c - min_c + 1\n\n        orig_r_start, orig_r_end, orig_c_start, orig_c_end = quadrants[orig_quad]\n\n        offset_r = min_r - orig_r_start\n        offset_c = min_c - orig_c_start\n\n        # New top-left for duplicate cluster in target quadrant (with clamping)\n        new_min_r = r_start + offset_r\n        new_min_c = c_start + offset_c\n\n        if new_min_r < r_start:\n            new_min_r = r_start\n        if new_min_c < c_start:\n            new_min_c = c_start\n        if new_min_r + cluster_height - 1 > r_end:\n            new_min_r = r_end - cluster_height + 1\n        if new_min_c + cluster_width - 1 > c_end:\n            new_min_c = c_end - cluster_width + 1\n\n        # Duplicate pixels copied exactly at new location (no overwrite blue)\n        for r, c in positions:\n            rr = new_min_r + (r - min_r)\n            cc = new_min_c + (c - min_c)\n            if 0 <= rr < target_size and 0 <= cc < target_size:\n                if output[rr, cc] != blue_color:\n                    output[rr, cc] = color\n\n    return output.tolist()\n```\n\n---\n\nThis solution:\n\n- Keeps blue unchanged.\n- Copies every other cluster fully and duplicates it in the opposite quadrant precisely shifted by offset.\n- Clamps cluster duplicates to quadrant bounds.\n- Avoids overwriting blue pixels.\n- Output size always 11\u00d711.\n\nThis should maximize correctness on training sets and generalize well to test inputs.\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n\n    arr = np.array(grid)\n    target_size = 11\n\n    # Normalize input to 11x11\n    norm = np.zeros((target_size, target_size), dtype=int)\n    norm[:arr.shape[0], :arr.shape[1]] = arr[:target_size, :target_size]\n    arr = norm\n\n    output = np.zeros_like(arr)\n    blue_color = 1\n\n    # Copy blue pixels as is\n    output[arr == blue_color] = blue_color\n\n    # Colors excluding 0 and blue\n    colors = set(np.unique(arr))\n    colors.discard(0)\n    colors.discard(blue_color)\n\n    # Quadrant boundaries inclusive: (row_start, row_end, col_start, col_end)\n    quadrants = {\n        'TL': (0, 5, 0, 5),\n        'TR': (0, 5, 6, 10),\n        'BL': (6, 10, 0, 5),\n        'BR': (6, 10, 6, 10)\n    }\n\n    # Map quadrant to duplication target quadrant\n    quadrant_map = {\n        'TL': 'TR',\n        'TR': 'BL',\n        'BL': 'BR',\n        'BR': 'TL'\n    }\n\n    def get_quadrant(r, c):\n        for q_name, (rs, re, cs, ce) in quadrants.items():\n            if rs <= r <= re and cs <= c <= ce:\n                return q_name\n        return None\n\n    for color in colors:\n        positions = np.argwhere(arr == color)\n        if positions.size == 0:\n            continue\n\n        min_r, min_c = positions.min(axis=0)\n        max_r, max_c = positions.max(axis=0)\n\n        # Copy cluster pixels to output at original positions\n        for r, c in positions:\n            output[r, c] = color\n\n        # Compute cluster centroid for quadrant\n        centroid_r = int(round(positions[:, 0].mean()))\n        centroid_c = int(round(positions[:, 1].mean()))\n        orig_quad = get_quadrant(centroid_r, centroid_c)\n        target_quad = quadrant_map[orig_quad]\n\n        r_start, r_end, c_start, c_end = quadrants[target_quad]\n\n        cluster_height = max_r - min_r + 1\n        cluster_width = max_c - min_c + 1\n\n        orig_r_start, orig_r_end, orig_c_start, orig_c_end = quadrants[orig_quad]\n\n        offset_r = min_r - orig_r_start\n        offset_c = min_c - orig_c_start\n\n        # New top-left for duplicate cluster in target quadrant (with clamping)\n        new_min_r = r_start + offset_r\n        new_min_c = c_start + offset_c\n\n        if new_min_r < r_start:\n            new_min_r = r_start\n        if new_min_c < c_start:\n            new_min_c = c_start\n        if new_min_r + cluster_height - 1 > r_end:\n            new_min_r = r_end - cluster_height + 1\n        if new_min_c + cluster_width - 1 > c_end:\n            new_min_c = c_end - cluster_width + 1\n\n        # Duplicate pixels copied exactly at new location (no overwrite blue)\n        for r, c in positions:\n            rr = new_min_r + (r - min_r)\n            cc = new_min_c + (c - min_c)\n            if 0 <= rr < target_size and 0 <= cc < target_size:\n                if output[rr, cc] != blue_color:\n                    output[rr, cc] = color\n\n    return output.tolist()\n```"
        ]
      },
      {
        "role": "user",
        "content": [
          {
            "type": "input_text",
            "text": "Please analyze the training feedback and programs from all prior turns, and write an improved transformation.\n\n**Important**:\n1. Always start by attempting to find a complete rule that solves all training examples and should generalize to the test input.\n2. If you cannot find a perfect solution, provide your best attempt at a transformation that solves as many training examples as possible - ideally more than in the best previous turn.\n3. Even if your solution doesn't solve all examples perfectly, ensure it demonstrates meaningful pattern recognition and provides reasonable outputs that minimize pixel-level errors.\n\nFinal answer:\n```python\ndef transform(grid):\n    # Your improved transformation logic here (even if partial)\n    return transformed_grid\n```"
          },
          {
            "type": "input_text",
            "text": "Training results: 0/4 examples solved, 76.0% pixel accuracy - Good partial progress! Your approach is capturing some patterns. Next, try to identify a transformation that solves at least one of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[1, 1, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 1, 1, 1, 0, 3, 3, 3, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 1, 1, 1, 0, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0]]\nPixel accuracy: 86.0%\n\nTraining Example 2 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 1, 0, 0, 0, 0, 0, 0, 6, 0], [0, 1, 1, 1, 1, 0, 0, 6, 6, 6, 6], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 6, 0], [0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 86.4%\n\nTraining Example 3 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 77.8%\n\nTraining Example 4 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 60.4%\n\n\u26a0\ufe0f  GRID SIZE ERROR: One or more of your output grids are incorrect in size. They should ALL be 11\u00d711 for this task.\n\n"
          },
          {
            "type": "input_image",
            "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAmcAAATYCAIAAADVnPfcAABQcklEQVR4nO3de5RU5Z3o711IN6Jgo6ioXLwhrTkoIl6QIFHhrKMgWiVgjLdAMPEy3kBQmTF64pKIQjQxMegJiiI6OhqrUYMETRBiApFRJoJ4QUDlpkG0QQSa2/4tU7/pxYBNXqqp3tXwPIs/2ur9rb27qJePe1d1dyqO4wgACNAgZCMAQDUBYAeoJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaAFAn1bzmmmtSNbvkkku+cZvS0tKDDjro3HPPffPNN7e9z5dffjmVSu23337r1q3b6lPPPvtsKpUaM2ZM7j/79++fSqVGjhy51WaLFy9OpVK33nprbaZy1q1b99BDD51xxhmHHHJIo0aNDjnkkH79+v3pT3/azmNy66231vSAzJkzZ/sPWo8ePf7pA1u9zeWXX77l7bnD69Onz/Tp07c8nnQ6vdVmhx9++HXXXffFF1/s0IOf89lnn915550dO3YsKyvbe++9Tz755DFjxmz5a3Nyu9tq/I033jjggAOaNm06ZcqU7Tx0AMUvgXPNDRs2fPrppy+88MIZZ5yxYMGCrT77yCOPRFH0xRdfPP300yH3dtttt7377rs7egwhUx9++OGpp5565ZVXvvrqq8uWLVu/fv2yZcueffbZbt263XvvvVGRyR3ec88917Vr1yeeeGI7m3344Ye//OUvzzrrrM2bN+/Qgz99+vQOHTr8+Mc//q//+q9Vq1atWbNm5syZP/zhDwcOHLidA/vjH/94xhlnbNq06ZVXXjnjjDNq8SUC1PNq/upXv4r/2zPPPBNF0dixY6tvGT9+fPWWCxcurL593bp177zzzkUXXbRq1arRo0dveYeVlZUVFRX9+vXbb7/9HnzwwZBjWL9+ff/+/Tdt2rRDR/5PpzZs2NC3b9//+q//6tKly/PPP//ZZ59t2LDh448//vWvf73ffvvddNNNuRPHmsyaNSveRvv27b/xAan2yiuvbHknIdssW7Ysd/vatWs/+OCDW265JY7jH/zgBx999NGWm61du3bLB79Hjx6vv/76yy+/HP7g//3vf89kMkuXLv3e9743Y8aMVatWff755xUVFUccccTYsWMfeuihb3wcstlsz54999prr1dfffWUU07ZziMGUC8kcK7ZqFGjo48++u67746iaKtzzSeffHLdunVXXHHFgAEDZsyY8dZbb/3Te7v22mv/+te//uxnP9uhY/inU4899tgbb7zRo0ePadOm9e7du3nz5g0bNmzduvVVV1313HPPbdq06d///d+jYrLnnnseeeSRd91112233bZ+/fqf//zn23nwb7jhhlxxwx/8e++999NPPx00aNCTTz55yimnNG3adN999z3vvPOmTp26995733vvvdv+evOHH364X79+Bx544J/+9Kfjjjuu+vZHH300lUr96le/2qkPAMAuWs2qqqq333578ODBURS1a9duy0+NHTv2mGOOOfPMM6+66qo99tgj5HTzpz/9adu2bW+77bZ33nkn/Bj+6dSTTz6ZSqX+3//7f3vsscdWn/rOd74zd+7cO++8MypKN95441577fX73//+Gz+7YcOG999///7772/YsOF3vvOd8Af/P/7jPxo3bnzHHXdsdYetWrV67bXXXn311VQqteXt99xzz+WXX37EEUe89tprRx111M77+gB2g2oefvjh1W9I2XPPPdu3b//MM8/sv//+119/ffU2c+bM+c///M+hQ4emUqkjjzyyX79+TzzxxOrVq7d/z3vttdfYsWM3bNiwQ9dp/+nUrFmzjjnmmMMPP/wbx4855pitIrGVjh07bvUuntdee62mB6Taq6++uqPbbKtp06ZHHXXUVifxjRs3zo2XlpaWl5f/+c9/fuyxx7b86rb/4G/YsOHDDz88+eSTmzRpsu0ejz/++IMPPnjLW2666aabb745iqLTTjutTZs2W23fv3//OI6vueaa7X8hAEUome88admy5Q9+8IO//e1vBx10UPWNjzzySMuWLS+++OLcfw4bNuzLL78MuRDatWvX66677vXXXx81alT4MWxnasOGDZWVlS1atNjyxq3e13rYYYdFxap58+ZV/1DTBps2bZoxY8aGDRsCH/zKyso4jps3bx54AL/85S9PPfXUHj16PPLII88991ztvhqA3a+auTe2rF+//qmnnsqdDI0YMeKQQw6p3mDDhg3jx49fsmRJo0aNclnq0KFDHMeB7wn66U9/etRRR91+++1z584NP6qapkpKSpo2bbp8+fIoX9u+G6hr167/9J0+p59++o5u842++OKLkpKSRo0abftuoPXr1y9YsOBf/uVffvnLXw4ZMiTwwd9vv/0aNGgQ/oAMGDDg1VdfHTdu3H777ffDH/5wyZIlgYMARa5OzzVLSkq++93vPv3001OnTj3rrLO2/K6+F1988Rv/UX7zzTdnzpz5T++5cePGeVyn3c7UscceO3fu3I8//vgb3zDcqVOnqFitXr16zpw5xxxzzDd+tqSk5PDDDx81alT79u0fffTRwAd/jz32OOaYY/7zP/9zzZo122521113XXbZZUuXLq2+5de//nVpaenBBx/8q1/96vPPP7/sssu2/S4XgPoogSu0Z5999rXXXvvmm29Wn+vkrhDuueeeK1eu3PK86i9/+UsURTV9V8NWvv3tb19//fUzZ87c9icY5DF18cUXb968+eqrr/7GBm/7ftHicd99923YsOGss87a/mYNGjRYvXr1xo0bAx/8dDq9du3a//t//+9W9/Phhx/ec889L7744jdev/3e977Xt2/fP/7xjzt08RygaCXzuuZPf/rTNm3ajB49+q9//WsURZ988smkSZN69+69zz77bLnZqaeeWl5e/u///u8rV64Mudvhw4cfddRRv/71r3foYL5x6vLLL+/UqdPvfve7k08++T/+4z8++eSTDRs25H7KQa9evd58880GDYrrhxFWVVW99957t956609+8pO99tqrpvfaxHG8ePHioUOHvvXWWx07dmzYsGHggz9o0KDmzZuPHDnysssu+8///M+1a9d++umnTz755Omnn15ZWTl06NAtLwhvafTo0S1atLj11lvfeOONwnzpAHUnmX/6995771/+8pebN2++4oorNm7cOG7cuI0bN1a/FWVL3//+99esWfP444+HX3Hd/rtbA6dKS0srKipOPfXUN99887vf/e7BBx9cWlqa+4l6EydOLC8vD/zRRTX5xvfHplKpLd8zHLLNwQcfXP3O5KOPPnr48OG5Hx/YunXrrb7G3GYNGjRo3br1qFGjGjRokPvmmcAHv3nz5k8//XTTpk0ff/zxk046aa+99jrooIMuvvjijz76KJPJ3HTTTTV9pfvvv/9vfvObDRs2XHTRRV999ZXv1wTqtcROmM4999x0Ov23v/3t5z//+aOPPrrvvvueffbZ22522WWXNWjQIPAibe6Ka+5b+HfIN061atXqT3/60/jx43v27NmqVavS0tIWLVr07NnzsccemzNnzkknnRQVk5KSktatW1944YV//vOfv/e979W02R577HHggQf26tXr5Zdfzl3FDX/wu3fvPmvWrOuuu+7oo49u0qRJ48aNTznllDFjxvz2t7/d9rtat9S7d+/+/fu///77W36jEUB9lCrml+gAoKgU14tzAFDMVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZq7lBUrVrz77rtJHwUUBcuBQlDNQmnVqlVqG+PHjy/oTnv06DFjxozw7UeNGtW5c+eaPltZWXnEEUfs0B3Ctvbff//qJVBaWnrMMcfcf//9ed9b9ZO2srIylUptp4uWA4WgmgV03333xf/TJZdcUtA9rl27dmfd1aJFi3r06LFw4cKddYfszkaPHp1bAl999dXIkSOHDBny+OOP1/I+mzVrFsfx0UcfXdMGlgOFoJp17eGHH27UqNGiRYuiKFq+fPk+++wzduzYzz77LJVKPfzww61atSorKxs4cGD1gl+2bFnfvn2bNGnSunXrwYMHV9++ZMmSTCbTtGnTAw444Oqrr66qqjr99NPfe++9AQMGXH755dsZfPvtt0877bTGjRt36dKlpn8Ffve737Vv375Tp0519aiwuygpKTnnnHO6d++ezWY/+eSTVCo1bNiwsrKy/v377+iTdstzTcuBOqOadW3gwIFdu3YdMWJEFEXDhw8/8cQTBwwYkPvUPffcM2nSpFmzZr3xxhvXXHNN7sY+ffo0bdr0ww8/nDp16syZMwcNGhRF0aZNm84+++zS0tL58+dPnz599uzZt99++6uvvlpeXj527NgxY8bUNLhu3bqePXt26NBh6dKlw4YNGzt27DceZKNGjV555ZUHHnigDh8YdiMbN25s0qRJ7uN333138eLFd9xxR95PWsuBOrXVJUR2lpYtW271UO+xxx65T82bN69Zs2b33ntvWVnZvHnz4jhevnx5FEXZbDa3weTJk0tLS1evXj116tS99tqrqqoqd/vMmTMbNGiwdu3aqVOnlpaWrlixYqud5v6ZiOO4psGKioqysrI1a9bkbv/Rj350yimn1PQlbNiwIYqi6dOnF+DhYTfSvHnz6iu0lZWVY8eObdCgwYsvvrhs2bIoiiZOnJj71I4+ab/44osoit555x3LgbrkXLPuXtfcuHFj7va2bdsOHTp08ODBN954Y9u2bau3r34nwvHHH79+/fr58+fPnTt3zZo1jRo1yr2T4qSTTtq8efOCBQvefvvtVq1a7bfffjXtuqbBuXPnHnnkkY0bN85t1rFjxwI/BvC1q666KvdUbNGixahRox544IFevXrlPtWmTZtaPmktB+qSaiZjzpw5URS9+eabW95YUlKS+2DTpk1RFDVs2HDjxo1t27bd6v90vvWtb5WUlKRSqe3cf02DW21WvUcoqOpzzXXr1s2ZM+fKK6+s/lSjRo1q+aS1HKhLqpmAl1566emnnx45cuSECRMqKiqqb3/rrbdyH8yaNatJkyZHHnnk0UcfvXDhwsWLF291D+3atVu0aFHuCtWWqv/tqGmwffv28+bN++qrr3L/OXv27J39xUGe8n7SWg7UJdWsa6tXr77yyiuvu+66IUOG/PCHP7zmmmu+/PLL3KduuummhQsXzps37+abb/7Rj37UqFGjM88887jjjhswYMCiRYuWLFlyww03tGnTpqqq6rTTTmvfvv2111772Wefffjhh3369Pne974XRdHee++9dOnSL7/8sqbB//N//s/BBx98/fXXf/7556+88sojjzyS9OMB/7+8n7SWA3VqJ70+yj9/N1AURVdcccW111572GGHrV69Oo7jlStXtm7d+pprrsm9G+iWW2459NBD991338GDB69fvz53Px999NF55523995777PPPmedddY777yTu33hwoVnn332nnvu2bx58/79+69cuTKO49/85jdNmjTp06fPdgbnz5/fvXv3Pffcs3379oMHD/b2B+ry3UBbyr0bKPeGuJwdetJWvxvIcqAupeI4jpKQyWQS2W9xWr9+/cSJE7t37960adOkj2X3lc1mE9mvtUCxSWot1AsNE9x3Rdu78xtMf3BzrWa3eClxx2bT6YLO/uEPf0hkv9uZXXBrZX6zR9zZrDaziXy9CbIWzBbVLNvhdU0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABAqFcdxlIRMJpPIfqEm2Ww2kf1a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QqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqnmLmXFihXvvvtu0kcBRcFyoBBUs1BatWqV2sb48eMLutMePXrMmDEjfPtRo0Z17tx529vnzZt3zjnnNGvW7OCDD77iiitWrVq1Uw+T3cv+++9fvQRKS0uPOeaY+++/P+97q37SVlZWplKp7XTRcqAQVLOA7rvvvvh/uuSSSwq6x7Vr19b+TjZs2HDOOeccdthhCxcu/NOf/vTGG29ceeWVO+Po2H2NHj06twS++uqrkSNHDhky5PHHH6/lfTZr1iyO46OPPrqmDSwHCkE169rDDz/cqFGjRYsWRVG0fPnyffbZZ+zYsZ999lkqlXr44YdbtWpVVlY2cODA6gW/bNmyvn37NmnSpHXr1oMHD66+fcmSJZlMpmnTpgcccMDVV19dVVV1+umnv/feewMGDLj88su3M/j222+fdtppjRs37tKly8KFC7c9wpkzZy5YsODee+/dd99927Zte/vtt0+YMCGO4zp8kNhllZSUnHPOOd27d89ms5988kkqlRo2bFhZWVn//v139Em75bmm5UCdUc26NnDgwK5du44YMSKKouHDh5944okDBgzIfeqee+6ZNGnSrFmz3njjjWuuuSZ3Y58+fZo2bfrhhx9OnTp15syZgwYNiqJo06ZNZ599dmlp6fz586dPnz579uzbb7/91VdfLS8vHzt27JgxY2oaXLduXc+ePTt06LB06dJhw4aNHTt22yPs0qXLhg0bSktLc/+5bNmy/fbbL5VK1eGDxC5u48aNTZo0yX387rvvLl68+I477sj7SWs5UKe2uoTIztKyZcutHuo99tgj96l58+Y1a9bs3nvvLSsrmzdvXhzHy5cvj6Iom83mNpg8eXJpaenq1aunTp261157VVVV5W6fOXNmgwYN1q5dO3Xq1NLS0hUrVmy109w/E3Ec1zRYUVFRVla2Zs2a3O0/+tGPTjnllO18FZWVlYcffvjtt9++sx8ediPNmzevvkJbWVk5duzYBg0avPjii8uWLYuiaOLEiblP7eiT9osvvoii6J133rEcqEvONevudc2NGzfmbm/btu3QoUMHDx584403tm3btnr76nciHH/88evXr58/f/7cuXPXrFnTqFGj3DspTjrppM2bNy9YsODtt99u1arVfvvtV9OuaxqcO3fukUce2bhx49xmHTt23M7xf/XVV717927fvv2tt966kx4SdlNXXXVV7qnYokWLUaNGPfDAA7169cp9qk2bNrV80loO1CXVTMacOXOiKHrzzTe3vLGkpCT3waZNm6Ioatiw4caNG9u2bbvV/+l861vfKikp2f41opoGt9qseo/bWrFiRffu3Vu1avXss882bNiwdl8uu7vqc81169bNmTNnyzfUNGrUqJZPWsuBuqSaCXjppZeefvrpkSNHTpgwoaKiovr2t956K/fBrFmzmjRpcuSRRx599NELFy5cvHjxVvfQrl27RYsW5a5Qban6346aBtu3bz9v3ryvvvoq95+zZ8/+xiNcvHhx165du3Xr9sQTT1S/ogMFlfeT1nKgTu2kK71srWXLltt+50kcx19++WWbNm1uuOGG3OsoLVu2XLVqVe51zRNPPHHBggXvv//+scceO3jw4DiON23a1LFjxx49enz88ceLFy++/vrrW7duvW7dus2bN59wwgkXX3zx8uXLFy5ceP7551944YVxHHfq1Gn48OGrVq2qabCqqqpdu3YDBw5csWLFyy+/3LRp021fyPniiy+OOuqom266qa4eKnaj1zW3lHtdM/fS/nae7TU9aatf17QcqEuqWXfvBoqi6Iorrrj22msPO+yw1atXx3G8cuXK1q1bX3PNNblq3nLLLYceeui+++47ePDg9evX5+7no48+Ou+88/bee+999tnnrLPOeuedd3K3L1y48Oyzz95zzz2bN2/ev3//lStXxnH8m9/8pkmTJn369NnO4Pz587t3777nnnu2b99+8ODB2/4zcdddd2175F9++WXdPn7sdtXc0SdtdTUtB+pSKqlvPMpkMonstzitX79+4sSJ3bt3b9q0adLHsvvKZrOJ7NdaoNgktRbqhzgh6XQ672M2a7YQs9aCWbPJroV6wbuBACCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAqFQcx1ESMplMIvuFmmSz2UT2ay1QbJJaC/VDnJB0Op33MZs1W4hZa8Gs2WTXQr3gCi0AhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAiViuM4SkImk0lkv1CTbDabyH6tBYpNUmuhfogTkk6n8z5ms2YLMWstmDWb7FqoF1yhBYBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVJxHEdJyGQyiewXapLNZhPZr7VAsUlqLdQPcULS6XTex2zWbCFmrQWzZpNdC/WCK7QAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASBUw+AtAWDHpVI1fiqhH4ReG6oJQN3Gcttt6k8+VROAOu/lN47Uh3aqJgDJ9bK+tdO7gQAogmTu9PspDNUEoMhSlyrecKomAMUXuVSRhlM1ASjKvKWKMZypOKHXXTOZTCL7hZpks9lE9mstUI/XQqrwYSuyNwcl+R7aioqK/AbT6XRF27vznP3g5lrN1uaYzQbPPjrtuvxm+3e7P+/ZBFkLZotqtrjOBVOpogqnK7QAEEo1ASjuFx1TRfQCp2oCQCjVBKDoT/5SxXK6qZoAEEo1ASCUagJQHy6WporiIq3feQJAgcVxNGFCtHFjVFISnXtukfQvP841ASiw11+PXnop6ts3ev75aMaMqD5TTQAKbNGiqKoq6tw5WrLk6z/1mWoCUHjjx0fDhkWTJkX1nGoCUHgDBkSPPhr17h3Vc6oJQIG1bh01bhxls19/0LJlVJ95Dy0ABXbyydEnn0Tdun39HtrOnaP6TDUBKLBUPf5Wk624QgvAjogT+m2XxfFbNlUTAEKpJgCESsUJnfNmMplE9gs1yWaziezXWqBeroVUaje8PJvwu4EqKiryG0yn07WabXt3nrMf3JzYMe9ms49Ouy6/2f7d7s97vwmyFszWNLu7rYXi5wotAMV98hcXy4mmagLADlBNAIr4FDAuohNN1YQ8HX/88Uv+8asbqqqq2rVrd//993fs2PGEE06YPHly0ocGdSiOd6tkqibkqW/fvs8//3wURVOmTDnrrLPuvPPOadOmPfnkk+PHj0/60KBuxfHuk0zVhDz169dvwoQJURS98MILF1xwQc+ePS+77LJFixaNGzcu6UODOhfHu0kyVRPyVF5evmLFilWrVs2aNevb3/72o48+OmjQoNGjRw8YMCDpQ4MkxPHukEw/vR3yd955540YMeLkk09etWrVueee+8orr3Tq1OmII45I+rggIXG8c370QREnUzUhf/369TvuuOOmTJlSVlZ2zjnndO7cefPmzT/+8Y+TPi5ITvyP4OXdzuLuZY5qQp7Ky8urqqpyHw/9h6SPCOptO+N60Msc1QSgAOL/DuF28ll/YllNNQEopLj+pXE7vIcWAEKpJgCEUk0ACKWaABBKNQEglGoCQKhUnNB7gjOZTCL7hZpks9lE9mstUGySWgv1QpLfr1lRUZHfYDqdrmh7d56zH9xcL2dr81jVYvbRadflN9u/2/31bjZB1kLxr4XdapbtcIUWAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBKBW/vCHP3Tp0uWMM8447bTTpk+fHkXR5s2br7vuulNPPbVbt24LFizYdmTixImNGzeOomjEiBHt27cfOXJkbqpXr16VlZVREfP7NQGolYEDB06ZMuXwww+fP39+7969586d++CDDzZt2nT69OnZbHbIkCHPPffcltt/+eWXd955Z0lJSRRFv/jFL957773y8vKhQ4eOGTOmT58+zZo1i4qYc00AaqV58+YrVqyIomjFihVfffVVFEVPPPHEgAEDoijq1atX586dt9r+lltuueGGGxo0+DpAJSUlf//730tLSz///PMJEybkpoqZagJQKw8++GDXrl2PPfbYbt26PfDAA1EUvf/++88///zpp5/+3e9+94ILLthy49dee23p0qXVNw4fPvySSy656667br311p/85CepVCoqbqoJQK0MGTLkiSeemD179uOPP567GLt+/fpDDz301VdfveSSSwYOHFi9ZVVV1ZAhQ3Jlzbn00ktnzJhRXl4eRdGCBQt69er17LPPRkXM65oA1Mrs2bNzv4Tg/PPPv+qqq6IoatGiRTqdzv043CuvvLJ6y9/+9rdffvnlRRddFEXR6tWrL7vssnHjxsVxfNttt40bN65Tp04zZszo0qVL3759o2LlXBOAWikvL//zn/8cRdH06dMPO+ywKIrOPPPMadOmRVE0bdq0Dh065BoZRdFFF1309ttvv/oPTZo0GTduXBRFjzzySO/evZs3b7527do4jtesWRMVMeeaANTKgw8+eN11X/+uoVQqNWbMmCiK7rjjjoEDB95xxx0NGzZ86KGHcqehkydP3na2srLymWeemThxYhRFgwYN6tGjx4033hgVMdUEoFY6dOgwderULW858MADX3jhhS1v2TaZue/LbNas2aRJk3K33PIPUXFzhRYAQqkmAIRSTQAIlYrjOEpC7m3KUDyy2Wwi+7UWKDZJrYX6IU5I7lt58mPWbCFmrQWzZpNdC/WCK7QAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASBUKo7jKAmZTCaR/UJNstlsIvu1Fig2Sa2F+iFOSDqdzvuYzZotxKy1YNZssmuhXnCFFgBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhErFcRwlIZPJJLJfqEk2m01kv9YCxSaptVA/xAlJp9N5H7NZs4WYtRbMmk12LdQLrtACQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqgkAoVQTAEKpJgCEUk0ACKWaABBKNQEglGoCQCjVBIBQqTiOoyRkMplE9gs1yWaziezXWqDYJLUW6oc4Iel0Ou9jNmu2ELPWwg7NVu73x/z+1NOvd7eaTWot1Auu0AJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCpOI6jJGQymUT2CzXJZrNJHwJQ9OKEpNPpvI/ZrNlCzCa1FoB6xBVaAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQKhXHcfDGALBbc64JAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFLNXcqKFSvefffdpI8C6gGLhfyoZqG0atUqtY3x48cXdKc9evSYMWNG+PajRo3q3Lnztrd/+umnffv23WeffVq3bn3nnXfu1GOE/2H//fevXiClpaXHHHPM/fffn/e9VT+lKysrU6nUdrposZCfhnnOEeC+++674YYb6nKPa9eu3Sn3c9FFF7Vp02bRokXz5s07++yzDzrooMsvv3yn3DNsa/To0VdeeWUURRs2bPj9739//vnn77vvvpdeemlt7rNZs2ZxHG9nA4uF/DjXrGsPP/xwo0aNFi1aFEXR8uXL99lnn7Fjx3722WepVOrhhx9u1apVWVnZwIEDq5f0smXL+vbt26RJk9atWw8ePLj69iVLlmQymaZNmx5wwAFXX311VVXV6aef/t577w0YMCC3aGsafPvtt0877bTGjRt36dJl4cKF2x7h/Pnzp0yZMmrUqLKyshNPPPGMM874y1/+UoePELuvkpKSc845p3v37tls9pNPPkmlUsOGDSsrK+vfv/+OPqW3PNe0WNiZYgqjZcuW99133zd+6swzz7z66qvjOL7++uvPOOOMOI6XL18eRVG7du1mz549f/78Dh06/OAHP8htfOqpp/bv33/58uXz58/v2rXrFVdcEcfxxo0bjz322AsuuODTTz+dN29e165db7755jiOy8vLx44du53BtWvXtmnT5l/+5V8+//zz559/vnHjxqecckpNX8KGDRteeeWV/fbb7/nnny/MgwRx8+bNR48eveUtPXr0uPTSS5ctWxZFUTqdXrVq1UcffbSjT+kvvvgiiqJ33nnHYmHnUs1Cadmy5Vb/g7LHHnvkPjVv3rxmzZrde++9ZWVl8+bNq65mNpvNbTB58uTS0tLVq1dPnTp1r732qqqqyt0+c+bMBg0arF27durUqaWlpStWrNhqp9X/ENQ0WFFRUVZWtmbNmtztP/rRj7bzD0F5eXmjRo1OP/305cuXF+ARgq2rWVlZOXbs2AYNGrz44ou5ak6cODH3qR19SldX02Jh53KFtoC2OtfcuHFj7va2bdsOHTp08ODBN954Y9u2bau3r36vwfHHH79+/fr58+fPnTt3zZo1jRo1yr1X4qSTTtq8efOCBQvefvvtVq1a7bfffjXtuqbBuXPnHnnkkY0bN85t1rFjx+0c/7vvvrtixYq99trrnHPO2UkPCXyDq666KvdEbdGixahRox544IFevXrlPtWmTZtaPqUtFnYu1UzGnDlzoih68803t7yxpKQk98GmTZu+fqdWw4YbN25s27btVv+n861vfaukpCSVSm3n/msa3Gqz6j3WZO+997711lv/+te/Ll26NN+vFf6J6nPNdevWzZkzJ/fOoJxGjRrV8iltsbBzqWYCXnrppaeffnrkyJETJkyoqKiovv2tt97KfTBr1qwmTZoceeSRRx999MKFCxcvXrzVPbRr127RokW5a1Bbqv7XoabB9u3bz5s376uvvsr95+zZs7c9vEmTJpWVlVVVVeX+8/PPP99jjz2aNWtWuy8aaiXvp7TFwk62k670EvpuoC+//LJNmzY33HBD7pWSli1brlq1Kve65oknnrhgwYL333//2GOPHTx4cBzHmzZt6tixY48ePT7++OPFixdff/31rVu3Xrdu3ebNm0844YSLL754+fLlCxcuPP/88y+88MI4jjt16jR8+PBVq1bVNFhVVdWuXbuBAweuWLHi5Zdfbtq06bYv1axdu7Zdu3ZXX311ZWXl3/72t2OOOebyyy+vq4eN3c627wbKyb2umXvhfztroaandPXrmhYLO5dq1t27gaIouuKKK6699trDDjts9erVcRyvXLmydevW11xzTa6at9xyy6GHHrrvvvsOHjx4/fr1ufv56KOPzjvvvL333nufffY566yz3nnnndztCxcuPPvss/fcc8/mzZv3799/5cqVcRz/5je/adKkSZ8+fbYzOH/+/O7du++5557t27cfPHjwN77B4YMPPujZs+c+++zTpk2bYcOGrV27tg4fOXYvgdXc0ad0dTUtFnau1Pa/Ebg2MplMge5517N+/fqJEyd27969adOmSR8L3yybzSayX+uIYpNNaC0Ui7hg0ul03ke1u8327Nkzkf2aLYaVYh2ZrV+z8e7Nu4EAIJRqFoXS0tKkDwGAf041ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAEEo1ASCUagJAKNUEgFCqCQChVBMAQqkmAIRSTQAIpZoAECoVx3FUGJlMpkD3DHUvm80msl/riGKTTWgtFImGBb33ioqK/AbT6XS9nG17d56zH9xcL7/e3Wk2QfXusbKOdu3Z3ZwrtAAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQSjUBIJRqAkAo1QSAUKoJAKFUEwBCqSYAhFJNAAilmgAQ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1VcjR44cMmTI448/Xsv7bNasWRzHRx99dE0bWErURDXr2sMPP9yoUaNFixZFUbR8+fJ99tln7Nixn332WSqVevjhh1u1alVWVjZw4MDqRbts2bK+ffs2adKkdevWgwcPrr59yZIlmUymadOmBxxwwNVXX11VVXX66ae/9957AwYMuPzyy7cz+Pbbb5922mmNGzfu0qXLwoULazrOdevWDRw48MQTT6yTRwX+uZKSknPOOad79+7ZbPaTTz5JpVLDhg0rKyvr37//jj7htzzXtJTYIapZ1wYOHNi1a9cRI0ZEUTR8+PATTzxxwIABuU/dc889kyZNmjVr1htvvHHNNdfkbuzTp0/Tpk0//PDDqVOnzpw5c9CgQVEUbdq06eyzzy4tLZ0/f/706dNnz559++23v/rqq+Xl5WPHjh0zZkxNg+vWrevZs2eHDh2WLl06bNiwsWPH1nSct9122//6X//r/PPPr6sHBoJs3LixSZMmuY/ffffdxYsX33HHHXk/4S0ldthWlxDZWVq2bLnVQ73HHnvkPjVv3rxmzZrde++9ZWVl8+bNi+N4+fLlURRls9ncBpMnTy4tLV29evXUqVP32muvqqqq3O0zZ85s0KDB2rVrp06dWlpaumLFiq12mlvqcRzXNFhRUVFWVrZmzZrc7T/60Y9OOeWUbQ/+9ddfP+CAA5YtW3bXXXd95zvfKdiDBP9E8+bNq6/QVlZWjh07tkGDBi+++OKyZcuiKJo4cWLuUzv6hP/iiy+iKHrnnXcsJXaUc826e11z48aNudvbtm07dOjQwYMH33jjjW3btq3evvrdBMcff/z69evnz58/d+7cNWvWNGrUKPduiJNOOmnz5s0LFix4++23W7Vqtd9++9W065oG586de+SRRzZu3Di3WceOHbed3bBhww9+8IORI0cedNBBO/shgR121VVX5Z7GLVq0GDVq1AMPPNCrV6/cp9q0aVPLJ7ylxI5SzWTMmTMniqI333xzyxtLSkpyH2zatCmKooYNG27cuLFt27Zb/Z/Ot771rZKSklQqtZ37r2lwq82q97il4cOHt2rV6vvf//7O+EKhtqrPNdetWzdnzpwrr7yy+lONGjWq5RPeUmJHqWYCXnrppaeffnrkyJETJkyoqKiovv2tt97KfTBr1qwmTZoceeSRRx999MKFCxcvXrzVPbRr127RokW5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"
          },
          {
            "type": "input_text",
            "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
          }
        ]
      },
      {
        "type": "message",
        "role": "assistant",
        "content": [
          "The core approach has been stable and correct in essence:\n\n- Keep blue cluster fixed.\n- Duplicate every other color cluster exactly.\n- Place duplicated cluster in a fixed opposite quadrant, preserving relative cluster shape and internal offsets.\n- Output fixed 11\u00d711 grid.\n\nThe main limitation is pixel accuracy\u2014not perfect\u2014likely due to slight offsets or cluster positioning near boundaries.\n\n---\n\n**Further refinements:**\n\n1. Use **connected component labeling** to isolate clusters precisely, avoid mixing different clusters of same color.\n2. Move entire connected cluster as a unit, rather than all pixels of a color (better if multiple clusters per color).\n3. Attempt to place duplicates with minimal shifting when quadrant boundary constraints force clamping.\n4. Avoid placing duplicates overlapping original clusters.\n5. Preserve original blue cluster exactly.\n\n---\n\n### Here is an improved solution incorporating connected component analysis for more precise cluster separation:\n\n```python\ndef transform(grid):\n    import numpy as np\n    from scipy.ndimage import label\n\n    arr = np.array(grid)\n    target_size = 11\n\n    norm = np.zeros((target_size, target_size), dtype=int)\n    norm[:arr.shape[0], :arr.shape[1]] = arr[:target_size, :target_size]\n    arr = norm\n\n    output = np.zeros_like(arr)\n    blue_color = 1\n    output[arr == blue_color] = blue_color\n\n    # Define quadrants (inclusive)\n    quadrants = {\n        'TL': (0, 5, 0, 5),\n        'TR': (0, 5, 6, 10),\n        'BL': (6, 10, 0, 5),\n        'BR': (6, 10, 6, 10)\n    }\n    quadrant_map = {'TL': 'TR', 'TR': 'BL', 'BL': 'BR', 'BR': 'TL'}\n\n    def get_quadrant(r, c):\n        for q, (rs, re, cs, ce) in quadrants.items():\n            if rs <= r <= re and cs <= c <= ce:\n                return q\n        return None\n\n    # Process each nonzero color except blue\n    colors = set(np.unique(arr))\n    colors.discard(0)\n    colors.discard(blue_color)\n\n    for color in colors:\n        mask = (arr == color)\n        if not np.any(mask):\n            continue\n\n        # Label connected components for this color\n        labeled, num_features = label(mask)\n        for comp_id in range(1, num_features + 1):\n            comp_mask = (labeled == comp_id)\n            rows, cols = np.where(comp_mask)\n\n            min_r, max_r = rows.min(), rows.max()\n            min_c, max_c = cols.min(), cols.max()\n\n            # Copy original cluster pixels exactly\n            output[rows, cols] = color\n\n            centroid_r = int(round(rows.mean()))\n            centroid_c = int(round(cols.mean()))\n            orig_quad = get_quadrant(centroid_r, centroid_c)\n            target_quad = quadrant_map[orig_quad]\n\n            r_start, r_end, c_start, c_end = quadrants[target_quad]\n\n            cluster_height = max_r - min_r + 1\n            cluster_width = max_c - min_c + 1\n\n            orig_r_start, orig_r_end, orig_c_start, orig_c_end = quadrants[orig_quad]\n            offset_r = min_r - orig_r_start\n            offset_c = min_c - orig_c_start\n\n            # Calculate tentative new top-left position for duplicate cluster\n            new_min_r = r_start + offset_r\n            new_min_c = c_start + offset_c\n\n            # Clamp to fit cluster inside target quadrant\n            if new_min_r < r_start:\n                new_min_r = r_start\n            if new_min_c < c_start:\n                new_min_c = c_start\n            if new_min_r + cluster_height - 1 > r_end:\n                new_min_r = r_end - cluster_height + 1\n            if new_min_c + cluster_width - 1 > c_end:\n                new_min_c = c_end - cluster_width + 1\n\n            # Create output mask for duplicate - write pixels without overwriting blue pixels\n            for r, c in zip(rows, cols):\n                rr = new_min_r + (r - min_r)\n                cc = new_min_c + (c - min_c)\n                if 0 <= rr < target_size and 0 <= cc < target_size:\n                    if output[rr, cc] != blue_color:\n                        output[rr, cc] = color\n\n    return output.tolist()\n```\n\n---\n\n**Summary of improvements:**\n\n- Used `scipy.ndimage.label` to separate connected clusters within the same color.\n- Each connected cluster moved and duplicated independently.\n- Keeps blue shape unchanged.\n- Duplicates each cluster preserving shape and relative position.\n- Duplicates copied to corresponding mapped quadrant, clamped to fit.\n- Avoids overwriting blue pixels.\n\n---\n\nThis approach should fix errors from merging multiple clusters of one color and better preserve positions.\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n    from scipy.ndimage import label\n\n    arr = np.array(grid)\n    target_size = 11\n\n    norm = np.zeros((target_size, target_size), dtype=int)\n    norm[:arr.shape[0], :arr.shape[1]] = arr[:target_size, :target_size]\n    arr = norm\n\n    output = np.zeros_like(arr)\n    blue_color = 1\n    output[arr == blue_color] = blue_color\n\n    quadrants = {\n        'TL': (0, 5, 0, 5),\n        'TR': (0, 5, 6, 10),\n        'BL': (6, 10, 0, 5),\n        'BR': (6, 10, 6, 10)\n    }\n    quadrant_map = {'TL': 'TR', 'TR': 'BL', 'BL': 'BR', 'BR': 'TL'}\n\n    def get_quadrant(r, c):\n        for q, (rs, re, cs, ce) in quadrants.items():\n            if rs <= r <= re and cs <= c <= ce:\n                return q\n        return None\n\n    colors = set(np.unique(arr))\n    colors.discard(0)\n    colors.discard(blue_color)\n\n    for color in colors:\n        mask = (arr == color)\n        if not np.any(mask):\n            continue\n\n        labeled, num_features = label(mask)\n        for comp_id in range(1, num_features + 1):\n            comp_mask = (labeled == comp_id)\n            rows, cols = np.where(comp_mask)\n            min_r, max_r = rows.min(), rows.max()\n            min_c, max_c = cols.min(), cols.max()\n\n            # Copy original pixels\n            output[rows, cols] = color\n\n            centroid_r = int(round(rows.mean()))\n            centroid_c = int(round(cols.mean()))\n            orig_quad = get_quadrant(centroid_r, centroid_c)\n            target_quad = quadrant_map[orig_quad]\n\n            r_start, r_end, c_start, c_end = quadrants[target_quad]\n            cluster_height = max_r - min_r + 1\n            cluster_width = max_c - min_c + 1\n\n            orig_r_start, orig_r_end, orig_c_start, orig_c_end = quadrants[orig_quad]\n            offset_r = min_r - orig_r_start\n            offset_c = min_c - orig_c_start\n\n            new_min_r = r_start + offset_r\n            new_min_c = c_start + offset_c\n\n            if new_min_r < r_start:\n                new_min_r = r_start\n            if new_min_c < c_start:\n                new_min_c = c_start\n            if new_min_r + cluster_height - 1 > r_end:\n                new_min_r = r_end - cluster_height + 1\n            if new_min_c + cluster_width - 1 > c_end:\n                new_min_c = c_end - cluster_width + 1\n\n            for r, c in zip(rows, cols):\n                rr = new_min_r + (r - min_r)\n                cc = new_min_c + (c - min_c)\n                if 0 <= rr < target_size and 0 <= cc < target_size:\n                    if output[rr, cc] != blue_color:\n                        output[rr, cc] = color\n\n    return output.tolist()\n```\n"
        ]
      }
    ],
    "all_responses": [
      {
        "id": "resp_686f8a9c3450819dbafb428ea513c8b106ed706914c182fd",
        "model": "gpt-4.1-mini-2025-04-14",
        "usage": {
          "input_tokens": 4940,
          "output_tokens": 1376,
          "total_tokens": 6316
        },
        "output": [
          {
            "type": "message",
            "content": [
              "Let's analyze the training examples carefully:\n\n- The grids are always 11\u00d711.\n- There are colored shapes formed by nonzero numbers.\n- Each example has at least two distinctive colors (numbers).\n- The blue shape(s) remains mostly unchanged on the output.\n- The colored single or small cluster points of different colors in input appear to be \"grown\" or \"duplicated\" spatially in output in distinct areas, often reflected or repositioned.\n- The newly created shape (of the second color) in the output:\n  - Matches the shape of the original colored cluster but is rotated or translated to a different location.\n  - Appears in a different corner or side of the grid relative to input positions.\n- In the last example, a small light blue cluster in Input (lower left) grows and appears in output too.\n- Essentially, the transformation seems to:\n  1. Keep original blue figures as is.\n  2. Identify secondary colored shapes (single-color or cluster).\n  3. Copy or replicate these secondary shapes with possible simple transforms (translation, flipping) to a different quadrant.\n  4. Color the copies with same or different colors.\n  \nAlso, from the colors and examples:\n\n- Blue shapes keep the same color.\n- Secondary shapes (green, pink, red, light blue) recreate or partially replicate elsewhere.\n- Sometimes single points get extended into multi-point shapes in output.\n- The extra shapes appear usually in corners opposite or other quadrant.\n\nBecause these datasets are ARC-style, transformations are often geometric (translation, 90\u00b0 rotations, quarters flips).\n\n---\n\n### Hypothesis for the transformation:\n\n- Keep all original blue pixels (color 1).\n- For each secondary color cluster distinct from blue:\n  - Find its shape.\n  - Place a translated or flipped copy of that shape somewhere else on the grid:\n    - Usually near the opposite corner or a clear predefined quadrant.\n  - Color of the copy can be the same or closely related.\n- Some pixels that appear isolated in input become replicated as mini shapes in output.\n\n---\n\n### Implementation plan:\n\n1. Identify main blue shape and keep it.\n2. Find the other colored clusters (nonzero and not blue).\n3. Extract the bounding box of these clusters.\n4. Mirror horizontally or vertically this bounding box.\n5. Translate mirrored shape to a new location (opposite quadrant).\n6. Paste it back in output grid.\n7. Also keep original secondary cluster as is (or make copy only).\n8. Output always 11\u00d711 grid.\n\n---\n\n### Since the problem wants an 11\u00d711 output grid and inputs can be 11\u00d711 or bigger, we need to normalize sizes:\n\n- Clip or pad input to 11\u00d711 before processing.\n- Output is always 11\u00d711.\n\n---\n\n### Simplifications based on examples:\n\n- Blue shapes unchanged.\n- For the other colors:\n  - find their bounding boxes,\n  - flip horizontally,\n  - place near bottom-left or top-right quadrant,\n  - color in output remains same color for simplicity.\n- Do this for all secondary colors.\n\n---\n\nNow I will write code that implements these steps.\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n\n    # Normalize input to 11x11 (pad or crop)\n    rows = len(grid)\n    cols = len(grid[0])\n    target_size = 11\n    arr = np.zeros((target_size, target_size), dtype=int)\n    # Crop or pad top-left corner\n    min_rows = min(rows, target_size)\n    min_cols = min(cols, target_size)\n    arr[:min_rows, :min_cols] = np.array(grid)[:min_rows, :min_cols]\n\n    output = np.zeros_like(arr)\n\n    # Blue color is considered 1 (based on examples)\n    # Keep all blue pixels as is\n    blue_mask = (arr == 1)\n    output[blue_mask] = 1\n\n    # Find all colors present except 0 and blue(1)\n    colors = set(np.unique(arr))\n    colors.discard(0)\n    if 1 in colors:\n        colors.discard(1)\n\n    # For each secondary color cluster, find bounding boxes, then flip horizontally and place near opposite corner\n    for color in colors:\n        mask = (arr == color)\n        if not np.any(mask):\n            continue\n\n        # Find bounding box of cluster for this color\n        rows_idx, cols_idx = np.where(mask)\n        min_r, max_r = rows_idx.min(), rows_idx.max()\n        min_c, max_c = cols_idx.min(), cols_idx.max()\n\n        cluster = arr[min_r:max_r+1, min_c:max_c+1]\n        # Only keep this cluster pixels equal to color, others zeroed\n        cluster_mask = (cluster == color)\n        cluster_shape = np.where(cluster_mask, color, 0)\n\n        # Flip cluster horizontally\n        flipped = np.fliplr(cluster_shape)\n\n        # Decide placement for flipped cluster:\n        # Place it in bottom-left quadrant or top-right quadrant depending on where original cluster is.\n        # If original is in top half, place in bottom half; else top half\n        # If original is in left half, place in right half; else left half\n\n        original_center_r = (min_r + max_r)//2\n        original_center_c = (min_c + max_c)//2\n        hr, hc = flipped.shape\n\n        if original_center_r < target_size // 2:\n            # place in bottom half\n            new_r = target_size - hr - 1\n        else:\n            # top half\n            new_r = 1\n\n        if original_center_c < target_size // 2:\n            # place in right half\n            new_c = target_size - hc - 1\n        else:\n            # left half\n            new_c = 1\n\n        # Bound check to avoid overflow\n        new_r = max(0, min(new_r, target_size - hr))\n        new_c = max(0, min(new_c, target_size - hc))\n\n        # Paste flipped cluster into output (overlay, preserve existing blue)\n        for rr in range(hr):\n            for cc in range(hc):\n                val = flipped[rr, cc]\n                if val != 0:\n                    output[new_r + rr, new_c + cc] = val\n\n        # Also keep original secondary cluster pixels as is:\n        for rr in range(min_r, max_r+1):\n            for cc in range(min_c, max_c+1):\n                if arr[rr, cc]==color:\n                    output[rr, cc] = color\n\n    return output.tolist()\n```\n"
            ]
          }
        ]
      },
      {
        "id": "resp_686f8ab2561c819d81cd0cdd8a3e37bd06ed706914c182fd",
        "model": "gpt-4.1-mini-2025-04-14",
        "usage": {
          "input_tokens": 11113,
          "output_tokens": 1444,
          "total_tokens": 12557
        },
        "output": [
          {
            "type": "message",
            "content": [
              "Let's analyze carefully based on the feedback and visuals:\n\n1. The blue shape always remains fixed at its original location in output.\n2. The secondary colors (3, 6, 2, 8, etc.) are always *replicated* into a *new region* spatially separated from the original, sometimes with a transformation like reflection or rotation.\n3. These replications are contiguous \"clusters\" matching the secondary shape's size and form but shifted to the opposite side of the grid.\n4. There is no deletion of the original secondary shapes.\n5. The new \"secondary cluster\" is placed near another corner/quadrant of the grid, with some flipping.\n\nFrom visual feedback:\n\n- In example 1: Secondary color 3 (green) cluster appears enlarged near the top-right corner. Secondary color 8 cluster appears enlarged toward bottom-left corner.\n- In example 2: Secondary color 6 cluster is copied and expanded near bottom right.\n- In example 3: Secondary color 2 cluster is copied and expanded near bottom-left.\n- In example 4: Secondary color 2 cluster is copied and expanded near top-right with additional duplication of secondary light blue cluster near bottom-left.\n\n### Conjecture for the general transform:\n\n- Blue shape(s) copied unchanged.\n- For each non-blue secondary color cluster:\n  - Identify cluster bounding box.\n  - Reflect cluster horizontally (flip left-right).\n  - Place the flipped copy in the opposite half of the grid (if original in top-left quadrant -> copied in bottom-right quadrant, etc.).\n  - Also expand the cluster somewhat by including neighbor pixels if they exist (to roughly mimic the \"extension\"/\"enlargement\").\n  - Same color is used.\n- Leave original clusters as is.\n\n---\n\n### Details to implement:\n\n- The grid is always 11\u00d711.\n- Define quadrants:\n  - Top-left: rows < 5, cols < 5\n  - Top-right: rows < 5, cols \u2265 5\n  - Bottom-left: rows \u2265 5, cols < 5\n  - Bottom-right: rows \u2265 5, cols \u2265 5\n- For each cluster, determine which quadrant it occupies mostly by center of mass.\n- Target placement quadrant should be \"opposite\":\n  - TL -> BR\n  - TR -> BL\n  - BL -> TR\n  - BR -> TL\n- Horizontally flip the cluster.\n- Place carefully to avoid overflow (stay within 11\u00d711).\n- In case the cluster is larger, use the bounding box size for placement.\n- Preserve blue shapes and original clusters.\n\n---\n\n### This should fit all examples reasonably well.\n\nNow, let's implement this.\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n\n    arr = np.array(grid)\n    h, w = arr.shape\n    target_size = 11\n\n    # Normalize grid to 11x11 size with cropping or padding\n    canvas = np.zeros((target_size, target_size), dtype=int)\n    rr = min(h, target_size)\n    cc = min(w, target_size)\n    canvas[:rr, :cc] = arr[:rr, :cc]\n    arr = canvas\n\n    output = np.zeros_like(arr)\n\n    # Define center line for quadrant split\n    mid_row = target_size // 2\n    mid_col = target_size // 2\n\n    # Blue color is 1, copy all blue pixels unchanged\n    blue_mask = (arr == 1)\n    output[blue_mask] = 1\n\n    # Find all nonzero colors except blue\n    colors = set(np.unique(arr))\n    colors.discard(0)\n    if 1 in colors:\n        colors.discard(1)\n\n    def find_quadrant(r, c):\n        # return 'TL','TR','BL','BR'\n        if r < mid_row and c < mid_col:\n            return 'TL'\n        elif r < mid_row and c >= mid_col:\n            return 'TR'\n        elif r >= mid_row and c < mid_col:\n            return 'BL'\n        else:\n            return 'BR'\n\n    def opposite_quadrant(q):\n        # Map to opposite quadrant\n        return {'TL':'BR', 'TR':'BL', 'BL':'TR', 'BR':'TL'}[q]\n\n    def quadrant_top_left(q):\n        if q == 'TL':\n            return (0, 0)\n        elif q == 'TR':\n            return (0, mid_col)\n        elif q == 'BL':\n            return (mid_row, 0)\n        else:  # BR\n            return (mid_row, mid_col)\n\n    for color in colors:\n        mask = (arr == color)\n        if not np.any(mask):\n            continue\n        rows_idx, cols_idx = np.where(mask)\n        min_r, max_r = rows_idx.min(), rows_idx.max()\n        min_c, max_c = cols_idx.min(), cols_idx.max()\n\n        cluster = arr[min_r:max_r+1, min_c:max_c+1]\n        # Binary mask of cluster pixels of this color\n        cluster_mask = (cluster == color)\n\n        # Find cluster center approx\n        center_r = int(np.mean(rows_idx))\n        center_c = int(np.mean(cols_idx))\n        orig_quad = find_quadrant(center_r, center_c)\n        targ_quad = opposite_quadrant(orig_quad)\n        targ_r0, targ_c0 = quadrant_top_left(targ_quad)\n\n        # Flip cluster horizontally\n        cluster_flipped = np.fliplr(cluster * cluster_mask)\n\n        # size of cluster\n        ch, cw = cluster.shape\n\n        # Place flipped cluster in target quadrant so that cluster fits inside quadrant boundaries:\n        # Quadrants are 5\u00d75 or 6\u00d76 blocks. Target quadrant may have variable size:\n        # For 11x11, top-left quadrants rows 0-5 or cols 0-5 except that mid line is at 5\n        max_r_place = targ_r0 + mid_row if targ_r0 == 0 else target_size\n        max_c_place = targ_c0 + mid_col if targ_c0 == 0 else target_size\n\n        # Adjust to fit cluster inside quadrant at top-left corner placement:\n        place_r = targ_r0\n        place_c = targ_c0\n        if (place_r + ch) > max_r_place:\n            place_r = max_r_place - ch\n        if (place_c + cw) > max_c_place:\n            place_c = max_c_place - cw\n\n        # Place the flipped cluster in output\n        for rr in range(ch):\n            for cc in range(cw):\n                if cluster_flipped[rr, cc] == color:\n                    output[place_r+rr, place_c+cc] = color\n\n        # Also keep original cluster pixels as is\n        output[min_r:max_r+1, min_c:max_c+1][cluster_mask] = color\n\n    return output.tolist()\n```\n"
            ]
          }
        ]
      },
      {
        "id": "resp_686f8ac58484819d8244ec03592f3fe406ed706914c182fd",
        "model": "gpt-4.1-mini-2025-04-14",
        "usage": {
          "input_tokens": 17354,
          "output_tokens": 2230,
          "total_tokens": 19584
        },
        "output": [
          {
            "type": "message",
            "content": [
              "Let's analyze the examples further with the feedback in mind:\n\n1. The blue shape (value 1) is always kept unchanged as a fixed figure in the output.\n2. The duplicated secondary shapes tend to appear in output as an *expanded* cluster in a different location, not just flipped or moved simply.\n3. The \"green\" cluster (value 3), \"pink\" cluster (value 6), \"red\" cluster (value 2), or \"light blue\" cluster (value 8) in the input are:\n   - Recreated in output in a **different corner or edge**,\n   - The duplicates often form small rectangles or block shapes that approximate or extend the input cluster shape, often 3\u00d73 or similar small solid blobs.\n   - The duplicated clusters fill more area than their input counterpart (they tend to be expanded versions of those clusters).\n4. Original colored clusters (non-blue) remain at their input positions \u2014 no removal.\n5. The output is always 11\u00d711.\n\n---\n\n### Hypothesis refined:\n\n- Keep blue cluster unchanged.\n- For each non-blue color cluster:\n   - Copy the cluster pixels unchanged to output at their input positions.\n   - Create a **new solid block region** of roughly the same general size, scaled up or enlarged to a rectangular shape, placed in a specific \"other\" quadrant/corner.\n   - This new solid block uses the same color as the cluster and covers more space than original cluster.\n   - The placement corner depends on input cluster position (generally opposite corner or adjacent edge).\n- The lower-left cluster in example 1 (color 8) is a 3\u00d73 block that appears enlarged into a roughly 3\u00d73 block in output, but shifted left or bottom.\n- The green cluster (3) in example 1 is expanded into a roughly 3\u00d73 block in output, positioned top right.\n\n---\n\n### Implementation Plan:\n\n- Identify clusters (connected sets) of unique colors aside from blue.\n- For each cluster:\n  - Determine bounding box.\n  - Copy original cluster pixels as is.\n  - Compute a target quadrant/corner for duplication:\n    - If cluster mostly top-left, duplicate to top-right or bottom-left.\n    - If cluster mostly top-right, duplicate to bottom-left or bottom-right.\n    - Choose a rectangle in target to place a filled solid rectangle of cluster's color.\n  - The duplicated block size is max(width, height) of the bounding box, or at least 3\u00d73 if smaller.\n  - Place duplicated block with some padding from edges so it does not overlap original.\n- Preserve blue cluster pixels at all times.\n\n---\n\n### This approach improves handling of cluster expansion and placement shown clearly in training examples.\n\n---\n\n### Code follows:\n\n```python\ndef transform(grid):\n    import numpy as np\n\n    arr = np.array(grid)\n    h, w = arr.shape\n    target_size = 11\n    # Normalize size to 11 x 11 (crop or pad as needed)\n    norm = np.zeros((target_size, target_size), dtype=int)\n    norm[:h, :w] = arr[:target_size, :target_size]\n    arr = norm\n\n    output = np.zeros_like(arr)\n\n    # Blue cluster color\n    blue_color = 1\n\n    # Copy blue cluster pixels directly\n    blue_mask = (arr == blue_color)\n    output[blue_mask] = blue_color\n\n    # Find all colors excluding 0 and blue\n    colors = set(np.unique(arr))\n    colors.discard(0)\n    if blue_color in colors:\n        colors.discard(blue_color)\n\n    def get_quadrant(r, c):\n        # quadrants by midline indices (0-based)\n        mid = target_size // 2\n        if r < mid and c < mid:\n            return 'TL'\n        elif r < mid and c >= mid:\n            return 'TR'\n        elif r >= mid and c < mid:\n            return 'BL'\n        else:\n            return 'BR'\n\n    def opposite_quadrant(q):\n        mapping = {'TL': 'BR', 'TR': 'BL', 'BL': 'TR', 'BR': 'TL'}\n        return mapping[q]\n\n    def quadrant_bounds(q):\n        mid = target_size // 2\n        if q == 'TL':\n            return (0, mid), (0, mid)\n        elif q == 'TR':\n            return (0, mid), (mid, target_size)\n        elif q == 'BL':\n            return (mid, target_size), (0, mid)\n        else:  # BR\n            return (mid, target_size), (mid, target_size)\n\n    for color in colors:\n        mask = (arr == color)\n        if not np.any(mask):\n            continue\n        rows, cols = np.where(mask)\n        min_r, max_r = rows.min(), rows.max()\n        min_c, max_c = cols.min(), cols.max()\n\n        # Copy original cluster pixels as is\n        output[min_r:max_r+1, min_c:max_c+1][arr[min_r:max_r+1, min_c:max_c+1] == color] = color\n\n        # Determine cluster center to assign quadrant\n        center_r = int(np.mean(rows))\n        center_c = int(np.mean(cols))\n        orig_quad = get_quadrant(center_r, center_c)\n        targ_quad = opposite_quadrant(orig_quad)\n\n        # Compute bounds of target quadrant\n        (r_start, r_end), (c_start, c_end) = quadrant_bounds(targ_quad)\n\n        # Decide rectangle size for duplicate block:\n        height = max_r - min_r +1\n        width = max_c - min_c +1\n        block_size = max(height, width)\n        if block_size < 3:\n            block_size = 3\n\n        # Place duplication block inside target quadrant with padding of 1\n        block_r_start = r_start + 1\n        block_c_start = c_start + 1\n\n        # Ensure block doesn't overflow quadrant\n        if block_r_start + block_size > r_end:\n            block_r_start = r_end - block_size\n        if block_c_start + block_size > c_end:\n            block_c_start = c_end - block_size\n\n        # Draw solid block of color in output\n        for rr in range(block_r_start, block_r_start + block_size):\n            for cc in range(block_c_start, block_c_start + block_size):\n                output[rr, cc] = color\n\n    return output.tolist()\n```\n\nThis improved solution:\n\n- Keeps blue cluster intact.\n- Duplicates each secondary cluster as a solid block in the opposite quadrant.\n- Duplication block size expands original cluster roughly but minimally 3\u00d73.\n- Block placed safely to avoid overlap outside quadrant.\n- Preserves original clusters in output.\n\nThis covers all training examples better, capturing spatial duplication and expansion. It should generalize well to test inputs with similar structure.\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n\n    arr = np.array(grid)\n    h, w = arr.shape\n    target_size = 11\n    # Normalize size to 11 x 11 (crop or pad as needed)\n    norm = np.zeros((target_size, target_size), dtype=int)\n    norm[:h, :w] = arr[:target_size, :target_size]\n    arr = norm\n\n    output = np.zeros_like(arr)\n\n    # Blue cluster color\n    blue_color = 1\n\n    # Copy blue cluster pixels directly\n    blue_mask = (arr == blue_color)\n    output[blue_mask] = blue_color\n\n    # Find all colors excluding 0 and blue\n    colors = set(np.unique(arr))\n    colors.discard(0)\n    if blue_color in colors:\n        colors.discard(blue_color)\n\n    def get_quadrant(r, c):\n        # quadrants by midline indices (0-based)\n        mid = target_size // 2\n        if r < mid and c < mid:\n            return 'TL'\n        elif r < mid and c >= mid:\n            return 'TR'\n        elif r >= mid and c < mid:\n            return 'BL'\n        else:\n            return 'BR'\n\n    def opposite_quadrant(q):\n        mapping = {'TL': 'BR', 'TR': 'BL', 'BL': 'TR', 'BR': 'TL'}\n        return mapping[q]\n\n    def quadrant_bounds(q):\n        mid = target_size // 2\n        if q == 'TL':\n            return (0, mid), (0, mid)\n        elif q == 'TR':\n            return (0, mid), (mid, target_size)\n        elif q == 'BL':\n            return (mid, target_size), (0, mid)\n        else:  # BR\n            return (mid, target_size), (mid, target_size)\n\n    for color in colors:\n        mask = (arr == color)\n        if not np.any(mask):\n            continue\n        rows, cols = np.where(mask)\n        min_r, max_r = rows.min(), rows.max()\n        min_c, max_c = cols.min(), cols.max()\n\n        # Copy original cluster pixels as is\n        output[min_r:max_r+1, min_c:max_c+1][arr[min_r:max_r+1, min_c:max_c+1] == color] = color\n\n        # Determine cluster center to assign quadrant\n        center_r = int(np.mean(rows))\n        center_c = int(np.mean(cols))\n        orig_quad = get_quadrant(center_r, center_c)\n        targ_quad = opposite_quadrant(orig_quad)\n\n        # Compute bounds of target quadrant\n        (r_start, r_end), (c_start, c_end) = quadrant_bounds(targ_quad)\n\n        # Decide rectangle size for duplicate block:\n        height = max_r - min_r +1\n        width = max_c - min_c +1\n        block_size = max(height, width)\n        if block_size < 3:\n            block_size = 3\n\n        # Place duplication block inside target quadrant with padding of 1\n        block_r_start = r_start + 1\n        block_c_start = c_start + 1\n\n        # Ensure block doesn't overflow quadrant\n        if block_r_start + block_size > r_end:\n            block_r_start = r_end - block_size\n        if block_c_start + block_size > c_end:\n            block_c_start = c_end - block_size\n\n        # Draw solid block of color in output\n        for rr in range(block_r_start, block_r_start + block_size):\n            for cc in range(block_c_start, block_c_start + block_size):\n                output[rr, cc] = color\n\n    return output.tolist()\n```"
            ]
          }
        ]
      },
      {
        "id": "resp_686f8ae4f1c0819d83053bc85b15c6f806ed706914c182fd",
        "model": "gpt-4.1-mini-2025-04-14",
        "usage": {
          "input_tokens": 24381,
          "output_tokens": 2388,
          "total_tokens": 26769
        },
        "output": [
          {
            "type": "message",
            "content": [
              "Analyzing the feedback and the examples once again:\n\n- The blue shapes remain precisely unchanged.\n- The transformation creates a **secondary shape of the cluster color** that is:\n  - Positioned in a different quadrant than the original cluster,\n  - Not an arbitrary block but **matches the exact shape** of the cluster itself, i.e., a copy of the cluster,\n  - This copy is **translated (shifted)** to another quadrant, without flipping or rotation.\n- The new position of the copy is determined by moving clusters to a distinct quadrant that doesn't overlap with original clusters:\n  - E.g., if cluster is top-left, the duplicate goes to top-right or bottom-left.\n- The duplicate is the **same shape and color** as the original cluster.\n- The original cluster remains in place.\n- All output grids are 11\u00d711.\n- No flipping or resizing; direct copy and translation of each cluster to a distinct quadrant.\n\n---\n\n### Improved approach:\n\n1. Identify all distinct colors except 0 and blue (blue=1).\n2. Copy blue pixels unchanged.\n3. For each remaining cluster:\n   - Extract its pixels and bounding box.\n   - Copy its pixels unchanged to output at the original position.\n   - Determine the cluster's \"main quadrant\" based on centroid.\n   - Define a mapping from each cluster quadrant to a specific **target quadrant** to copy the cluster to.\n   - Calculate translation needed to place cluster into the target quadrant at approximately the same relative position inside that quadrant.\n   - Write the duplicated cluster pixels to the target location, ensuring no overlap with original cluster.\n4. This tile-based quadrant movement better matches examples visually.\n5. The quadrant partition is: 11x11 grid \u2192 quadrants split at 6th row and col (index 5, since 0-based):\n   - Rows 0-5 and cols 0-5: top-left (TL)\n   - Rows 0-5 and cols 6-10: top-right (TR)\n   - Rows 6-10 and cols 0-5: bottom-left (BL)\n   - Rows 6-10 and cols 6-10: bottom-right (BR)\n6. Use fixed quadrant-to-quadrant mappings:\n   - TL \u2192 TR\n   - TR \u2192 BL\n   - BL \u2192 BR\n   - BR \u2192 TL\n\n---\n\n### Let's implement this carefully:\n\n```python\ndef transform(grid):\n    import numpy as np\n\n    arr = np.array(grid)\n    target_size = 11\n\n    # Normalize input size\n    norm = np.zeros((target_size, target_size), dtype=int)\n    rows, cols = arr.shape\n    norm[:min(rows, target_size), :min(cols, target_size)] = arr[:target_size, :target_size]\n    arr = norm\n\n    output = np.zeros_like(arr)\n\n    blue_color = 1\n\n    # Copy blue pixels unchanged\n    blue_mask = (arr == blue_color)\n    output[blue_mask] = blue_color\n\n    # Identify colors excluding 0 and blue\n    colors = set(np.unique(arr))\n    colors.discard(0)\n    if blue_color in colors:\n        colors.discard(blue_color)\n\n    # Define quadrant boundaries ((row_start, row_end), (col_start, col_end))\n    # Split at row=6, col=6 (0-based indices)\n    def get_quadrant(r, c):\n        if r < 6 and c < 6:\n            return 'TL'\n        elif r < 6 and c >= 6:\n            return 'TR'\n        elif r >= 6 and c < 6:\n            return 'BL'\n        else:\n            return 'BR'\n\n    quadrant_to_pos = {\n        'TL': (0, 0),\n        'TR': (0, 6),\n        'BL': (6, 0),\n        'BR': (6, 6)\n    }\n\n    # Define quadrant copies mapping\n    quadrant_copy_map = {\n        'TL': 'TR',\n        'TR': 'BL',\n        'BL': 'BR',\n        'BR': 'TL'\n    }\n\n    for color in colors:\n        mask = (arr == color)\n        if not np.any(mask):\n            continue\n        rows_c, cols_c = np.where(mask)\n        min_r, max_r = rows_c.min(), rows_c.max()\n        min_c, max_c = cols_c.min(), cols_c.max()\n\n        # Copy original cluster pixels unchanged\n        for (r, c) in zip(rows_c, cols_c):\n            output[r, c] = color\n\n        # Calculate cluster centroid to find quadrant\n        mean_r = int(np.round(np.mean(rows_c)))\n        mean_c = int(np.round(np.mean(cols_c)))\n        orig_quad = get_quadrant(mean_r, mean_c)\n        target_quad = quadrant_copy_map[orig_quad]\n\n        # Get top-left corner of orig and target quadrants\n        orig_r0, orig_c0 = quadrant_to_pos[orig_quad]\n        targ_r0, targ_c0 = quadrant_to_pos[target_quad]\n\n        # Compute cluster offset relative to orig quadrant\n        offset_r = min_r - orig_r0\n        offset_c = min_c - orig_c0\n\n        # Compute target cluster top-left position in target quadrant\n        new_min_r = targ_r0 + offset_r\n        new_min_c = targ_c0 + offset_c\n\n        # Ensure cluster fits into output bounds\n        cluster_height = max_r - min_r + 1\n        cluster_width = max_c - min_c + 1\n\n        # Adjust new_min_r, new_min_c to stay within quadrant limits (0-5 for cols/rows)\n        max_row = targ_r0 + 5\n        max_col = targ_c0 + 5\n\n        if new_min_r < targ_r0:\n            new_min_r = targ_r0\n        if new_min_c < targ_c0:\n            new_min_c = targ_c0\n\n        if new_min_r + cluster_height -1 > max_row:\n            new_min_r = max_row - cluster_height +1\n        if new_min_c + cluster_width -1 > max_col:\n            new_min_c = max_col - cluster_width +1\n\n        # Write duplicated cluster pixels into output at computed positions\n        for r, c in zip(rows_c, cols_c):\n            rr = r - min_r + new_min_r\n            cc = c - min_c + new_min_c\n            if 0 <= rr < target_size and 0 <= cc < target_size:\n                # Avoid overwriting blue pixels, but overwrite others\n                if output[rr, cc] != blue_color:\n                    output[rr, cc] = color\n\n    return output.tolist()\n```\n\n---\n\nThis code:\n\n- Preserves blue cluster exactly.\n- For each non-blue cluster, duplicates it exactly with shape preserved \u2014 no flip, no resize.\n- Positions duplicate in a fixed different quadrant depending on original quadrant.\n- Keeps duplicate well inside quadrant bounds.\n- Avoids overwriting blue pixels.\n- Keeps output grid size 11\u00d711 exactly.\n\n---\n\nThis solution should solve or closely approximate all training examples, correctly handling spatial cluster replication and quadrant repositioning, without resizing or flipping.\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n\n    arr = np.array(grid)\n    target_size = 11\n\n    # Normalize input size\n    norm = np.zeros((target_size, target_size), dtype=int)\n    rows, cols = arr.shape\n    norm[:min(rows, target_size), :min(cols, target_size)] = arr[:target_size, :target_size]\n    arr = norm\n\n    output = np.zeros_like(arr)\n\n    blue_color = 1\n\n    # Copy blue pixels unchanged\n    blue_mask = (arr == blue_color)\n    output[blue_mask] = blue_color\n\n    # Identify colors excluding 0 and blue\n    colors = set(np.unique(arr))\n    colors.discard(0)\n    if blue_color in colors:\n        colors.discard(blue_color)\n\n    # Define quadrant boundaries ((row_start, row_end), (col_start, col_end))\n    # Split at row=6, col=6 (0-based indices)\n    def get_quadrant(r, c):\n        if r < 6 and c < 6:\n            return 'TL'\n        elif r < 6 and c >= 6:\n            return 'TR'\n        elif r >= 6 and c < 6:\n            return 'BL'\n        else:\n            return 'BR'\n\n    quadrant_to_pos = {\n        'TL': (0, 0),\n        'TR': (0, 6),\n        'BL': (6, 0),\n        'BR': (6, 6)\n    }\n\n    # Define quadrant copies mapping\n    quadrant_copy_map = {\n        'TL': 'TR',\n        'TR': 'BL',\n        'BL': 'BR',\n        'BR': 'TL'\n    }\n\n    for color in colors:\n        mask = (arr == color)\n        if not np.any(mask):\n            continue\n        rows_c, cols_c = np.where(mask)\n        min_r, max_r = rows_c.min(), rows_c.max()\n        min_c, max_c = cols_c.min(), cols_c.max()\n\n        # Copy original cluster pixels unchanged\n        for (r, c) in zip(rows_c, cols_c):\n            output[r, c] = color\n\n        # Calculate cluster centroid to find quadrant\n        mean_r = int(np.round(np.mean(rows_c)))\n        mean_c = int(np.round(np.mean(cols_c)))\n        orig_quad = get_quadrant(mean_r, mean_c)\n        target_quad = quadrant_copy_map[orig_quad]\n\n        # Get top-left corner of orig and target quadrants\n        orig_r0, orig_c0 = quadrant_to_pos[orig_quad]\n        targ_r0, targ_c0 = quadrant_to_pos[target_quad]\n\n        # Compute cluster offset relative to orig quadrant\n        offset_r = min_r - orig_r0\n        offset_c = min_c - orig_c0\n\n        # Compute target cluster top-left position in target quadrant\n        new_min_r = targ_r0 + offset_r\n        new_min_c = targ_c0 + offset_c\n\n        # Ensure cluster fits into output bounds\n        cluster_height = max_r - min_r + 1\n        cluster_width = max_c - min_c + 1\n\n        max_row = targ_r0 + 5\n        max_col = targ_c0 + 5\n\n        if new_min_r < targ_r0:\n            new_min_r = targ_r0\n        if new_min_c < targ_c0:\n            new_min_c = targ_c0\n\n        if new_min_r + cluster_height -1 > max_row:\n            new_min_r = max_row - cluster_height +1\n        if new_min_c + cluster_width -1 > max_col:\n            new_min_c = max_col - cluster_width +1\n\n        # Write duplicated cluster pixels into output at computed positions\n        for r, c in zip(rows_c, cols_c):\n            rr = r - min_r + new_min_r\n            cc = c - min_c + new_min_c\n            if 0 <= rr < target_size and 0 <= cc < target_size:\n                # Avoid overwriting blue pixels, but overwrite others\n                if output[rr, cc] != blue_color:\n                    output[rr, cc] = color\n\n    return output.tolist()\n```"
            ]
          }
        ]
      },
      {
        "id": "resp_686f8b0d8234819d999f3c40a639794306ed706914c182fd",
        "model": "gpt-4.1-mini-2025-04-14",
        "usage": {
          "input_tokens": 31566,
          "output_tokens": 1932,
          "total_tokens": 33498
        },
        "output": [
          {
            "type": "message",
            "content": [
              "The main insight is that the output copies the blue shapes identically, and duplicates each other color cluster exactly\u2014but places the duplicate in a different quadrant without resizing or flipping, maintaining the original shape.\n\nAlso, duplicates do not overlap originals and are placed roughly in the corresponding relative position in the target quadrant.\n\n---\n\n### Key improvements to fix:\n\n- Use quadrant boundaries exactly as per 11x11 indexing (0\u201310).\n- Place duplicates inside the target quadrant **with careful bounds** (max indices inclusive).\n- Fix padding and clamp offsets to ensure entire duplicated cluster fits inside target quadrant.\n- Avoid overwriting blue pixels during duplication.\n- Make sure output size is always 11x11.\n\n---\n\nHere's an improved and clarified implementation reflecting these ideas:\n\n```python\ndef transform(grid):\n    import numpy as np\n\n    arr = np.array(grid)\n    target_size = 11\n\n    # Normalize input size to 11\u00d711\n    norm = np.zeros((target_size, target_size), dtype=int)\n    rows, cols = arr.shape\n    norm[:min(rows, target_size), :min(cols, target_size)] = arr[:target_size, :target_size]\n    arr = norm\n\n    output = np.zeros_like(arr)\n\n    blue_color = 1\n\n    output[arr == blue_color] = blue_color  # Copy blue pixels directly\n\n    # Identify non-blue, non-zero colors\n    colors = set(np.unique(arr))\n    colors.discard(0)\n    colors.discard(blue_color)\n\n    # Quadrants defined by split at row=6, col=6 (indexes 0..10)\n    quadrant_limits = {\n        'TL': (0, 5, 0, 5),\n        'TR': (0, 5, 6, 10),\n        'BL': (6, 10, 0, 5),\n        'BR': (6, 10, 6, 10)\n    }\n\n    quadrant_copy_map = {\n        'TL': 'TR',\n        'TR': 'BL',\n        'BL': 'BR',\n        'BR': 'TL'\n    }\n\n    def get_quadrant(r, c):\n        if r <= 5 and c <= 5:\n            return 'TL'\n        elif r <= 5 and c >= 6:\n            return 'TR'\n        elif r >= 6 and c <= 5:\n            return 'BL'\n        else:\n            return 'BR'\n\n    for color in colors:\n        mask = (arr == color)\n        if not np.any(mask):\n            continue\n\n        rows_c, cols_c = np.where(mask)\n        min_r, max_r = rows_c.min(), rows_c.max()\n        min_c, max_c = cols_c.min(), cols_c.max()\n\n        # Copy original cluster pixels unchanged\n        output[rows_c, cols_c] = color\n\n        # Calculate center to determine original quadrant\n        mean_r = int(round(np.mean(rows_c)))\n        mean_c = int(round(np.mean(cols_c)))\n        orig_quad = get_quadrant(mean_r, mean_c)\n        target_quad = quadrant_copy_map[orig_quad]\n\n        r_start, r_end, c_start, c_end = quadrant_limits[target_quad]\n        quad_row_span = r_end - r_start + 1\n        quad_col_span = c_end - c_start + 1\n\n        cluster_height = max_r - min_r + 1\n        cluster_width = max_c - min_c + 1\n\n        # Relative offset inside original quadrant\n        orig_r_start, orig_r_end, orig_c_start, orig_c_end = quadrant_limits[orig_quad]\n\n        offset_r = min_r - orig_r_start\n        offset_c = min_c - orig_c_start\n\n        # Compute tentative new top-left in target quadrant\n        new_min_r = r_start + offset_r\n        new_min_c = c_start + offset_c\n\n        # Clamp to fit cluster inside target quadrant\n        if new_min_r < r_start:\n            new_min_r = r_start\n        if new_min_c < c_start:\n            new_min_c = c_start\n\n        if new_min_r + cluster_height - 1 > r_end:\n            new_min_r = r_end - cluster_height + 1\n        if new_min_c + cluster_width - 1 > c_end:\n            new_min_c = c_end - cluster_width + 1\n\n        # Copy the cluster pixels to the duplicate position without overwriting blue pixels\n        for r_, c_ in zip(rows_c, cols_c):\n            rr = new_min_r + (r_ - min_r)\n            cc = new_min_c + (c_ - min_c)\n            if 0 <= rr < target_size and 0 <= cc < target_size:\n                if output[rr, cc] != blue_color:\n                    output[rr, cc] = color\n\n    return output.tolist()\n```\n\n---\n\nThis should:\n\n- Preserve blue cluster exactly.\n- Duplicate precisely each non-blue cluster in the appropriate target quadrant.\n- Keep cluster shape intact.\n- Fit duplicates fully inside the target quadrant.\n- Avoid overlapping or overriding blue pixels.\n- Always produce a 11\u00d711 grid output.\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n\n    arr = np.array(grid)\n    target_size = 11\n\n    # Normalize input size to 11\u00d711\n    norm = np.zeros((target_size, target_size), dtype=int)\n    rows, cols = arr.shape\n    norm[:min(rows, target_size), :min(cols, target_size)] = arr[:target_size, :target_size]\n    arr = norm\n\n    output = np.zeros_like(arr)\n\n    blue_color = 1\n\n    output[arr == blue_color] = blue_color  # Copy blue pixels directly\n\n    # Identify non-blue, non-zero colors\n    colors = set(np.unique(arr))\n    colors.discard(0)\n    colors.discard(blue_color)\n\n    # Quadrants defined by split at row=6, col=6 (indexes 0..10)\n    quadrant_limits = {\n        'TL': (0, 5, 0, 5),\n        'TR': (0, 5, 6, 10),\n        'BL': (6, 10, 0, 5),\n        'BR': (6, 10, 6, 10)\n    }\n\n    quadrant_copy_map = {\n        'TL': 'TR',\n        'TR': 'BL',\n        'BL': 'BR',\n        'BR': 'TL'\n    }\n\n    def get_quadrant(r, c):\n        if r <= 5 and c <= 5:\n            return 'TL'\n        elif r <= 5 and c >= 6:\n            return 'TR'\n        elif r >= 6 and c <= 5:\n            return 'BL'\n        else:\n            return 'BR'\n\n    for color in colors:\n        mask = (arr == color)\n        if not np.any(mask):\n            continue\n\n        rows_c, cols_c = np.where(mask)\n        min_r, max_r = rows_c.min(), rows_c.max()\n        min_c, max_c = cols_c.min(), cols_c.max()\n\n        # Copy original cluster pixels unchanged\n        output[rows_c, cols_c] = color\n\n        # Calculate center to determine original quadrant\n        mean_r = int(round(np.mean(rows_c)))\n        mean_c = int(round(np.mean(cols_c)))\n        orig_quad = get_quadrant(mean_r, mean_c)\n        target_quad = quadrant_copy_map[orig_quad]\n\n        r_start, r_end, c_start, c_end = quadrant_limits[target_quad]\n        quad_row_span = r_end - r_start + 1\n        quad_col_span = c_end - c_start + 1\n\n        cluster_height = max_r - min_r + 1\n        cluster_width = max_c - min_c + 1\n\n        # Relative offset inside original quadrant\n        orig_r_start, orig_r_end, orig_c_start, orig_c_end = quadrant_limits[orig_quad]\n\n        offset_r = min_r - orig_r_start\n        offset_c = min_c - orig_c_start\n\n        # Compute tentative new top-left in target quadrant\n        new_min_r = r_start + offset_r\n        new_min_c = c_start + offset_c\n\n        # Clamp to fit cluster inside target quadrant\n        if new_min_r < r_start:\n            new_min_r = r_start\n        if new_min_c < c_start:\n            new_min_c = c_start\n\n        if new_min_r + cluster_height - 1 > r_end:\n            new_min_r = r_end - cluster_height + 1\n        if new_min_c + cluster_width - 1 > c_end:\n            new_min_c = c_end - cluster_width + 1\n\n        # Copy the cluster pixels to the duplicate position without overwriting blue pixels\n        for r_, c_ in zip(rows_c, cols_c):\n            rr = new_min_r + (r_ - min_r)\n            cc = new_min_c + (c_ - min_c)\n            if 0 <= rr < target_size and 0 <= cc < target_size:\n                if output[rr, cc] != blue_color:\n                    output[rr, cc] = color\n\n    return output.tolist()\n```"
            ]
          }
        ]
      },
      {
        "id": "resp_686f8b2608f8819d93ca19d4fc265f9806ed706914c182fd",
        "model": "gpt-4.1-mini-2025-04-14",
        "usage": {
          "input_tokens": 38295,
          "output_tokens": 1859,
          "total_tokens": 40154
        },
        "output": [
          {
            "type": "message",
            "content": [
              "The main challenge remains reproducing the secondary colored clusters in a shifted quadrant correctly, preserving their shape and relative arrangement, while leaving the blue cluster intact.\n\nThe previous approach mostly got the duplication and placement logic correct but suffered from scatter/partial placement (some pixels moved incorrectly or missed), and possibly some quadrant offset or cluster bounding box handling errors that caused inaccuracies.\n\n---\n\n**Improvement plan:**\n\n- Carefully extract each cluster using its exact bounding box and positions (not just centroid).\n- Duplicate *all* cluster pixels exactly to the target quadrant using *offset relative to quadrant origin*, preserving shape perfectly.\n- Make sure the duplicated cluster fits entirely inside the target quadrant and adjust placement if needed.\n- Keep blue cluster unchanged.\n- Avoid overwriting blue pixels in output.\n- Ensure output size is exactly 11x11.\n\n---\n\nHere's the refined implementation:\n\n```python\ndef transform(grid):\n    import numpy as np\n\n    arr = np.array(grid)\n    target_size = 11\n\n    # Normalize grid size\n    norm = np.zeros((target_size, target_size), dtype=int)\n    norm[:arr.shape[0], :arr.shape[1]] = arr[:target_size, :target_size]\n    arr = norm\n\n    output = np.zeros_like(arr)\n    blue_color = 1\n\n    # Copy blue pixels unchanged\n    output[arr == blue_color] = blue_color\n\n    # Get unique colors other than 0 and blue\n    colors = set(np.unique(arr))\n    colors.discard(0)\n    colors.discard(blue_color)\n\n    # Define quadrants limits (inclusive ranges)\n    # Rows and cols split at 6 (0-based indexing: 0 to 10, split at index 6)\n    quadrants = {\n        'TL': (0, 5, 0, 5),\n        'TR': (0, 5, 6, 10),\n        'BL': (6, 10, 0, 5),\n        'BR': (6, 10, 6, 10)\n    }\n\n    # Map each original quadrant to target quadrant\n    quadrant_map = {\n        'TL': 'TR',\n        'TR': 'BL',\n        'BL': 'BR',\n        'BR': 'TL'\n    }\n\n    def get_quadrant(r, c):\n        for q_name, (r_start, r_end, c_start, c_end) in quadrants.items():\n            if r_start <= r <= r_end and c_start <= c <= c_end:\n                return q_name\n        return None  # Should never happen here\n\n    for color in colors:\n        positions = np.argwhere(arr == color)\n        if positions.size == 0:\n            continue\n\n        min_r, min_c = positions.min(axis=0)\n        max_r, max_c = positions.max(axis=0)\n\n        # Copy original cluster pixels\n        for r, c in positions:\n            output[r, c] = color\n\n        # Compute centroid of cluster pixels to find original quadrant\n        centroid_r = int(round(positions[:, 0].mean()))\n        centroid_c = int(round(positions[:, 1].mean()))\n        orig_quad = get_quadrant(centroid_r, centroid_c)\n        target_quad = quadrant_map[orig_quad]\n\n        # Quadrant bounds\n        r_start, r_end, c_start, c_end = quadrants[target_quad]\n\n        cluster_height = max_r - min_r + 1\n        cluster_width = max_c - min_c + 1\n\n        # Compute offset within original quadrant top-left corner\n        orig_r_start, orig_r_end, orig_c_start, orig_c_end = quadrants[orig_quad]\n        offset_r = min_r - orig_r_start\n        offset_c = min_c - orig_c_start\n\n        # Calculate tentative top-left target position\n        new_min_r = r_start + offset_r\n        new_min_c = c_start + offset_c\n\n        # Clamp to fit cluster fully inside target quadrant\n        if new_min_r < r_start:\n            new_min_r = r_start\n        if new_min_c < c_start:\n            new_min_c = c_start\n        if new_min_r + cluster_height - 1 > r_end:\n            new_min_r = r_end - cluster_height + 1\n        if new_min_c + cluster_width - 1 > c_end:\n            new_min_c = c_end - cluster_width + 1\n\n        # Place duplicated cluster pixels preserving shape & relative pos\n        for r, c in positions:\n            rr = new_min_r + (r - min_r)\n            cc = new_min_c + (c - min_c)\n            if 0 <= rr < target_size and 0 <= cc < target_size:\n                # Don't overwrite blue pixels\n                if output[rr, cc] != blue_color:\n                    output[rr, cc] = color\n\n    return output.tolist()\n```\n\n---\n\nThis solution strictly:\n\n- Preserves blue pixels identically.\n- Duplicates all non-blue clusters exactly, preserving shape and relative arrangement.\n- Places duplicates in mapped quadrant, preserving relative offset w.r.t. quadrant origin.\n- Clamps duplicate to fit inside quadrant.\n- Avoids overwriting blue pixels.\n- Outputs 11\u00d711 grid.\n\nThis should improve pixel-level agreement and solve more training cases correctly, better matching the clusters' spatial arrangement in outputs.\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n\n    arr = np.array(grid)\n    target_size = 11\n\n    # Normalize grid size\n    norm = np.zeros((target_size, target_size), dtype=int)\n    norm[:arr.shape[0], :arr.shape[1]] = arr[:target_size, :target_size]\n    arr = norm\n\n    output = np.zeros_like(arr)\n    blue_color = 1\n\n    # Copy blue pixels unchanged\n    output[arr == blue_color] = blue_color\n\n    # Get unique colors other than 0 and blue\n    colors = set(np.unique(arr))\n    colors.discard(0)\n    colors.discard(blue_color)\n\n    # Define quadrants limits (inclusive ranges)\n    quadrants = {\n        'TL': (0, 5, 0, 5),\n        'TR': (0, 5, 6, 10),\n        'BL': (6, 10, 0, 5),\n        'BR': (6, 10, 6, 10)\n    }\n\n    # Map each original quadrant to target quadrant\n    quadrant_map = {\n        'TL': 'TR',\n        'TR': 'BL',\n        'BL': 'BR',\n        'BR': 'TL'\n    }\n\n    def get_quadrant(r, c):\n        for q_name, (r_start, r_end, c_start, c_end) in quadrants.items():\n            if r_start <= r <= r_end and c_start <= c <= c_end:\n                return q_name\n        return None\n\n    for color in colors:\n        positions = np.argwhere(arr == color)\n        if positions.size == 0:\n            continue\n\n        min_r, min_c = positions.min(axis=0)\n        max_r, max_c = positions.max(axis=0)\n\n        # Copy original cluster pixels\n        for r, c in positions:\n            output[r, c] = color\n\n        centroid_r = int(round(positions[:, 0].mean()))\n        centroid_c = int(round(positions[:, 1].mean()))\n        orig_quad = get_quadrant(centroid_r, centroid_c)\n        target_quad = quadrant_map[orig_quad]\n\n        r_start, r_end, c_start, c_end = quadrants[target_quad]\n\n        cluster_height = max_r - min_r + 1\n        cluster_width = max_c - min_c + 1\n\n        orig_r_start, orig_r_end, orig_c_start, orig_c_end = quadrants[orig_quad]\n        offset_r = min_r - orig_r_start\n        offset_c = min_c - orig_c_start\n\n        new_min_r = r_start + offset_r\n        new_min_c = c_start + offset_c\n\n        if new_min_r < r_start:\n            new_min_r = r_start\n        if new_min_c < c_start:\n            new_min_c = c_start\n        if new_min_r + cluster_height - 1 > r_end:\n            new_min_r = r_end - cluster_height + 1\n        if new_min_c + cluster_width - 1 > c_end:\n            new_min_c = c_end - cluster_width + 1\n\n        for r, c in positions:\n            rr = new_min_r + (r - min_r)\n            cc = new_min_c + (c - min_c)\n            if 0 <= rr < target_size and 0 <= cc < target_size:\n                if output[rr, cc] != blue_color:\n                    output[rr, cc] = color\n\n    return output.tolist()\n```"
            ]
          }
        ]
      },
      {
        "id": "resp_686f8b3e8d1c819d8e60ffd4e84e763a06ed706914c182fd",
        "model": "gpt-4.1-mini-2025-04-14",
        "usage": {
          "input_tokens": 44951,
          "output_tokens": 1900,
          "total_tokens": 46851
        },
        "output": [
          {
            "type": "message",
            "content": [
              "After carefully reviewing the examples and previous attempts, the key insights remain:\n\n- The **blue shape (color 1) stays unchanged**.\n- Each **non-blue cluster** is copied **exactly and fully** in the output both at its original position and an **additional position in a different quadrant**, preserving shape and relative position inside quadrants.\n- The quadrants are defined by splitting the 11\u00d711 grid at row 6 and column 6 (indices 0\u20135 and 6\u201310).\n- The cluster gets duplicated into a **mapped opposite quadrant**, keeping its shape intact, and positioned with the same offset from the quadrant top-left corner (clamped to fit quadrant).\n- Blue pixels are never overwritten in output duplication.\n\n---\n\n### What needs fixing from last attempt:\n\n- The output size must always be exactly 11\u00d711 (was correct).\n- Ensure careful clamping of duplicated cluster position to not go outside quadrant.\n- Avoid overwriting blue or previously written pixels only when duplicating (already done).\n- Place duplicate cluster with exact relative offset from target quadrant's top-left corner.\n- Fully copy all cluster pixels.\n\nThis approach will give best fit with training data.\n\n---\n\n### Final improved code:\n\n```python\ndef transform(grid):\n    import numpy as np\n\n    arr = np.array(grid)\n    target_size = 11\n\n    # Normalize input to 11x11\n    norm = np.zeros((target_size, target_size), dtype=int)\n    norm[:arr.shape[0], :arr.shape[1]] = arr[:target_size, :target_size]\n    arr = norm\n\n    output = np.zeros_like(arr)\n    blue_color = 1\n\n    # Copy blue pixels as is\n    output[arr == blue_color] = blue_color\n\n    # Colors excluding 0 and blue\n    colors = set(np.unique(arr))\n    colors.discard(0)\n    colors.discard(blue_color)\n\n    # Quadrant boundaries inclusive: (row_start, row_end, col_start, col_end)\n    quadrants = {\n        'TL': (0, 5, 0, 5),\n        'TR': (0, 5, 6, 10),\n        'BL': (6, 10, 0, 5),\n        'BR': (6, 10, 6, 10)\n    }\n\n    # Map quadrant to duplication target quadrant\n    quadrant_map = {\n        'TL': 'TR',\n        'TR': 'BL',\n        'BL': 'BR',\n        'BR': 'TL'\n    }\n\n    def get_quadrant(r, c):\n        for q_name, (rs, re, cs, ce) in quadrants.items():\n            if rs <= r <= re and cs <= c <= ce:\n                return q_name\n        return None\n\n    for color in colors:\n        positions = np.argwhere(arr == color)\n        if positions.size == 0:\n            continue\n\n        min_r, min_c = positions.min(axis=0)\n        max_r, max_c = positions.max(axis=0)\n\n        # Copy cluster pixels to output at original positions\n        for r, c in positions:\n            output[r, c] = color\n\n        # Compute cluster centroid for quadrant\n        centroid_r = int(round(positions[:, 0].mean()))\n        centroid_c = int(round(positions[:, 1].mean()))\n        orig_quad = get_quadrant(centroid_r, centroid_c)\n        target_quad = quadrant_map[orig_quad]\n\n        r_start, r_end, c_start, c_end = quadrants[target_quad]\n\n        cluster_height = max_r - min_r + 1\n        cluster_width = max_c - min_c + 1\n\n        orig_r_start, orig_r_end, orig_c_start, orig_c_end = quadrants[orig_quad]\n\n        offset_r = min_r - orig_r_start\n        offset_c = min_c - orig_c_start\n\n        # New top-left for duplicate cluster in target quadrant (with clamping)\n        new_min_r = r_start + offset_r\n        new_min_c = c_start + offset_c\n\n        if new_min_r < r_start:\n            new_min_r = r_start\n        if new_min_c < c_start:\n            new_min_c = c_start\n        if new_min_r + cluster_height - 1 > r_end:\n            new_min_r = r_end - cluster_height + 1\n        if new_min_c + cluster_width - 1 > c_end:\n            new_min_c = c_end - cluster_width + 1\n\n        # Duplicate pixels copied exactly at new location (no overwrite blue)\n        for r, c in positions:\n            rr = new_min_r + (r - min_r)\n            cc = new_min_c + (c - min_c)\n            if 0 <= rr < target_size and 0 <= cc < target_size:\n                if output[rr, cc] != blue_color:\n                    output[rr, cc] = color\n\n    return output.tolist()\n```\n\n---\n\nThis solution:\n\n- Keeps blue unchanged.\n- Copies every other cluster fully and duplicates it in the opposite quadrant precisely shifted by offset.\n- Clamps cluster duplicates to quadrant bounds.\n- Avoids overwriting blue pixels.\n- Output size always 11\u00d711.\n\nThis should maximize correctness on training sets and generalize well to test inputs.\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n\n    arr = np.array(grid)\n    target_size = 11\n\n    # Normalize input to 11x11\n    norm = np.zeros((target_size, target_size), dtype=int)\n    norm[:arr.shape[0], :arr.shape[1]] = arr[:target_size, :target_size]\n    arr = norm\n\n    output = np.zeros_like(arr)\n    blue_color = 1\n\n    # Copy blue pixels as is\n    output[arr == blue_color] = blue_color\n\n    # Colors excluding 0 and blue\n    colors = set(np.unique(arr))\n    colors.discard(0)\n    colors.discard(blue_color)\n\n    # Quadrant boundaries inclusive: (row_start, row_end, col_start, col_end)\n    quadrants = {\n        'TL': (0, 5, 0, 5),\n        'TR': (0, 5, 6, 10),\n        'BL': (6, 10, 0, 5),\n        'BR': (6, 10, 6, 10)\n    }\n\n    # Map quadrant to duplication target quadrant\n    quadrant_map = {\n        'TL': 'TR',\n        'TR': 'BL',\n        'BL': 'BR',\n        'BR': 'TL'\n    }\n\n    def get_quadrant(r, c):\n        for q_name, (rs, re, cs, ce) in quadrants.items():\n            if rs <= r <= re and cs <= c <= ce:\n                return q_name\n        return None\n\n    for color in colors:\n        positions = np.argwhere(arr == color)\n        if positions.size == 0:\n            continue\n\n        min_r, min_c = positions.min(axis=0)\n        max_r, max_c = positions.max(axis=0)\n\n        # Copy cluster pixels to output at original positions\n        for r, c in positions:\n            output[r, c] = color\n\n        # Compute cluster centroid for quadrant\n        centroid_r = int(round(positions[:, 0].mean()))\n        centroid_c = int(round(positions[:, 1].mean()))\n        orig_quad = get_quadrant(centroid_r, centroid_c)\n        target_quad = quadrant_map[orig_quad]\n\n        r_start, r_end, c_start, c_end = quadrants[target_quad]\n\n        cluster_height = max_r - min_r + 1\n        cluster_width = max_c - min_c + 1\n\n        orig_r_start, orig_r_end, orig_c_start, orig_c_end = quadrants[orig_quad]\n\n        offset_r = min_r - orig_r_start\n        offset_c = min_c - orig_c_start\n\n        # New top-left for duplicate cluster in target quadrant (with clamping)\n        new_min_r = r_start + offset_r\n        new_min_c = c_start + offset_c\n\n        if new_min_r < r_start:\n            new_min_r = r_start\n        if new_min_c < c_start:\n            new_min_c = c_start\n        if new_min_r + cluster_height - 1 > r_end:\n            new_min_r = r_end - cluster_height + 1\n        if new_min_c + cluster_width - 1 > c_end:\n            new_min_c = c_end - cluster_width + 1\n\n        # Duplicate pixels copied exactly at new location (no overwrite blue)\n        for r, c in positions:\n            rr = new_min_r + (r - min_r)\n            cc = new_min_c + (c - min_c)\n            if 0 <= rr < target_size and 0 <= cc < target_size:\n                if output[rr, cc] != blue_color:\n                    output[rr, cc] = color\n\n    return output.tolist()\n```"
            ]
          }
        ]
      },
      {
        "id": "resp_686f8b585ebc819dba7e371b4dd1af1506ed706914c182fd",
        "model": "gpt-4.1-mini-2025-04-14",
        "usage": {
          "input_tokens": 51648,
          "output_tokens": 1779,
          "total_tokens": 53427
        },
        "output": [
          {
            "type": "message",
            "content": [
              "The core approach has been stable and correct in essence:\n\n- Keep blue cluster fixed.\n- Duplicate every other color cluster exactly.\n- Place duplicated cluster in a fixed opposite quadrant, preserving relative cluster shape and internal offsets.\n- Output fixed 11\u00d711 grid.\n\nThe main limitation is pixel accuracy\u2014not perfect\u2014likely due to slight offsets or cluster positioning near boundaries.\n\n---\n\n**Further refinements:**\n\n1. Use **connected component labeling** to isolate clusters precisely, avoid mixing different clusters of same color.\n2. Move entire connected cluster as a unit, rather than all pixels of a color (better if multiple clusters per color).\n3. Attempt to place duplicates with minimal shifting when quadrant boundary constraints force clamping.\n4. Avoid placing duplicates overlapping original clusters.\n5. Preserve original blue cluster exactly.\n\n---\n\n### Here is an improved solution incorporating connected component analysis for more precise cluster separation:\n\n```python\ndef transform(grid):\n    import numpy as np\n    from scipy.ndimage import label\n\n    arr = np.array(grid)\n    target_size = 11\n\n    norm = np.zeros((target_size, target_size), dtype=int)\n    norm[:arr.shape[0], :arr.shape[1]] = arr[:target_size, :target_size]\n    arr = norm\n\n    output = np.zeros_like(arr)\n    blue_color = 1\n    output[arr == blue_color] = blue_color\n\n    # Define quadrants (inclusive)\n    quadrants = {\n        'TL': (0, 5, 0, 5),\n        'TR': (0, 5, 6, 10),\n        'BL': (6, 10, 0, 5),\n        'BR': (6, 10, 6, 10)\n    }\n    quadrant_map = {'TL': 'TR', 'TR': 'BL', 'BL': 'BR', 'BR': 'TL'}\n\n    def get_quadrant(r, c):\n        for q, (rs, re, cs, ce) in quadrants.items():\n            if rs <= r <= re and cs <= c <= ce:\n                return q\n        return None\n\n    # Process each nonzero color except blue\n    colors = set(np.unique(arr))\n    colors.discard(0)\n    colors.discard(blue_color)\n\n    for color in colors:\n        mask = (arr == color)\n        if not np.any(mask):\n            continue\n\n        # Label connected components for this color\n        labeled, num_features = label(mask)\n        for comp_id in range(1, num_features + 1):\n            comp_mask = (labeled == comp_id)\n            rows, cols = np.where(comp_mask)\n\n            min_r, max_r = rows.min(), rows.max()\n            min_c, max_c = cols.min(), cols.max()\n\n            # Copy original cluster pixels exactly\n            output[rows, cols] = color\n\n            centroid_r = int(round(rows.mean()))\n            centroid_c = int(round(cols.mean()))\n            orig_quad = get_quadrant(centroid_r, centroid_c)\n            target_quad = quadrant_map[orig_quad]\n\n            r_start, r_end, c_start, c_end = quadrants[target_quad]\n\n            cluster_height = max_r - min_r + 1\n            cluster_width = max_c - min_c + 1\n\n            orig_r_start, orig_r_end, orig_c_start, orig_c_end = quadrants[orig_quad]\n            offset_r = min_r - orig_r_start\n            offset_c = min_c - orig_c_start\n\n            # Calculate tentative new top-left position for duplicate cluster\n            new_min_r = r_start + offset_r\n            new_min_c = c_start + offset_c\n\n            # Clamp to fit cluster inside target quadrant\n            if new_min_r < r_start:\n                new_min_r = r_start\n            if new_min_c < c_start:\n                new_min_c = c_start\n            if new_min_r + cluster_height - 1 > r_end:\n                new_min_r = r_end - cluster_height + 1\n            if new_min_c + cluster_width - 1 > c_end:\n                new_min_c = c_end - cluster_width + 1\n\n            # Create output mask for duplicate - write pixels without overwriting blue pixels\n            for r, c in zip(rows, cols):\n                rr = new_min_r + (r - min_r)\n                cc = new_min_c + (c - min_c)\n                if 0 <= rr < target_size and 0 <= cc < target_size:\n                    if output[rr, cc] != blue_color:\n                        output[rr, cc] = color\n\n    return output.tolist()\n```\n\n---\n\n**Summary of improvements:**\n\n- Used `scipy.ndimage.label` to separate connected clusters within the same color.\n- Each connected cluster moved and duplicated independently.\n- Keeps blue shape unchanged.\n- Duplicates each cluster preserving shape and relative position.\n- Duplicates copied to corresponding mapped quadrant, clamped to fit.\n- Avoids overwriting blue pixels.\n\n---\n\nThis approach should fix errors from merging multiple clusters of one color and better preserve positions.\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n    from scipy.ndimage import label\n\n    arr = np.array(grid)\n    target_size = 11\n\n    norm = np.zeros((target_size, target_size), dtype=int)\n    norm[:arr.shape[0], :arr.shape[1]] = arr[:target_size, :target_size]\n    arr = norm\n\n    output = np.zeros_like(arr)\n    blue_color = 1\n    output[arr == blue_color] = blue_color\n\n    quadrants = {\n        'TL': (0, 5, 0, 5),\n        'TR': (0, 5, 6, 10),\n        'BL': (6, 10, 0, 5),\n        'BR': (6, 10, 6, 10)\n    }\n    quadrant_map = {'TL': 'TR', 'TR': 'BL', 'BL': 'BR', 'BR': 'TL'}\n\n    def get_quadrant(r, c):\n        for q, (rs, re, cs, ce) in quadrants.items():\n            if rs <= r <= re and cs <= c <= ce:\n                return q\n        return None\n\n    colors = set(np.unique(arr))\n    colors.discard(0)\n    colors.discard(blue_color)\n\n    for color in colors:\n        mask = (arr == color)\n        if not np.any(mask):\n            continue\n\n        labeled, num_features = label(mask)\n        for comp_id in range(1, num_features + 1):\n            comp_mask = (labeled == comp_id)\n            rows, cols = np.where(comp_mask)\n            min_r, max_r = rows.min(), rows.max()\n            min_c, max_c = cols.min(), cols.max()\n\n            # Copy original pixels\n            output[rows, cols] = color\n\n            centroid_r = int(round(rows.mean()))\n            centroid_c = int(round(cols.mean()))\n            orig_quad = get_quadrant(centroid_r, centroid_c)\n            target_quad = quadrant_map[orig_quad]\n\n            r_start, r_end, c_start, c_end = quadrants[target_quad]\n            cluster_height = max_r - min_r + 1\n            cluster_width = max_c - min_c + 1\n\n            orig_r_start, orig_r_end, orig_c_start, orig_c_end = quadrants[orig_quad]\n            offset_r = min_r - orig_r_start\n            offset_c = min_c - orig_c_start\n\n            new_min_r = r_start + offset_r\n            new_min_c = c_start + offset_c\n\n            if new_min_r < r_start:\n                new_min_r = r_start\n            if new_min_c < c_start:\n                new_min_c = c_start\n            if new_min_r + cluster_height - 1 > r_end:\n                new_min_r = r_end - cluster_height + 1\n            if new_min_c + cluster_width - 1 > c_end:\n                new_min_c = c_end - cluster_width + 1\n\n            for r, c in zip(rows, cols):\n                rr = new_min_r + (r - min_r)\n                cc = new_min_c + (c - min_c)\n                if 0 <= rr < target_size and 0 <= cc < target_size:\n                    if output[rr, cc] != blue_color:\n                        output[rr, cc] = color\n\n    return output.tolist()\n```\n"
            ]
          }
        ]
      }
    ]
  }
}