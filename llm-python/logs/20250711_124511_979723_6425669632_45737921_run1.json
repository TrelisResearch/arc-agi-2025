{
  "task_id": "45737921",
  "model": "gpt-4.1-mini",
  "reasoning_effort": "N/A",
  "api_type": "responses_api_independent_attempts",
  "program": "def transform(grid):\n    from collections import deque\n    import copy\n\n    R = len(grid)\n    C = len(grid[0])\n\n    # Directions (4-neighbors)\n    directions = [(-1,0),(1,0),(0,-1),(0,1)]\n\n    visited = [[False]*C for _ in range(R)]\n    output = copy.deepcopy(grid)\n\n    def neighbors(r,c):\n        for dr,dc in directions:\n            nr,nc = r+dr, c+dc\n            if 0<=nr<R and 0<=nc<C:\n                yield nr,nc\n\n    # Find connected components (clusters) ignoring 0\n    for r in range(R):\n        for c in range(C):\n            if grid[r][c] != 0 and not visited[r][c]:\n                color = grid[r][c]\n                # BFS to find cluster\n                q = deque()\n                q.append((r,c))\n                cluster_cells = []\n                colors_in_cluster = set()\n                visited[r][c] = True\n\n                while q:\n                    rr,cc = q.popleft()\n                    cluster_cells.append((rr,cc))\n                    colors_in_cluster.add(grid[rr][cc])\n                    for nr,nc in neighbors(rr,cc):\n                        if not visited[nr][nc] and grid[nr][nc]!=0:\n                            visited[nr][nc] = True\n                            q.append((nr,nc))\n\n                # Proceed only if cluster has exactly 2 distinct colors\n                if len(colors_in_cluster) == 2:\n                    c1, c2 = list(colors_in_cluster)\n\n                    # Partition cluster cells by color\n                    part1 = [pos for pos in cluster_cells if grid[pos[0]][pos[1]] == c1]\n                    part2 = [pos for pos in cluster_cells if grid[pos[0]][pos[1]] == c2]\n\n                    # Heuristic check - parts usually similar size, if they differ too much, skip\n                    if abs(len(part1) - len(part2)) > len(cluster_cells)//2:\n                        # sizes differ too much, skip swapping\n                        continue\n\n                    # Swap colors in output grid\n                    for (rr,cc) in part1:\n                        output[rr][cc] = c2\n                    for (rr,cc) in part2:\n                        output[rr][cc] = c1\n\n                # else: cluster with 1 color or more than 2 colors - leave unchanged\n\n    return output",
  "execution_error": "",
  "timed_out": false,
  "tokens_used": 8123,
  "request_cost": 0.0057224,
  "turns_used": 2,
  "raw_response": {
    "id": "resp_6870f93ae8d081a29ec7a22e53d21b2e00f796bf49746e52",
    "model": "gpt-4.1-mini-2025-04-14",
    "usage": {
      "input_tokens": 3031,
      "output_tokens": 870,
      "total_tokens": 3901
    },
    "output": [
      {
        "type": "message",
        "content": [
          "Analysis:\n\n1. The grids contain several colored blocks/groups each composed of connected colored cells.\n2. The transformation swaps the colors of certain blocks within each cluster.\n3. Each example shows a specific pattern of swapping:\n   - Example 1: In three clusters of 4 colored cells, the colors in the two halves are swapped horizontally.\n   - Example 2: Similar swap of colors within a cluster.\n   - Example 3: Each cluster has two 2x2 blocks of different colors; the colors are swapped to the opposite block.\n   \nFrom the visuals and examples, the rule seems to be:\n\n**Within each distinct colored cluster of exactly two colors (in two adjacent sub-blocks), swap colors between the two sub-blocks that form the cluster.** \n\n- Usually, clusters are 2x2 or 3x2 cells.\n- The cluster splits into two equal halves of different colors.\n- The colors in these halves are swapped to produce the output.\n\nAdditional notes:\n\n- The grid size remains the same.\n- Background (color 0) remains unchanged.\n- Clusters with more than two colors or irregular shapes may be untouched.\n\nImplementation plan:\n\n- Identify clusters: find connected components ignoring 0.\n- For each cluster:\n  - Find distinct colors inside that cluster.\n  - If exactly two colors, find a way to split cluster into two halves by color.\n  - Swap the colors of these halves.\n- Assemble final output grid.\n\nI will use BFS for connected components. Assumptions based on examples:\n\n- Clusters have exactly two colors (non-zero).\n- Each half occupies contiguous positions in cluster.\n\nIf cluster has more colors or coloring pattern is complex, leave it unchanged.\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    from collections import deque\n    import copy\n\n    R = len(grid)\n    C = len(grid[0])\n\n    # Directions (4-neighbors)\n    directions = [(-1,0),(1,0),(0,-1),(0,1)]\n\n    visited = [[False]*C for _ in range(R)]\n    output = copy.deepcopy(grid)\n\n    def neighbors(r,c):\n        for dr,dc in directions:\n            nr,nc = r+dr, c+dc\n            if 0<=nr<R and 0<=nc<C:\n                yield nr,nc\n\n    # Find connected components (clusters) ignoring 0\n    for r in range(R):\n        for c in range(C):\n            if grid[r][c] != 0 and not visited[r][c]:\n                color = grid[r][c]\n                # BFS to find cluster\n                q = deque()\n                q.append((r,c))\n                cluster_cells = []\n                colors_in_cluster = set()\n                visited[r][c] = True\n\n                while q:\n                    rr,cc = q.popleft()\n                    cluster_cells.append((rr,cc))\n                    colors_in_cluster.add(grid[rr][cc])\n                    for nr,nc in neighbors(rr,cc):\n                        if not visited[nr][nc] and grid[nr][nc]!=0:\n                            visited[nr][nc] = True\n                            q.append((nr,nc))\n\n                # Proceed only if cluster has exactly 2 distinct colors\n                if len(colors_in_cluster) == 2:\n                    c1, c2 = list(colors_in_cluster)\n\n                    # Partition cluster cells by color\n                    part1 = [pos for pos in cluster_cells if grid[pos[0]][pos[1]] == c1]\n                    part2 = [pos for pos in cluster_cells if grid[pos[0]][pos[1]] == c2]\n\n                    # Heuristic check - parts usually similar size, if they differ too much, skip\n                    if abs(len(part1) - len(part2)) > len(cluster_cells)//2:\n                        # sizes differ too much, skip swapping\n                        continue\n\n                    # Swap colors in output grid\n                    for (rr,cc) in part1:\n                        output[rr][cc] = c2\n                    for (rr,cc) in part2:\n                        output[rr][cc] = c1\n\n                # else: cluster with 1 color or more than 2 colors - leave unchanged\n\n    return output\n```\n"
        ]
      }
    ]
  },
  "score": {
    "correct": true,
    "pixel_accuracy": 1.0,
    "total_pixels": 72,
    "correct_pixels": 72,
    "error": null,
    "predicted_output": [
      [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ],
      [
        0,
        2,
        3,
        3,
        0,
        0,
        0,
        0,
        0
      ],
      [
        0,
        2,
        2,
        3,
        0,
        0,
        0,
        0,
        0
      ],
      [
        0,
        2,
        3,
        3,
        0,
        0,
        0,
        0,
        0
      ],
      [
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        0
      ],
      [
        0,
        0,
        0,
        0,
        0,
        6,
        6,
        6,
        0
      ],
      [
        0,
        0,
        0,
        0,
        0,
        6,
        1,
        1,
        0
      ],
      [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ]
    ],
    "actual_output": [
      [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ],
      [
        0,
        2,
        3,
        3,
        0,
        0,
        0,
        0,
        0
      ],
      [
        0,
        2,
        2,
        3,
        0,
        0,
        0,
        0,
        0
      ],
      [
        0,
        2,
        3,
        3,
        0,
        0,
        0,
        0,
        0
      ],
      [
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        0
      ],
      [
        0,
        0,
        0,
        0,
        0,
        6,
        6,
        6,
        0
      ],
      [
        0,
        0,
        0,
        0,
        0,
        6,
        1,
        1,
        0
      ],
      [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ]
    ]
  },
  "predicted_output": [
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      2,
      3,
      3,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      2,
      2,
      3,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      2,
      3,
      3,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      6,
      6,
      6,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      6,
      1,
      1,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]
  ],
  "actual_output": [
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      2,
      3,
      3,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      2,
      2,
      3,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      2,
      3,
      3,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      6,
      6,
      6,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      6,
      1,
      1,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]
  ],
  "api_success": true,
  "independent_attempts_data": {
    "attempt_details": [
      {
        "attempt_number": 1,
        "timestamp": "2025-07-11T12:44:42.281839",
        "input_tokens": 3031,
        "output_tokens": 1191,
        "attempt_cost": 0.003118,
        "program_extracted": true,
        "program": "def transform(grid):\n    import numpy as np\n    rows_in = len(grid)\n    cols_in = len(grid[0]) if rows_in > 0 else 0\n    \n    # Target output size\n    ROWS, COLS = 13, 10\n    \n    # Convert grid to numpy array for easy indexing\n    arr = np.zeros((ROWS, COLS), dtype=int)\n    # Place input grid at top-left corner\n    arr[:rows_in, :cols_in] = np.array(grid)\n    \n    visited = np.zeros_like(arr, dtype=bool)\n    \n    def neighbors(r,c):\n        for nr,nc in [(r-1,c),(r+1,c),(r,c-1),(r,c+1)]:\n            if 0 <= nr < ROWS and 0 <= nc < COLS:\n                yield nr,nc\n    \n    from collections import deque\n    \n    def rotate_block_clockwise(block):\n        # block is 2D numpy array\n        # rotate colors clockwise inside block\n        # If shape is 1x1, no change\n        if block.shape[0] == 1 and block.shape[1] == 1:\n            return block.copy()\n        # For simplicity, rotate the array clockwise:\n        # But we want to rotate colors preserving shape by moving colors clockwise:\n        # We'll rotate the array by 90 degrees clockwise\n        # This matches the permutation seen in examples where colors relocate inside block\n        return np.rot90(block, k=-1)\n    \n    output = np.zeros((ROWS, COLS), dtype=int)\n    \n    # Find connected components of non-zero cells\n    for r in range(ROWS):\n        for c in range(COLS):\n            if arr[r,c] != 0 and not visited[r,c]:\n                color_val = arr[r,c]\n                q = deque()\n                q.append((r,c))\n                visited[r,c] = True\n                cells = []\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n                \n                while q:\n                    rr, cc = q.popleft()\n                    cells.append((rr,cc))\n                    if rr < min_r: min_r = rr\n                    if rr > max_r: max_r = rr\n                    if cc < min_c: min_c = cc\n                    if cc > max_c: max_c = cc\n                    for nr,nc in neighbors(rr,cc):\n                        if arr[nr,nc] != 0 and not visited[nr,nc]:\n                            visited[nr,nc] = True\n                            q.append((nr,nc))\n                \n                height = max_r - min_r + 1\n                width = max_c - min_c + 1\n                \n                # Extract sub-block\n                sub_block = arr[min_r:max_r+1,min_c:max_c+1].copy()\n                \n                # Apply rotation only if block height & width > 1\n                # If 1x1, no change\n                if height > 1 or width > 1:\n                    rotated_block = rotate_block_clockwise(sub_block)\n                else:\n                    rotated_block = sub_block\n                \n                # Paste rotated block in output\n                output[min_r:max_r+1,min_c:max_c+1] = rotated_block\n    \n    # Return as list of lists\n    return output.tolist()",
        "test_result": {
          "correct": false,
          "pixel_accuracy": 0.0,
          "total_pixels": 72,
          "correct_pixels": 0,
          "error": "Grid height mismatch"
        },
        "status": "failed_test"
      },
      {
        "attempt_number": 2,
        "timestamp": "2025-07-11T12:44:58.762358",
        "input_tokens": 3031,
        "output_tokens": 870,
        "attempt_cost": 0.0026043999999999998,
        "program_extracted": true,
        "program": "def transform(grid):\n    from collections import deque\n    import copy\n\n    R = len(grid)\n    C = len(grid[0])\n\n    # Directions (4-neighbors)\n    directions = [(-1,0),(1,0),(0,-1),(0,1)]\n\n    visited = [[False]*C for _ in range(R)]\n    output = copy.deepcopy(grid)\n\n    def neighbors(r,c):\n        for dr,dc in directions:\n            nr,nc = r+dr, c+dc\n            if 0<=nr<R and 0<=nc<C:\n                yield nr,nc\n\n    # Find connected components (clusters) ignoring 0\n    for r in range(R):\n        for c in range(C):\n            if grid[r][c] != 0 and not visited[r][c]:\n                color = grid[r][c]\n                # BFS to find cluster\n                q = deque()\n                q.append((r,c))\n                cluster_cells = []\n                colors_in_cluster = set()\n                visited[r][c] = True\n\n                while q:\n                    rr,cc = q.popleft()\n                    cluster_cells.append((rr,cc))\n                    colors_in_cluster.add(grid[rr][cc])\n                    for nr,nc in neighbors(rr,cc):\n                        if not visited[nr][nc] and grid[nr][nc]!=0:\n                            visited[nr][nc] = True\n                            q.append((nr,nc))\n\n                # Proceed only if cluster has exactly 2 distinct colors\n                if len(colors_in_cluster) == 2:\n                    c1, c2 = list(colors_in_cluster)\n\n                    # Partition cluster cells by color\n                    part1 = [pos for pos in cluster_cells if grid[pos[0]][pos[1]] == c1]\n                    part2 = [pos for pos in cluster_cells if grid[pos[0]][pos[1]] == c2]\n\n                    # Heuristic check - parts usually similar size, if they differ too much, skip\n                    if abs(len(part1) - len(part2)) > len(cluster_cells)//2:\n                        # sizes differ too much, skip swapping\n                        continue\n\n                    # Swap colors in output grid\n                    for (rr,cc) in part1:\n                        output[rr][cc] = c2\n                    for (rr,cc) in part2:\n                        output[rr][cc] = c1\n\n                # else: cluster with 1 color or more than 2 colors - leave unchanged\n\n    return output",
        "test_result": {
          "correct": true,
          "pixel_accuracy": 1.0,
          "total_pixels": 72,
          "correct_pixels": 72,
          "error": null,
          "predicted_output": [
            [
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              0,
              2,
              3,
              3,
              0,
              0,
              0,
              0,
              0
            ],
            [
              0,
              2,
              2,
              3,
              0,
              0,
              0,
              0,
              0
            ],
            [
              0,
              2,
              3,
              3,
              0,
              0,
              0,
              0,
              0
            ],
            [
              0,
              0,
              0,
              0,
              0,
              1,
              1,
              1,
              0
            ],
            [
              0,
              0,
              0,
              0,
              0,
              6,
              6,
              6,
              0
            ],
            [
              0,
              0,
              0,
              0,
              0,
              6,
              1,
              1,
              0
            ],
            [
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0
            ]
          ],
          "actual_output": [
            [
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              0,
              2,
              3,
              3,
              0,
              0,
              0,
              0,
              0
            ],
            [
              0,
              2,
              2,
              3,
              0,
              0,
              0,
              0,
              0
            ],
            [
              0,
              2,
              3,
              3,
              0,
              0,
              0,
              0,
              0
            ],
            [
              0,
              0,
              0,
              0,
              0,
              1,
              1,
              1,
              0
            ],
            [
              0,
              0,
              0,
              0,
              0,
              6,
              6,
              6,
              0
            ],
            [
              0,
              0,
              0,
              0,
              0,
              6,
              1,
              1,
              0
            ],
            [
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0
            ]
          ]
        },
        "status": "success"
      }
    ],
    "total_attempts": 2,
    "all_responses": [
      {
        "id": "resp_6870f92a72248192a3c1f7c21b4a864009e44547656e1e3a",
        "model": "gpt-4.1-mini-2025-04-14",
        "usage": {
          "input_tokens": 3031,
          "output_tokens": 1191,
          "total_tokens": 4222
        },
        "output": [
          {
            "type": "message",
            "content": [
              "Let's analyze the patterns in the training examples:\n\n**Observations:**\n\n- Each training input contains groups of distinct colored blocks arranged as 2x2 or 3x3 squares or similar shapes.\n- In the output:\n  - The groups are transformed by swapping or rotating their internal color positions.\n  - Specifically:\n    - The color blocks inside each group appear to be rotated or permuted.\n    - For example, in the first example's large blocks of 2x2 or 3x3 shapes, the colors are cyclically permuted between positions inside the block.\n- The test input shows two 2x2 blocks of colors (green/red and blue/magenta).\n- The output size **should always be 13\u00d710**, even if input is smaller. So we must generate a grid of size 13 rows x 10 columns.\n- The transformations are local to each color block (group), applying a rotation/permutation inside them.\n- Blocks are 2x2 or 3x3 mostly.\n\n**Hypothesis:**\n\nFor each connected color block (non-zero cells connected horizontally or vertically), if the block forms a 2x2 or 3x3 square or rectangular shape, perform a clockwise rotation of the colors inside that block.\n\nWe will:\n\n- Identify connected blocks of the same color or connected colored cells.\n- Extract the bounding box of each block.\n- Extract the subgrid of that block.\n- Rotate the block's colors clockwise (or apply a cyclic color permutation).\n- Paste it back into the output grid.\n- The rest of the grid remains zero.\n\nIf blocks are irregular or too small, keep them the same.\n\nAlso, the output grid needs to be exactly 13 rows and 10 columns. If input is smaller, pad with zeros.\n\n---\n\n### Implementation plan:\n\n- Use BFS or DFS to find connected non-zero blocks.\n- For each block, extract bounding box and the subgrid.\n- Rotate colors clockwise inside that subgrid.\n- Create output grid 13x10 initialized with zeros\n- Paste rotated blocks in corresponding positions.\n- Return output grid.\n\n---\n\n### Note on input size differences\n\n- If input grid has fewer rows than 13, or fewer columns than 10, place the input grid at top-left corner of the 13x10 output grid before processing.\n- Or process input as is, then embed result into 13x10.\n\n---\n\n### Code implementation below\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n    rows_in = len(grid)\n    cols_in = len(grid[0]) if rows_in > 0 else 0\n    \n    # Target output size\n    ROWS, COLS = 13, 10\n    \n    # Convert grid to numpy array for easy indexing\n    arr = np.zeros((ROWS, COLS), dtype=int)\n    # Place input grid at top-left corner\n    arr[:rows_in, :cols_in] = np.array(grid)\n    \n    visited = np.zeros_like(arr, dtype=bool)\n    \n    def neighbors(r,c):\n        for nr,nc in [(r-1,c),(r+1,c),(r,c-1),(r,c+1)]:\n            if 0 <= nr < ROWS and 0 <= nc < COLS:\n                yield nr,nc\n    \n    from collections import deque\n    \n    def rotate_block_clockwise(block):\n        # block is 2D numpy array\n        # rotate colors clockwise inside block\n        # If shape is 1x1, no change\n        if block.shape[0] == 1 and block.shape[1] == 1:\n            return block.copy()\n        # For simplicity, rotate the array clockwise:\n        # But we want to rotate colors preserving shape by moving colors clockwise:\n        # We'll rotate the array by 90 degrees clockwise\n        # This matches the permutation seen in examples where colors relocate inside block\n        return np.rot90(block, k=-1)\n    \n    output = np.zeros((ROWS, COLS), dtype=int)\n    \n    # Find connected components of non-zero cells\n    for r in range(ROWS):\n        for c in range(COLS):\n            if arr[r,c] != 0 and not visited[r,c]:\n                color_val = arr[r,c]\n                q = deque()\n                q.append((r,c))\n                visited[r,c] = True\n                cells = []\n                min_r, max_r = r, r\n                min_c, max_c = c, c\n                \n                while q:\n                    rr, cc = q.popleft()\n                    cells.append((rr,cc))\n                    if rr < min_r: min_r = rr\n                    if rr > max_r: max_r = rr\n                    if cc < min_c: min_c = cc\n                    if cc > max_c: max_c = cc\n                    for nr,nc in neighbors(rr,cc):\n                        if arr[nr,nc] != 0 and not visited[nr,nc]:\n                            visited[nr,nc] = True\n                            q.append((nr,nc))\n                \n                height = max_r - min_r + 1\n                width = max_c - min_c + 1\n                \n                # Extract sub-block\n                sub_block = arr[min_r:max_r+1,min_c:max_c+1].copy()\n                \n                # Apply rotation only if block height & width > 1\n                # If 1x1, no change\n                if height > 1 or width > 1:\n                    rotated_block = rotate_block_clockwise(sub_block)\n                else:\n                    rotated_block = sub_block\n                \n                # Paste rotated block in output\n                output[min_r:max_r+1,min_c:max_c+1] = rotated_block\n    \n    # Return as list of lists\n    return output.tolist()\n```\n"
            ]
          }
        ]
      },
      {
        "id": "resp_6870f93ae8d081a29ec7a22e53d21b2e00f796bf49746e52",
        "model": "gpt-4.1-mini-2025-04-14",
        "usage": {
          "input_tokens": 3031,
          "output_tokens": 870,
          "total_tokens": 3901
        },
        "output": [
          {
            "type": "message",
            "content": [
              "Analysis:\n\n1. The grids contain several colored blocks/groups each composed of connected colored cells.\n2. The transformation swaps the colors of certain blocks within each cluster.\n3. Each example shows a specific pattern of swapping:\n   - Example 1: In three clusters of 4 colored cells, the colors in the two halves are swapped horizontally.\n   - Example 2: Similar swap of colors within a cluster.\n   - Example 3: Each cluster has two 2x2 blocks of different colors; the colors are swapped to the opposite block.\n   \nFrom the visuals and examples, the rule seems to be:\n\n**Within each distinct colored cluster of exactly two colors (in two adjacent sub-blocks), swap colors between the two sub-blocks that form the cluster.** \n\n- Usually, clusters are 2x2 or 3x2 cells.\n- The cluster splits into two equal halves of different colors.\n- The colors in these halves are swapped to produce the output.\n\nAdditional notes:\n\n- The grid size remains the same.\n- Background (color 0) remains unchanged.\n- Clusters with more than two colors or irregular shapes may be untouched.\n\nImplementation plan:\n\n- Identify clusters: find connected components ignoring 0.\n- For each cluster:\n  - Find distinct colors inside that cluster.\n  - If exactly two colors, find a way to split cluster into two halves by color.\n  - Swap the colors of these halves.\n- Assemble final output grid.\n\nI will use BFS for connected components. Assumptions based on examples:\n\n- Clusters have exactly two colors (non-zero).\n- Each half occupies contiguous positions in cluster.\n\nIf cluster has more colors or coloring pattern is complex, leave it unchanged.\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    from collections import deque\n    import copy\n\n    R = len(grid)\n    C = len(grid[0])\n\n    # Directions (4-neighbors)\n    directions = [(-1,0),(1,0),(0,-1),(0,1)]\n\n    visited = [[False]*C for _ in range(R)]\n    output = copy.deepcopy(grid)\n\n    def neighbors(r,c):\n        for dr,dc in directions:\n            nr,nc = r+dr, c+dc\n            if 0<=nr<R and 0<=nc<C:\n                yield nr,nc\n\n    # Find connected components (clusters) ignoring 0\n    for r in range(R):\n        for c in range(C):\n            if grid[r][c] != 0 and not visited[r][c]:\n                color = grid[r][c]\n                # BFS to find cluster\n                q = deque()\n                q.append((r,c))\n                cluster_cells = []\n                colors_in_cluster = set()\n                visited[r][c] = True\n\n                while q:\n                    rr,cc = q.popleft()\n                    cluster_cells.append((rr,cc))\n                    colors_in_cluster.add(grid[rr][cc])\n                    for nr,nc in neighbors(rr,cc):\n                        if not visited[nr][nc] and grid[nr][nc]!=0:\n                            visited[nr][nc] = True\n                            q.append((nr,nc))\n\n                # Proceed only if cluster has exactly 2 distinct colors\n                if len(colors_in_cluster) == 2:\n                    c1, c2 = list(colors_in_cluster)\n\n                    # Partition cluster cells by color\n                    part1 = [pos for pos in cluster_cells if grid[pos[0]][pos[1]] == c1]\n                    part2 = [pos for pos in cluster_cells if grid[pos[0]][pos[1]] == c2]\n\n                    # Heuristic check - parts usually similar size, if they differ too much, skip\n                    if abs(len(part1) - len(part2)) > len(cluster_cells)//2:\n                        # sizes differ too much, skip swapping\n                        continue\n\n                    # Swap colors in output grid\n                    for (rr,cc) in part1:\n                        output[rr][cc] = c2\n                    for (rr,cc) in part2:\n                        output[rr][cc] = c1\n\n                # else: cluster with 1 color or more than 2 colors - leave unchanged\n\n    return output\n```\n"
            ]
          }
        ]
      }
    ],
    "mode": "independent_attempts"
  }
}