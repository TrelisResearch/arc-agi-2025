{
  "task_id": "a680ac02",
  "model": "gpt-4.1",
  "reasoning_effort": "N/A",
  "api_type": "responses_api_multiturn",
  "program": "import numpy as np\n\ndef is_hollow_ring(patch):\n    # patch: 4x4 numpy array\n    if patch.shape != (4,4):\n        return False\n    c = patch[0,0]\n    if c == 0:\n        return False\n    # Border must be all c\n    if not np.all(patch[0,:] == c): return False\n    if not np.all(patch[3,:] == c): return False\n    if not np.all(patch[:,0] == c): return False\n    if not np.all(patch[:,3] == c): return False\n    # Center 2x2 must be all zero\n    if not np.all(patch[1:3,1:3] == 0): return False\n    # The rest must be c or 0 (like the corners and ring)\n    # Make sure we don't have c==0, and the whole patch is only c and 0\n    mask = (patch == c) | (patch == 0)\n    if not np.all(mask):\n        return False\n    return True\n\ndef find_hollow_rings(grid):\n    arr = np.array(grid)\n    h, w = arr.shape\n    found = []\n    for r in range(h-3):\n        for c in range(w-3):\n            patch = arr[r:r+4, c:c+4]\n            if is_hollow_ring(patch):\n                found.append((r, c, patch.copy()))\n    # Remove duplicates: don't pick the same hollow square twice (no overlaps)\n    # Optionally, remove if another ring's top-left lies within this patch\n    unique = []\n    taken = np.zeros_like(arr, dtype=bool)\n    for r, c, patch in sorted(found, key=lambda x: (x[0], x[1])):\n        if not np.any(taken[r:r+4, c:c+4]):\n            unique.append((r, c, patch))\n            taken[r:r+4, c:c+4] = True\n    return unique\n\ndef transform(grid):\n    import numpy as np\n    # Find all hollow rings, order by (row, col)\n    hollow_rings = find_hollow_rings(grid)\n    # Sort by row, then col (they're already sorted)\n    hollow_rings = sorted(hollow_rings, key=lambda x: (x[0], x[1]))\n    n = len(hollow_rings)\n    # Each ring is 4x4, we concatenate them horizontally\n    ring_patches = [patch for (r, c, patch) in hollow_rings]\n    if n == 0:\n        result = np.zeros((4,8), dtype=int)\n    else:\n        concat = np.concatenate(ring_patches, axis=1) if n > 0 else np.zeros((4,0), dtype=int)\n        # Ensure result is 4x8 (clip or pad with zeros as necessary)\n        if concat.shape[1] < 8:\n            pad = np.zeros((4, 8 - concat.shape[1]), dtype=int)\n            result = np.concatenate([concat, pad], axis=1)\n        else:\n            result = concat[:,:8]\n    return result.tolist()",
  "execution_error": "Max turns reached",
  "timed_out": false,
  "tokens_used": 6616,
  "request_cost": 0.020048,
  "turns_used": 1,
  "raw_response": {
    "id": "resp_687002cae83881a0afc0904bdd54ca4d0118eda089acbce5",
    "model": "gpt-4.1-2025-04-14",
    "usage": {
      "input_tokens": 5480,
      "output_tokens": 1136,
      "total_tokens": 6616
    },
    "output": [
      {
        "type": "message",
        "content": [
          "Let's analyze the problem:\n\n### Observations\n\nFrom the training examples:\n- The output is always a 4x8 grid.\n- Each object in the input is a distinct colored (solid or hollow) square.\n- In the outputs, only the *hollow squares* (colored rings) are present (not the solid ones).\n- Each hollow square is cropped to a 4x4 patch (just the ring, including the black center).\n- The output is made by taking all 4x4 hollow rings in the input and arranging them **side-by-side** (horizontally, left-to-right) in the order: **top-to-bottom, then left-to-right among objects at the same row**.\n- The output grid is filled with as many 4x4 hollow squares as present in the input; the output is always 4 rows, the number of columns is 4\u00d7N, where N is the number of hollow squares (it seems outputs are always 4x8, so usually 2 hollow squares, but example 3 shows more: 4x12 if there are 3 rings).\n\n### Extraction logic\n\nSo, we need to:\n1. Find all 4x4 hollow square \"rings\" in the input (identify by their colored border and black (0) interior).\n2. For each, cut out its 4x4 bounding box.\n3. Order by: smallest row first, then smallest column.\n4. Concatenate the patches **horizontally** in that order.\n5. Output a 4\u00d7[4 * number_of_hollow_squares] grid.\n6. If there are fewer than two hollow squares (e.g. only one), fill the rest with zeros to make 4x8 grid.\n\n### Implementation details\n\n- To find 4x4 hollow squares:\n    - For each nonzero pixel, check if it\u2019s the top-left corner of a 4x4 group which forms a hollow ring (colored on the border, black in the 2x2 inner area).\n    - We can brute-force over all possible 4x4 subgrids.\n\n### Let's write the logic in code.\n\nFinal answer:\n```python\nimport numpy as np\n\ndef is_hollow_ring(patch):\n    # patch: 4x4 numpy array\n    if patch.shape != (4,4):\n        return False\n    c = patch[0,0]\n    if c == 0:\n        return False\n    # Border must be all c\n    if not np.all(patch[0,:] == c): return False\n    if not np.all(patch[3,:] == c): return False\n    if not np.all(patch[:,0] == c): return False\n    if not np.all(patch[:,3] == c): return False\n    # Center 2x2 must be all zero\n    if not np.all(patch[1:3,1:3] == 0): return False\n    # The rest must be c or 0 (like the corners and ring)\n    # Make sure we don't have c==0, and the whole patch is only c and 0\n    mask = (patch == c) | (patch == 0)\n    if not np.all(mask):\n        return False\n    return True\n\ndef find_hollow_rings(grid):\n    arr = np.array(grid)\n    h, w = arr.shape\n    found = []\n    for r in range(h-3):\n        for c in range(w-3):\n            patch = arr[r:r+4, c:c+4]\n            if is_hollow_ring(patch):\n                found.append((r, c, patch.copy()))\n    # Remove duplicates: don't pick the same hollow square twice (no overlaps)\n    # Optionally, remove if another ring's top-left lies within this patch\n    unique = []\n    taken = np.zeros_like(arr, dtype=bool)\n    for r, c, patch in sorted(found, key=lambda x: (x[0], x[1])):\n        if not np.any(taken[r:r+4, c:c+4]):\n            unique.append((r, c, patch))\n            taken[r:r+4, c:c+4] = True\n    return unique\n\ndef transform(grid):\n    import numpy as np\n    # Find all hollow rings, order by (row, col)\n    hollow_rings = find_hollow_rings(grid)\n    # Sort by row, then col (they're already sorted)\n    hollow_rings = sorted(hollow_rings, key=lambda x: (x[0], x[1]))\n    n = len(hollow_rings)\n    # Each ring is 4x4, we concatenate them horizontally\n    ring_patches = [patch for (r, c, patch) in hollow_rings]\n    if n == 0:\n        result = np.zeros((4,8), dtype=int)\n    else:\n        concat = np.concatenate(ring_patches, axis=1) if n > 0 else np.zeros((4,0), dtype=int)\n        # Ensure result is 4x8 (clip or pad with zeros as necessary)\n        if concat.shape[1] < 8:\n            pad = np.zeros((4, 8 - concat.shape[1]), dtype=int)\n            result = np.concatenate([concat, pad], axis=1)\n        else:\n            result = concat[:,:8]\n    return result.tolist()\n```\n"
        ]
      }
    ]
  },
  "score": {
    "correct": false,
    "pixel_accuracy": 0.0,
    "total_pixels": 48,
    "correct_pixels": 0,
    "error": "Max turns reached"
  },
  "actual_output": [
    [
      3,
      3,
      3,
      3
    ],
    [
      3,
      0,
      0,
      3
    ],
    [
      3,
      0,
      0,
      3
    ],
    [
      3,
      3,
      3,
      3
    ],
    [
      2,
      2,
      2,
      2
    ],
    [
      2,
      0,
      0,
      2
    ],
    [
      2,
      0,
      0,
      2
    ],
    [
      2,
      2,
      2,
      2
    ],
    [
      1,
      1,
      1,
      1
    ],
    [
      1,
      0,
      0,
      1
    ],
    [
      1,
      0,
      0,
      1
    ],
    [
      1,
      1,
      1,
      1
    ]
  ],
  "api_success": true,
  "multiturn_data": {
    "turn_details": [
      {
        "turn_number": 1,
        "timestamp": "2025-07-10T19:13:30.796091",
        "input_tokens": 5480,
        "output_tokens": 1136,
        "turn_cost": 0.020048,
        "program_extracted": true,
        "program": "import numpy as np\n\ndef is_hollow_ring(patch):\n    # patch: 4x4 numpy array\n    if patch.shape != (4,4):\n        return False\n    c = patch[0,0]\n    if c == 0:\n        return False\n    # Border must be all c\n    if not np.all(patch[0,:] == c): return False\n    if not np.all(patch[3,:] == c): return False\n    if not np.all(patch[:,0] == c): return False\n    if not np.all(patch[:,3] == c): return False\n    # Center 2x2 must be all zero\n    if not np.all(patch[1:3,1:3] == 0): return False\n    # The rest must be c or 0 (like the corners and ring)\n    # Make sure we don't have c==0, and the whole patch is only c and 0\n    mask = (patch == c) | (patch == 0)\n    if not np.all(mask):\n        return False\n    return True\n\ndef find_hollow_rings(grid):\n    arr = np.array(grid)\n    h, w = arr.shape\n    found = []\n    for r in range(h-3):\n        for c in range(w-3):\n            patch = arr[r:r+4, c:c+4]\n            if is_hollow_ring(patch):\n                found.append((r, c, patch.copy()))\n    # Remove duplicates: don't pick the same hollow square twice (no overlaps)\n    # Optionally, remove if another ring's top-left lies within this patch\n    unique = []\n    taken = np.zeros_like(arr, dtype=bool)\n    for r, c, patch in sorted(found, key=lambda x: (x[0], x[1])):\n        if not np.any(taken[r:r+4, c:c+4]):\n            unique.append((r, c, patch))\n            taken[r:r+4, c:c+4] = True\n    return unique\n\ndef transform(grid):\n    import numpy as np\n    # Find all hollow rings, order by (row, col)\n    hollow_rings = find_hollow_rings(grid)\n    # Sort by row, then col (they're already sorted)\n    hollow_rings = sorted(hollow_rings, key=lambda x: (x[0], x[1]))\n    n = len(hollow_rings)\n    # Each ring is 4x4, we concatenate them horizontally\n    ring_patches = [patch for (r, c, patch) in hollow_rings]\n    if n == 0:\n        result = np.zeros((4,8), dtype=int)\n    else:\n        concat = np.concatenate(ring_patches, axis=1) if n > 0 else np.zeros((4,0), dtype=int)\n        # Ensure result is 4x8 (clip or pad with zeros as necessary)\n        if concat.shape[1] < 8:\n            pad = np.zeros((4, 8 - concat.shape[1]), dtype=int)\n            result = np.concatenate([concat, pad], axis=1)\n        else:\n            result = concat[:,:8]\n    return result.tolist()",
        "training_feedback": {
          "feedback_messages": [
            {
              "type": "input_text",
              "text": "Training results: 1/3 examples solved, 50.0% pixel accuracy - Great progress! You're on the right track. Next, try to identify a transformation that solves more than 1 of the training examples.\n\nTraining Example 1 \u2713:\nExpected: [[2, 2, 2, 2, 4, 4, 4, 4], [2, 0, 0, 2, 4, 0, 0, 4], [2, 0, 0, 2, 4, 0, 0, 4], [2, 2, 2, 2, 4, 4, 4, 4]]\nYour output: [[2, 2, 2, 2, 4, 4, 4, 4], [2, 0, 0, 2, 4, 0, 0, 4], [2, 0, 0, 2, 4, 0, 0, 4], [2, 2, 2, 2, 4, 4, 4, 4]]\n\nTraining Example 2 \u2717:\nExpected: [[1, 1, 1, 1], [1, 0, 0, 1], [1, 0, 0, 1], [1, 1, 1, 1], [2, 2, 2, 2], [2, 0, 0, 2], [2, 0, 0, 2], [2, 2, 2, 2]]\nYour output: [[1, 1, 1, 1, 2, 2, 2, 2], [1, 0, 0, 1, 2, 0, 0, 2], [1, 0, 0, 1, 2, 0, 0, 2], [1, 1, 1, 1, 2, 2, 2, 2]]\nPixel accuracy: 50.0%\n\nTraining Example 3 \u2717:\nExpected: [[4, 4, 4, 4, 3, 3, 3, 3, 2, 2, 2, 2], [4, 0, 0, 4, 3, 0, 0, 3, 2, 0, 0, 2], [4, 0, 0, 4, 3, 0, 0, 3, 2, 0, 0, 2], [4, 4, 4, 4, 3, 3, 3, 3, 2, 2, 2, 2]]\nYour output: [[3, 3, 3, 3, 4, 4, 4, 4], [3, 0, 0, 3, 4, 0, 0, 4], [3, 0, 0, 3, 4, 0, 0, 4], [3, 3, 3, 3, 4, 4, 4, 4]]\nPixel accuracy: 16.7%\n\n\u26a0\ufe0f  GRID SIZE ERROR: One or more of your output grids are incorrect in size. They should ALL be 4\u00d78 for this task.\n\n"
            },
            {
              "type": "input_image",
              "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAhcAAAINCAIAAAAC9sriAAAwaUlEQVR4nO3de1zUVeL/8TMogyg4CBYql0oJtAephPfQ1eT7+CqIgmJrZS6E5WW9BF7K1nTzK+kGq5td3L6pmJGrqxughob+1ktuYqZs3o0ACxAN0QGRO3x+j/rszpflFhwuwwyv58M/Zs58zsyZzxw+bz/nfGaORlEUAQCAFAu5agAAkCIAgGYhRQAA8kgRAIA8UgQAII8UAQDII0UAAPJIEQCAPFIEACCPFAEAyCNFAADySBEAgDxSBABgpBRZsGCBpn4zZ86scxutVturV6/JkyefO3eu9nMePnxYo9HY29uXlJTUeGjv3r0ajWbLli3q3ZCQEI1GExUVVWOzrKwsjUazcuXK5tRSlZSUfPDBB+PGjevTp4+VlVWfPn2mT5/+xRdfNLBPVq5cWd8OuXjxYsM7zdfX9xd3rGGb2bNnVy9Xmzdt2rRTp05Vb09gYGCNzR555JFFixbdvXu3STtfdfv27bVr13p5eel0um7dug0bNmzLli3VfxZafbka1c+ePfvAAw/Y2toePXq0gV0HwBQZ4VykvLz81q1b+/fvHzduXHp6eo1Ht23bJoS4e/fu7t27G/Nsq1atunr1alPb0Jha169fHzly5Ny5c48dO5aTk1NWVpaTk7N3794xY8Zs2LBBtDNq8z799FMfH59PPvmkgc2uX7/+zjvvTJgwoaqqqkk7/9SpU4MGDXr99df/+c9/FhQUFBUVnTlz5sUXXwwLC2ugYX//+9/HjRtXWVl55MiRcePGNeMtAjC7FHn33XeVf9uzZ48QIiYmxlASGxtr2DIjI8NQXlJScuXKlWeffbagoGDz5s3Vn1Cv18fHx0+fPt3e3v7Pf/5zY9pQVlYWEhJSWVnZpJb/Yq3y8vLg4OB//vOfo0aN2rdv3+3bt8vLy3/44Yf333/f3t5++fLl6olFfVJSUpRaPD0969whBkeOHKn+JI3ZJicnRy0vLi7+7rvvXn31VUVRXnjhhe+//776ZsXFxdV3vq+v71dffXX48OHG7/wff/wxKCjoxo0bzzzzTHJyckFBwZ07d+Lj4/v27RsTE/PBBx/UuR/i4uL8/Py6du167Nix4cOHN7DHAJgoI5yLWFlZ9e/f/w9/+IMQosa5yM6dO0tKSubMmRMaGpqcnHz+/PlffLaFCxeePn36j3/8Y5Pa8Iu1Pvroo7Nnz/r6+p44cSIgIMDBwaFz584uLi7z5s379NNPKysr//KXv4j2pEuXLv369Vu3bt2qVavKysr+9Kc/NbDzX375ZTWBGr/zN2zYcOvWrfDw8J07dw4fPtzW1rZHjx5Tpkw5fvx4t27dNmzYUHu5s61bt06fPv3BBx/84osvBg4caCjfvn27RqN59913W3QHAOgwKVJaWnrp0qWIiAghhLu7e/WHYmJiBgwY8NRTT82bN69Tp06NOR1588033dzcVq1adeXKlca34Rdr7dy5U6PR/O///m+nTp1qPPSrX/3q8uXLa9euFe3SkiVLunbt+vnnn9f5aHl5+bfffrtp06bOnTv/6le/avzO/+tf/2ptbb1mzZoaT+js7Hzy5Mljx45pNJrq5W+99dbs2bP79u178uTJRx99tOXeH4AOmSKPPPKIYYK3S5cunp6ee/bs6dmz5+LFiw3bXLx48euvv162bJlGo+nXr9/06dM/+eSTwsLChp+5a9euMTEx5eXlTRrX+sVaKSkpAwYMeOSRR+qsPmDAgBoHzRq8vLxqzIqfPHmyvh1icOzYsaZuU5utre2jjz5a4yTP2tpara7Vaj08PP7xj3989NFH1d9dwzu/vLz8+vXrw4YNs7Gxqf2KgwcP7t27d/WS5cuXv/LKK0KI0aNHu7q61tg+JCREUZQFCxY0/EYAmATjXOnr5OT0wgsvfPPNN7169TIUbtu2zcnJ6bnnnlPvrlix4t69e40ZOPLx8Vm0aNFXX30VHR3d+DY0UKu8vFyv1zs6OlYvrHHd1MMPPyzaKwcHh9Kf1bdBZWVlcnJyeXl5I3e+Xq9XFMXBwaGRDXjnnXdGjhzp6+u7bdu2Tz/9tHnvBkC71kYpok4Ul5WV7dq1S/3P8vr16/v06WPYoLy8PDY2Njs728rKSj1MDxo0SFGURs6xv/nmm48++ujq1asvX77c+FbVV8vS0tLW1jY3N1fIqj277uPj84sz52PHjm3qNnW6e/eupaWllZVV7dn1srKy9PT03/72t++8887SpUsbufPt7e0tLCwav0NCQ0OPHTu2Y8cOe3v7F198MTs7u5EVAZicNj0XsbS0/PWvf7179+7jx49PmDCh+rcKDhw4UOdB6ty5c2fOnPnFZ7a2tpYY12qg1uOPP3758uUffvihzgvSvL29RXtVWFh48eLFAQMG1PmopaXlI488Eh0d7enpuX379kbu/E6dOg0YMODrr78uKiqqvdm6detmzZp148YNQ8n777+v1Wp79+797rvv3rlzZ9asWbWvKgZgHowwojVx4sSFCxeeO3fO8H9hdUSlS5cu+fn51f/f/eWXXwoh6ruKtIYnn3xy8eLFZ86cqf2NQolazz33XFVV1fz58+vMpNrXI7UfGzduLC8vnzBhQsObWVhYFBYWVlRUNHLnBwYGFhcX//73v6/xPNevX3/rrbcOHDhQ53jXM888Exwc/Pe//71Jg40ATIhx5kXefPNNV1fXzZs3nz59Wghx8+bNQ4cOBQQEdO/evfpmI0eO9PDw+Mtf/pKfn9+Yp42MjHz00Ufff//9JjWmzlqzZ8/29vb+7LPPhg0b9te//vXmzZvl5eXqtw79/f3PnTtnYdG+fjymtLT02rVrK1eufOONN7p27Vrf3LWiKFlZWcuWLTt//ryXl1fnzp0bufPDw8MdHByioqJmzZr19ddfFxcX37p1a+fOnWPHjtXr9cuWLas+gFbd5s2bHR0dV65cefbs2dZ56wCMyTiHwm7dur3zzjtVVVVz5sypqKjYsWNHRUWFYWq3ut/85jdFRUUff/xx40eoGr56qpG1tFptfHz8yJEjz5079+tf/7p3795arVb9BZTExEQPD49GfrW+PnVef6XRaKpfk9aYbXr37m248q1///6RkZHqz724uLjUeI/qZhYWFi4uLtHR0RYWFurFyo3c+Q4ODrt377a1tf3444+HDh3atWvXXr16Pffcc99//31QUNDy5cvre6c9e/b88MMPy8vLn3322fv37/N9EcDMGO0/1JMnTw4MDPzmm2/+9Kc/bd++vUePHhMnTqy92axZsywsLBo5qKWOUKlfqWuSOms5Ozt/8cUXsbGxfn5+zs7OWq3W0dHRz8/vo48+unjx4tChQ0V7Ymlp6eLiMmPGjH/84x/PPPNMfZt16tTpwQcf9Pf3P3z4sDrq1fidP378+JSUlEWLFvXv39/Gxsba2nr48OFbtmz529/+VvtbNdUFBASEhIR8++231S/sBmAeNO15iB8A0M61r8F9AIBpIUUAAPJIEQCAPFIEACCPFAEAyCNFAADySBEAgDxSBAAgjxQBAMgjRQAA8kgRAIA8UgQAII8UAQDII0UAAPJIEQCA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"
            },
            {
              "type": "input_text",
              "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
            }
          ],
          "solved_count": 1,
          "total_training_examples": 3,
          "pixel_accuracy": 0.5
        },
        "test_result": {
          "correct": false,
          "pixel_accuracy": 0.0,
          "total_pixels": 48,
          "correct_pixels": 0,
          "error": "Grid height mismatch"
        },
        "status": "failed_test"
      }
    ],
    "total_turns": 1,
    "conversation_history": [
      {
        "role": "system",
        "content": "You are an expert at solving abstract reasoning puzzles. Write clean, efficient Python code."
      },
      {
        "role": "user",
        "content": [
          {
            "type": "input_text",
            "text": "You are solving an ARC (Abstraction and Reasoning Corpus) task. \nI will show you training examples with input and output grids, plus a test input grid. Your task is to:\n\n1. **Analyze the training examples** to discover patterns that map input grids to output grids\n2. **Write a Python program** that implements your best understanding of the transformation  \n3. **DO NOT predict or generate the test output** - your job is only to write the transformation program\n4. **Attempt a solution** - even if the pattern isn't completely clear, provide your best hypothesis\n5. **Do not repeat the same transformation** - if you have already tried a transformation, do not repeat it.\n\n**IMPORTANT: Your transformation must always produce a 4\u00d78 output grid.**\n\nThe test input is shown for context so you understand what type of grid your program will eventually process. Focus on learning patterns from training examples and writing code that captures your understanding.\n\nTraining Examples:\n\nExample 1:\nInput:\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0\n0 2 0 0 2 0 0 0 0 4 4 4 4 0 0 0 0\n0 2 0 0 2 0 0 0 0 4 0 0 4 0 0 0 0\n0 2 2 2 2 0 0 0 0 4 0 0 4 0 0 0 0\n0 0 0 0 0 0 0 0 0 4 4 4 4 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0 0\n0 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0 0\n0 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0 0\n0 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 8 8 8 8 0 0 0\n0 0 0 0 0 0 0 0 0 0 8 8 8 8 0 0 0\n0 0 0 0 0 0 0 0 0 0 8 8 8 8 0 0 0\n0 0 0 0 0 0 0 0 0 0 8 8 8 8 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\nOutput:\n2 2 2 2 4 4 4 4\n2 0 0 2 4 0 0 4\n2 0 0 2 4 0 0 4\n2 2 2 2 4 4 4 4\n\nExample 2:\nInput:\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 8 8 8 8 0 0 0 0\n0 0 0 0 0 0 0 0 8 8 8 8 0 0 0 0\n0 0 0 0 0 0 0 0 8 8 8 8 0 0 0 0\n0 0 0 0 0 0 0 0 8 8 8 8 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0\n0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0\n0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0\n0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 2 2 2 2 0 0 0 0 0 0 0 0 0\n0 0 0 2 0 0 2 0 0 0 0 0 0 0 0 0\n0 0 0 2 0 0 2 0 0 0 0 0 0 0 0 0\n0 0 0 2 2 2 2 0 0 0 4 4 4 4 0 0\n0 0 0 0 0 0 0 0 0 0 4 4 4 4 0 0\n0 0 0 0 0 0 0 0 0 0 4 4 4 4 0 0\n0 0 0 0 0 0 0 0 0 0 4 4 4 4 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\nOutput:\n1 1 1 1\n1 0 0 1\n1 0 0 1\n1 1 1 1\n2 2 2 2\n2 0 0 2\n2 0 0 2\n2 2 2 2\n\nExample 3:\nInput:\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8 8 0 0\n0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 8 8 8 8 0 0\n0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 8 8 8 8 0 0\n0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 8 8 8 8 0 0\n0 1 1 1 1 0 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 3 0 0 3 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 3 0 0 3 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 6 6 6 6 0 0 0 0 0 0\n0 0 4 4 4 4 0 0 0 0 0 0 6 6 6 6 0 0 2 2 2 2\n0 0 4 0 0 4 0 0 0 0 0 0 6 6 6 6 0 0 2 0 0 2\n0 0 4 0 0 4 0 0 0 0 0 0 6 6 6 6 0 0 2 0 0 2\n0 0 4 4 4 4 0 0 0 0 0 0 0 0 0 0 0 0 2 2 2 2\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\nOutput:\n4 4 4 4 3 3 3 3 2 2 2 2\n4 0 0 4 3 0 0 3 2 0 0 2\n4 0 0 4 3 0 0 3 2 0 0 2\n4 4 4 4 3 3 3 3 2 2 2 2\n\nTest Input:\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 3 0 0 3 0 0 0 0 0 0 0 0 0 8 8 8 8 0\n0 0 0 3 0 0 3 0 0 0 0 0 0 0 0 0 8 8 8 8 0\n0 0 0 3 3 3 3 0 0 0 0 0 0 0 0 0 8 8 8 8 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8 8 0\n0 0 0 0 0 0 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 2 0 0 2 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 2 0 0 2 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 4 4 4 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 4 4 4 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 4 4 4 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 4 4 4 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\nAnalyze the patterns in the training examples and write a Python function that performs this transformation.\n\n**Approach Guidelines:**\n- Look for patterns in shapes, colors, positions, sizes, rotations, reflections, etc.\n- Even if you can't solve all training examples perfectly, implement what patterns you do observe\n- A partial solution that captures some aspects is better than returning the input unchanged\n- If the pattern is unclear, make your best educated guess based on what you can see\n\nRequirements:\n- The function takes a 2D list (grid) where grid[row][col] gives the value at that position\n- Values are integers from 0-9\n- Return a new grid (2D list) with the transformation applied\n- You can use numpy if needed - just add 'import numpy as np' at the start of your function\n- Aim to handle the training examples as well as possible, even if not perfectly\n- Your function should attempt some meaningful transformation based on the patterns you observe\n\nYou MUST end your response with the following exact format:\n\nFinal answer:\n```python\ndef transform(grid):\n    # Your transformation logic here (implement your best understanding)\n    return transformed_grid\n```\n"
          },
          {
            "type": "input_image",
            "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAwwAAAeyCAIAAAClkuE6AABR90lEQVR4nO3df5zVdZ3o8XP08EMQB8lWBUsYaNUuhcb6MysNrN1M/X53MUu9tyFJbaPiJsrdHlT3pqn82O2WP0oviRZmqdfveWwbD++G+yDt3ixTwhJRUExxLAWF/BEywPc+dufeebDwxma+M8N3zszz+fAP+HLe5/uZc+Z8eXE+M2M1z/MKAAD/3j67/B4AAJEEABATSQAAAZEEABAQSQAAAZEEABAQSQAAAZEEABAQSQAAAZEEABAQSQAAAZEEABAQSQAAPR1JM2fOrO7Z+eefH95m8ODBhxxyyJlnnvnQQw/tfp8//vGPq9XqqFGjtmzZsssf3XnnndVqddGiRe2/bWlpqVarCxYs2OVm69evr1arc+fO7c5Uuy1bttxwww2nnnrq6NGjhwwZMnr06LPPPvu+++4r9phMnTq1Uqls3Lhx9OjRBx544Pr163eZ/eu//uvBgwf/8pe/7OQD8tGPfrRardZqtRdeeGH3lUycOLFarba0tLT/dsaMGTsvZt999z3ggAOOP/74b3/72x0jSZJUq9XdT9TJD63dhg0bLrvssiOPPHK//fYbOXLkSSed9M1vfnP79u1v8KABQB9UwjtJbW1tv//973/4wx+eeuqpTz755C5/etNNN1UqlZdeeukHP/hBZ+7tS1/60urVq7u6hs5MPfXUUyeeeOLFF1+8fPny5557buvWrc8999ydd9753ve+9x/+4R8qRb3pTW+66aabNm3aNH369DzPO45fd911WZZdeeWVf/EXf9GlB2T79u133XXXLgd//etfP/LII2+wjB07drz88su/+MUvZsyYMX/+/EoPeeGFF4499tgFCxY89thjW7Zs2bx5889+9rO//du/Pfvss3f+YAGgn0fStddem/9/d9xxR6VSWbx4cceRJUuWdNxy3bp1Hce3bNny6KOPnnvuuX/4wx+++c1v7nyHmzZtqtfrZ5999qhRo771rW91Zg1bt25taWnp6hsVf3Kqra1t2rRpv/rVr0466aR//Md/3LBhQ1tb29NPP3399dePGjXqsssu+81vfvMG97/zx9th2bJl7X/6l3/5l5/+9KeXLVt27bXXth9ZuXLlJZdc8oEPfOCSSy7p0gOy7777HnHEEbfffvsux7///e//h//wH3a//XPPPde+mB07drzyyivf+973hg4d+tWvfvX1119/wwessx/aN77xjaeeemratGkrV6589dVXN23a9C//8i/HHHNMlmU//OEPO3kKABig7yQNGTLkyCOPnDdvXqVS2eWdpO9973tbtmy56KKLpk+ffv/99z/88MN/8t4+85nP/PznP//7v//7Lq3hT07dcsstDz744NSpU++9994zzjjjTW96U61We8tb3vKpT33qrrvu2r59+2233VbphgULFhx55JFz5sx57LHHXnnllY985CNNTU3f+c53qtVqVx+Qj3zkIz/5yU+ef/75nQ/+4Ac/OOecc95gAdVqdfjw4R/72Mc++tGP/uEPf3j88ccrPWH16tW1Wm3JkiXvfOc7hw0b1tTUdOqpp7a/0XX33Xe33+bmm2+uVqsdgQgAfVMJkfT6668/8sgjn//85yuVyp//+Z/v/EeLFy8+6qij3v/+93/qU5/ad999O/Nm0pVXXjlhwoQvfelLjz76aOfX8Cenvve971Wr1RtvvHHffffd5Y/e9773rVq16oorrqh0w3777Xfrrbdu27bt/PPPv/jii9esWfOd73zn4IMP3uVmnXlAPvKRj+yy4/aLX/ziiSee+MhHPtKZlbS/h7T7h1nMpEmTtm3blmXZzgfHjh2b5/n111/fI6cAgH4VSePGjev4It+hQ4dOnDjxjjvuOOiggz73uc913OY3v/nNL3/5y0svvbRarY4fP/7ss8++9dZbX3nllTe+52HDhi1evLitra1Lm25/cmrFihVHHXXUuHHjwvGjjjpql7d83uDj7bB8+fKdb/Oud73rv/7X//rLX/7y1ltv/fznP//BD35wlzvp5AMyceLEt7/97e3bne2+//3v/8Vf/MX48ePfYIXbt29vbW39+te/fvvtt//Zn/3ZEUcc8QY37vyHNmvWrJNPPvljH/tYc3PzjBkzbrzxxt2/NKqlpSXP85kzZ3byjAAwgH4EwJgxYz7xiU+sXLnykEMO6Th40003jRkz5rzzzmv/7d/93d+9/PLLndnVOvnkkz/72c/+4he/WLhwYefX8AZTbW1tmzZt2uV9nV2+t2vs2LGVbjvrrLPaY+vkk0/e/U87/4DsvOOW5/ntt9++p722Qw89tH39tVptzJgxs2bN2r59+5VXXtlT7yTtv//+y5cvX7JkyaRJk+r1+kUXXTRx4sRx48bdcsstPXL/ANDfIqn9q323bt36/e9/f8SIEW9729uuvvrq0aNHd9ygra1tyZIlzz777JAhQ9r/Fp80aVKe55388u0rr7zybW9725e//OVVq1Z1flV7mho0aNCIESPC76vvzlc3n3LKKTvfZsuWLeeee25TU9OIESMuuuiiXb6oqEsPyDnnnNOx43bvvfe2trb+yb22ffbZZ9SoUVOmTKnX6xdccEEPfmj77rvveeedl2XZhg0b1qxZs3jx4oMPPrilpeVrX/ta588CAAPrnaRBgwadc845P/jBD37yk5/85V/+5c4/j+ef/umfwih56KGHHnjggT95z/vtt1+BTbc3mHrHO96xatWqp59+OvxWvsmTJ1e6bdasWQ8//PA3/s3zzz//iU98Yuc/7dIDcuSRR77jHe9o/x63H/zgByeccMJb3/rW8KQd3922ffv2jRs3Llu27Kyzzqr0mgkTJrS0tPz0pz895phjuvlVXADQ/7fb/uqv/uozn/nMQw89NHv27I6DN91009ChQzdv3rzz+xP/5//8n0qlcsMNN3Tmbt/97nd/7nOfe+CBB3b/QZEFps4777wdO3b87d/+bZhc3f+RP3fccccNN9xw7rnn/sf/+B9bWlr+5m/+5kc/+tHOPxChqw/IOeecc++997b/JKc3/r623vPss89Wq9UZM2bscrxWq73jHe/YtGnT1q1bS1kYADTM1yRdeeWVb33rW7/5zW/+/Oc/r1Qqv/vd7+6+++4zzjjjgAMO2PlmJ5544hFHHHHbbbdt3ry5M3f71a9+9W1ve1tXv4sqnJoxY8bkyZN/9KMfHXfccbfffvvvfve7tra29gQ5/fTTH3rooX32Kf7QrVu37pOf/OS4ceM6quiGG2449NBDL7nkkvYfcVngAWnfcZs1a9aGDRvOPvvsShnGjBnzrne966abbpo5c+bPfvaz3//+91u2bHniiSeuv/76O+6447jjjhs8eHApCwOAhomk4cOHX3PNNTt27Ljooou2bdv2ne98Z9u2bR1fobyzj3/846+99tp3v/vdzm+fvfH3nXVyavDgwfV6/cQTT3zooYfOOeecQw89dPDgwe3/W5KlS5ceccQRb/wDwcNvAatWq6+88kpbW9s555zz6quv3nrrrR0N9KY3venmm2/esmXLeeed19bWVuABmTBhwjHHHHP77be/5z3v2fmLvQrYb7/9dln2zTff3JkPrf0NsJEjR1533XUnnXTSIYccst9++02YMOHTn/50rVbr+MFIfk4SAA2htP/B7ZlnnpkkycqVK//7f//vN99884EHHvhXf/VXu9/sP/2n/7TPPvt0csetffts1qxZXV1MOHXYYYfdd999S5Ys+dCHPnTYYYcNHjz44IMP/tCHPnTLLbf85je/OfbYYyuF/Jf/8l8eeOCBL3/5yyeeeOLOxz/wgQ/MnDnzoYcemjt3brEHpH2XrZM/HqmXTJo06ZFHHrnkkksmTpx4wAEHDB48eOzYsRdeeOGvf/3rHvlCLgDYa6r+j1oAAH3onSQAgL5MJAEABEQSAEBAJAEABEQSAEBAJAEABEQSAEBAJAEABEQSAEBAJAEABEQSAEBAJAEABEQSAEBAJAEABEQSAEBAJAEABEQSAEBAJAEABEQSAEBAJAEABEQSAEBAJAEABEQSAEBAJAEABEQSAEBAJAEABEQSAEBAJAEABEQSAEBAJAEABEQSAEBAJAEABEQSAEBAJAEABEQSAEBAJAEABEQS9JaNGzeuXr267FXAANKdF50XLLsTSfCvkiRpaWnp2fucOnXq/fffv6c/3bRpU3Nz8xvcAAayZ5555pOf/OSYMWOGDh3a3Nw8e/bsF198sZsvuu7MesEOTCIJessf//jHPf3RM888M3Xq1HXr1u3dFUFjePzxxydPnvzSSy8tXbr0xRdfvOuuux599NHJkyc/99xzhV90f5IXLLsTSfDvbNiwoVqtXnfddWPHjh06dOgHP/jBZ599tuP4t7/97cMOO6ypqemCCy5ov6SuX7++Wq0+9dRT7eMLFy484YQTKpXKKaec8thjj02fPn3GjBm7nOJHP/rRxIkTJ0+eXMbHBw1gxowZ73vf++68885JkyYNGzbs6KOP/uEPf3jIIYd89rOf7eSLzguWHiGSIHDLLbfcc889q1evbm1t/cpXvtJxfP78+XffffeKFSsefPDBmTNnvsE9LF++/Igjjli8ePGiRYt2+aMhQ4YsW7bsuuuu67XlQwP77W9/e9999+3y+tpnn31mzZpVr9dfeumlzr/ovGDpJpEEgS9+8Yvjx48fO3ZsS0vLAw880HF83rx5EydObG5uXrBgwZIlS1599dUCdz516tRjjz22R9cL/ceqVasqlcpRRx21y/FJkyZt27Zt7dq1nb8rL1i6SSRBYOzYse2/GD58eFtbW8fx9nfmK5XK0UcfvXXr1ieeeKKkBUK/Va1WK5XK9u3bdzn++uuvd/WuvGDpJpEEgUGDBnX8Os/z3Y+3X8FrtVr7Bb3D7ld2oEva30Nqfz9pZ6tXr67VahMmTOj8i84Llm4SSdAFDz/8cPsvVqxYsf/++48fP37w4MGVSqXjbfynn36648a7XI6Bzjj88MOnTJly9dVX73xwx44d8+fPP/PMMw888MDOv+i8YOkmkQRdcNlll61bt27NmjVz5sy58MILhwwZctBBB40bN+6GG2547bXXli1bdtttt3XcePjw4a2trS+//HKpS4bGc+ONNz7yyCPnn3/+448/3tbWtmrVqmnTpj3//PPXXHNNpVLp/IvOC5ZuEknQBVOnTj311FOPP/740047rf1futVqddGiRcuWLRs1atTll1/+hS98oePGF1988VVXXTV9+vRSlwyNp7m5+aGHHho5cuRpp502YsSI008//fDDD//Vr341evToLr3ovGDppurOX29Bd6RpWvYS6EVbt25dunTplClTRowYUfZa6FuyLKs0mn5/vRrgL9hG/Jzsm2plL6BfqdfrxQaTJDHbx2c/9KEPVSqVe+65Zy+f12zfn21Q2ebWYoNp0+i+P7uhbdubK5VrX3nhyB0v/7/ZhQWf33R20nCz9BTbbQAAAe8kQae0f1MM0BAOGlTLTz2u7FXQ8LyTBAAQEEkAAAGRBAAQEEkAAAGRBAAQEEkAAAGRBAAQEEkAAAGRBAAQEEkAAAGRBAAQEEkAAAGRBAAQEEkAAAGRBAAQEEkAAIFqnufRcbosTdOylwCUIMuySqNxverfGvFzsm+qlb2AfqVerxcbTJIk29xabDZtGt2Is915rMya7VOzDaoRX7/dul4tLHjedHZpn5OF10xPsd0GABAQSQAAAZEEABAQSQAAAZEEABAQSQAAAZEEABAQSQAAAZEEABAQSQAAAZEEABAQSQAAAZEEABAQSQAAAZEEABAQSQAAAZEEABAQSQAAgWqe59FxuixN07KXAJQgy7JKo3G96t8a8XOyb6qVvYB+pV6vFxtMkiTb3FpsNm0a3Z3zDrQ1l/ZYLSw4m85uyNlGfI4KzzaoRnz9dmfNjfj5XHjN9BTbbQAAAZEEABAQSQAAAZEEABAQSQAAAZEEABAQSQAAAZEEABAQSQAAAZEEABAQSQAAAZEEABAQSQAAAZEEABAQSQAAAZEEABAQSQAAAZEEABCo5nkeHafL0jQtewlACbIsqzQa16v+rRE/J/umWtkL6Ffq9XqxwSRJss2txWbTptHdOe9AW3Npj9XCgrPpbGvu67MNqjuv34ac7cbnc8PN0lNstwEABEQSAEBAJAEABEQSAEBAJAEABEQSAEBAJAEABEQSAEBAJAEABEQSAEBAJAEABEQSAEBAJAEABEQSAEBAJAEABEQSAEBAJAEABEQSAECgmud5dJwuS9O07CUAJciyrOwlAL2i1jt3O0DV6/Vig0mSZJtbi82mTaMbcbY7j1UjzmYLC86ms625r88C/ZXtNgCAgEgCAAiIJACAgEgCAAiIJACAgEgCAAiIJACAgEgCAAiIJACAgEgCAAiIJACAgEgCAAiIJACAgEgCAAiIJACAgEgCAAiIJACAgEgCAAhU8zyPjtNlaZqWvQSgBFmWlb0EoHfk9JAkSQo/C2b7/Wy+tlLsvwadLetxLmW27GsP0FtstwEABEQSAEBAJAEABEQSAEBAJAEABEQSAEBAJAEABEQSAEBAJAEABEQSAEBAJAEABEQSAEBAJAEABEQSAEBAJAEABEQSAEBAJAEABEQSAECgmud5dJwuS9O07CUAJciyrOwlAL0jp4ckSVL4WTBr1mzjzpZ97QF6i+02AICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACFTzPI+O02Vpmpa9BKAEWZaVvQSgV9R6524HqHq9XmwwSZKyZp+cu6nYbPMVIxtxthGfI7N9fBbor2y3AQAERBIAQEAkAQAERBIAQEAkAQAERBIAQEAkAQAERBIAQEAkAQAERBIAQEAkAQAERBIAQEAkAQAERBIAQEAkAQAERBIAQEAkAQAERBIAQKCa53l0nC5L07TsJQAlyLKs7CUAvaLWO3c7QNXr9WKDSZKUNfvk3E3FZpuvGNmIs434HJnt47N7TbXqn7WwV9luA2gY1Wq17CXAACKSABqJToK9RiQBAAREEkCD8WYS7B2+cBug8XKnfdDXcUOv8k4SAEBAJAEABGy3AZSmS/tlO+/N2WiDvcA7SQANRiHB3iGSAAAC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d99994oVKx588MGZM2e+wT0sX778iCOOWLx48aJFi3Y+ftJJJ7W1tQ0ePLj9t88999yoUaOq1WqvfSiwR7/97W/vu+++XT6T99lnn1mzZtXr9Zdeeqnzn95eGvQqkQR9yBe/+MXx48ePHTu2paXlgQce6Dg+b968iRMnNjc3L1iwYMmSJa+++mp3zrJ58+arr776ggsu6IklQ5etWrWqUqkcddRRuxyfNGnStm3b1q5d2/m78tKgV4kk6EPGjh3b/ovhw4e3tbV1HD/hhBPaf3H00Udv3br1iSeeKHyKV1999Ywzzpg4ceLcuXO7vV4oov19mu3bt+9y/PXXX+/qXXlp0KtEEvQhgwYN6vh1nue7H2//e6VWq+2yHbD73zehjRs3Tpky5bDDDrvzzjtrtVrPLRy6oP09pPb3k3a2evXqWq02YcKEzn96e2nQq0QSNICHH364/RcrVqzYf//9x48f3/4lFB2bC08//XTHjff05RTr168/+eST3/ve9956660dX4EBe9/hhx8+ZcqUq6++eueDO3bsmD9//plnnnnggQd2/tPbS4NeJZKgAVx22WXr1q1bs2bNnDlzLrzwwiFDhhx00EHjxo274YYbXnvttWXLlt12220dNx4+fHhra+vLL7+88z1s2rTp/e9//5lnnjl//nxflErpbrzxxkceeeT8889//PHH29raVq1aNW3atOeff/6aa66pVCqd//T20qBXiSRoAFOnTj311FOPP/740047rf3f39VqddGiRcuWLRs1atTll1/+hS98oePGF1988VVXXTV9+vSd7+Fb3/rWmjVr2v8a6PDKK6+U8dFApbm5+aGHHho5cuRpp502YsSI008//fDDD//Vr341evToLn16e2nQq6o7f90D/U+apmUvgW7ZunXr0qVLp0yZMmLEiLLXwt6WZVml0ey1a04feWk04nNE5/nytP6vXq8XG0ySxGwfmb3nnntKOa/ZcmcbVH3CvGKDydo5XZj940uVytJ7Dp9dGdXc5dnunJeBxHYbAEDAO0kANKD9DqzMfqzsRdDPeScJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAtU8z6Pj9BNpmpa9BKCgLMsqjWagXXMa8Tmi82pduC2NqV6vFxtMksRs35+dtKDgNXrlpWkjzjbic1R4tkHVJ8wrNpisnVPac1R0zfRvttsAAAIiCQAgIJIAAAIiCQAgIJIAAAIiCQAgIJIAAAIiCQAgIJIAAAIiCQAgIJIAAAIiCQAgIJIAAAIiCQAgIJIAAAIiCQAgIJIAAAIiCQAgUM3zPDpOP5GmadlLAArKsqzSaAbaNacRnyM6r9aF29KY6vV6scEkScz2/dlJCwpeo1demjbibCM+R4VnG1R9wrxig8naOaU9R0XXTP9muw0AICCSAAACIgkAICCSAAACIgkAICCSAAACIgkAICCSAAACIgkAICCSAAACIgkAICCSAAACIgkAICCSAAACIgkAICCSAAACIgkAICCSAAAC1TzPo+P0E2malr0EoKAsyyqNZqBdcxrxOaLzal24LY2pXq8XG0ySxGzfn520oOA1euWlaSPONuJzVHi2QdUnzCs2mKyd03Cz9G+22wAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACBQzfM8Ok4/kaZp2UsACsqyrNJoBto1pxGfIzqv1oXb0pjq9XqxwSRJzPb92UkLCl6jV16aNuJsIz5HhWcbVLa5tdhg2jS64Wbp32y3AQAERBIAQEAkAQAERBIAQEAkAQAERBIAQEAkAQAERBIAQEAkAQAERBIAQEAkAQAERBIAQEAkAQAERBIAQEAkAQAERBIAQEAkAQAERBIAQKCa53l0nH4iTdOylwAUlGVZpdEMtGtOIz5HdF6tC7elMdXr9WKDSZKYNWu2xNkGlW1uLTaYNo0u6zkqvGb6N9ttAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEKjmeR4dp59I07TsJQAFZVlWaTQD7ZrTiM8RnVfrwm1pTPV6vdhgkiT1CfMKzq6d05Cz3XmszJrt6dkGlW1uLTaYNo0u6zkqvGb6N9ttAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEKjmeR4dp59I07TsJQAFZVlWaTQD7ZrTiM8RnVfrwm1pTPV6vdhgkiT1CfMKzq6d063zDrQ1mzXbj2SbW4sNpk2jG26W/s12GwBAQCQBAAREEgBAQCQBAAREEgBAQCQBAAREEgBAQCQBAAREEgBAQCQBAAREEgBAQCQBAAREEgBAQCQBAAREEgBAQCQBAAREEgBAQCQBAASqeZ5Hx+kn0jQtewlAQVmWlb0EGNBqZS+AXlev14sNJklSnzCv4OzaOd0670Bbs1mzQN9juw0AICCSAAACIgkAICCSAAACIgkAICCSAAACIgkAICCSAAACIgkAICCSAAACIgkAICCSAAACIgkAICCSAAACIgkAICCSAAACIgkAICCSAAAC1TzPo+P0E2malr0EoKAsy8peAgxotbIXQK+r1+vFBpMkqU+YV3B27ZyGnO3OY2XWbE/PAuWy3QYAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAANdtVotewnQF4kkAHQSBEQSAP9KJ8EuRBIAQEAkAfD/eDMJdlb7d78DYGDnTvtgnuc9vSJoPN5JAgAIiCQAgIDtNoB+qEv7ZTvvzdlogw5Vr4f+LU3TspcAFJRl2d45UUck+RsB/p2cfi1JkkpRZs2aLXd2r10o9v4ZoSH4miQA/pW3kWAXIgkAhQQBkQQw0CkkCIkkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAIBANc/z6Dj9RJqmZS8BKCjLsrKXAANbTr+WJEnhzw2zZs2WO1v29QMGOtttAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEBBJAAABkQQAEKjmeR4dp59I07TsJQAFZVlW9hJgQKuVvQB6Xb1eLzaYJElZs9nm1mKzadPoRpxtxOfI7F6YBcpluw0AICCSAAACIgkAICCSAAACIgkAICCSAAACIgkAICCSAAACIgkAICCSAAACIgkAICCSAAACIgkAICCSAAACIgkAICCSAAACIgkAICCSAAAC1TzPo+P0E2malr0EoKAsy8peAgxotbIXQK+r1+vFBpMkKWs229xabDZtGm3NZvvNLFAu220A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QDXP80pRaZoWngUYCLIsK3sJQEG1SvfU6/Vig0mSdGc2W1hwNp3dkLNlPc4Dbfbmez9bbLblvd9oxNnSXr+bW4vNpk2jG24WaFy22wAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACBQzfO8UlSapoVnAQaCLMvKXgJQUK3SPfV6vdhgkiTdmc0WFpxNZ3frvANtzQNt9uZ7P1tstuW932jE2dJeC5tbi82mTaMbbs1A47LdBgAQEEkAAAGRBAAQEEkAAAGRBAAQEEkAAAGRBAAQEEkAAAGRBAAQEEkAAAGRBAAQEEkAAAGRBAAQEEkAAAGRBAAQEEkAAAGRBAAQEEkAAIFqnueVotI0LTwLMBBkWVb2EoCCapXuqdfrxQaTJOnObLaw4Gw6u1vnHWhrHmizN9/72WKzLe/9RiPOlvZa2NxabDZtGt1wawYal+02AICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACFTzPK8UlaZp4VmAgSDLsrKXABRUq3RPvV4vNpgkSXdms4UFZ9PZDTlb1uNs1mxvzGabW4vNpk2jG24WaFy22wAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACAgkgAAAiIJACBQzfO8UlSapoVnAQaCLMvKXgJQVN4NSZIUPq9Zs2bNDoTZ7lxjgXLZbgMACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAIBANc/zSlFpmhaeBRgIsiwrewlAUXk3JElS+LxmzZo1OxBmu3ONBcpluw0AICCSAAACIgkAICCSAAACIgkAICCSAAACIgkAICCSAAACIgkAICCSAAACIgkAICCSAAACIgkAICCSAAACIgkAICCSAAACIgkAICCSAAAC1TzPK0WlaVp4FmAgyLKs7CUAReXdkCRJ4fOaNWvW7ECY7c41FiiX7TYAgIBIAgAIiCQAgIBIAgAIiCQAgIBIAgAIiCQAgIBIAgAIiCQAgIBIAgAIiCQAgIBIAgAIiCQAgIBIAgAIiCQAgIBIAgAIiCQAgIBIAgAIVPM8rxSVpmnhWYCBIMuyspcAFJV3Q5Ikhc9r1qxZswNhtjvXWKBcttsAAAIiCQAgIJIAAAIiCQAgIJIAAAIiCQAgIJIAAAIiCQAgIJIAAAIiCQAgIJIAAAIiCQAgIJIAAAIiCQAgIJIAAAIiCQAgIJIAAAIiCQAgUM3zvFJUmqaFZwEGgizLyl4CUFTeDUmSFD6vWbNmzQ6E2e5cY4Fy2W4DAAiIJACAgEgCAAiIJACAgEgCAAiIJACAgEgCAAiIJACAgEgCAAiIJACAgEgCAAiIJACAgEgCAAiIJACAgEgCAAiIJACAgEgCAAiIJACAQDXP8+g4AMCA5p0kAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICejqSZM2dW9+z8889/49tMnTq14642bNhw2WWXHXnkkfvtt9/IkSNPOumkb37zm9u3b+/8iXZx5513VqvVRYsWtf+2paWlWq0uWLBgl5utX7++Wq3OnTu3/bczZszY+Z733XffAw444Pjjj//2t7+9y0f91FNP7XJXq1evrlars2fPLrZgAKBPqVX6gBdeeOG4447ryI4tW7b87N/8+Mc//p//839Wq9WeOtGXvvSlM84448gjj+zk7Xfs2PHyyy//4t9s3Ljxsssu66mVAAD9+Z2ka6+9Nv//7rjjjkqlsnjx4o4jS5Ys6bjlunXr8t0sW7as/U+/8Y1vPPXUU9OmTVu5cuWrr766adOmf/mXfznmmGOyLPvhD3/YpRO9sa1bt7a0tHS8QbUnzz33XPs979ix45VXXvne9743dOjQr371q6+//nqPPzIAQN/UJ74mafXq1bVabcmSJe985zuHDRvW1NR06qmn3nXXXZVK5e677+7BE33mM5/5+c9//vd///edvH21Wh0+fPjHPvaxj370o3/4wx8ef/zxHlzMzTffXK1Wr7322h68TwCgX0XSpEmTtm3blmXZzgfHjh2b5/n111/fgye68sorJ0yY8KUvfenRRx/t0mD7e0j77rtvDy4GAOjL9lIkjRs3bvevX16+fHn7n86aNevkk0/+2Mc+1tzcPGPGjBtvvPGRRx7pjWUMGzZs8eLFbW1tndl0q1Qq27dvb21t/frXv3777bf/2Z/92RFHHNGDi2lpacnzfObMmT14nwBAv3onaf/991++fPmSJUsmTZpUr9cvuuiiiRMnjhs37pZbbunxc5188smf/exnf/GLXyxcuHBPtzn00EPbM65Wq40ZM2bWrFnbt2+/8sorvZMEAAPHXoqk8Au3TznllI4b7Lvvvuedd16WZRs2bFizZs3ixYsPPvjglpaWr33taz2+mCuvvPJtb3vbl7/85VWrVr3xLffZZ59Ro0ZNmTKlXq9fcMEF7QdrtX/9lsC2trZdbtx+pP1PAYBG1yfeSdrFhAkTWlpafvrTnx5zzDFXXHFFj9//fvvt98abbh3f3bZ9+/aNGzcuW7bsrLPO6vjTpqamSqXy/PPP7zL1u9/9ruNPAYBGV34kPfvss9VqdcaMGbscr9Vq73jHOzZt2rR169YeP+m73/3uz33ucw888MDuP17yTxo3blz4bXftR5qbm3tumQBAacrfGxozZsy73vWum266aejQoeedd15zc3NTU9Ozzz77v/7X/7rjjjuOO+64wYMH98Z5v/rVr/7TP/1Tge+eO+200wYNGjR//vympqbzzjvvzW9+8+9///vvf//711xzzbBhw97//vf3xmoBgAH03W3VavWVV16pVCo33XTTyJEjr7vuupNOOumQQw7Zb7/9JkyY8OlPf7pWq/XejxFq33Qr8OO8x4wZ89/+23/bunXrpZdeOnr06EGDBh122GGzZ8/etm3bP/zDP7z5zW/u5P34OUkA0Jf1lZ+T9Mgjj1xyySUTJ0484IADBg8ePHbs2AsvvPDXv/715MmTe++87373u2fNmlVg8O/+7u/q9foHP/jBgw8+eNCgQYceeugZZ5yxbNmyiy66qBeWCQCUoJrneRnnBQDo0/rEO0kAAH2NSAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkAICASAIACIgkoBwbN25cvXp1/zsX0G+IJKALpk2bVo0sW7asq3c1derU+++/f/fjSZK0tLT00Hr/xLkA3oBIArrgzjvvzP/N4sWLhw8f3v7rPM+nTp3a1bv64x//2DtrLPlcQL8hkoAe89xzz02bNm3//fd/y1ve8vnPf74jTb71rW81NzePGDHi2GOPveuuuyqVyimnnPLYY49Nnz59xowZe7q3DRs2VKvV6667buzYsUOHDv3gBz/47LPPdhz/9re/fdhhhzU1NV1wwQXtJ1q/fn21Wn3qqafaxxcuXHjCCSd08lwAuxNJQI/5m7/5mxEjRjz11FM/+clPHnjggf/8n/9zpVJ5+OGHL7vssjvvvHPDhg2f+9znzj333Jdeemn58uVHHHHE4sWLFy1a9Mb3ecstt9xzzz2rV69ubW39yle+0nF8/vz5d99994oVKx588MGZM2e+wT10/lwAOxNJQM+49957V65cecMNNxx00EHNzc1f+9rX/sf/+B9btmz57W9/W6lUhg8fPmTIkPPPP3/Lli0HHnhg5+/2i1/84vjx48eOHdvS0vLAAw90HJ83b97EiRObm5sXLFiwZMmSV199tXc+LGDgEklAz1i1atVrr702ZMiQ9i/lPvbYY3fs2PHkk0+edtppxx133FFHHXXcccddfvnl69ev79Ldjh07tv0Xw4cPb2tr6zjevpVWqVSOPvrorVu3PvHEEz360QCIJKCHbNu2bcKECfm/9/a3v33o0KE//vGPf/rTn06ZMuW73/3uMcccs2bNms7f7aBBgzp+nef57se3b99eqVRqtVq1Wt15sP04QGEiCegZRx555Lp168I3iqrV6kknnXTVVVetWrVq2LBh//zP/9x+sDune/jhh9t/sWLFiv3333/8+PGDBw+uVCod+25PP/30zgvozrmAgUkkAT3j/e9//zvf+c7p06c/88wzzz777KxZs9761re+/vrr3/3ud8eOHfub3/xm69at99133/PPP/+ud72rffustbX15ZdfLna6yy67bN26dWvWrJkzZ86FF144ZMiQgw46aNy4cTfccMNrr722bNmy2267rePG3TwXMDCJJKBn7LPPPvV6ffjw4UcdddTb3/72xx57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"
          },
          {
            "type": "input_text",
            "text": "Above is a visual representation of all the training examples and the test input. Each grid cell is colored according to its value (0-9), with clear labels and arrows showing input\u2192output transformations. Use both the textual and visual information to understand the pattern."
          }
        ]
      },
      {
        "type": "message",
        "role": "assistant",
        "content": [
          "Let's analyze the problem:\n\n### Observations\n\nFrom the training examples:\n- The output is always a 4x8 grid.\n- Each object in the input is a distinct colored (solid or hollow) square.\n- In the outputs, only the *hollow squares* (colored rings) are present (not the solid ones).\n- Each hollow square is cropped to a 4x4 patch (just the ring, including the black center).\n- The output is made by taking all 4x4 hollow rings in the input and arranging them **side-by-side** (horizontally, left-to-right) in the order: **top-to-bottom, then left-to-right among objects at the same row**.\n- The output grid is filled with as many 4x4 hollow squares as present in the input; the output is always 4 rows, the number of columns is 4\u00d7N, where N is the number of hollow squares (it seems outputs are always 4x8, so usually 2 hollow squares, but example 3 shows more: 4x12 if there are 3 rings).\n\n### Extraction logic\n\nSo, we need to:\n1. Find all 4x4 hollow square \"rings\" in the input (identify by their colored border and black (0) interior).\n2. For each, cut out its 4x4 bounding box.\n3. Order by: smallest row first, then smallest column.\n4. Concatenate the patches **horizontally** in that order.\n5. Output a 4\u00d7[4 * number_of_hollow_squares] grid.\n6. If there are fewer than two hollow squares (e.g. only one), fill the rest with zeros to make 4x8 grid.\n\n### Implementation details\n\n- To find 4x4 hollow squares:\n    - For each nonzero pixel, check if it\u2019s the top-left corner of a 4x4 group which forms a hollow ring (colored on the border, black in the 2x2 inner area).\n    - We can brute-force over all possible 4x4 subgrids.\n\n### Let's write the logic in code.\n\nFinal answer:\n```python\nimport numpy as np\n\ndef is_hollow_ring(patch):\n    # patch: 4x4 numpy array\n    if patch.shape != (4,4):\n        return False\n    c = patch[0,0]\n    if c == 0:\n        return False\n    # Border must be all c\n    if not np.all(patch[0,:] == c): return False\n    if not np.all(patch[3,:] == c): return False\n    if not np.all(patch[:,0] == c): return False\n    if not np.all(patch[:,3] == c): return False\n    # Center 2x2 must be all zero\n    if not np.all(patch[1:3,1:3] == 0): return False\n    # The rest must be c or 0 (like the corners and ring)\n    # Make sure we don't have c==0, and the whole patch is only c and 0\n    mask = (patch == c) | (patch == 0)\n    if not np.all(mask):\n        return False\n    return True\n\ndef find_hollow_rings(grid):\n    arr = np.array(grid)\n    h, w = arr.shape\n    found = []\n    for r in range(h-3):\n        for c in range(w-3):\n            patch = arr[r:r+4, c:c+4]\n            if is_hollow_ring(patch):\n                found.append((r, c, patch.copy()))\n    # Remove duplicates: don't pick the same hollow square twice (no overlaps)\n    # Optionally, remove if another ring's top-left lies within this patch\n    unique = []\n    taken = np.zeros_like(arr, dtype=bool)\n    for r, c, patch in sorted(found, key=lambda x: (x[0], x[1])):\n        if not np.any(taken[r:r+4, c:c+4]):\n            unique.append((r, c, patch))\n            taken[r:r+4, c:c+4] = True\n    return unique\n\ndef transform(grid):\n    import numpy as np\n    # Find all hollow rings, order by (row, col)\n    hollow_rings = find_hollow_rings(grid)\n    # Sort by row, then col (they're already sorted)\n    hollow_rings = sorted(hollow_rings, key=lambda x: (x[0], x[1]))\n    n = len(hollow_rings)\n    # Each ring is 4x4, we concatenate them horizontally\n    ring_patches = [patch for (r, c, patch) in hollow_rings]\n    if n == 0:\n        result = np.zeros((4,8), dtype=int)\n    else:\n        concat = np.concatenate(ring_patches, axis=1) if n > 0 else np.zeros((4,0), dtype=int)\n        # Ensure result is 4x8 (clip or pad with zeros as necessary)\n        if concat.shape[1] < 8:\n            pad = np.zeros((4, 8 - concat.shape[1]), dtype=int)\n            result = np.concatenate([concat, pad], axis=1)\n        else:\n            result = concat[:,:8]\n    return result.tolist()\n```\n"
        ]
      }
    ],
    "all_responses": [
      {
        "id": "resp_687002cae83881a0afc0904bdd54ca4d0118eda089acbce5",
        "model": "gpt-4.1-2025-04-14",
        "usage": {
          "input_tokens": 5480,
          "output_tokens": 1136,
          "total_tokens": 6616
        },
        "output": [
          {
            "type": "message",
            "content": [
              "Let's analyze the problem:\n\n### Observations\n\nFrom the training examples:\n- The output is always a 4x8 grid.\n- Each object in the input is a distinct colored (solid or hollow) square.\n- In the outputs, only the *hollow squares* (colored rings) are present (not the solid ones).\n- Each hollow square is cropped to a 4x4 patch (just the ring, including the black center).\n- The output is made by taking all 4x4 hollow rings in the input and arranging them **side-by-side** (horizontally, left-to-right) in the order: **top-to-bottom, then left-to-right among objects at the same row**.\n- The output grid is filled with as many 4x4 hollow squares as present in the input; the output is always 4 rows, the number of columns is 4\u00d7N, where N is the number of hollow squares (it seems outputs are always 4x8, so usually 2 hollow squares, but example 3 shows more: 4x12 if there are 3 rings).\n\n### Extraction logic\n\nSo, we need to:\n1. Find all 4x4 hollow square \"rings\" in the input (identify by their colored border and black (0) interior).\n2. For each, cut out its 4x4 bounding box.\n3. Order by: smallest row first, then smallest column.\n4. Concatenate the patches **horizontally** in that order.\n5. Output a 4\u00d7[4 * number_of_hollow_squares] grid.\n6. If there are fewer than two hollow squares (e.g. only one), fill the rest with zeros to make 4x8 grid.\n\n### Implementation details\n\n- To find 4x4 hollow squares:\n    - For each nonzero pixel, check if it\u2019s the top-left corner of a 4x4 group which forms a hollow ring (colored on the border, black in the 2x2 inner area).\n    - We can brute-force over all possible 4x4 subgrids.\n\n### Let's write the logic in code.\n\nFinal answer:\n```python\nimport numpy as np\n\ndef is_hollow_ring(patch):\n    # patch: 4x4 numpy array\n    if patch.shape != (4,4):\n        return False\n    c = patch[0,0]\n    if c == 0:\n        return False\n    # Border must be all c\n    if not np.all(patch[0,:] == c): return False\n    if not np.all(patch[3,:] == c): return False\n    if not np.all(patch[:,0] == c): return False\n    if not np.all(patch[:,3] == c): return False\n    # Center 2x2 must be all zero\n    if not np.all(patch[1:3,1:3] == 0): return False\n    # The rest must be c or 0 (like the corners and ring)\n    # Make sure we don't have c==0, and the whole patch is only c and 0\n    mask = (patch == c) | (patch == 0)\n    if not np.all(mask):\n        return False\n    return True\n\ndef find_hollow_rings(grid):\n    arr = np.array(grid)\n    h, w = arr.shape\n    found = []\n    for r in range(h-3):\n        for c in range(w-3):\n            patch = arr[r:r+4, c:c+4]\n            if is_hollow_ring(patch):\n                found.append((r, c, patch.copy()))\n    # Remove duplicates: don't pick the same hollow square twice (no overlaps)\n    # Optionally, remove if another ring's top-left lies within this patch\n    unique = []\n    taken = np.zeros_like(arr, dtype=bool)\n    for r, c, patch in sorted(found, key=lambda x: (x[0], x[1])):\n        if not np.any(taken[r:r+4, c:c+4]):\n            unique.append((r, c, patch))\n            taken[r:r+4, c:c+4] = True\n    return unique\n\ndef transform(grid):\n    import numpy as np\n    # Find all hollow rings, order by (row, col)\n    hollow_rings = find_hollow_rings(grid)\n    # Sort by row, then col (they're already sorted)\n    hollow_rings = sorted(hollow_rings, key=lambda x: (x[0], x[1]))\n    n = len(hollow_rings)\n    # Each ring is 4x4, we concatenate them horizontally\n    ring_patches = [patch for (r, c, patch) in hollow_rings]\n    if n == 0:\n        result = np.zeros((4,8), dtype=int)\n    else:\n        concat = np.concatenate(ring_patches, axis=1) if n > 0 else np.zeros((4,0), dtype=int)\n        # Ensure result is 4x8 (clip or pad with zeros as necessary)\n        if concat.shape[1] < 8:\n            pad = np.zeros((4, 8 - concat.shape[1]), dtype=int)\n            result = np.concatenate([concat, pad], axis=1)\n        else:\n            result = concat[:,:8]\n    return result.tolist()\n```\n"
            ]
          }
        ]
      }
    ]
  }
}