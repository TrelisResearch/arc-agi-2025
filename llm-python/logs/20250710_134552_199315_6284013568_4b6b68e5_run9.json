{
  "task_id": "4b6b68e5",
  "model": "gpt-4.1-mini",
  "reasoning_effort": "N/A",
  "api_type": "responses_api_multiturn",
  "program": "def transform(grid):\n    import numpy as np\n    from collections import deque, Counter\n\n    grid = np.array(grid)\n    h, w = grid.shape\n    output = grid.copy()\n\n    def neighbors4(r, c):\n        for nr, nc in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\n            if 0 <= nr < h and 0 <= nc < w:\n                yield nr, nc\n\n    def neighbors8(r, c):\n        for dr in [-1,0,1]:\n            for dc in [-1,0,1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r+dr, c+dc\n                if 0 <= nr < h and 0 <= nc < w:\n                    yield nr, nc\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    # Find connected outline components using 4-connectivity\n    def bfs_component(sr, sc):\n        q = deque([(sr, sc)])\n        comp = []\n        visited[sr, sc] = True\n        while q:\n            r, c = q.popleft()\n            comp.append((r, c))\n            for nr, nc in neighbors4(r, c):\n                if not visited[nr, nc] and grid[nr, nc] != 0:\n                    visited[nr, nc] = True\n                    q.append((nr, nc))\n        return comp\n\n    # Identify outline pixels of the component\n    def find_outline_pixels(component):\n        comp_set = set(component)\n        outline = set()\n        for r, c in component:\n            for nr, nc in neighbors8(r, c):\n                if (nr, nc) not in comp_set:\n                    outline.add((r, c))\n                    break\n        return outline\n\n    components = []\n    for r in range(h):\n        for c in range(w):\n            if grid[r, c] != 0 and not visited[r, c]:\n                comp = bfs_component(r, c)\n                components.append(comp)\n\n    for comp in components:\n        comp_set = set(comp)\n        outline_set = find_outline_pixels(comp)\n\n        # Majority outline color\n        outline_colors = [grid[r, c] for r, c in comp]\n        outline_color = Counter(outline_colors).most_common(1)[0][0]\n\n        rows = [r for r, _ in comp]\n        cols = [c for _, c in comp]\n        rmin, rmax = max(min(rows), 0), min(max(rows), h - 1)\n        cmin, cmax = max(min(cols), 0), min(max(cols), w - 1)\n\n        box_h = rmax - rmin + 1\n        box_w = cmax - cmin + 1\n\n        mask = np.zeros((box_h, box_w), dtype=np.int8)\n\n        for r, c in comp_set:\n            rr, cc = r - rmin, c - cmin\n            if (r, c) in outline_set:\n                mask[rr, cc] = 1  # outline\n            else:\n                mask[rr, cc] = 2  # candidate interior\n\n        # Flood fill exterior (mask==0) from box edges using 8-connectivity\n        visited_box = np.zeros_like(mask, dtype=bool)\n        q = deque()\n        for rr in range(box_h):\n            for cc in [0, box_w - 1]:\n                if mask[rr, cc] == 0 and not visited_box[rr, cc]:\n                    q.append((rr, cc))\n                    visited_box[rr, cc] = True\n        for cc in range(box_w):\n            for rr in [0, box_h - 1]:\n                if mask[rr, cc] == 0 and not visited_box[rr, cc]:\n                    q.append((rr, cc))\n                    visited_box[rr, cc] = True\n\n        while q:\n            rr, cc = q.popleft()\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    nr, nc = rr + dr, cc + dc\n                    if dr == 0 and dc == 0:\n                        continue\n                    if 0 <= nr < box_h and 0 <= nc < box_w:\n                        if not visited_box[nr, nc] and mask[nr, nc] == 0:\n                            visited_box[nr, nc] = True\n                            q.append((nr, nc))\n\n        # Interior pixels: mask==2 and not reachable from outside\n        interior_pixels = []\n        for rr in range(box_h):\n            for cc in range(box_w):\n                if mask[rr, cc] == 2 and not visited_box[rr, cc]:\n                    interior_pixels.append((rr + rmin, cc + cmin))\n\n        if not interior_pixels:\n            continue\n\n        # Find connected interior regions (4-connectivity) and fill each\n        interior_pixel_set = set(interior_pixels)\n        interior_visited = set()\n        def bfs_interior(sr, sc):\n            q = deque([(sr, sc)])\n            group = []\n            interior_visited.add((sr, sc))\n            while q:\n                r, c = q.popleft()\n                group.append((r, c))\n                for nr, nc in neighbors4(r, c):\n                    if (nr, nc) in interior_pixel_set and (nr, nc) not in interior_visited:\n                        interior_visited.add((nr, nc))\n                        q.append((nr, nc))\n            return group\n\n        groups = []\n        for pix in interior_pixels:\n            if pix not in interior_visited:\n                groups.append(bfs_interior(*pix))\n\n        # For each group, determine fill color and fill\n        for group in groups:\n            non_outline_colors = [grid[r, c] for r, c in group if grid[r, c] != 0 and grid[r, c] != outline_color]\n            if non_outline_colors:\n                fill_color = Counter(non_outline_colors).most_common(1)[0][0]\n            else:\n                alt_colors = [grid[r, c] for r, c in group if grid[r, c] != 0]\n                if alt_colors:\n                    fill_color = Counter(alt_colors).most_common(1)[0][0]\n                else:\n                    fill_color = outline_color\n            for r, c in group:\n                output[r, c] = fill_color\n\n    return output.tolist()",
  "execution_error": "Max turns reached",
  "timed_out": false,
  "tokens_used": 324921,
  "request_cost": 0.1438464,
  "turns_used": 8,
  "raw_response": {
    "id": "resp_686fb5e34674819e8cf4cdf26abfa7090954bbe2e6f93c24",
    "model": "gpt-4.1-mini-2025-04-14",
    "usage": {
      "input_tokens": 73654,
      "output_tokens": 1529,
      "total_tokens": 75183
    },
    "output": [
      {
        "type": "message",
        "content": [
          "Based on all previous analyses and feedback, here is a refined solution that tries to fully fill each closed colored outline with a uniform interior fill color. This color is chosen as the most frequent non-outline, nonzero color inside the polygon, using robust connectivity and exterior flood-fill via 8-neighbors to separate interior vs exterior pixels. The algorithm handles multiple disconnected interior regions and preserves outlines and background perfectly.\n\n```python\ndef transform(grid):\n    import numpy as np\n    from collections import deque, Counter\n\n    grid = np.array(grid)\n    h, w = grid.shape\n    output = grid.copy()\n\n    def neighbors4(r, c):\n        for nr, nc in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\n            if 0 <= nr < h and 0 <= nc < w:\n                yield nr, nc\n\n    def neighbors8(r, c):\n        for dr in [-1,0,1]:\n            for dc in [-1,0,1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r+dr, c+dc\n                if 0 <= nr < h and 0 <= nc < w:\n                    yield nr, nc\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    # Find connected outline components using 4-connectivity\n    def bfs_component(sr, sc):\n        q = deque([(sr, sc)])\n        comp = []\n        visited[sr, sc] = True\n        while q:\n            r, c = q.popleft()\n            comp.append((r, c))\n            for nr, nc in neighbors4(r, c):\n                if not visited[nr, nc] and grid[nr, nc] != 0:\n                    visited[nr, nc] = True\n                    q.append((nr, nc))\n        return comp\n\n    # Identify outline pixels of the component\n    def find_outline_pixels(component):\n        comp_set = set(component)\n        outline = set()\n        for r, c in component:\n            for nr, nc in neighbors8(r, c):\n                if (nr, nc) not in comp_set:\n                    outline.add((r, c))\n                    break\n        return outline\n\n    components = []\n    for r in range(h):\n        for c in range(w):\n            if grid[r, c] != 0 and not visited[r, c]:\n                comp = bfs_component(r, c)\n                components.append(comp)\n\n    for comp in components:\n        comp_set = set(comp)\n        outline_set = find_outline_pixels(comp)\n\n        # Majority outline color\n        outline_colors = [grid[r, c] for r, c in comp]\n        outline_color = Counter(outline_colors).most_common(1)[0][0]\n\n        rows = [r for r, _ in comp]\n        cols = [c for _, c in comp]\n        rmin, rmax = max(min(rows), 0), min(max(rows), h - 1)\n        cmin, cmax = max(min(cols), 0), min(max(cols), w - 1)\n\n        box_h = rmax - rmin + 1\n        box_w = cmax - cmin + 1\n\n        mask = np.zeros((box_h, box_w), dtype=np.int8)\n\n        for r, c in comp_set:\n            rr, cc = r - rmin, c - cmin\n            if (r, c) in outline_set:\n                mask[rr, cc] = 1  # outline\n            else:\n                mask[rr, cc] = 2  # candidate interior\n\n        # Flood fill exterior (mask==0) from box edges using 8-connectivity\n        visited_box = np.zeros_like(mask, dtype=bool)\n        q = deque()\n        for rr in range(box_h):\n            for cc in [0, box_w - 1]:\n                if mask[rr, cc] == 0 and not visited_box[rr, cc]:\n                    q.append((rr, cc))\n                    visited_box[rr, cc] = True\n        for cc in range(box_w):\n            for rr in [0, box_h - 1]:\n                if mask[rr, cc] == 0 and not visited_box[rr, cc]:\n                    q.append((rr, cc))\n                    visited_box[rr, cc] = True\n\n        while q:\n            rr, cc = q.popleft()\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    nr, nc = rr + dr, cc + dc\n                    if dr == 0 and dc == 0:\n                        continue\n                    if 0 <= nr < box_h and 0 <= nc < box_w:\n                        if not visited_box[nr, nc] and mask[nr, nc] == 0:\n                            visited_box[nr, nc] = True\n                            q.append((nr, nc))\n\n        # Interior pixels: mask==2 and not reachable from outside\n        interior_pixels = []\n        for rr in range(box_h):\n            for cc in range(box_w):\n                if mask[rr, cc] == 2 and not visited_box[rr, cc]:\n                    interior_pixels.append((rr + rmin, cc + cmin))\n\n        if not interior_pixels:\n            continue\n\n        # Find connected interior regions (4-connectivity) and fill each\n        interior_pixel_set = set(interior_pixels)\n        interior_visited = set()\n        def bfs_interior(sr, sc):\n            q = deque([(sr, sc)])\n            group = []\n            interior_visited.add((sr, sc))\n            while q:\n                r, c = q.popleft()\n                group.append((r, c))\n                for nr, nc in neighbors4(r, c):\n                    if (nr, nc) in interior_pixel_set and (nr, nc) not in interior_visited:\n                        interior_visited.add((nr, nc))\n                        q.append((nr, nc))\n            return group\n\n        groups = []\n        for pix in interior_pixels:\n            if pix not in interior_visited:\n                groups.append(bfs_interior(*pix))\n\n        # For each group, determine fill color and fill\n        for group in groups:\n            non_outline_colors = [grid[r, c] for r, c in group if grid[r, c] != 0 and grid[r, c] != outline_color]\n            if non_outline_colors:\n                fill_color = Counter(non_outline_colors).most_common(1)[0][0]\n            else:\n                alt_colors = [grid[r, c] for r, c in group if grid[r, c] != 0]\n                if alt_colors:\n                    fill_color = Counter(alt_colors).most_common(1)[0][0]\n                else:\n                    fill_color = outline_color\n            for r, c in group:\n                output[r, c] = fill_color\n\n    return output.tolist()\n```\n\n---\n\nThis approach should solve the training examples better by:\n\n- Accurately separating interior and exterior via 8-connected flood fill.\n- Handling multiple disconnected interior regions.\n- Choosing fill colors prioritizing non-outline interior colors.\n- Maintaining all outlines and background untouched.\n\nIt generalizes across examples and should work on the test input as well.\n\nFeel free to test and further iterate!"
        ]
      }
    ]
  },
  "score": {
    "correct": false,
    "pixel_accuracy": 0.0,
    "total_pixels": 624,
    "correct_pixels": 0,
    "error": "Max turns reached"
  },
  "actual_output": [
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      0,
      0,
      0,
      0,
      0,
      0,
      3,
      3,
      3,
      3,
      3,
      3,
      0,
      0
    ],
    [
      0,
      0,
      0,
      2,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      0,
      0,
      0,
      0,
      3,
      8,
      8,
      8,
      8,
      3,
      0,
      0
    ],
    [
      0,
      0,
      0,
      2,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      0,
      0,
      0,
      0,
      3,
      8,
      8,
      8,
      8,
      3,
      0,
      0
    ],
    [
      0,
      0,
      0,
      2,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      0,
      0,
      3,
      3,
      3,
      8,
      8,
      8,
      8,
      3,
      0,
      0
    ],
    [
      0,
      2,
      2,
      2,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      0,
      0,
      3,
      8,
      8,
      8,
      8,
      8,
      8,
      3,
      0,
      0
    ],
    [
      0,
      2,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      0,
      0,
      3,
      8,
      8,
      8,
      8,
      8,
      8,
      3,
      0,
      0
    ],
    [
      0,
      2,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      0,
      0,
      3,
      8,
      8,
      8,
      8,
      8,
      8,
      3,
      0,
      0
    ],
    [
      0,
      2,
      1,
      1,
      1,
      1,
      1,
      2,
      0,
      0,
      0,
      0,
      0,
      0,
      3,
      8,
      8,
      8,
      8,
      8,
      8,
      3,
      0,
      0
    ],
    [
      0,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      0,
      0,
      0,
      0,
      0,
      0,
      3,
      8,
      8,
      8,
      8,
      8,
      8,
      3,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      3,
      3,
      3,
      3,
      8,
      8,
      8,
      3,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      3,
      8,
      8,
      8,
      3,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      3,
      8,
      8,
      8,
      3,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      8,
      8,
      8,
      8,
      8,
      0,
      0,
      0,
      0,
      0,
      3,
      3,
      3,
      3,
      3,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      8,
      4,
      4,
      4,
      8,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      8,
      8,
      8,
      8,
      8,
      8,
      4,
      4,
      4,
      8,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      8,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      8,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      8,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      8,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      8,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      8,
      0,
      0,
      0,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      0,
      0
    ],
    [
      0,
      0,
      8,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      8,
      0,
      0,
      0,
      7,
      0,
      0,
      0,
      0,
      0,
      7,
      0,
      0
    ],
    [
      0,
      0,
      8,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      8,
      0,
      0,
      0,
      7,
      0,
      0,
      0,
      0,
      0,
      7,
      0,
      0
    ],
    [
      0,
      0,
      8,
      4,
      4,
      8,
      8,
      8,
      8,
      4,
      4,
      8,
      0,
      0,
      0,
      7,
      0,
      0,
      0,
      0,
      0,
      7,
      0,
      0
    ],
    [
      0,
      0,
      8,
      8,
      8,
      8,
      0,
      0,
      8,
      8,
      8,
      8,
      0,
      0,
      0,
      7,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      7,
      7,
      7,
      7,
      7,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]
  ],
  "api_success": true,
  "multiturn_data": {
    "turn_details": [
      {
        "turn_number": 1,
        "timestamp": "2025-07-10T13:41:32.463040",
        "input_tokens": 8230,
        "output_tokens": 839,
        "turn_cost": 0.0046344,
        "program_extracted": true,
        "program": "import numpy as np\nfrom scipy.ndimage import label, binary_fill_holes\n\ndef transform(grid):\n    grid = np.array(grid)\n    h, w = grid.shape\n\n    # Output grid starts as copy of input\n    output = grid.copy()\n\n    # Get all nonzero pixels (potential outlines)\n    nonzero_mask = grid != 0\n\n    # Label connected components of nonzero pixels\n    labeled, num_features = label(nonzero_mask)\n\n    for comp_id in range(1, num_features + 1):\n        comp_mask = (labeled == comp_id)\n\n        # Determine the outline pixels for this component:\n        # Outline pixels are component pixels that have at least one neighbor outside component\n        # Use binary erosion to find inner pixels, outline = comp_mask - eroded\n        from scipy.ndimage import binary_erosion\n\n        eroded = binary_erosion(comp_mask, structure=np.ones((3,3)))\n        outline_mask = comp_mask & (~eroded)\n\n        # Identify enclosed region by filling holes inside the component mask\n        # Using binary_fill_holes\n        filled_mask = binary_fill_holes(comp_mask)\n\n        # Interior pixels = filled_mask but not outline nor component itself? \n        # Actually, outline within component, so interior = filled_mask & ~outline_mask\n\n        # Pixels strictly inside the outline are those in filled_mask but not on the outline\n        interior_mask = filled_mask & (~outline_mask)\n\n        # The shape interior includes the component pixels (outline + interior inside)\n        # But only fill interior pixels (inside area)\n\n        # Determine fill color: pick the most frequent nonzero color in the interior area inside the component\n        # Usually the interior in input has scattered points - pick dominant color inside interior_mask\n\n        # Get colors in interior\n        interior_colors = grid[interior_mask]\n        # Ignore zero colors\n        interior_colors = interior_colors[interior_colors != 0]\n\n        if len(interior_colors) == 0:\n            # No interior colors inside, maybe fill with 0 (leave unchanged)\n            fill_color = 0\n        else:\n            # Use mode (most frequent color) as fill color\n            vals, counts = np.unique(interior_colors, return_counts=True)\n            fill_color = vals[np.argmax(counts)]\n\n        # Apply fill color to interior pixels in output\n        output[interior_mask] = fill_color\n\n        # Outline pixels remains original color (already preserved)\n\n    # Return result as list of lists\n    return output.tolist()",
        "training_feedback": {
          "feedback_messages": [
            {
              "type": "input_text",
              "text": "Training results: 0/3 examples solved, 0.0% pixel accuracy - Keep experimenting! Try a different approach to the transformation.\n\nTraining Example 1 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 1, 1, 1, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nError: Traceback (most recent call last):\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmpg4v0cmnn.py\", line 30, in <module>\n    from scipy.ndimage import label, binary_fill_holes\nModuleNotFoundError: No module named 'scipy'\n\n\nTraining Example 2 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 6, 6, 6, 0, 0], [0, 0, 2, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 2, 2, 2, 3, 3, 3, 3, 3, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 6, 6, 6, 6, 6], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nError: Traceback (most recent call last):\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmpw5jmu2fu.py\", line 30, in <module>\n    from scipy.ndimage import label, binary_fill_holes\nModuleNotFoundError: No module named 'scipy'\n\n\nTraining Example 3 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 3, 3, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 3, 3, 6, 6, 6, 6, 6, 6, 3, 3, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 3, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nError: Traceback (most recent call last):\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmpenxxjshv.py\", line 30, in <module>\n    from scipy.ndimage import label, binary_fill_holes\nModuleNotFoundError: No module named 'scipy'\n\n\n"
            },
            {
              "type": "input_image",
              "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAj8AAAUtCAIAAACcd7J+AABEVklEQVR4nO3de5SU9Zng8beUiyjYLcRRuUURQXPwgsQbQUYD5yxi1HoVHaPRhWA0MV4xeEkYs9kD0QQXJyYnbjYqxCGMjm6qMIlx0RMVHUNilPGuQRoNAjKIdiOCze3dY/oswzYXm+pL1dP9+Rz/aN6up+rXb73dX+vtt7tzWZYlABDKHuVeAADsNvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QKgg9XriiuuyO3cV77ylR3epkuXLgceeOCZZ575/PPPb3+fjz76aC6X69mz58cff9zoXQ8++GAul7vrrrsa/jl+/PhcLjd9+vRGN3vnnXdyudyUKVOaM9Xg448//tnPfnbqqaf27t27a9euvXv3Pvfcc5966qld7JMpU6bsbIe8/PLLu95po0eP/tQdu/U2l1xyybbbG5Z3zjnn/OEPf9h2Pfl8vtHNDjnkkKuuuuqDDz7YrZ3f4L333ps6derQoUOrqqr22Wef448//q677tr2zxQ0PFyj8eeee27//ffv0aPH448/votdB1DRr702bty4cuXKX//616eeempNTU2j995zzz1JknzwwQf3339/U+7t5ptvfv3113d3DU2Zeuutt0466aSvf/3rTzzxxIoVKzZs2LBixYoHH3xw5MiRM2bMSCpMw/J+9atfjRgx4pe//OUubvbWW2/9+Mc/HjNmzJYtW3Zr5//hD384+uij//Ef//Hf//3f16xZs27dumefffZrX/vaxIkTd7Gw3//+96eeeurmzZsfe+yxU089tRkfIkAL1esnP/lJ9v888MADSZLMnDlz65bZs2dvveWSJUu2bv/4449fe+21Cy64YM2aNXfeeee2d1hbW1ssFs8999yePXv+z//5P5uyhg0bNowfP37z5s27tfJPndq4ceO4ceP+/d//ffjw4Q899NB77723cePGv/71rz/96U979ux5/fXXN7yQ2pmFCxdm2xkyZMgOd8hWjz322LZ30pTbrFixomH7+vXr33zzzRtvvDHLsq9+9atvv/32tjdbv379tjt/9OjRf/rTnx599NGm7/z/+I//SNN0+fLlX/7ylxcsWLBmzZr333+/WCwOGDBg5syZP/vZz3a4HwqFwtixY/fee+8nnnjihBNO2MUeA6j0115du3Y9/PDDf/CDHyRJ0ui115w5cz7++OPLLrtswoQJCxYsePHFFz/13q688so//vGP/+N//I/dWsOnTv3iF7947rnnRo8ePX/+/DPOOKNXr16dOnXq16/fN77xjV/96lebN2/+l3/5l6SS7LXXXoceeugtt9xy8803b9iw4Z/+6Z92sfOvueaahvI1fefPmDFj5cqV11577Zw5c0444YQePXrst99+Z5111pNPPrnPPvvMmDFj+z9zevfdd5977rl/93d/99RTTx111FFbt8+aNSuXy/3kJz9p0R0AdCxlqFd9ff0rr7wyadKkJEkGDRq07btmzpx5xBFHfPGLX/zGN76x5557NuXl1/e///2BAwfefPPNr732WtPX8KlTc+bMyeVy/+t//a8999yz0bv+/u///tVXX506dWpSka677rq99977//yf/7PD927cuPEvf/nLHXfc0alTp7//+79v+s7/13/9127duv33//7fG91h3759n3766SeeeCKXy227/Yc//OEll1wyYMCAp59++rDDDmu5jw+gDet1yCGHbL1wYK+99hoyZMgDDzzwmc985uqrr956m5dffvnPf/7z5MmTc7ncoYceeu655/7yl79cu3btru957733njlz5saNG3fr/OGnTi1cuPCII4445JBDdjh+xBFHNPpi3cjQoUMbXW3x9NNP72yHbPXEE0/s7m2216NHj8MOO6zRi9pu3bo1jHfp0mXw4MH/9m//9otf/GLbj27XO3/jxo1vvfXW8ccf37179+0f8ZhjjjnooIO23XL99dffcMMNSZKcfPLJ/fv3b3T78ePHZ1l2xRVX7PoDAai4K+b79Onz1a9+9YUXXjjwwAO3brznnnv69Olz4YUXNvzzpptu+vDDD5tygm7EiBFXXXXVn/70p9tuu63pa9jF1MaNG2traw844IBtNza6DvDggw9OKlWvXr3q/2ZnN9i8efOCBQs2btzYxJ1fW1ubZVmvXr2auIAf//jHJ5100ujRo++5555f/epXzftoAMpXr4YLEDZs2HDfffc1vDi49dZbe/fuvfUGGzdunD179rJly7p27dqQh6OPPjrLsiZeu/H973//sMMO++53v/vqq682fVU7m+rcuXOPHj1WrVqVlGr7qzZGjBjxqVdknHLKKbt7mx364IMPOnfu3LVr1+2v2tiwYUNNTc03v/nNH//4x9/61reauPN79uy5xx57NH2HTJgw4Yknnrj33nt79uz5ta99bdmyZU0cBKjE116dO3f+h3/4h/vvv//JJ58cM2bMtj8V9Jvf/GaHXxyff/75Z5999lPvuVu3biWcP9zF1JFHHvnqq6/+9a9/3eEFlsOGDUsq1dq1a19++eUjjjhih+/t3LnzIYcccttttw0ZMmTWrFlN3Pl77rnnEUcc8ec//3ndunXb3+yWW265+OKLly9fvnXLT3/60y5duhx00EE/+clP3n///Ysvvnj7q/MBgp05PO2006688srnn39+6//7N5y52muvverq6rZ9nfHMM88kSbKzq7Eb+cIXvnD11Vc/++yz2/8kcglTF1544ZYtWy6//PIdtnD76+sqx+23375x48YxY8bs+mZ77LHH2rVrN23a1MSdn8/n169f/9/+239rdD9vvfXWD3/4w9/85jc7PK/45S9/edy4cb///e9366QuQIV+3+v73/9+//7977zzzj/+8Y9Jkrz77ruPPPLIGWecse+++257s5NOOmnw4MH/8i//UldX15S7nTZt2mGHHfbTn/50txazw6lLLrlk2LBhv/3tb48//vh//dd/fffddzdu3Njw08qnn376888/v8celfVLturr6994440pU6Z873vf23vvvXd2TUSWZe+8887kyZNffPHFoUOHdurUqYk7/9prr+3Vq9f06dMvvvjiP//5z+vXr1+5cuWcOXNOOeWU2trayZMnb3uiclt33nnnAQccMGXKlOeee651PnSgIyrPl+B99tnnxz/+8ZYtWy677LJNmzbde++9mzZt2nrJwLb+63/9r+vWrfvnf/7npp8J3PXVgE2c6tKlS7FYPOmkk55//vl/+Id/OOigg7p06dLwm6IefvjhwYMHN/FXgezMDq8nzOVy215j2ZTbHHTQQVuv5Dz88MOnTZvW8Gux+vXr1+hjbLjZHnvs0a9fv9tuu22PPfZouOi/iTu/V69e999/f48ePf75n//5uOOO23vvvQ888MALL7zw7bffTtP0+uuv39lH+pnPfObnP//5xo0bL7jggo8++sjPewEtomwvIM4888x8Pv/CCy/80z/906xZs/bbb7/TTjtt+5tdfPHFe+yxRxNPHjacCWz4UdzdssOpvn37PvXUU7Nnzx47dmzfvn27dOlywAEHjB079he/+MXLL7983HHHJZWkc+fO/fr1O//88//t3/7ty1/+8s5utueee/7d3/3d6aef/uijjzacXWz6zh81atTChQuvuuqqww8/vHv37t26dTvhhBPuuuuu//2///f2PxW3rTPOOGP8+PF/+ctftv0BCYDmyFXyt3AAYIcq65s3ANAU6gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqRWCrV69+/fXXy70KqAirO9ing3rRMvr27ZvbzuzZs1v1QUePHr1gwYKm3/6222478cQTd/be2traAQMG7NYdQmvbetDW1tbmcrld9Gn0bn46RNep3Aug/bj99tuvueaatnzE9evXt9RdLV26NE3TJUuWtNQdQsuqrq7OsqxtPh1C8NqL1nX33Xd37dp16dKlSZKsWrVq3333nTlz5nvvvZfL5e6+++6+fftWVVVNnDhx6yfeihUrxo0b17179379+k2aNGnr9mXLlqVp2qNHj/333//yyy+vr68/5ZRT3njjjQkTJlxyySW7GHzllVdOPvnkbt26DR8+fGdx+u1vfztkyJBhw4a11V6BJtn2oN32tdeyJnw6JO1eBi2hT58+t99++w7f9cUvfvHyyy/Psuzqq68+9dRTsyxbtWpVkiSDBg166aWXFi9efPTRR3/1q19tuPFJJ500fvz4VatWLV68eMSIEZdddlmWZZs2bTryyCPPO++8lStXLlq0aMSIETfccEOWZYMHD545c+YuBtevX9+/f/9vfvOb77///kMPPdStW7cTTjhh+xU++uijf/rTnzZu3JgkyR/+8IfW3E+wG7Y9aD/44IMkSV577bUmfjpk7Z160TL69OnT6H+M9txzz4Z3LVq0qLq6esaMGVVVVYsWLdpar0Kh0HCDefPmdenSZe3atU8++eTee+9dX1/fsP3ZZ5/dY4891q9f/+STT3bp0mX16tWNHnTrp+vOBovFYlVV1bp16xq2X3rppTusVwP1ogJtPWi31quJnw5Ze+fMIS2m0WuvTZs2NWwfOHDg5MmTJ02adN11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vvKVVn3E9evXN/9ONm7c+KUvfenggw9esmTJU0899dxzz339619vidXREVVXV2dZdvjhh7fqQYt60eruvvvurl27Ll26NEmSVatW7bvvvjNnznzvvfdyudzdd9/dt2/fqqqqiRMnbv2UXrFixbhx47p3796vX79JkyZt3b5s2bI0TXv06LH//vtffvnl9fX1p5xyyhtvvDFhwoRLLrlkF4OvvPLKySef3K1bt+HDhy9ZsmT7FT777LM1NTUzZszYb7/9Bg4c+N3vfnfu3LlZlrXhTiK2bQ+tbV97NeWgLffaA1MvWtfEiRNHjBhx6623Jkkybdq0z3/+8xMmTGh41w9/+MNHHnlk4cKFzz333BVXXNGw8ZxzzunRo8dbb7315JNPPvvss9dee22SJJs3bz7ttNO6dOmyePHiP/zhDy+99NJ3v/vdJ554YvDgwTNnzrzrrrt2Nvjxxx+PHTv26KOPXr58+U033TRz5sztVzh8+PCNGzd26dKl4Z8rVqzo2bNnLpdrw51EbDs8tJp40JZpye1Co1M9UJo+ffo0OrT23HPPhnctWrSourp6xowZVVVVixYtyrJs1apVSZIUCoWGG8ybN69Lly5r16598skn99577/r6+obtzz777B577LF+/fonn3yyS5cuq1evbvSgDV8Isizb2WCxWKyqqlq3bl3D9ksvvfSEE07YxUdRW1t7yCGHfPe7323p3UM7t/XQ+uCDD5Ikee2115p40JZpve2B11601ve9Nm3a1LB94MCBkydPnjRp0nXXXTdw4MCtt996AcUxxxyzYcOGxYsXv/rqq+vWrevatWvDRR/HHXfcli1bampqXnnllb59+/bs2XNnD72zwVdfffXQQw/t1q1bw82GDh26i/V/9NFHZ5xxxpAhQ6ZMmdJCu4SOYvtDq4kHbesvrd1SL9rCyy+/nCTJ888/v+3Gzp07N7yxefPmJEk6deq0adOmgQMHNvo/rM997nOdO3fe9am8nQ02utnWR9ze6tWrR40a1bdv3wcffLBTp07N+3DpcLY/tJp40Lbyutoz9aLV/e53v7v//vunT58+d+7cYrG4dfuLL77Y8MbChQu7d+9+6KGHHn744UuWLHnnnXca3cOgQYOWLl3acE5mW1u/OuxscMiQIYsWLfroo48a/vnSSy/tcIXvvPPOiBEjRo4c+ctf/nLrN8Cg6bY/tJp40LbVAtuj1j85SYfQp0+f7a+Yz7Lsww8/7N+//zXXXNPwvYE+ffqsWbOm4ften//852tqav7yl78ceeSRkyZNyrJs8+bNQ4cOHT169F//+td33nnn6quv7tev38cff7xly5Zjjz32wgsvXLVq1ZIlS84+++zzzz8/y7Jhw4ZNmzZtzZo1Oxusr68fNGjQxIkTV69e/eijj/bo0WP773t98MEHhx122PXXX99Wu4r2ZttDa+v3vZp40JZ77YGpF6111UaSJJdddtmVV1558MEHr127Nsuyurq6fv36XXHFFQ31uvHGGz/72c/ut99+kyZN2rBhQ8P9vP3222edddY+++yz7777jhkz5rXXXmvYvmTJktNOO22vvfbq1avX+PHj6+rqsiz7+c9/3r1793POOWcXg4sXLx41atRee+01ZMiQSZMmbV+vW265ZfuVf/jhh227/whs20Nra72aeNCWe+2B5Srz51rSNC33EmhFGzZsePjhh0eNGtWjR49yr4X2o1AolHsJtJ3K/e70tt8g2S35fN5s02cLdctLm02repc8e3q3zyRJ8pO1qw7f8mFbPm4zZyM+vx1qlg7FVRsAxFO5r71ox7p06ZKdeny5VwEE5rUXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPHksixLKk+apuVeAhBMoVAo9xJoO5X7t5WLxWJpg/l8vjmzhbrlpc2mVb072mzNlNrSZgdMrS7XbHM+3nIdk2Zhe84cAhCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEE8uy7Kk8qRpWu4lAMEUCoVyL4G20ympVMVisbTBfD7fnNlC3fLSZtOq3jVTakubHTC12mzbzDbn+S3XMTlr/lWlzY4feUe5Zsuyr+hQnDkEIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgnlyWZUnlSdO03EsAgikUCuVeAm2nU1KpisViaYP5fL45s4W65aXNplW9a6bUljY7YGq12baZbc7zW65jctb8q0qbHT/yjnKtuSyzdCjOHAIQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARBPLsuypPKkaVruJQDBFAqFci+BttMpqVTFYrG0wXw+35zZQt3y0mbTqt7lmq2ZUlva7ICp1R1ttjn7uVzH5Kz5V5U2O37kHeVac1lm6VCcOQQgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiCeXJZlSeVJ07TcSwCCKRQK5V4CbadTUqmKxWJpg/l8PuJsoW55abNpVe+aKbWlzQ6YWt3RZpuzn8t1bMyaf1Vps+NH3tGhZulQnDkEIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgnlyWZUnlSdO03EsAgikUCuVeAm2nU1KpisViaYP5fD7ibKFueWmzaVXvmim1pc0OmFrd0Wabs58jHlcdapYOxZlDAOJRLwDiUS8A4lEvAOJRLwDiUS8A4lEvAOJRLwDiUS8A4lEvAOJRLwDiUS8A4lEvAOJRLwDiUS8A4lEvAOJRLwDiUS8A4sllWZZUnjRNy70EIJhCoVDuJdB2OiWVqlgsljaYz+cjzhbqlpc2m1b1rplSW9rsgKnVHW22Ofs54nHVoWbpUCq3XgDsnlxup++qyNNszaFeAO03Wtvfpr1kTL0A2nW3djgSv2HqBdAxutW+GuaKeYAOlq4Wv59yUC+AUFo2ObmoAVMvgDhaIza5kAFTL4AgWi8zuXgBUy+ACFo7MLlgAVMvgIrXNmnJRQqYegEQj3oBVLa2fEmUC/PyS70AiEe9ACpY278YysV4+aVeAMSjXgDEo14AlapcJ/FyAU4e+h3zAO1IliVz5yabNiWdOydnnhmiQ6XJZRX5G/LTNC33EoBgCoVC0s6U0J4//jG5557kZz9LJk5MLrkkOemkEh+6ItMQ47VXsVgsbTCfz0ecLdQtL202repttm1mIx5XHWqWTyxdmtTXJyeemCxb9sl/7ZfvewG0L7NnJzfdlDzySNKuqRdA+zJhQjJrVnLGGUm7pl4A7Ui/fkm3bkmh8Mkbffok7Vflft8LgN12/PHJu+8mI0d+cs3hiScm7Zd6AbQjuXZ7iXwjzhwCVKpyXbaeVfrl8uoFQEjqBUA86gVQwdr+JF4W4LShegEQknoBVLa2fDGUxXjhpV4AhKReABWvbV4SZWFeeKkX0EEdc8wxy/72K9jr6+sHDRp0xx13DB069Nhjj503b15SmVo7LVmkdKkX0EGNGzfuoYceSpLk8ccfHzNmzNSpU+fPnz9nzpzZs2cnFav1ApMFS5d6AR3UueeeO3fu3CRJfv3rX5933nljx469+OKLly5deu+99yaVrDUyk8VLl3oBHdTgwYNXr169Zs2ahQsXfuELX5g1a9a111575513TpgwIalwLRubLGS6/JZeoOM666yzbr311uOPP37NmjVnnnnmY489NmzYsAEDBiSVL8ta5rfxhk3XJ7+OOKvI1adpWu4lAMEUCoXduv0bb7xx1FFHPf7448OHD58+ffp99923ZcuWiRMnXnHFFUkUuVIbVpFf+XdPVpHy+XzJH5FZs2Y75mzWYSXJbvzXXjhzCBBcln36S7F28GLr/6deAO1F1t4StQuuOQQgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71Aoinrq4un8+PGDEin8/X1dXtYvutt946ZMiQ6dOnJ0myZcuW008/vba2NolPvQDimTZt2siRI59++umTTz75lltu2cX2H/3oR88888yMGTOSJLnrrrvOOeec6urqJL7c3/6odMVJ07TcSwCCKRQKSYcxZMiQefPm9e7de9myZWPGjHnppZd2tr1///6///3vR40atXDhwosuuug3v/lNbhd/gjmQrCLl8/mSPyKzZltpNnszKe2/oLPl2s8lz2YdyWc+85nNmzdnWbZ58+b9999/F9vvvffeE0444Ze//OU3vvGNZ599NmsvnDkEaM8uuuiiBQsWDB48OEmSmpqa008//cEHH0zi61TuBQCw2w444IB33323d+/eK1asOOCAA3a9Pcuym2+++d577x02bNiCBQuGDx8+bty4JDivvQDiGTt27H333ZckyX333Td27NgkSdauXbvD7UmS3HPPPWeccUavXr3Wr1+fZdm6deuS+NQLIJ7vfOc78+fPHzFixFNPPfXtb387SZKzzz57h9tra2sfeOCBSy+9NEmSa6+9dvTo0dddd10SnzOHAPFUVVUVi8Vtt8ybN2+H26urqx955JGGt2/8m6Rd8NoLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHhyWZYllSdN03IvAQimUCiUewm0ncr9CymNfsl/0+XzebNtM1u4rcTZ9Fsdbvbo6SV+YX1hctqc2easOdwxSYfizCEA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDx5LIsSypPmqblXgIQTKFQKPcSaDudkkpVLBZLG8zn82bbZrZwW4mz6bfyR08v8QvNC5NTs02fbc5zFO6YpENx5hCAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B4clmWJZUnTdNyLwEIplAolHsJtJ1OSaUqFoulDebzebNtM1u4rcTZ9Fv5o6eX+IXmhcmp2abPNuc5CndM0qE4cwhAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA8uSzLksqTpmm5lwAEUygUyr0E2k6npFIVi8XSBvP5vNm2mS3cVuJs+q380dNL/ELzwuTUbNNnm/MchTsm6VCcOQQgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiCeXJZlSeVJ07TcSwCCKRQK5V4CbadTUqmKxWJpg/l83mzbzBZuK3E2/Vb+6OklfqF5YXJqtumzzXmOwh2TdCjOHAIQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARBPLsuypPKkaVruJQDBFAqFci+BttMpqVTFYrG0wXw+b7ZtZgu3lTibfqvDzR49vcQvrC9MTpsz25w1hzsm6VCcOQQgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiCeXJZlSeVJ07TcSwCCKRQK5V4CbSirSPl8vuSPyKzZVprN3kxK+y/obLn2c8mz5f66RZty5hCAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B4clmWJZUnTdNyLwEIplAolHsJtKGsIuXz+ZI/IrNmzXbM2XJ/3aJNOXMIQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPLksy8q9BgDYPV57ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPehHY6tWrX3/99XKvgpAcPNGpFy2jb9++ue3Mnj27VR909OjRCxYsaPrtb7vtthNPPHH77StXrhw3bty+++7br1+/qVOntugaaVNbn+La2tpcLreLPu3uwUOl6VTuBdB+3H777ddcc01bPuL69etb5H4uuOCC/v37L126dNGiRaeddtqBBx54ySWXtMg9Uy7V1dVZlrXBwUO5eO1F67r77ru7du26dOnSJElWrVq17777zpw587333svlcnfffXffvn2rqqomTpy49UvJihUrxo0b17179379+k2aNGnr9mXLlqVp2qNHj/333//yyy+vr68/5ZRT3njjjQkTJjSUZmeDr7zyysknn9ytW7fhw4cvWbJk+xUuXrz48ccfv+2226qqqj7/+c+feuqpzzzzTBvuIVrMtk/xtq+9mnLwlHvt7L4MWkKfPn1uv/32Hb7ri1/84uWXX55l2dVXX33qqadmWbZq1aokSQYNGvTSSy8tXrz46KOP/upXv9pw45NOOmn8+PGrVq1avHjxiBEjLrvssizLNm3adOSRR5533nkrV65ctGjRiBEjbrjhhizLBg8ePHPmzF0Mrl+/vn///t/85jfff//9hx56qFu3bieccMLOPoSNGzc+9thjPXv2fOihh1pnJ9G6tn2KP/jggyRJXnvttSYePOVeO7tNvWgZffr0afQ/RnvuuWfDuxYtWlRdXT1jxoyqqqpFixZtrVehUGi4wbx587p06bJ27donn3xy7733rq+vb9j+7LPP7rHHHuvXr3/yySe7dOmyevXqRg+69QvQzgaLxWJVVdW6desatl966aW7qNfgwYO7du16yimnrFq1qhX2EG1h61O8tV5NPHjKtF5K58whLabRa69NmzY1bB84cODkyZMnTZp03XXXDRw4cOvtt15Accwxx2zYsGHx4sWvvvrqunXrunbt2nDRx3HHHbdly5aamppXXnmlb9++PXv23NlD72zw1VdfPfTQQ7t169Zws6FDh+5i/a+//vrq1av33nvvL33pSy20S2hr2z/FTTx4Wn9ptDD1oi28/PLLSZI8//zz227s3LlzwxubN2/+5AqiTp02bdo0cODARv+H9bnPfa5z5865XG4X97+zwUY32/qIO7PPPvtMmTLlj3/84/Lly0v9WCmn7Z/iJh48rbwuWp560ep+97vf3X///dOnT587d26xWNy6/cUXX2x4Y+HChd27dz/00EMPP/zwJUuWvPPOO43uYdCgQUuXLm04F7StrV+VdjY4ZMiQRYsWffTRRw3/fOmll7Zf3iOPPFJVVVVfX9/wz/fff3/PPfesrq5u3gdNeWz/FDfx4GmrBdJymnHWET79qo0PP/ywf//+11xzTcP3JPr06bNmzZqG73t9/vOfr6mp+ctf/nLkkUdOmjQpy7LNmzcPHTp09OjRf/3rX995552rr766X79+H3/88ZYtW4499tgLL7xw1apVS5YsOfvss88///wsy4YNGzZt2rQ1a9bsbLC+vn7QoEETJ05cvXr1o48+2qNHj+2/77V+/fpBgwZdfvnltbW1L7zwwhFHHHHJJZe01W6jJW37FG/9vlcTD55yr53dpl601lUbSZJcdtllV1555cEHH7x27dosy+rq6vr163fFFVc01OvGG2/87Gc/u99++02aNGnDhg0N9/P222+fddZZ++yzz7777jtmzJjXXnutYfuSJUtOO+20vfbaq1evXuPHj6+rq8uy7Oc//3n37t3POeecXQwuXrx41KhRe+2115AhQyZNmrTDqzbefPPNsWPH7rvvvv3797/pppvWr1/fhnuOFrPtU7y1Xk08eMq9dnZbbtc/0NfRpGla7iV0CBs2bHj44YdHjRrVo0ePcq+FllcoFMq9BDqA3Q9ee5bP50vek2abbuzYsWV5XLNtM1vuz2M6BFdtABCPelEGXbp0KfcSgNjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B4clmWlXsNFSRN03IvAcIrFArlXgLtX6dyL6DiFIvF0gbz+Xy5Zmum1JY2O2BqtdnKnw13TEIbcOYQgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeHJZlpV7DRUkTdNyLwHCKxQK5V4C7V+nci+g4hSLxdIG8/l8uWZrptSWNjtgavWs+VeVNjt+5B1mmz7bnOco3DEJbcCZQwDiUS8A4lEvAOJRLwDiUS8A4lEvAOJRLwDiUS8A4lEvAOJRLwDiUS8A4lEvAOJRLwDiUS8A4lEvAOJRLwDiUS8A4lEvAOLJZVlW7jVUkDRNy70ECK9QKJR7CbR/ncq9gIpTLBZLG8zn8zVTakubHTC1ulyzs+ZfVdrs+JF3mG36bHOeo+Yck2WZhTbgzCEA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDx5LIsK/caKkiapuVeAoRXKBTKvQTav07lXkDFKRaLpQ3m8/maKbWlzQ6YWj1r/lWlzY4feYfZyp9tzrHRnGOyLLPQBpw5BCAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIJ5clmXlXkMFSdO03EuA8AqFQrmXQPvXqdwLqDjFYrG0wXw+XzOltrTZAVOrZ82/qrTZ8SPvMFv5s805NppzTJZlFtqAM4cAxKNeAMSjXgDEo14AxKNeAMSjXgDEo14AxKNeAMSjXgDEo14AxOM3RQG0tFxup+/yq2VbiHoBtH60tr+NjDWPegG0Sbd2OKJhpVIvgLbt1vbjGrb7XLUBUKZ0tfj9dCTqBVAByRGw3aReAJURGwHbHeoFUDGZEbAmy2W+W7iNNE3LvQQIr1AoJO1YGwTGl+UmcM1hY8VisbTBfD5fM6W2tNkBU6vLNTtr/lWlzY4feYfZps+W6/ltzvFc8mx71javjXI5AftUzhwCEI96AVTeN6V8A+zTqBcA8agXQEW+GPLya5fUC4B41AuAeNQLoFJP4jl5uHN+3gugFWRZMndusmlT0rlzcuaZOtTivPYCaAV/+lPyu98l48YlDz2ULFhQ7tW0Q+oF0AqWLk3q65MTT0yWLfvkP1qaegG0jtmzk5tuSh55pNzraJ/UC6B1TJiQzJqVnHFGudfRPqkXQCvo1y/p1i0pFD55o0+fcq+mHXLNIUArOP745N13k5EjP7nm8MQTy72adki9AFqBS+RbmTOHAJ+mXH9ty1/52jn1AiAe9QIgnlzmlek20jQt9xIgvEKhkLRLbfytLF+cd8lVG40Vi8XSBvP5fLlma6bUljY7YGr1rPlXlTY7fuQdZttmtjnPb1mOSWgDzhwCVN6LIS+8Po16ARCPegFU2EsiL7yaQL2AcjrmmGOW/e1XsNfX1w8aNOiOO+4YOnToscceO2/evKQytXZapKtp1Asop3Hjxj300ENJkjz++ONjxoyZOnXq/Pnz58yZM3v27KRitV5gpKvJ1Asop3PPPXfu3LlJkvz6178+77zzxo4de/HFFy9duvTee+9NKllrZEa6dod6AeU0ePDg1atXr1mzZuHChV/4whdmzZp17bXX3nnnnRMmTEgqXMvGRrp2k5/3AsrsrLPOuvXWW48//vg1a9aceeaZjz322LBhwwYMGJBUvixrmR9hlq7dp15AmZ177rlHHXXU448/XlVV9aUvfenEE0/csmXLP/7jPyYhNISn5IbpVqnUCyizwYMH19fXN7w9+W+ScEpomG41j3oBtJCtQdpFxkSrhagXQEuTqNbnmkMA4lEvAOJRLwDiUS8A4lEvAOJRLwDiyWWu7NxGmqblXgKEVygUyr0E2j8/79VYsVgsbTCfz5drtmZKbWmzA6ZWz5p/VWmz40feYbZtZpvz/JblmIQ24MwhAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXQOnq6ury+fyIESPy+XxdXd0utt96661DhgyZPn16kiRbtmw5/fTTa2tL/FkI1AugWaZNmzZy5Minn3765JNPvuWWW3ax/Uc/+tEzzzwzY8aMJEnuuuuuc845p7q6uqxrj029AEr38MMPn3/++UmSnH/++b/97W93sb1z587/8R//0aVLl/fff3/u3LkTJkwo68LDUy+A0q1cufLAAw9MkuSggw5auXLlLrZPmzbtK1/5yi233DJlypTvfe97uVyurAsPT70A2sJFF120YMGCwYMHJ0lSU1Nz+umnP/jgg+VeVGB+zyFA6Q444IB33323d+/eK1asOOCAA3a9Pcuym2+++d577x02bNiCBQuGDx8+bty48q09Nq+9AEo3duzY++67L0mS++67b+zYsUmSrF27dofbkyS55557zjjjjF69eq1fvz7LsnXr1pV7+YGpF0DpvvOd78yfP3/EiBFPPfXUt7/97SRJzj777B1ur62tfeCBBy699NIkSa699trRo0dfd9115V5+YM4cApSuqqqq0Z+SmTdv3g63V1dXP/LIIw1v3/g3bbvS9sZrLwDiUS8A4lEvAOLJZVlW7jVUkDRNy70ECK9QKJR7CbR/rtporNE3Wpsun883Z7ZmSom/r3PA1OrmzM6af1Vps+NH3mG2bWab8/yW5XiGNuDMIQDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPHksiwr9xoqSJqm5V4ChFcoFMq9BNq/TuVeQMUpFoulDebz+ebM1kypLW12wNTqWfOvKm12/Mg7zFb+bHOOjbIcz9AGnDkEIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgnlyWZeVeQwVJ07TcS4DwCoVCuZdA+9ep3AuoOMVisbTBfD7fnNmaKbWlzQ6YWj1r/lWlzY4feUfE2ebsq442W5bjGdqAM4cAxKNeAMSjXgDEo14AxKNeAMSjXgDEo14AxKNeAMSjXgDEo14AxKNeAMSjXgDEo14AxKNeAMSjXgDEo14AxKNeAMSjXgDEk8uyrNxrqCBpmpZ7CRBeoVAo9xJo/zqVewEVp1gsljaYz+ebM1szpba02QFTq2fNv6q02fEj74g425x9Va7nt0PNQhtw5hCAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B4clmWlXsNFSRN03IvAcIrFArlXgLtX6dyL6DiFIvF0gbz+XxzZmum1JY2O2Bqtdmmz5br+e1Qs9AGnDkEIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgnlyWZeVeQwVJ07TcS4DwCoVCuZdAB5CxjXw+X/KeNGvWbINyfx7TIThzCEA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDy5LMvKvYYKkqZpuZcA4RUKhXIvgQ4gYxv5fL7kPWnWrNkG5f48pkNw5hCAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B4clmWlXsNALB7vPYCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIAnn/wIXNxxJtw6kZgAAAABJRU5ErkJggg=="
            },
            {
              "type": "input_text",
              "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
            }
          ],
          "solved_count": 0,
          "total_training_examples": 3,
          "pixel_accuracy": 0.0
        },
        "test_result": {
          "execution_error": "Traceback (most recent call last):\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmpsfel6xdd.py\", line 30, in <module>\n    from scipy.ndimage import label, binary_fill_holes\nModuleNotFoundError: No module named 'scipy'\n",
          "timed_out": false,
          "predicted_output": null
        },
        "status": "failed_test",
        "feedback_sent": true
      },
      {
        "turn_number": 2,
        "timestamp": "2025-07-10T13:41:54.161845",
        "input_tokens": 13793,
        "output_tokens": 1424,
        "turn_cost": 0.0077956,
        "program_extracted": true,
        "program": "def transform(grid):\n    import numpy as np\n    from collections import deque, Counter\n\n    grid = np.array(grid)\n    h, w = grid.shape\n    output = np.array(grid)  # start from input copy\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def neighbors(r, c):\n        for nr, nc in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\n            if 0 <= nr < h and 0 <= nc < w:\n                yield nr, nc\n\n    def bfs_component(sr, sc):\n        \"\"\"Get all connected pixels (4-dir) of nonzero pixels starting at (sr, sc).\"\"\"\n        q = deque()\n        q.append((sr, sc))\n        comp_pixels = []\n        visited[sr, sc] = True\n        while q:\n            r, c = q.popleft()\n            comp_pixels.append((r,c))\n            for nr, nc in neighbors(r,c):\n                if not visited[nr, nc] and grid[nr, nc] != 0:\n                    visited[nr, nc] = True\n                    q.append((nr, nc))\n        return comp_pixels\n\n    def flood_fill_inside(outline_set, start, outline_color):\n        \"\"\"Flood fill from start pixel inside the outline boundary.\n        outline_set: set of outline pixels (r,c)\n        fill inside only within bounding box limits.\n        Return set of filled pixels.\"\"\"\n        q = deque()\n        q.append(start)\n        filled = set()\n        filled.add(start)\n        while q:\n            r,c = q.popleft()\n            for nr,nc in neighbors(r,c):\n                if (nr,nc) in outline_set:\n                    continue\n                if (nr,nc) in filled:\n                    continue\n                # Must be inside bounding box and not on outline\n                # Also only fill pixels that are zero or inside area (not outside)\n                # We trust outline forms closed polygon so flood_fill won't leak outside\n                filled.add((nr,nc))\n                q.append((nr,nc))\n        return filled\n\n    # Find all connected components of nonzero pixels (likely outlines)\n    components = []\n    for r in range(h):\n        for c in range(w):\n            if grid[r,c] != 0 and not visited[r,c]:\n                comp = bfs_component(r,c)\n                components.append(comp)\n\n    # Process each component\n    for comp_pixels in components:\n        # Colors in component\n        comp_points = comp_pixels\n        comp_vals = [grid[r,c] for r,c in comp_points]\n        # Outline color: majority (likely uniform)\n        cnt = Counter(comp_vals)\n        outline_color, _ = cnt.most_common(1)[0]\n\n        # Make set of outline pixels for fast lookup\n        outline_set = set(comp_points)\n\n        # Get bounding box\n        rows = [p[0] for p in comp_points]\n        cols = [p[1] for p in comp_points]\n        rmin, rmax = min(rows), max(rows)\n        cmin, cmax = min(cols), max(cols)\n\n        # Find a seed point inside to flood fill from\n        # Try center point of bounding box\n        sr = (rmin + rmax) // 2\n        sc = (cmin + cmax) // 2\n\n        # If center is on outline, try to move inside (up to 10 steps)\n        found_seed = False\n        for dr in range(-5,6):\n            for dc in range(-5,6):\n                rr, cc = sr+dr, sc+dc\n                if rmin <= rr <= rmax and cmin <= cc <= cmax:\n                    if (rr, cc) not in outline_set:\n                        found_seed = True\n                        sr, sc = rr, cc\n                        break\n            if found_seed:\n                break\n        if not found_seed:\n            # Cannot find inside seed, skip filling this component\n            continue\n\n        # Get fill area by flood fill inside outline\n        fill_area = flood_fill_inside(outline_set, (sr, sc), outline_color)\n\n        # Determine fill color: most common nonzero color inside fill_area in input that is not outline_color\n        interior_colors = []\n        for (rr, cc) in fill_area:\n            v = grid[rr, cc]\n            # exclude outline color and zero\n            if v != 0 and v != outline_color:\n                interior_colors.append(v)\n        if interior_colors:\n            fill_color = Counter(interior_colors).most_common(1)[0][0]\n        else:\n            # If no other colors, as fallback try colors inside bounding box excluding outline pixels\n            # Just pick zero or outline_color otherwise\n            fill_color = 0\n\n        # Fill interior in output (keep outline pixels unchanged)\n        for (rr, cc) in fill_area:\n            output[rr, cc] = fill_color\n\n        # outline pixels remain unchanged, so nothing to do\n\n    return output.tolist()",
        "training_feedback": {
          "feedback_messages": [
            {
              "type": "input_text",
              "text": "Training results: 0/3 examples solved, 21.4% pixel accuracy - Good partial progress! Your approach is capturing some patterns. Next, try to identify a transformation that solves at least one of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 1, 1, 1, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]]\nPixel accuracy: 6.3%\n\nTraining Example 2 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 6, 6, 6, 0, 0], [0, 0, 2, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 2, 2, 2, 3, 3, 3, 3, 3, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 6, 6, 6, 6, 6], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]]\nPixel accuracy: 9.4%\n\nTraining Example 3 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 3, 3, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 3, 3, 6, 6, 6, 6, 6, 6, 3, 3, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 3, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0], [0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 3, 0, 0, 0, 8, 0, 0, 8, 0, 3, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 0, 3, 0, 6, 0, 0, 2, 0, 0, 3, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 3, 0, 0, 0, 0, 6, 0, 0, 0, 3, 0, 0], [0, 0, 3, 0, 0, 6, 0, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 69.6%\n\n"
            },
            {
              "type": "input_image",
              "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA88AAAUtCAIAAABNteEnAABTSElEQVR4nO3de5xVdb3w8bVxGETBGaUyEaiQRHvxeMm7qaHwvFLwsndgPZp64KCmhRQImufF0fJgmvBo0cV8UkAzypO1tpfMQ55E8ihlSt41EvQgox5vgyLIRdbzqulMHBCCPfOdNZv9fr/6Y9yzv3v9Zs1ei0+btTeFLMsSAAAgQJeIBwUAANQ2AAAEUtsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAnbK2x44dW9i000477T3vU19f/8EPfvDEE098+OGHN37MX/3qV4VCYZdddnnnnXc2+NYtt9xSKBSuu+66lv8cNWpUoVCYOnXqBnd74YUXCoXC5MmT2zLV4p133rn22muPPvro3r17d+vWrXfv3ieffPJvfvObzeyTyZMnb2qHPP7445vfaUOHDv27O7b1Pmeeeeb6t7csb8SIEQ888MD66ykWixvc7SMf+ci4cePeeOONrdr5LV599dUpU6bsv//+DQ0NO+6448EHH3zddddlWbbB5jYYf+ihh97//vf37Nnznnvu2cyuAwDY9uTw2vaaNWtefvnl22+//eijj160aNEG350xY0aSJG+88cbNN9+8JY928cUXP/3001u7hi2Zeu655w477LBzzjln7ty5L7744urVq1988cVbbrnlqKOOuuqqq5JOpmV5P//5z4844ogf/ehHm7nbc8899+1vf/vYY49dt27dVu38Bx54YN999/3nf/7nP/zhD2+++eaKFSsefPDBs846a8yYMZtZ2K9//eujjz763Xffvfvuu48++ug2/IgAADVW29/5zney//bTn/40SZKZM2e23nLTTTe13nPx4sWtt7/zzjtPPfXUqaee+uabb15zzTXrP2Bzc3O5XD755JN32WWX73//+1uyhtWrV48aNerdd9/dqpX/3ak1a9aMHDnyD3/4w+GHH37bbbe9+uqra9as+c///M/vfe97u+yyywUXXNDyQvWmLFiwINvIoEGD3nOHtLr77rvXf5Atuc+LL77YcvvKlSv/9Kc/feUrX8my7B//8R+ff/759e+2cuXK9Xf+0KFDf/e73/3qV7/a8p3/X//1X6VSqamp6ZRTTpk/f/6bb775+uuvl8vl/v37z5w589prr33P/ZCm6bBhw3bYYYe5c+cecsghm9ljAADbpBxe2+7Wrdtee+31jW98I0mSDV7bnj179jvvvPP5z39+9OjR8+fPf/TRR//uo5133nm//e1v/+///b9btYa/O3XDDTc89NBDQ4cOnTdv3gknnNCrV6+6urq+ffuee+65P//5z999990f//jHSWey/fbb77HHHpdffvnFF1+8evXqb37zm5vZ+V/+8pdbSn3Ld/5VV1318ssvjx8/fvbs2YccckjPnj133nnnk0466d57791xxx2vuuqq9a8naXH99deffPLJH/jAB37zm9/ss88+rbfPmjWrUCh85zvfadcdAADQGeVQ26tWrXriiScmTJiQJMmee+65/rdmzpy59957H3PMMeeee+522223JS9vf/3rXx8wYMDFF1/81FNPbfka/u7U7NmzC4XC//t//2+77bbb4Fuf/OQnn3zyySlTpiSd0vnnn7/DDjv827/923t+d82aNX/84x+nT59eV1f3yU9+cst3/r/+679279790ksv3eAB+/Tpc999982dO7dQKKx/+5VXXnnmmWf279//vvvu++hHP9p+Px8AQDXpoNr+yEc+0vpGve23337QoEE//elP3/e+933pS19qvc/jjz/++9//ftKkSYVCYY899jj55JN/9KMfLV++fPOPvMMOO8ycOXPNmjVbdT3J351asGDB3nvv/ZGPfOQ9x/fee+8N4nID+++//wbvbrzvvvs2tUNazZ07d2vvs7GePXt+9KMf3eAvDbp3794yXl9fP3DgwP/4j/+44YYb1v/pNr/z16xZ89xzzx188ME9evTYeIv77bffbrvttv4tF1xwwYUXXpgkyZFHHtmvX78N7j9q1Kgsy8aOHbv5HwQAYBuQzycA7r777v/4j//4yCOPfPCDH2y9ccaMGbvvvvvnPve5lv+86KKL3nrrrS25YOOII44YN27c7373u2nTpm35GjYztWbNmubm5l133XX9Gzf4nJAPf/jDSWfVq1evVX+xqTu8++678+fPX7NmzRbu/Obm5izLevXqtYUL+Pa3v33YYYcNHTp0xowZP//5z9v20wAAVLEOqu2WN/ytXr36Jz/5ScuLr1dccUXv3r1b77BmzZqbbrpp6dKl3bp1a8nZfffdN8uyLXyv5Ne//vWPfvSjl1xyyZNPPrnlq9rUVNeuXXv27PnKK68kldr4XZJHHHHE330H5ODBg7f2Pu/pjTfe6Nq1a7du3TZ+l+Tq1asXLVr0xS9+8dvf/vbEiRO3cOfvsssuXbp02fIdMnr06Llz595444277LLLWWedtXTp0i0cBADYxnToa9tdu3b97Gc/e/PNN997773HHnvs+p/KfMcdd7xnzD388MMPPvjg333k7t27V3A9yWam/tf/+l9PPvnkf/7nf77nB7AccMABSWe1fPnyxx9/fO+9937P73bt2vUjH/nItGnTBg0aNGvWrC3c+dttt93ee+/9+9//fsWKFRvf7fLLLz/jjDOamppab/ne975XX1+/2267fec733n99dfPOOOMjT9tEACgFuRwJclxxx133nnnPfzww62vrbZcybD99tsvW7Zs/ddx77///iRJNvXpchv4xCc+8aUvfenBBx/c+F+uqWDqc5/73Lp1677whS+8Z7tv/PkbncfVV1+9Zs2aY489dvN369Kly/Lly9euXbuFO79YLK5cufKrX/3qBo/z3HPPXXnllXfcccd7XmdyyimnjBw58te//vVWXeQDALDNyOe67a9//ev9+vW75pprfvvb3yZJ8tJLL911110nnHDCTjvttP7dDjvssIEDB/74xz9etmzZljzsZZdd9tGPfvR73/veVi3mPafOPPPMAw444Be/+MXBBx/8r//6ry+99NKaNWta/nWb4cOHP/zww126dK5/9H7VqlXPPPPM5MmTv/a1r+2www6beg9ilmUvvPDCpEmTHn300f3337+urm4Ld/748eN79eo1derUM8444/e///3KlStffvnl2bNnDx48uLm5edKkSetfuLK+a665Ztddd508efJDDz0U86MDAHRe+STjjjvu+O1vf3vdunWf//zn165de+ONN65du7b1LXrr+4d/+IcVK1b88Ic/3PIrQzb/aSFbOFVfX18ulw877LCHH374s5/97G677VZfX9/yL7ffeeedAwcO3MJ/6nJT3vPzRgqFwvqfwbIl99ltt91aP+llr732uuyyy1r+mfq+fftu8DO23K1Lly59+/adNm1aly5dWj7EcAt3fq9evW6++eaePXv+8Ic/POigg3bYYYcPfvCDn/vc555//vlSqXTBBRds6id93/ve94Mf/GDNmjWnnnrq22+/7fO2AYCaktsLtCeeeGKxWHzkkUe++c1vzpo1a+eddz7uuOM2vtsZZ5zRpUuXLbyYpOXKkJZ/umWrvOdUnz59fvOb39x0003Dhg3r06dPfX39rrvuOmzYsBtuuOHxxx8/6KCDks6ka9euffv2/T//5//8x3/8xymnnLKpu2233XYf+MAHhg8f/qtf/arlapMt3/lDhgxZsGDBuHHj9tprrx49enTv3v2QQw657rrrfvazn238qeTrO+GEE0aNGvXHP/5x/Q98BACoBYXOfAkyAABUtc518TEAAGxL1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLVNFXvttdeefvrpvFcBsM1ymoW2U9u0jz59+hQ2ctNNN4VudOjQofPnz9/y+0+bNu3QQw/d1Hebm5v79++/VQ8I0DHe9773tZ5a6+vr99577+nTp1f8aK0nw+bm5kKhsJmedpqFtlPbtJurr746+59OO+200C2uXLmyvR5qyZIlQ4cOXbx4cXs9IED7uuaaa1pOrW+//fbUqVMnTpz4wx/+sI2P2djYmGXZXnvttak7OM1C26ltYl1//fXdunVbsmRJkiSvvPLKTjvtNHPmzFdffbVQKFx//fV9+vRpaGgYM2ZM6wn9xRdfHDlyZI8ePfr27TthwoTW25cuXVoqlXr27Pn+97//C1/4wqpVqwYPHvzMM8+MHj36zDPP3MzgE088ceSRR3bv3v3www/f1Fn+F7/4xaBBgw444ICO2isAlevatevxxx8/ZMiQNE1feumlQqFw0UUXNTQ0jBo1amtPhuu/tu00C0HUNrHGjBlzxBFHXHHFFUmSXHbZZQceeODo0aNbvnXllVfeddddCxYseOihh8aOHdty44gRI3r27Pncc8/de++9Dz744Pjx45Mkeffdd4877rj6+vpnn332gQceeOyxxy655JK5c+cOHDhw5syZ11133aYG33nnnWHDhu27775NTU0XXXTRzJkz33OR3bp1u/vuu7/73e924I4BaJO1a9f26NGj5eunn376hRdeuPTSSys+GTrNQqAN/uofKrP77rtv8NTabrvtWr61cOHCxsbGq666qqGhYeHChVmWvfLKK0mSpGnacoc5c+bU19cvX7783nvv3WGHHVatWtVy+4MPPtilS5eVK1fee++99fX1r7322gYbbfljIMuyTQ2Wy+WGhoYVK1a03H722Wcfcsghm/oR1qxZkyTJAw88ELB7ANqkV69erVeSNDc3z5w5s0uXLnfccceLL76YJMmdd97Z8q2tPRm+8cYbSZI89dRTTrMQx2vbRF23vXbt2pbbBwwYMGnSpAkTJpx//vkDBgxovX/rO2n222+/1atXP/vss08++eSKFSu6devW8k6ggw46aN26dYsWLXriiSf69Omzyy67bGrTmxp88skn99hjj+7du7fcbf/99w/eBwBRzj333JZT3K677jpt2rTvfve7w4cPb/lWv3792ngydJqFOGqbjvD4448nSfLwww+vf2PXrl1bvnj33XeTJKmrq1u7du2AAQM2+H+EH/vYx7p27VooFDbz+Jsa3OBurVsEqDqtr22/8847jz/++DnnnNP6rW7durXxZOg0C3HUNuF++ctf3nzzzVOnTr311lvL5XLr7Y8++mjLFwsWLOjRo8cee+yx1157LV68+IUXXtjgEfbcc88lS5a0/I3n+lr/bNjU4KBBgxYuXPj222+3/Odjjz3W3j8cQCdS8cnQaRbiqG1iLV++/Jxzzhk3btzEiRPPOuussWPHvvXWWy3fuuCCCxYvXrxw4cILL7zw7LPP7tat2zHHHLPPPvuMHj16yZIlS5cu/fKXv9yvX79Vq1YdeeSRgwYNOu+881599dXnnntuxIgRp5xySpIkO+64Y1NT01tvvbWpwU996lO77bbbl770pddff/3uu++eMWNG3vsDIFDFJ0OnWYijtmk348eP3+BftznnnHP+6Z/+qUuXLlOmTEmSZOrUqV26dPmnf/qnlvsPHTr06KOPPuSQQ/73//7fLR9a0qVLl3K5vOOOO+69994f+9jHnnnmmTlz5rRcJvizn/3s9ddf79u374EHHrjTTjtde+21SZKcc845l19++ejRozc1WF9f/8tf/vK5557bfffdx48ff9ZZZ+W9kwACVXwydJqFOIUsyyoeLpVK7boYasXq1avvvPPOIUOG9OzZM++1wN+Xpmku23WOBWpB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ydKlf/5f3ly3DQDAtuWmm5KLLkruuivpBNQ2AADbltGjk1mzkhNOSDoBtQ0AwDakb9+ke/ckTf/8xe67570an0kCAMC25OCDk5deSo466s+fSXLooXmvRm0DALAtKeT8kX8bcCUJAACdVZZV+3bVNgAARFHbAAAQRW0DANCJZVlVb1FtAwBAFLUNAEDnlmXVuy21DQAAUdQ2AACdXpZV6VbUNkB72m+//ZYuXZokyapVq/bcc8/p06fvv//+H//4x+fMmZP30gCqXJZV4+OrbYD2NHLkyNtuuy1JknvuuefYY4+dMmXKvHnzZs+efdNNN+W9NIDql2VV98hqG6A9nXzyybfeemuSJLfffvtnPvOZYcOGnXHGGUuWLLnxxhvzXhrANiHLqutVc7UN0J4GDhz42muvvfnmmwsWLPjEJz4xa9as8ePHX3PNNaNHj857aQDbiiyrogtU6kIfHaAGnXTSSVdcccXBBx/85ptvnnjiiXffffcBBxzQv3//vNcFsA3JsqRQaJ/HCVbI2rCNUqnUrosB6IzSNN2q+z/zzDP77LPPPffcc/jhh0+dOvUnP/nJunXrxowZM3bs2K16HOdYoBakW3mO3VDFzd1Rn+Hd1toul8uVzRaLRbNbMTvgGxXO/unCmputwt/vosnNlc32n9JodstnK/4dteU82RalUild1lThbENvs2bNmq2K2eTXv03abquau2PP6q4kAQCgymXZ38/unF46UdsAAGwrsnySejN8JgkAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBQfdatWzdu3LjDDjvsqKOOWrRoUevtK1as+OxnPzt48OADDjjgF7/4RZIkV1xxxaBBg6ZOndoyNXz48Obm5g5bp9oGAKD6fP/73+/Zs+cDDzwwfvz4iRMntt7+ne9856CDDpo7d+4dd9zxxS9+MUmSb33rW/fff/9VV12VJMl11103YsSIxsbGDltnIcuyiodLpVK7LgagM0rTNJftOscCtSCt9Bz7iU984oYbbhgwYMDq1au/+c1vXnDBBS23v/HGGzvuuGN9ff3dd9997rnnLly4sF+/fr/+9a+HDBmyYMGC008//Y477igUCklHqWvjfLlcrmywWCxW5eyAb1Q4+6cL85o99dRTK5udPXt2XrNt2lfV+Lwy27lnc5Qua6pssNTQ26xZs2arYrZif/zjH2/7i5133vnqq69uvX3nnXdOkuT000//+c9/fttttyVJctlll5122mmXX3755MmTv/a1r3VkaruSBACAqrR69eoPfehDc+fOPe2008aMGbPBd3/4wx/Onj37hhtuaCnv+fPnDxw4MEmSRYsWDR8+/JZbbumwdaptAACqz6677losFlv+9vLRRx9tvf28885bu3ZtkiTHH398y7skkyTJsuziiy/+l3/5lwsuuOD6669vveykA6htAACqzzHHHDNv3rwkSebNm7fvvvsmSbJ8+fIkSZYtW9Zy6eD999/f8np2kiQzZsw44YQTevXqtXLlyizLVqxYUTXXbQMAQMe79NJLx4wZc+mll9bV1V177bVJknz605+eM2fOlClT/uEf/uHb3/52fX39jBkzkiRpbm7+6U9/eueddyZJMn78+KFDh55//vkdtk61DQBA9fnABz5w++23r3/LnDlzkiTp16/fPffcs/7tjY2Nd911V8vXX/mLjlynK0kAACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACBKIcuyiodLpVK7LgagM0rTNJftOscCtSDN6RzbYeraOF8ulysbLBaLVTk74BsVzv7pwlNPPbWy2dmzZ9fabFv2c1U+r8x27tkcpcuaKhssNfQ2a9as2aqY3ea5kgQAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiFLIsqzi4VKp1K6LAeiM0jTNZbvOsUAtyOsc22Hq2jhfLpcrGywWi1U5O+AbFc7+6cJTTz21stnZs2fX2mxb9nNVPq/Mdu7ZHKXLmiobLDX0NmvWrNmqmN3muZIEAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIhSyLKs4uFSqdSuiwHojNI0zWW7zrFALUhzOsd2mLo2zpfL5coGi8ViVc4O+EaFs3+68NRTT61sdvbs2bU225b9XJXPK7OdezZH6bKmygZLDb3NmjVrtipmt3muJAEAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAohSyLKt4uFQqtetiADqjNE1z2a5zLFAL0pzOsR2mro3z5XK5ssFisViVswO+UeHsny489dRTK5udPXt2rc22ZT9X5fPKbOeezVG6rKmywVJDb7NmzZqtitltnitJAAAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAohSzLKh4ulUrtuhiAzihN01y26xwL1II0p3Nsh6lr43y5XK5ssFgsVuXsgG9UOPunC2tt9tRTT61sdvbs2W1aczU+r8x27tkcpcuaKhssNfQ2a9as2aqY3ea5kgQAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiFLIsqzi4VKp1K6LAeiM0jTNZbvOsUAtSHM6x3aYujbOl8vlygaLxaLZKpgd8I0KZ/90YW6z1bifzXbu2Ryly5oqGyw19DZr1qzZqpjd5rmSBAAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIUsiyrOLhUqnUrosB6IzSNM1lu86xQC1IczrHdpi6Ns6Xy+XKBovFolmzZs1WxWyO0mVNlQ2WGnqbNWvWbFXMbvNcSQIAAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARClkWVbxcKlUatfFAHRGaZrmsl3nWKAWpDmdYztMXRvny+VyZYPFYtGsWbNmq2I2R+mypsoGSw29zZo1a7YqZrd5riQBAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKIUsiyreLhUKrXrYgA6ozRNc9mucyxQC9KczrEdpq6N8+VyubLBYrFo1qxZs1Uxm6N0WVNlg6WG3mbNmjVbFbPbPFeSAABAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABRClmWhT04AADUNK9tAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2/AeXnvttaeffjrvVQBsEacs6MzUNp1dnz59Chu56aabQjc6dOjQ+fPnb/n9p02bduihh258+8KFC48//vjGxsbddtvt85///JtvvtmuywQ6l/e9732tp6n6+vq99957+vTpFT9a64mlubm5UChspqedsqAzU9tUgauvvjr7n0477bTQLa5cubLtD7JmzZrjjz/+wx/+8OLFi3/zm9889NBD55xzTnusDui8rrnmmpbT1Ntvvz116tSJEyf+8Ic/bONjNjY2Zlm21157beoOTlnQmaltqtX111/frVu3JUuWJEnyyiuv7LTTTjNnznz11VcLhcL111/fp0+fhoaGMWPGtP4h9OKLL44cObJHjx59+/adMGFC6+1Lly4tlUo9e/Z8//vf/4UvfGHVqlWDBw9+5plnRo8efeaZZ25m8IknnjjyyCO7d+9++OGHL168eOMVPvjgg4sWLbrqqqt23nnnAQMGXHLJJbfeemuWZR24k4DcdO3a9fjjjx8yZEiapi+99FKhULjooosaGhpGjRq1tSeW9V/bdsqCqqO2qVZjxow54ogjrrjiiiRJLrvssgMPPHD06NEt37ryyivvuuuuBQsWPPTQQ2PHjm25ccSIET179nzuuefuvffeBx98cPz48UmSvPvuu8cdd1x9ff2zzz77wAMPPPbYY5dccsncuXMHDhw4c+bM6667blOD77zzzrBhw/bdd9+mpqaLLrpo5syZG6/w8MMPX7NmTX19fct/vvjii7vsskuhUOjAnQTkbO3atT169Gj5+umnn37hhRcuvfTSik8sTllQlTb4C3robHbfffcNnrTbbbddy7cWLlzY2Nh41VVXNTQ0LFy4MMuyV155JUmSNE1b7jBnzpz6+vrly5ffe++9O+yww6pVq1puf/DBB7t06bJy5cp77723vr7+tdde22CjLX90ZVm2qcFyudzQ0LBixYqW288+++xDDjlkMz9Fc3PzRz7ykUsuuaS9dw/QifTq1av1SpLm5uaZM2d26dLljjvuePHFF5MkufPOO1u+tbUnljfeeCNJkqeeesopC6qR17apvuu2165d23L7gAEDJk2aNGHChPPPP3/AgAGt9299989+++23evXqZ5999sknn1yxYkW3bt1a3r100EEHrVu3btGiRU888USfPn122WWXTW16U4NPPvnkHnvs0b1795a77b///ptZ/9tvv33CCScMGjRo8uTJ7bRLgE7q3HPPbTld7LrrrtOmTfvud787fPjwlm/169evjScWpyyoRmqb6vb4448nSfLwww+vf2PXrl1bvnj33XeTJKmrq1u7du2AAQM2+P+aH/vYx7p27br5vyfd1OAGd2vd4sZee+21IUOG9OnT55Zbbqmrq2vbjwt0dq2vbb/zzjuPP/74+m807NatWxtPLE5ZUI3UNlXsl7/85c033zx16tRbb721XC633v7oo4+2fLFgwYIePXrssccee+211+LFi1944YUNHmHPPfdcsmRJy9/Srq/1z7NNDQ4aNGjhwoVvv/12y38+9thj77nCF1544YgjjjjqqKN+9KMftV4NCdS4ik8sTllQjdQ21Wr58uXnnHPOuHHjJk6ceNZZZ40dO/att95q+dYFF1ywePHihQsXXnjhhWeffXa3bt2OOeaYffbZZ/To0UuWLFm6dOmXv/zlfv36rVq16sgjjxw0aNB555336quvPvfccyNGjDjllFOSJNlxxx2bmpreeuutTQ1+6lOf2m233b70pS+9/vrrd99994wZMzZeYXNz8zHHHHPiiSdeeeWV3mkEtKr4xOKUBVWpna7/ho57l2SSJJ///OfPO++8D3/4w8uXL8+ybNmyZX379h07dmzLuyS/8pWvfOhDH9p5550nTJiwevXqlsd5/vnnTzrppB133HGnnXY69thjn3rqqZbbFy9efNxxx22//fa9evUaNWrUsmXLsiz7wQ9+0KNHjxEjRmxm8Nlnnx0yZMj2228/aNCgCRMmbPyWo8svv3zjlb/11lsdu/+AfN4lub6Wd0m2vJm7xVadWFrfJemUBdWoUGsfpVkqlfJeAoFWr1595513DhkypGfPnnmvhW1Hmqa5bNf5CqiW8xWbUYtvgFj/At+tUiwWzW75bLqsqbLZUkPvimeHd39fkiTfWf7KXuve6sjttnG2Gn+/NTWbo7yek2bNmq3SWToh120DAECUWnxtm21YfX19dvTBea8CAOCvvLYNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAlEKWZUktKZVKeS8BqDJpmuayXecroFrOV2xGXVJ7yuVyZYPFYrEts+mypspmSw29a2120eTmymb7T2nMa7YtP29ez0mznV81Hr9mzZrNcZZOyJUkAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAECUQpZlSS0plUp5LwGoMmma5rJd5yugWs5XbEZdUnvK5XJlg8VisS2z6bKmymZLDb0XTW6ubLb/lEazHTPblt9vXs/JWfPGVTY76qjpec3msq9y1JbnlVmzZmtwlk7IlSQAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQJRClmVJLSmVSnkvAagyaZrmsl3nK6BazldsRl1Se8rlcmWDxWKxLbPpsqbKZksNvRdNbq5stv+URrMdM9uW329ez8lZ88ZVNjvqqOl5rTmX2Ry15Xll1qzZGpylE3IlCQAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQpZBlWVJLSqVS3ksAqkyaprls1/kKqJbzFZtRl9Secrlc2WCxWGzLbLqsqbLZUkPvvGYXTW6ubLb/lMZam23Lfs7rOTlr3rjKZkcdNT2vNecym6NqPG+YNWs2x1k6IVeSAABAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABRClmWJbWkVCrlvQSgyqRpmst2na+AajlfsRl1Se0pl8uVDRaLxWqcTZc1VTZbaui9aHJzZbP9pzTW2mxb9nNez41Z88ZVNjvqqOk1NZujtjyvzJo1W4OzdEKuJAEAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAohSyLEtqSalUynsJQJVJ0zSX7TpfAdVyvmIz6pLaUy6XKxssFovVOJsua6psttTQe9Hk5spm+09prLXZtuznanxe1dRsjtryvDJr1mwNztIJuZIEAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIhSyLIsqSWlUinvJQBVJk3TXLbrfAVUy/mKzahLak+5XK5ssFgsVuNsuqypstlSQ+9Fk5srm+0/pbHWZtuyn6vxeVVTszlqy/PKrFmzNThLJ1SLtQ0AwN9XKGzyWzV2cURbqG0AALYssje+j+z+e9Q2AABb3NnvOaK5N01tAwDUvAo6e+Nxzf1efAIgAEBta2Nqt/vjbFvUNgBADWvfRBbcG1HbAAC1KiKOBff/pLYBAGpSXBYL7vWobQCA2hMdxIL7v6ltAIAa0zEpLLj/Qm0DAEAUtQ0AUEs68iXngpe31TYAAIRR2wAANaPjX2wu1PrL22obAACiqG0AAIiitgEAakNeF3UUavpikrq8FwAAQGeVZcmttyZr1yZduyYnnljj3VyZQpZlSS0plUp5LwGoMmma5rJd5yugnc9XFbTyb3+bzJiRXHttMmZMcuaZyWGHVbiyrLaCs9Zf2y6Xy5UNFovFapxNlzVVNltq6G22Y2ar8XlVU7M5qsbns1mzZnOcbX9LliSrViWHHposXfrn/7H1XLcNAMCm3XRTctFFyV135b2OaqW2AQDYtNGjk1mzkhNOyHsd1UptAwCwCX37Jt27J2n65y923z3v1VSlWrxuGwCALXLwwclLLyVHHfXnzyQ59NC8V1OV1DYAAJvgI//azJUkAAC1Ia+P4ctq9+P/1DYAAARS2wAAEEVtAwDUjI6/qCOr6ctI1DYAAARS2wAAtaQjX2zOav2FbbUNAACB1DYAQI3pmJecvbD9F2oboD3tt99+S5cuTZJk1apVe+655/Tp0/fff/+Pf/zjc+bMyXtpAB2YwlL7v6ltgPY0cuTI2267LUmSe+6559hjj50yZcq8efNmz55900035b00gI4KYqm9HrUN0J5OPvnkW2+9NUmS22+//TOf+cywYcPOOOOMJUuW3HjjjXkvDaBDslhq/09qG6A9DRw48LXXXnvzzTcXLFjwiU98YtasWePHj7/mmmtGjx6d99IA4uNYam+kbuObAGiLk0466Yorrjj44IPffPPNE0888e677z7ggAP69++f97oANiHLkkKhfR6HjRSyGtsvpVIp7yUAVSZN0626/zPPPLPPPvvcc889hx9++NSpU3/yk5+sW7duzJgxY8eO3arHcb4Cos9XG6q4uWusJ7dKLdZ2uVyubLZYLJo1a7YGZ/M6T5ZKpXRZU4WzDb3NmjVbg7PJr3+btN1WNXeNlWQFXEkCAMB7BfRmsltkbzG1DQDAe5HU7cFnkgAAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AECtW7x48ac+9anBgwcff/zxL7/88sZ3uPPOO7t3754kyRVXXDFo0KCpU6cmSbJu3brhw4c3NzfnseSqobYBAGrd2WeffcEFF8ydO3f8+PFf/epXN/juW2+9NWXKlK5duyZJ8q1vfev++++/6qqrkiS57rrrRowY0djYmNOqq0Mhy7KklpRKpbyXAFSZNE1z2a7zFdBh56v3v//9L7300nbbbffuu+9+7GMfe+aZZ9b/7he/+MVPfvKTZ599dnNzc79+/X79618PGTJkwYIFp59++h133FEoFNpp+dumuqT2lMvlygaLxaJZsxGz6bQKZ0sTq3K26n5HOUqXNVU2WGrobdas2Rqcrdg+++xz2223lUqlNE03uJLkvvvua2pq+sxnPnP22WcnSXLZZZeddtppl19++eTJk7/2ta9J7b/LlSQAALXuuuuuu/HGG48++ujnn3++vr6+9fZVq1ZNnDjxu9/9bustp59++vz58wcOHJgkyaJFi4YPH37LLbfktOrqUIuvbQMAsL4f//jHN998c319/cKFC9e/HOVnP/vZW2+9deqppyZJsnz58jPOOOPGG2/Msuziiy++8cYbDzjggPnz5x9++OEjR47Mdfmdmte2AQBq3e9///s777wzSZJZs2adcsopLW2dJMmpp576xBNPzP2LHj163HjjjUmSzJgx44QTTujVq9fKlSuzLFuxYkXey+/U1DYAQK278sorp02bdthhh7355pvnnntukiSf/vSn3/Oezc3NP/3pT1uu4R4/fvzQoUPPP//8Dl9vNXElCQBArRswYMB99923/i1z5szZ4D4tn6vd2Nh41113tdzylb/owGVWJa9tAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAlEKWZUktKZVKeS8BqDJpmuayXecroFrOV2xGXVJ7yuVyZYPFYtFsx8ym0yqcLU2sudl9p1Z4Yn1kUqkts21Zc9U9J3OULmuqbLDU0NusWbM1OEsn5EoSAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACBKIcuypJaUSqW8lwBUmTRNc9mu8xVQLecrNqMuqT3lcrmywWKxaLZjZtNpFc6WJhb3nVrhieaRSSWzWz7blt9R1T0nc5Qua6pssNTQ26xZszU4SyfkShIAAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIEohy7KklpRKpbyXAFSZNE1z2a7zFVAt5ys2oy6pPeVyubLBYrFotmNm02kVzpYmFvedWuGJ5pFJJbNbPtuW31HVPSdzlC5rqmyw1NDbrFmzNThLJ+RKEgAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgSiHLsqSWlEqlvJcAVJk0TXPZrvMVUC3nKzajLqk95XK5ssFisWi2Y2bTaRXOliYW951a4YnmkUkls1s+25bfUdU9J3OULmuqbLDU0NusWbM1OEsn5EoSAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACBKIcuypJaUSqW8lwBUmTRNc9mu8xVQLecrNqMuqT3lcrmywWKxaLZjZtNpFc6WJhb3nVrhieaRSSWzWz7blt9R1T0nc5Qua6pssNTQ26xZszU4SyfkShIAAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIEohy7KklpRKpbyXAFSZNE1z2a7zFVAt5ys2oy6pPeVyubLBYrFotmNm02kVzpYm1tzsvlMrPLE+MqnUltm2rLnqnpM5Spc1VTZYauht1qzZGpylE3IlCQAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQpZBlWVJLSqVS3ksAqkyaprls1/kKqJbzFZtRl9Secrlc2WCxWDRrNmI2nVbhbGliVc5W3e8oR+mypsoGSw29zZo1W4OzdEKuJAEAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAohSyLEtqSalUynsJQJVJ0zSX7TpfAdVyvmIz6pLaUy6XKxssFotmzZqtwdkcpcuaKhssNfQ2a9ZsDc7SCbmSBAAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIUsiyLOzBAQCgpnltGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2oZO5LXXXnv66afzXgVQIYcwsDG1De+tT58+hY3cdNNNoRsdOnTo/Pnzt/z+06ZNO/TQQze+/eWXXx45cuROO+3Ut2/fKVOmtOsaoQq8733vaz1s6+vr99577+nTp1f8aK0HWnNzc6FQ2ExPO4SBjdW9x23AX1x99dVf/vKXO3KLK1eubJfHOfXUU/v167dkyZKFCxced9xxH/zgB88888x2eWSoFtdcc80555yTJMmaNWv+7d/+7dOf/vTOO+98+umnt+UxGxsbsyzbzB0cwsDGvLYNW+f666/v1q3bkiVLkiR55ZVXdtppp5kzZ7766quFQuH666/v06dPQ0PDmDFjWv/QffHFF0eOHNmjR4++fftOmDCh9falS5eWSqWePXu+//3v/8IXvrBq1arBgwc/88wzo0ePbvljdVODTzzxxJFHHtm9e/fDDz988eLFG6/w2Wefveeee6ZNm9bQ0HDggQceffTR999/fwfuIehcunbtevzxxw8ZMiRN05deeqlQKFx00UUNDQ2jRo3a2gNt/de2HcLAFlLbsHXGjBlzxBFHXHHFFUmSXHbZZQceeODo0aNbvnXllVfeddddCxYseOihh8aOHdty44gRI3r27Pncc8/de++9Dz744Pjx45Mkeffdd4877rj6+vpnn332gQceeOyxxy655JK5c+cOHDhw5syZ11133aYG33nnnWHDhu27775NTU0XXXTRzJkzN17hHnvssW7dul69eq1du/bf/6JUKnXsToJOZ+3atT169Gj5+umnn37hhRcuvfTSig80hzCwFTLgvey+++4bHCzbbbddy7cWLlzY2Nh41VVXNTQ0LFy4MMuyV155JUmSNE1b7jBnzpz6+vrly5ffe++9O+yww6pVq1puf/DBB7t06bJy5cp77723vr7+tdde22CjLX9UZ1m2qcFyudzQ0LBixYqW288+++xDDjlkUz/CwIEDu3XrNnjw4FdeeSVgD0Hn1atXr2uuuabl6+bm5pkzZ3bp0uWOO+548cUXkyS58847W761tQfaG2+8kSTJU0895RAGtpzXtmGTrr766vWPlrVr17bcPmDAgEmTJk2YMOH8888fMGBA6/1b3+203377rV69+tlnn33yySdXrFjRrVu3lndrHXTQQevWrVu0aNETTzzRp0+fXXbZZVOb3tTgk08+uccee3Tv3r3lbvvvv/9m1v/000+/9tprO+yww/HHH99OuwSqxrnnntty+Oy6667Tpk377ne/O3z48JZv9evXr40HmkMY2HJqGyrx+OOPJ0ny8MMPr39j165dW7549913//we5Lq6tWvXDhgwYIP/j/uxj32sa9euhUJhM4+/qcEN7ta6xU3ZcccdJ0+e/Nvf/rapqanSnxWqUutr2++8887jjz/e8o7JFt26dWvjgeYQBrac2oat9stf/vLmm2+eOnXqrbfeWi6XW29/9NFHW75YsGBBjx499thjj7322mvx4sUvvPDCBo+w5557LlmypOVvpdfX+uf3pgYHDRq0cOHCt99+u+U/H3vssY2Xd9dddzU0NKxatarlP19//fXtttuusbGxbT80bIMqPtAcwsCWU9uwdZYvX37OOeeMGzdu4sSJZ5111tixY996662Wb11wwQWLFy9euHDhhRdeePbZZ3fr1u2YY47ZZ599Ro8evWTJkqVLl375y1/u16/fqlWrjjzyyEGDBp133nmvvvrqc889N2LEiFNOOaXldaympqa33nprU4Of+tSndtttty996Uuvv/763XffPWPGjI1XOHjw4A9+8IMTJkxYtmzZo48+OmnSpNGjR++www4dvqugs6v4QHMIA1thK67xhtp+l2SSJJ///OfPO++8D3/4w8uXL8+ybNmyZX379h07dmzLuyS/8pWvfOhDH9p5550nTJiwevXqlsd5/vnnTzrppB133HGnnXY69thjn3rqqZbbFy9efNxxx22//fa9evUaNWrUsmXLsiz7wQ9+0KNHjxEjRmxm8Nlnnx0yZMj2228/aNCgCRMmvOdbrP70pz8NGzZsp5126tev30UXXbRy5coO3HPQud4lub6Wd0m2vLm5xVYdaK3vknQIA1uusPkP6qfa+dyojrF69eo777xzyJAhPXv2zHsttL80TXPZruMXqvf4hb/ZijKnChWLxaRSZrfcsGHDctmu2Y6ZdfyaNVu9s3kdv9DKddsAABBFbUM7qK+vz3sJAEBnpLYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIUsiyLOzByV+pVMp7CVD10jTNZbuOX6je4xda1f3tS7ZR5XK5ssFisZjX7KLJzZXN9p/SaLbzz1bdczJHVbevHL/b/GzVPSchd64kAQCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiFLIsC3tw8lcqlfJeAlS9NE1z2a7jF6r3+IVWdX/7km1UuVyubLBYLOY1u2hyc2Wz/ac0zpo3rrLZUUdNN7vls235HVXdczJHtXb85rXmdFlTZbOlht5+R1u+3Vo7fqGFK0kAACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgCiFLMvCHpz8lUqlvJcAVS9N01y26/iF6j1+oVXd375kG1UulysbLBaLiyY3Vzbbf0pjXrOz5o2rbHbUUdPNbvlsW35HbXlO5jKbo1o7fqvuuVGlszX1O4LcuZIEAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIhSyLIs7MHJX6lUynsJUPXSNM1lu45fqN7jF1rV/e1LtlHlcrmywWKxuGhyc2Wz/ac0zpo3rrLZUUdNN9v5Z9vy3GjLczKX2Ro8fqvud1QsFvedWmFUPTKpVGtrrqnnBuTOlSQAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQJRClmVhD07+SqVS3kuAqpemaS7bdfxC9R6/0Krub1+yjSqXy5UNFovFRZObK5vtP6Vx1rxxlc2OOmq62c4/25bnRluek7nM1uDxW3W/I7NbNVtTzw3InStJAAAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAo/uV2AIAtUyhs8ltZ1qEroXqobQCASiN74/vIbv4ntQ0A0IbOfs8Rzc1/U9sAAO3R2RuPa268SxIAoJ1Tu90fh2qmtgEAwhJZcNc8tQ0AEBnHgru2qW0AgOAsFtw1rJC5fn+bViqV8l4CVL00TXPZruMXOvT47YAgFl01yWeSbPvK5XJlg8VicdHk5spm+09pzGt21rxxlc2OOmq62S2fzev325bnc8WzOaq14zeX328NztbU77dzvfZcKAjuGuRKEgAAiKK2AYDa1pEXVbuAu/aobQAAiKK2AYAa1vEvNnt5u8aobQAAiKK2AQAgitoGAGpVXhd1uJiklvi8bQCALZZlya23JmvXJl27JieeqJv5u7y2DQCwxX73u+SXv0xGjkxuuy2ZPz/v1VAF1DYAwBZbsiRZtSo59NBk6dI//w/+HrUNALA1bropueii5K678l4H1UFtAwBsjdGjk1mzkhNOyHsdVAe1DQCwxfr2Tbp3T9L0z1/svnveq6EK+EwSAIAtdvDByUsvJUcd9efPJDn00LxXQxVQ2wAAW8xH/rGVXEkCANSqLKut7ZIHtQ0AAFHUNgAARClk/i5jm1YqlfJeAlS9NE1z2a7jFzro+O3gS7GlV43xLsltX7lcrmywWCzmNbtocnNls/2nNM6aN66y2VFHTTfbMbNt+f3m8pzMUa0dv23Zbluek3ntq3RZU2WzpYbetfb7rcbjF1q4kgQAqG0d+WKzF7Zrj9oGAIAoahsAqHkd85KzF7ZrktoGaE/77bff0qVLkyRZtWrVnnvuOX369P333//jH//4nDlz8l4akGsKS+1apbYB2tPIkSNvu+22JEnuueeeY489dsqUKfPmzZs9e/ZNN92U99KA/IJYatcwtQ3Qnk4++eRbb701SZLbb7/9M5/5zLBhw84444wlS5bceOONeS8NyCmLpXZtU9sA7WngwIGvvfbam2++uWDBgk984hOzZs0aP378NddcM3r06LyXBuQRx1K75vm8bYB2dtJJJ11xxRUHH3zwm2++eeKJJ959990HHHBA//79814XsMWyrH3+yRupjdoGaHcnn3zyPvvsc8899zQ0NBx//PGHHnrounXr/vmf/znvdQFbH8oVN7fO5r+pbYB2NnDgwFWrVrV8Pekv8l4R0IHNrbP5n9Q2AMCWBfRmsltkswlqGwBgy0hqtp7PJAEAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAohQyn2WzTSuVSnkvAapemqa5bNfxC9V7/EIrn7e97SuXy5UNFovFvGYXTW6ubLb/lMZZ88ZVNjvqqOlmO2a2Lb/fXJ6TOaq147caf95am6263y/kzpUkAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0A8Ffr1q0bN27cYYcddtRRRy1atChJksWLF3/qU58aPHjw8ccf//LLL2/mnldcccWgQYOmTp3a8t3hw4c3N1f4gYlsS9Q2AMBfff/73+/Zs+cDDzwwfvz4iRMnJkly9tlnX3DBBXPnzh0/fvxXv/rVzdzzW9/61v3333/VVVclSXLdddeNGDGisbEx15+GTsG/bgMA8Fc/+tGPbrjhhiRJhg8fvnDhwiRJ/vCHPwwePDhJksGDB3/hC1/YzD27du36X//1X/X19a+//vqtt956xx135Pqj0Fl4bRsA4K/++Mc/3nbbbYMHD/7sZz/7mc98JkmSffbZ57bbbmv5R+DXv5Jk43tedtllp5122uWXXz558uSvfe1rhUIh1x+FzkJtAwD81erVqz/0oQ/NnTv3tNNOGzNmTMs1ITfeeOPRRx/9/PPP19fXb+aep59++vz58wcOHJgkyaJFi4YPH37LLbfk+tPQKbiSBADgr3bddddisZgkSbFYPOecc5Ik+fGPf3zzzTfX19cvXLgwTdPN3DNJkizLLr744htv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"
            },
            {
              "type": "input_text",
              "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
            }
          ],
          "solved_count": 0,
          "total_training_examples": 3,
          "pixel_accuracy": 0.21449851042701093
        },
        "test_result": {
          "correct": false,
          "pixel_accuracy": 0.14262820512820512,
          "total_pixels": 624,
          "correct_pixels": 89,
          "error": null
        },
        "status": "failed_test",
        "feedback_sent": true
      },
      {
        "turn_number": 3,
        "timestamp": "2025-07-10T13:42:22.300698",
        "input_tokens": 23661,
        "output_tokens": 1388,
        "turn_cost": 0.011685200000000001,
        "program_extracted": true,
        "program": "def transform(grid):\n    import numpy as np\n    from collections import deque, Counter\n\n    grid = np.array(grid)\n    h, w = grid.shape\n    output = grid.copy()\n\n    # Step 1: Identify all nonzero connected components (these are candidate outlines)\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def neighbors(r, c):\n        for nr, nc in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\n            if 0 <= nr < h and 0 <= nc < w:\n                yield nr, nc\n\n    def bfs_component(sr, sc):\n        q = deque([(sr, sc)])\n        comp_pixels = []\n        visited[sr, sc] = True\n        while q:\n            r, c = q.popleft()\n            comp_pixels.append((r, c))\n            for nr, nc in neighbors(r, c):\n                if not visited[nr, nc] and grid[nr, nc] != 0:\n                    visited[nr, nc] = True\n                    q.append((nr, nc))\n        return comp_pixels\n\n    components = []\n    for r in range(h):\n        for c in range(w):\n            if grid[r, c] != 0 and not visited[r, c]:\n                comp = bfs_component(r, c)\n                components.append(comp)\n\n    # Helper: For a component, find outline pixels by checking neighbors outside component\n    def find_outline_pixels(component):\n        comp_set = set(component)\n        outline = set()\n        for (r, c) in component:\n            for nr, nc in neighbors(r, c):\n                if (nr, nc) not in comp_set:\n                    outline.add((r, c))\n                    break\n        return outline\n\n    # Step 2: For each component:\n    # - find outline pixels (on edges)\n    # - find bounding box\n    # - flood-fill from outside the bounding box to mark outside pixels (external background)\n    # - pixels inside bounding box that are not outline and not outside are interior\n    # - fill interior pixels with most common interior color (from input)\n    for comp in components:\n        comp_set = set(comp)\n        outline_set = find_outline_pixels(comp)\n\n        # Determine outline color as majority color in component pixels\n        colors_in_comp = [grid[r, c] for r, c in comp]\n        outline_color = Counter(colors_in_comp).most_common(1)[0][0]\n\n        rows = [r for r, c in comp]\n        cols = [c for r, c in comp]\n        rmin, rmax = max(min(rows), 0), min(max(rows), h - 1)\n        cmin, cmax = max(min(cols), 0), min(max(cols), w - 1)\n\n        # Create mask for bounding box: 0 = unknown, 1 = outline, 2 = component interior candidate\n        box_h = rmax - rmin + 1\n        box_w = cmax - cmin + 1\n        mask = np.zeros((box_h, box_w), dtype=np.int8)\n\n        for (r, c) in comp_set:\n            rr, cc = r - rmin, c - cmin\n            if (r, c) in outline_set:\n                mask[rr, cc] = 1  # outline\n            else:\n                mask[rr, cc] = 2  # possible interior\n\n        # Flood fill from outside bounding box on mask == 0 pixels to mark external background\n        visited_box = np.zeros_like(mask, dtype=bool)\n        q = deque()\n        # Initialize queue with bounding box edges that are 0 in mask (outside)\n        for rr in range(box_h):\n            for cc in [0, box_w - 1]:\n                if mask[rr, cc] == 0:\n                    q.append((rr, cc))\n                    visited_box[rr, cc] = True\n        for cc in range(box_w):\n            for rr in [0, box_h - 1]:\n                if mask[rr, cc] == 0:\n                    q.append((rr, cc))\n                    visited_box[rr, cc] = True\n\n        while q:\n            rr, cc = q.popleft()\n            for nr, nc in ((rr-1, cc), (rr+1, cc), (rr, cc-1), (rr, cc+1)):\n                if 0 <= nr < box_h and 0 <= nc < box_w:\n                    if not visited_box[nr, nc] and mask[nr, nc] == 0:\n                        visited_box[nr, nc] = True\n                        q.append((nr, nc))\n\n        # Interior pixels in bounding box: those with mask == 2 and not reachable from outside\n        interior_pixels = []\n        for rr in range(box_h):\n            for cc in range(box_w):\n                if mask[rr, cc] == 2 and not visited_box[rr, cc]:\n                    interior_pixels.append((rr + rmin, cc + cmin))\n\n        # Find fill color: majority nonzero color inside interior pixels in input\n        interior_colors = [grid[r, c] for r, c in interior_pixels if grid[r, c] != 0]\n\n        if interior_colors:\n            fill_color = Counter(interior_colors).most_common(1)[0][0]\n        else:\n            # Fallback: fill with outline color if no interior color found\n            fill_color = outline_color\n\n        # Fill interior pixels in output with fill color\n        for r, c in interior_pixels:\n            output[r, c] = fill_color\n\n        # Outline pixels remain unchanged, already in output\n\n    return output.tolist()",
        "training_feedback": {
          "feedback_messages": [
            {
              "type": "input_text",
              "text": "Training results: 0/3 examples solved, 82.3% pixel accuracy - Good partial progress! Your approach is capturing some patterns. Next, try to identify a transformation that solves at least one of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 1, 1, 1, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 5, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 0, 8, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 8, 0, 0, 8, 2, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 3, 0, 8, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 1, 1, 1, 0, 0, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 5, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 5, 0, 5, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 90.0%\n\nTraining Example 2 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 6, 6, 6, 0, 0], [0, 0, 2, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 2, 2, 2, 3, 3, 3, 3, 3, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 6, 6, 6, 6, 6], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 3, 0, 2, 0, 0, 6, 6, 6, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 6, 0, 3, 0, 0], [0, 0, 2, 2, 2, 0, 3, 0, 0, 0, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 6, 6, 6, 6, 6], [0, 0, 0, 0, 2, 0, 0, 0, 8, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 8, 0], [3, 0, 0, 0, 0, 0, 0, 4, 8, 0, 3, 0, 8, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 8, 0, 4, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 80.7%\n\nTraining Example 3 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 3, 3, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 3, 3, 6, 6, 6, 6, 6, 6, 3, 3, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 3, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0], [0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 3, 0, 0, 0, 8, 0, 0, 8, 0, 3, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 0, 3, 0, 6, 0, 0, 2, 0, 0, 3, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 3, 0, 0, 0, 0, 6, 0, 0, 0, 3, 0, 0], [0, 0, 3, 0, 0, 6, 0, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 69.6%\n\n"
            },
            {
              "type": "input_image",
              "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA88AAAUtCAIAAABNteEnAABUgklEQVR4nO3de5xVdb34/7URBlFwRtFUBEsk0R58RdO8kHJQ+D5S8LJ3YB1NPXBQ035IgaLZ4WT5xTQhO9HF/IZCpqQnT3t7OWbkN4UsKVPyrqGgIaDH26AIcl2/R01n4oAQ7Jn3rFns5/PhH+Oe/d5r7TV7fXi5XbMppGmaAAAAATpEPCgAAKC2AQAgkNoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAaJe1PWbMmMLmnXnmme97n7q6ur322uuUU0559NFHN33MX/ziF4VCYbfddnvvvfc2+tbtt99eKBSmTZvW9K8jR44sFAqTJ0/e6G4vv/xyoVCYOHFiS6aavPfee9dff/1xxx3Xo0ePzp079+jR47TTTvvVr361hWMyceLEzR2QJ598cssHbciQIX/3wDbf55xzztnw9qbdGz58+EMPPbTh/hSLxY3utt9++40dO/att97apoPf5PXXX580adKhhx5aX1+/8847H3HEEdOmTUvTdKPNbTT+yCOP7LHHHt26dbv//vu3cOgAALY/Gby3vWbNmldfffWuu+467rjjFixYsNF3b7zxxiRJ3nrrrdtuu21rHu3LX/7ys88+u637sDVTL7744tFHH33++ec/8MADS5cuXb169dKlS2+//faBAwdee+21STvTtHs//elPjznmmFtuuWULd3vxxRe//e1vn3DCCevXr9+mg//QQw/179//X//1X//whz+8/fbbK1asePjhh88999zRo0dvYcd++ctfHnfccevWrbvvvvuOO+64FjxFAIAaq+3vfOc76X/7yU9+kiTJ9OnTm2+5+eabm++5cOHC5tvfe++9Z5555owzznj77bevu+66DR+wsbGxUqmcdtppu+222/e///2t2YfVq1ePHDly3bp127Tnf3dqzZo1I0aM+MMf/jBgwIA777zz9ddfX7NmzZ/+9Kfvfe97u+222yWXXNL0RvXmzJs3L91Ev3793veANLvvvvs2fJCtuc/SpUubbl+5cuXzzz//xS9+MU3Tf/7nf37ppZc2vNvKlSs3PPhDhgz53e9+94tf/GLrD/5//dd/lUqlJUuWnH766XPnzn377bfffPPNSqXSu3fv6dOnX3/99e97HMrl8tChQ3faaacHHnjgyCOP3MIRAwDYLmXw3nbnzp0PPPDAr3/960mSbPTe9syZM997773Pfvazo0aNmjt37uOPP/53H+3CCy/87W9/+41vfGOb9uHvTv3whz985JFHhgwZMmfOnJNPPrl79+4dO3bs1avXBRdc8NOf/nTdunU//vGPk/Zkxx133H///a+66qovf/nLq1ev/rd/+7ctHPwvfOELTaW+9Qf/2muvffXVV8eNGzdz5swjjzyyW7duu+6666mnnjp79uydd9752muv3fB6kiY33HDDaaed9oEPfOBXv/rVwQcf3Hz7jBkzCoXCd77znVY9AAAA7VEGtb1q1aqnnnpq/PjxSZIccMABG35r+vTpBx100PHHH3/BBRfssMMOW/P29te+9rU+ffp8+ctffuaZZ7Z+H/7u1MyZMwuFwv/9v/93hx122Ohb//AP//D0009PmjQpaZcuuuiinXba6ec///n7fnfNmjV//OMfp06d2rFjx3/4h3/Y+oP/7//+7126dLniiis2esCePXs++OCDDzzwQKFQ2PD2a6655pxzzundu/eDDz744Q9/uPWeHwBAnrRRbe+3337Nv6i344479uvX7yc/+cnuu+/++c9/vvk+Tz755O9///sJEyYUCoX999//tNNOu+WWW5YvX77lR95pp52mT5++Zs2abbqe5O9OzZs376CDDtpvv/3ed/yggw7aKC43cuihh270240PPvjg5g5IswceeGBb77Opbt26ffjDH97ofxp06dKlabyurq5v376//vWvf/jDH2747LZ88NesWfPiiy8eccQRXbt23XSLhxxyyN57773hLZdccsmll16aJMmxxx677777bnT/kSNHpmk6ZsyYLT8RAIDtQDafALjPPvv88z//82OPPbbXXns133jjjTfus88+n/nMZ5r+9bLLLnvnnXe25oKNY445ZuzYsb/73e+mTJmy9fuwhak1a9Y0NjbuueeeG9640eeEfOhDH0raq+7du6/6i83dYd26dXPnzl2zZs1WHvzGxsY0Tbt3776VO/Dtb3/76KOPHjJkyI033vjTn/60Zc8GACDH2qi2m37hb/Xq1bfeemvTm69XX311jx49mu+wZs2am2++efHixZ07d27K2f79+6dpupW/K/m1r33twx/+8OWXX/70009v/V5tbqpTp07dunV77bXXkmpt+luSxxxzzN/9DchBgwZt633e11tvvdWpU6fOnTtv+luSq1evXrBgwf/3//1/3/72ty+++OKtPPi77bZbhw4dtv6AjBo16oEHHrjpppt22223c889d/HixVs5CACwnWnT97Y7der06U9/+rbbbps9e/YJJ5yw4acy33333e8bc48++ujDDz/8dx+5S5cuVVxPsoWp//W//tfTTz/9pz/96X0/gOWwww5L2qvly5c/+eSTBx100Pt+t1OnTvvtt9+UKVP69es3Y8aMrTz4O+yww0EHHfT73/9+xYoVm97tqquuOvvss5csWdJ8y/e+9726urq99977O9/5zptvvnn22Wdv+mmDAAC1IIMrSU488cQLL7zw0UcfbX5vtelKhh133HHZsmUbvo/7m9/8JkmSzX263EY+/vGPf/7zn3/44Yc3/Ztrqpj6zGc+s379+s997nPv2+6bfv5G+/HNb35zzZo1J5xwwpbv1qFDh+XLl69du3YrD36xWFy5cuVXvvKVjR7nxRdfvOaaa+6+++73vc7k9NNPHzFixC9/+cttusgHAGC7kc1121/72tf23Xff66677re//W2SJK+88sq999578skn77LLLhve7eijj+7bt++Pf/zjZcuWbc3DXnnllR/+8Ie/973vbdPOvO/UOeecc9hhh/3nf/7nEUcc8e///u+vvPLKmjVrmv52m2HDhj366KMdOrSvv/R+1apVzz333MSJE7/61a/utNNOm/sdxDRNX3755QkTJjz++OOHHnpox44dt/Lgjxs3rnv37pMnTz777LN///vfr1y58tVXX505c+agQYMaGxsnTJiw4YUrG7ruuuv23HPPiRMnPvLIIzFPHQCg/comGXfeeedvf/vb69ev/+xnP7t27dqbbrpp7dq1zb+it6F/+qd/WrFixY9+9KOtvzJky58WspVTdXV1lUrl6KOPfvTRRz/96U/vvffedXV1TX9z+z333NO3b9+t/KsuN+d9P2+kUChs+BksW3Ofvffeu/mTXg488MArr7yy6a+p79Wr10bPseluHTp06NWr15QpUzp06ND0IYZbefC7d+9+2223devW7Uc/+tHHPvaxnXbaaa+99vrMZz7z0ksvlUqlSy65ZHPPdPfdd//BD36wZs2aM84449133/V52wBATcnsDdpTTjmlWCw+9thj//Zv/zZjxoxdd931xBNP3PRuZ599docOHbbyYpKmK0Oa/uqWbfK+Uz179vzVr3518803Dx06tGfPnnV1dXvuuefQoUN/+MMfPvnkkx/72MeS9qRTp069evX6x3/8x1//+tenn3765u62ww47fOADHxg2bNgvfvGLpqtNtv7gDx48eN68eWPHjj3wwAO7du3apUuXI488ctq0af/xH/+x6aeSb+jkk08eOXLkH//4xw0/8BEAoBYU2vMlyAAAkGvt6+JjAADYnqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqmxx74403nn322az3AmC7ZZmFllPbtI6ePXsWNnHzzTeHbnTIkCFz587d+vtPmTLlqKOO2tx3Gxsbe/fuvU0PCNA2dt999+alta6u7qCDDpo6dWrVj9a8GDY2NhYKhS30tGUWWk5t02q++c1vpv/TmWeeGbrFlStXttZDLVq0aMiQIQsXLmytBwRoXdddd13T0vruu+9Onjz54osv/tGPftTCx2xoaEjT9MADD9zcHSyz0HJqm1g33HBD586dFy1alCTJa6+9tssuu0yfPv31118vFAo33HBDz5496+vrR48e3bygL126dMSIEV27du3Vq9f48eObb1+8eHGpVOrWrdsee+zxuc99btWqVYMGDXruuedGjRp1zjnnbGHwqaeeOvbYY7t06TJgwIDNrfL/+Z//2a9fv8MOO6ytjgpA9Tp16nTSSScNHjy4XC6/8sorhULhsssuq6+vHzly5LYuhhu+t22ZhSBqm1ijR48+5phjrr766iRJrrzyysMPP3zUqFFN37rmmmvuvffeefPmPfLII2PGjGm6cfjw4d26dXvxxRdnz5798MMPjxs3LkmSdevWnXjiiXV1dS+88MJDDz30xBNPXH755Q888EDfvn2nT58+bdq0zQ2+9957Q4cO7d+//5IlSy677LLp06e/70527tz5vvvu++53v9uGBwagRdauXdu1a9emr5999tmXX375iiuuqHoxtMxCoI3+1z9UZ5999tnopbXDDjs0fWv+/PkNDQ3XXnttfX39/Pnz0zR97bXXkiQpl8tNd5g1a1ZdXd3y5ctnz5690047rVq1qun2hx9+uEOHDitXrpw9e3ZdXd0bb7yx0Uab/hhI03Rzg5VKpb6+fsWKFU23n3feeUceeeTmnsKaNWuSJHnooYcCDg9Ai3Tv3r35SpLGxsbp06d36NDh7rvvXrp0aZIk99xzT9O3tnUxfOutt5IkeeaZZyyzEMd720Rdt7127dqm2/v06TNhwoTx48dfdNFFffr0ab5/82/SHHLIIatXr37hhReefvrpFStWdO7cuek3gT72sY+tX79+wYIFTz31VM+ePXfbbbfNbXpzg08//fT+++/fpUuXprsdeuihwccAIMoFF1zQtMTtueeeU6ZM+e53vzts2LCmb+27774tXAwtsxBHbdMWnnzyySRJHn300Q1v7NSpU9MX69atS5KkY8eOa9eu7dOnz0b/RfiRj3ykU6dOhUJhC4+/ucGN7ta8RYDcaX5v+7333nvyySfPP//85m917ty5hYuhZRbiqG3C/exnP7vtttsmT558xx13VCqV5tsff/zxpi/mzZvXtWvX/fff/8ADD1y4cOHLL7+80SMccMABixYtavo/nhtq/rNhc4P9+vWbP3/+u+++2/SvTzzxRGs/OYB2pOrF0DILcdQ2sZYvX37++eePHTv24osvPvfcc8eMGfPOO+80feuSSy5ZuHDh/PnzL7300vPOO69z587HH3/8wQcfPGrUqEWLFi1evPgLX/jCvvvuu2rVqmOPPbZfv34XXnjh66+//uKLLw4fPvz0009PkmTnnXdesmTJO++8s7nBT3ziE3vvvffnP//5N99887777rvxxhuzPh4AgapeDC2zEEdt02rGjRu30d9uc/7553/pS1/q0KHDpEmTkiSZPHlyhw4dvvSlLzXdf8iQIccdd9yRRx75v//3/2760JIOHTpUKpWdd975oIMO+shHPvLcc8/NmjWr6TLB//iP/3jzzTd79ep1+OGH77LLLtdff32SJOeff/5VV101atSozQ3W1dX97Gc/e/HFF/fZZ59x48ade+65WR8kgEBVL4aWWYhTSNO06uFSqdSqO0OtWL169T333DN48OBu3bplvS/w95XL5Uy2a40FakE5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5/r16zdr1qwePXosXrz4hBNOeOKJJ5ruuent++677y9/+cvBgwfPmzfvrLPOuvvuuwuFQhKsYwvnK5VKdYPFYjGXs32+XuXs85dmNXvGGWdUNztz5sysZlt0rPL4ujLbvmczlLtjVYNrbFbHqv/kKv8j8LEJpTw+X7Pb8ey2Ovjgg++8885SqVQul5uuJHn11Vf32muvJEn23nvvpluabHr7lVdeeeaZZ1511VUTJ0786le/2gap7UoSAADyZNq0aTfddNNxxx330ksv1dXVbdPsWWedNXfu3L59+yZJsmDBgmHDht1+++1JO39vGwAA2syPf/zj2267ra6ubv78+U1Xoey5556vvPJKjx49li5duueeezbf831vT9P0y1/+8k033XTYYYfNnTt3wIABI0aMCN1h720DAJAbv//97++5554kSWbMmHH66acnSTJ06NBbb701SZJbb7116NChSZIsX778fW9PkuTGG288+eSTu3fvvnLlyjRNV6xYEb3DahsAgNy45pprpkyZcvTRR7/99tsXXHBBkiT/8i//MmfOnGOOOeZXv/rVl770pSRJPvnJT77v7Y2NjT/5yU/OO++8JEnGjRs3ZMiQiy66KHqHXUkCAEBu9OnT58EHH9zwlvr6+o1+R3PWrFnve3tDQ8O9997b9PUX/6INdth72wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEKWQpmnVw6VSqVV3BqA9KpfLmWzXGgvUgnJGa2yb6djC+UqlUt1gsVjM5Wyfr1c5+/ylZ5xxRnWzM2fOrLXZlhznXL6uzLbv2Qzl7lhluMZmtc8tWuscZ7Nma4ArSQAAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKIU0TaseLpVKrbozAO1RuVzOZLvWWKAWZLXGtpmOLZyvVCrVDRaLxVzO9vl6lbPPX3rGGWdUNztz5sxam23Jcc7l68ps+57NUO6OVYZrbC6fr+Ns1mwNcCUJAABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsA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hQsXbrqHDz/88IIFC6699tpdd921T58+l19++R133JGmaRseJCAznTp1OumkkwYPHlwul1955ZVCoXDZZZfV19ePHDlyWxeWDd/btmRB7qht8mr06NHHHHPM1VdfnSTJlVdeefjhh48aNarpW9dcc8299947b968Rx55ZMyYMU03Dh8+vFu3bi+++OLs2bMffvjhcePGJUmybt26E088sa6u7oUXXnjooYeeeOKJyy+//IEHHujbt+/06dOnTZu2ucH33ntv6NCh/fv3X7JkyWWXXTZ9+vRN93DAgAFr1qypq6tr+telS5futttuhUKhDQ8SkLG1a9d27dq16etnn3325ZdfvuKKK6peWCxZkEsb/Q96aG/22WefjV60O+ywQ9O35s+f39DQcO2119bX18+fPz9N09deey1JknK53HSHWbNm1dXVLV++fPbs2TvttNOqVauabn/44Yc7dOiwcuXK2bNn19XVvfHGGxtttOmPrjRNNzdYqVTq6+tXrFjRdPt555135JFHbuFZNDY27rfffpdffnlrHx6gHenevXvzlSSNjY3Tp0/v0KHD3XffvXTp0iRJ7rnnnqZvbevC8tZbbyVJ8swzz1iyII+8t03+rtteu3Zt0+19+vSZMGHC+PHjL7rooj59+jTfv/m3fw455JDVq1e/8MILTz/99IoVKzp37tz020sf+9jH1q9fv2DBgqeeeqpnz5677bbb5ja9ucGnn356//3379KlS9PdDj300C3s/7vvvnvyySf369dv4sSJrXRIgHbqggsuaFou9txzzylTpnz3u98dNmxY07f23XffFi4slizII7VNvj355JNJkjz66KMb3tipU6emL9atW5ckSceOHdeuXdunT5+N/lvzIx/5SKdOnbb8/0k3N7jR3Zq3uKk33nhj8ODBPXv2vP322zt27Niypwu0d83vbb/33ntPPvnkhr9o2Llz5xYuLJYsyCO1TY797Gc/u+222yZPnnzHHXdUKpXm2x9//PGmL+bNm9e1a9f999//wAMPXLhw4csvv7zRIxxwwAGLFi1q+r+0G2r+82xzg/369Zs/f/67777b9K9PPPHE++7hyy+/fMwxxwwcOPCWW25pvhoSqHFVLyyWLMgjtU1eLV++/Pzzzx87duzFF1987rnnjhkz5p133mn61iWXXLJw4cL58+dfeuml5513XufO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ABBFbQMAQBS1DQBQo/7f//t/AwYMOO6444499tiHHnooSZJly5YVi8VjjjmmWCwuW7as+Z7/+I//OOgvBgwYsPvuuydJcvXVV/fr12/y5MlJkqxfv37YsGGNjY2ZPpt2qmPWOwAAQDZGjx59//3377fffi+88MLJJ5/89NNPX3nllQMHDhw/fvw3vvGNq6666uqrr26656233tr0xbRp0/70pz8lSfKtb33rueee69u374QJE6ZNmzZ8+PCGhoZMn007VUjTNKklpVIp610AcqZcLmeyXesVEL1eHXbYYddff/3hhx/+u9/97rTTTnvppZf69es3a9asHj16LF68+IQTTnjiiSc2vH+aph/96Ed//vOff+ADH9h3331/+ctfDh48eN68eWedddbdd99dKBRa+wltF9IaUywWqz5WZs0GzabPJ9X9k9PZrI5z1bM1uF5dPj+t7p88/nzNbtNsHtcc69UW/O53v+vcuXO/fv06d+581113pWm6++67r1u3Lk3TdevW7bHHHhvd/4477jj33HObvr7pppuOPPLIW2655YILLnj44YdbaeXbDrluGwCgRl188cW33HLLE0888aMf/einP/3p373/N77xjYsuuqjp67POOmvu3Ll9+/ZNkmTBggXDhg27/fbb43c5f1y3DQBQo5544ommi9Y++clPXnDBBUmS7Lnnnq+88kqPHj2WLl265557bnjn3/72tw0NDU153SRN0y9/+cs33XTTYYcdNnfu3AEDBowYMSKL59GueW8bAKBG9e3b99e//nWSJA899NCHPvShJEmGDh3a9AuRt95669ChQ5MkWb58edOdr7nmmuY3tpvceOONJ598cvfu3VeuXJmm6YoVKzJ6Hu2a97YBAGrU97///bFjx/75czMKhWnTpiVJ8i//8i//9E//9NOf/nT33Xf/4Q9/2PS296xZs55//vklS5YMHDiwebaxsfEnP/nJPffckyTJuHHjhgwZslGL00RtAwDUqP79+8+ePXvDW+rr6yuVyoa3zJo1K0mSPn36NH0gd7OGhoZ777236esv/kWb7HL+uJIEAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiFNI0TWpJqVTKeheAnCmXy5ls13oF5GW9Ygs6JrWn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kiRr1qz5+c9//slPfnLXXXc966yzWvKYDQ0NaZpu4Q5OYWBT3tuGbXPDDTd07tx50aJFSZK89tpru+yyy/Tp019//fVCoXDDDTf07Nmzvr5+9OjRzX/oLl26dMSIEV27du3Vq9f48eObb1+8eHGpVOrWrdsee+zxuc99btWqVYMGDXruuedGjRrV9Mfq5gafeuqpY489tkuXLgMGDFi4cOGme/jCCy/cf//9U6ZMqa+vP/zww4877rjf/OY3bXiEoH3p1KnTSSedNHjw4HK5/MorrxQKhcsuu6y+vn7kyJHbeqJt+N62UxjYSmobts3o0aOPOeaYq6++OkmSK6+88vDDDx81alTTt6655pp777133rx5jzzyyJgxY5puHD58eLdu3V588cXZs2c//PDD48aNS5Jk3bp1J554Yl1d3QsvvPDQQw898cQTl19++QMPPNC3b9/p06dPmzZtc4Pvvffe0KFD+/fvv2TJkssuu2z69Omb7uH++++/fv367t27r1279v/9RalUatuDBO3O2rVru3bt2vT1s88++/LLL19xxRVVn2hOYWAbpMD72WeffTY6WXbYYYemb82fP7+hoeHaa6+tr6+fP39+mqavvfZakiTlcrnpDrNmzaqrq1u+fPns2bN32mmnVatWNd3+8MMPd+jQYeXKlbNnz66rq3vjjTc22mjTH9Vpmm5usFKp1NfXr1ixoun2884778gjj9zcU+jbt2/nzp0HDRr02muvBRwhaL+6d+9+3XXXNX3d2Ng4ffr0Dh063H333UuXLk2S5J577mn61raeaG+99VaSJM8884xTGNh63tuGzfrmN7+54dmydu3aptv79OkzYcKE8ePHX3TRRX369Gm+f/NvOx1yyCGrV69+4YUXnn766RUrVnTu3Lnpt7U+9rGPrV+/fsGCBU899VTPnj132223zW16c4NPP/30/vvv36VLl6a7HXrooVvY/2efffaNN97YaaedTjrppFY6JJAbF1xwQdPps+eee06ZMuW73/3usGHDmr617777tvBEcwoDW09tQzWefPLJJEkeffTRDW/s1KlT0xfr1q378+8gd+y4du3aPn36bPTfuB/5yEc6depUKBS28PibG9zobs1b3Jydd9554sSJv/3tb5csWVLtc4Vcan5v+7333nvyySebfmOySefOnVt4ojmFga2ntmGb/exn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JZc88MAD48aN+8pXvrKFe37rW9/6zW9+c+211yZJMm3atOHDhzc0NGT6bGgX/O02AAB/dcstt/zwhz9MkmTYsGHz589PkuQPf/jDoEGDkiQZNGjQ5z73uS3cs1OnTv/1X/9VV1f35ptv3nHHHXfffXemT4X2wnvbAAB/9cc//vHOO+8cNGjQpz/96U996lNJkhx88MF33nln018Cv+GVJJve88orrzzzzDOvuuqqiRMnfvWrXy0UCpk+FdoLtQ0A8FerV6/+4Ac/+MADD5x55pmjR49uuibkpptuOu6441566aW6urot3POss86aO3du3759kyRZsGDBsGHDbr/99kyfDe2CK0kAAP5qzz33LBaLSZIUi8Xzzz8/SZIf//jHt912W11d3fz588vl8hbumSRJmqZf/vKXb7rppsMOO2zu3LkDBgwYMWJEds+GdsF72wAAf3X88cfPmTMnSZI5c+b0798/SZLf//7399xzT5IkM2bMOP3005MkWb58+fveM0mSG2+88eSTT+7evfvKlSvTNF2xYkXWT4jseW8bAOCvrrjiitGjR19xxRUdO3a8/vrrkyS55pprRo4c+fWvf/3www//P//n/yRJ8slPfnLWrFmb3rOxsfEnP/lJU5qPGzduyJAhF110UdZPiOypbQCAv/rABz5w1113bXhLnz59HnzwwQ1vmTVr1vves6Gh4d577236+ot/0Sa7THvnShIAAIiitgEAIIraBgCAKIU0TcMenOyVSqWsdwFyb8PP/GpLzl/I7/kLzfyW5PavUqlUN1gsFlsyu2BiY3WzvSc1tGR2xpyx1c2OHDjVbNvMtuTnm8nrOUO1dv5m9XzNbv1s7n6+kDlXkgAAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUQppmoY9ONkrlUpZ7wLkXrlczmS7zl/I7/kLzTr+7Uu2U5VKpbrBYrHYktkFExurm+09qWHGnLHVzY4cONVs+59tyWsjk9dzhvJ4/ma1z1nNtuRcyOPzzd1rAzLnShIAAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIEohTdOwByd7pVIp612A3CuXy5ls1/kL+T1/oVnHv33JdqpSqVQ3WCwWWzK7YGJjdbO9JzXMmDO2utmRA6fmcbYlx6rWZjN5PWcoj+dvVvvcknMwq2NVa7O1dv5CE1eSAABAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABRCmmahj042SuVSlnvAuReuVzOZLvOX8jv+QvNOv7tS7ZTlUqlusFisdiS2QUTG6ub7T2pYcacsdXNjhw4NY+zLTlWWf18a2o2Q3k8f3P383Wstu9ZyJwrSQAAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKIU0TcMenOyVSqWsdwFyr1wuZ7Jd5y/k9/yFZh3/9iXbqUqlUt1gsVhsyeyCiY3Vzfae1GB262ez+vnW1GyGnL/b92zuzoU8zkLmXEkCAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAEQppGka9uBkr1QqZb0LkHvlcjmT7Tp/Ib/nL/xNynatWCwm1TJr1mwT569Zs/mdzer8hWauJAEAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAohTSNA17cLJXKpWy3gXIvXK5nMl2nb+Q3/MX/iZlu1YsFpNqmTVrtonz16zZ/M5mdf5CM1eSAABAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABRCmmahj04AADUNO9tAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAACRB/n+15RY5M4KyIgAAAABJRU5ErkJggg=="
            },
            {
              "type": "input_text",
              "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
            }
          ],
          "solved_count": 0,
          "total_training_examples": 3,
          "pixel_accuracy": 0.8232373386295928
        },
        "test_result": {
          "correct": false,
          "pixel_accuracy": 0.7596153846153846,
          "total_pixels": 624,
          "correct_pixels": 474,
          "error": null
        },
        "status": "failed_test",
        "feedback_sent": true
      },
      {
        "turn_number": 4,
        "timestamp": "2025-07-10T13:42:54.105045",
        "input_tokens": 33493,
        "output_tokens": 1689,
        "turn_cost": 0.016099600000000002,
        "program_extracted": true,
        "program": "def transform(grid):\n    import numpy as np\n    from collections import deque, Counter\n\n    grid = np.array(grid)\n    h, w = grid.shape\n    output = grid.copy()\n\n    def neighbors(r, c):\n        for nr, nc in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\n            if 0 <= nr < h and 0 <= nc < w:\n                yield nr, nc\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def bfs_component(sr, sc):\n        q = deque([(sr, sc)])\n        comp_pixels = []\n        visited[sr, sc] = True\n        while q:\n            r, c = q.popleft()\n            comp_pixels.append((r, c))\n            for nr, nc in neighbors(r, c):\n                if not visited[nr, nc] and grid[nr, nc] != 0:\n                    visited[nr, nc] = True\n                    q.append((nr, nc))\n        return comp_pixels\n\n    def find_outline_pixels(component):\n        comp_set = set(component)\n        outline = set()\n        for (r, c) in component:\n            for nr, nc in neighbors(r, c):\n                if (nr, nc) not in comp_set:\n                    outline.add((r, c))\n                    break\n        return outline\n\n    # Find connected components of outlines\n    components = []\n    for r in range(h):\n        for c in range(w):\n            if grid[r, c] != 0 and not visited[r, c]:\n                comp = bfs_component(r, c)\n                components.append(comp)\n\n    for comp in components:\n        comp_set = set(comp)\n        outline_set = find_outline_pixels(comp)\n\n        # Determine outline color (majority color in component)\n        colors_in_comp = [grid[r, c] for r, c in comp]\n        outline_color = Counter(colors_in_comp).most_common(1)[0][0]\n\n        rows = [r for r, c in comp]\n        cols = [c for r, c in comp]\n        rmin, rmax = max(min(rows), 0), min(max(rows), h - 1)\n        cmin, cmax = max(min(cols), 0), min(max(cols), w - 1)\n\n        box_h = rmax - rmin + 1\n        box_w = cmax - cmin + 1\n\n        mask = np.zeros((box_h, box_w), dtype=np.int8)\n\n        for (r, c) in comp_set:\n            rr, cc = r - rmin, c - cmin\n            if (r, c) in outline_set:\n                mask[rr, cc] = 1  # outline\n            else:\n                mask[rr, cc] = 2  # possible interior\n\n        # Flood fill mask from outside bounding box edges where mask == 0 (exterior)\n        visited_box = np.zeros_like(mask, dtype=bool)\n        q = deque()\n        for rr in range(box_h):\n            for cc in [0, box_w - 1]:\n                if mask[rr, cc] == 0 and not visited_box[rr, cc]:\n                    q.append((rr, cc))\n                    visited_box[rr, cc] = True\n        for cc in range(box_w):\n            for rr in [0, box_h - 1]:\n                if mask[rr, cc] == 0 and not visited_box[rr, cc]:\n                    q.append((rr, cc))\n                    visited_box[rr, cc] = True\n\n        while q:\n            rr, cc = q.popleft()\n            for nr, nc in ((rr-1, cc), (rr+1, cc), (rr, cc-1), (rr, cc+1)):\n                if 0 <= nr < box_h and 0 <= nc < box_w:\n                    if not visited_box[nr, nc] and mask[nr, nc] == 0:\n                        visited_box[nr, nc] = True\n                        q.append((nr, nc))\n\n        # Interior pixels are mask==2 and not visited (not reachable from outside)\n        interior_pixels = []\n        for rr in range(box_h):\n            for cc in range(box_w):\n                if mask[rr, cc] == 2 and not visited_box[rr, cc]:\n                    interior_pixels.append((rr + rmin, cc + cmin))\n\n        # Build counts of colors in interior pixels excluding outline_color and zero\n        interior_colors = [grid[r, c] for r, c in interior_pixels if grid[r, c] != 0 and grid[r, c] != outline_color]\n\n        if interior_colors:\n            fill_color = Counter(interior_colors).most_common(1)[0][0]\n        else:\n            # If none found, try including outline color to fill interior (covers gray in ex1)\n            interior_colors_alt = [grid[r, c] for r, c in interior_pixels if grid[r, c] != 0]\n            if interior_colors_alt:\n                fill_color = Counter(interior_colors_alt).most_common(1)[0][0]\n            else:\n                # Fallback to outline color if no interior pixels or colors found\n                fill_color = outline_color\n\n        # Fill interior pixels in output with fill_color (do not overwrite outline pixels)\n        for r, c in interior_pixels:\n            output[r, c] = fill_color\n\n    return output.tolist()",
        "training_feedback": {
          "feedback_messages": [
            {
              "type": "input_text",
              "text": "Training results: 0/3 examples solved, 82.3% pixel accuracy - Good partial progress! Your approach is capturing some patterns. Next, try to identify a transformation that solves at least one of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 1, 1, 1, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 5, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 0, 8, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 8, 0, 0, 8, 2, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 3, 0, 8, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 1, 1, 1, 0, 0, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 5, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 5, 0, 5, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 90.0%\n\nTraining Example 2 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 6, 6, 6, 0, 0], [0, 0, 2, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 2, 2, 2, 3, 3, 3, 3, 3, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 6, 6, 6, 6, 6], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 3, 0, 2, 0, 0, 6, 6, 6, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 6, 0, 3, 0, 0], [0, 0, 2, 2, 2, 0, 3, 0, 0, 0, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 6, 6, 6, 6, 6], [0, 0, 0, 0, 2, 0, 0, 0, 8, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 8, 0], [3, 0, 0, 0, 0, 0, 0, 4, 8, 0, 3, 0, 8, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 8, 0, 4, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 80.7%\n\nTraining Example 3 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 3, 3, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 3, 3, 6, 6, 6, 6, 6, 6, 3, 3, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 3, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0], [0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 3, 0, 0, 0, 8, 0, 0, 8, 0, 3, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 0, 3, 0, 6, 0, 0, 2, 0, 0, 3, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 3, 0, 0, 0, 0, 6, 0, 0, 0, 3, 0, 0], [0, 0, 3, 0, 0, 6, 0, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 69.6%\n\n"
            },
            {
              "type": "input_image",
              "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA88AAAUtCAIAAABNteEnAABUgklEQVR4nO3de5xVdb34/7URBlFwRtFUBEsk0R58RdO8kHJQ+D5S8LJ3YB1NPXBQ035IgaLZ4WT5xTQhO9HF/IZCpqQnT3t7OWbkN4UsKVPyrqGgIaDH26AIcl2/R01n4oAQ7Jn3rFns5/PhH+Oe/d5r7TV7fXi5XbMppGmaAAAAATpEPCgAAKC2AQAgkNoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAaJe1PWbMmMLmnXnmme97n7q6ur322uuUU0559NFHN33MX/ziF4VCYbfddnvvvfc2+tbtt99eKBSmTZvW9K8jR44sFAqTJ0/e6G4vv/xyoVCYOHFiS6aavPfee9dff/1xxx3Xo0ePzp079+jR47TTTvvVr361hWMyceLEzR2QJ598cssHbciQIX/3wDbf55xzztnw9qbdGz58+EMPPbTh/hSLxY3utt9++40dO/att97apoPf5PXXX580adKhhx5aX1+/8847H3HEEdOmTUvTdKPNbTT+yCOP7LHHHt26dbv//vu3cOgAALY/Gby3vWbNmldfffWuu+467rjjFixYsNF3b7zxxiRJ3nrrrdtuu21rHu3LX/7ys88+u637sDVTL7744tFHH33++ec/8MADS5cuXb169dKlS2+//faBAwdee+21STvTtHs//elPjznmmFtuuWULd3vxxRe//e1vn3DCCevXr9+mg//QQw/179//X//1X//whz+8/fbbK1asePjhh88999zRo0dvYcd++ctfHnfccevWrbvvvvuOO+64FjxFAIAaq+3vfOc76X/7yU9+kiTJ9OnTm2+5+eabm++5cOHC5tvfe++9Z5555owzznj77bevu+66DR+wsbGxUqmcdtppu+222/e///2t2YfVq1ePHDly3bp127Tnf3dqzZo1I0aM+MMf/jBgwIA777zz9ddfX7NmzZ/+9Kfvfe97u+222yWXXNL0RvXmzJs3L91Ev3793veANLvvvvs2fJCtuc/SpUubbl+5cuXzzz//xS9+MU3Tf/7nf37ppZc2vNvKlSs3PPhDhgz53e9+94tf/GLrD/5//dd/lUqlJUuWnH766XPnzn377bfffPPNSqXSu3fv6dOnX3/99e97HMrl8tChQ3faaacHHnjgyCOP3MIRAwDYLmXw3nbnzp0PPPDAr3/960mSbPTe9syZM997773Pfvazo0aNmjt37uOPP/53H+3CCy/87W9/+41vfGOb9uHvTv3whz985JFHhgwZMmfOnJNPPrl79+4dO3bs1avXBRdc8NOf/nTdunU//vGPk/Zkxx133H///a+66qovf/nLq1ev/rd/+7ctHPwvfOELTaW+9Qf/2muvffXVV8eNGzdz5swjjzyyW7duu+6666mnnjp79uydd9752muv3fB6kiY33HDDaaed9oEPfOBXv/rVwQcf3Hz7jBkzCoXCd77znVY9AAAA7VEGtb1q1aqnnnpq/PjxSZIccMABG35r+vTpBx100PHHH3/BBRfssMMOW/P29te+9rU+ffp8+ctffuaZZ7Z+H/7u1MyZMwuFwv/9v/93hx122Ohb//AP//D0009PmjQpaZcuuuiinXba6ec///n7fnfNmjV//OMfp06d2rFjx3/4h3/Y+oP/7//+7126dLniiis2esCePXs++OCDDzzwQKFQ2PD2a6655pxzzundu/eDDz744Q9/uPWeHwBAnrRRbe+3337Nv6i344479uvX7yc/+cnuu+/++c9/vvk+Tz755O9///sJEyYUCoX999//tNNOu+WWW5YvX77lR95pp52mT5++Zs2abbqe5O9OzZs376CDDtpvv/3ed/yggw7aKC43cuihh270240PPvjg5g5IswceeGBb77Opbt26ffjDH97ofxp06dKlabyurq5v376//vWvf/jDH2747LZ88NesWfPiiy8eccQRXbt23XSLhxxyyN57773hLZdccsmll16aJMmxxx677777bnT/kSNHpmk6ZsyYLT8RAIDtQDafALjPPvv88z//82OPPbbXXns133jjjTfus88+n/nMZ5r+9bLLLnvnnXe25oKNY445ZuzYsb/73e+mTJmy9fuwhak1a9Y0NjbuueeeG9640eeEfOhDH0raq+7du6/6i83dYd26dXPnzl2zZs1WHvzGxsY0Tbt3776VO/Dtb3/76KOPHjJkyI033vjTn/60Zc8GACDH2qi2m37hb/Xq1bfeemvTm69XX311jx49mu+wZs2am2++efHixZ07d27K2f79+6dpupW/K/m1r33twx/+8OWXX/70009v/V5tbqpTp07dunV77bXXkmpt+luSxxxzzN/9DchBgwZt633e11tvvdWpU6fOnTtv+luSq1evXrBgwf/3//1/3/72ty+++OKtPPi77bZbhw4dtv6AjBo16oEHHrjpppt22223c889d/HixVs5CACwnWnT97Y7der06U9/+rbbbps9e/YJJ5yw4acy33333e8bc48++ujDDz/8dx+5S5cuVVxPsoWp//W//tfTTz/9pz/96X0/gOWwww5L2qvly5c/+eSTBx100Pt+t1OnTvvtt9+UKVP69es3Y8aMrTz4O+yww0EHHfT73/9+xYoVm97tqquuOvvss5csWdJ8y/e+9726urq99977O9/5zptvvnn22Wdv+mmDAAC1IIMrSU488cQLL7zw0UcfbX5vtelKhh133HHZsmUbvo/7m9/8JkmSzX263EY+/vGPf/7zn3/44Yc3/Ztrqpj6zGc+s379+s997nPv2+6bfv5G+/HNb35zzZo1J5xwwpbv1qFDh+XLl69du3YrD36xWFy5cuVXvvKVjR7nxRdfvOaaa+6+++73vc7k9NNPHzFixC9/+cttusgHAGC7kc1121/72tf23Xff66677re//W2SJK+88sq999578skn77LLLhve7eijj+7bt++Pf/zjZcuWbc3DXnnllR/+8Ie/973vbdPOvO/UOeecc9hhh/3nf/7nEUcc8e///u+vvPLKmjVrmv52m2HDhj366KMdOrSvv/R+1apVzz333MSJE7/61a/utNNOm/sdxDRNX3755QkTJjz++OOHHnpox44dt/Lgjxs3rnv37pMnTz777LN///vfr1y58tVXX505c+agQYMaGxsnTJiw4YUrG7ruuuv23HPPiRMnPvLIIzFPHQCg/comGXfeeedvf/vb69ev/+xnP7t27dqbbrpp7dq1zb+it6F/+qd/WrFixY9+9KOtvzJky58WspVTdXV1lUrl6KOPfvTRRz/96U/vvffedXV1TX9z+z333NO3b9+t/KsuN+d9P2+kUChs+BksW3Ofvffeu/mTXg488MArr7yy6a+p79Wr10bPseluHTp06NWr15QpUzp06ND0IYZbefC7d+9+2223devW7Uc/+tHHPvaxnXbaaa+99vrMZz7z0ksvlUqlSy65ZHPPdPfdd//BD36wZs2aM84449133/V52wBATcnsDdpTTjmlWCw+9thj//Zv/zZjxoxdd931xBNP3PRuZ599docOHbbyYpKmK0Oa/uqWbfK+Uz179vzVr3518803Dx06tGfPnnV1dXvuuefQoUN/+MMfPvnkkx/72MeS9qRTp069evX6x3/8x1//+tenn3765u62ww47fOADHxg2bNgvfvGLpqtNtv7gDx48eN68eWPHjj3wwAO7du3apUuXI488ctq0af/xH/+x6aeSb+jkk08eOXLkH//4xw0/8BEAoBYU2vMlyAAAkGvt6+JjAADYnqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqmxx74403nn322az3AmC7ZZmFllPbtI6ePXsWNnHzzTeHbnTIkCFz587d+vtPmTLlqKOO2tx3Gxsbe/fuvU0PCNA2dt999+alta6u7qCDDpo6dWrVj9a8GDY2NhYKhS30tGUWWk5t02q++c1vpv/TmWeeGbrFlStXttZDLVq0aMiQIQsXLmytBwRoXdddd13T0vruu+9Onjz54osv/tGPftTCx2xoaEjT9MADD9zcHSyz0HJqm1g33HBD586dFy1alCTJa6+9tssuu0yfPv31118vFAo33HBDz5496+vrR48e3bygL126dMSIEV27du3Vq9f48eObb1+8eHGpVOrWrdsee+zxuc99btWqVYMGDXruuedGjRp1zjnnbGHwqaeeOvbYY7t06TJgwIDNrfL/+Z//2a9fv8MOO6ytjgpA9Tp16nTSSScNHjy4XC6/8sorhULhsssuq6+vHzly5LYuhhu+t22ZhSBqm1ijR48+5phjrr766iRJrrzyysMPP3zUqFFN37rmmmvuvffeefPmPfLII2PGjGm6cfjw4d26dXvxxRdnz5798MMPjxs3LkmSdevWnXjiiXV1dS+88MJDDz30xBNPXH755Q888EDfvn2nT58+bdq0zQ2+9957Q4cO7d+//5IlSy677LLp06e/70527tz5vvvu++53v9uGBwagRdauXdu1a9emr5999tmXX375iiuuqHoxtMxCoI3+1z9UZ5999tnopbXDDjs0fWv+/PkNDQ3XXnttfX39/Pnz0zR97bXXkiQpl8tNd5g1a1ZdXd3y5ctnz5690047rVq1qun2hx9+uEOHDitXrpw9e3ZdXd0bb7yx0Uab/hhI03Rzg5VKpb6+fsWKFU23n3feeUceeeTmnsKaNWuSJHnooYcCDg9Ai3Tv3r35SpLGxsbp06d36NDh7rvvXrp0aZIk99xzT9O3tnUxfOutt5IkeeaZZyyzEMd720Rdt7127dqm2/v06TNhwoTx48dfdNFFffr0ab5/82/SHHLIIatXr37hhReefvrpFStWdO7cuek3gT72sY+tX79+wYIFTz31VM+ePXfbbbfNbXpzg08//fT+++/fpUuXprsdeuihwccAIMoFF1zQtMTtueeeU6ZM+e53vzts2LCmb+27774tXAwtsxBHbdMWnnzyySRJHn300Q1v7NSpU9MX69atS5KkY8eOa9eu7dOnz0b/RfiRj3ykU6dOhUJhC4+/ucGN7ta8RYDcaX5v+7333nvyySfPP//85m917ty5hYuhZRbiqG3C/exnP7vtttsmT558xx13VCqV5tsff/zxpi/mzZvXtWvX/fff/8ADD1y4cOHLL7+80SMccMABixYtavo/nhtq/rNhc4P9+vWbP3/+u+++2/SvTzzxRGs/OYB2pOrF0DILcdQ2sZYvX37++eePHTv24osvPvfcc8eMGfPOO+80feuSSy5ZuHDh/PnzL7300vPOO69z587HH3/8wQcfPGrUqEWLFi1evPgLX/jCvvvuu2rVqmOPPbZfv34XXnjh66+//uKLLw4fPvz0009PkmTnnXdesmTJO++8s7nBT3ziE3vvvffnP//5N99887777rvxxhuzPh4AgapeDC2zEEdt02rGjRu30d9uc/7553/pS1/q0KHDpEmTkiSZPHlyhw4dvvSlLzXdf8iQIccdd9yRRx75v//3/2760JIOHTpUKpWdd975oIMO+shHPvLcc8/NmjWr6TLB//iP/3jzzTd79ep1+OGH77LLLtdff32SJOeff/5VV101atSozQ3W1dX97Gc/e/HFF/fZZ59x48ade+65WR8kgEBVL4aWWYhTSNO06uFSqdSqO0OtWL169T333DN48OBu3bplvS/w95XL5Uy2a40FakE5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5/r16zdr1qwePXosXrz4hBNOeOKJJ5ruuent++677y9/+cvBgwfPmzfvrLPOuvvuuwuFQhKsYwvnK5VKdYPFYjGXs32+XuXs85dmNXvGGWdUNztz5sysZlt0rPL4ujLbvmczlLtjVYNrbFbHqv/kKv8j8LEJpTw+X7Pb8ey2Ovjgg++8885SqVQul5uuJHn11Vf32muvJEn23nvvpluabHr7lVdeeeaZZ1511VUTJ0786le/2gap7UoSAADyZNq0aTfddNNxxx330ksv1dXVbdPsWWedNXfu3L59+yZJsmDBgmHDht1+++1JO39vGwAA2syPf/zj2267ra6ubv78+U1Xoey5556vvPJKjx49li5duueeezbf831vT9P0y1/+8k033XTYYYfNnTt3wIABI0aMCN1h720DAJAbv//97++5554kSWbMmHH66acnSTJ06NBbb701SZJbb7116NChSZIsX778fW9PkuTGG288+eSTu3fvvnLlyjRNV6xYEb3DahsAgNy45pprpkyZcvTRR7/99tsXXHBBkiT/8i//MmfOnGOOOeZXv/rVl770pSRJPvnJT77v7Y2NjT/5yU/OO++8JEnGjRs3ZMiQiy66KHqHXUkCAEBu9OnT58EHH9zwlvr6+o1+R3PWrFnve3tDQ8O9997b9PUX/6INdth72wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEKWQpmnVw6VSqVV3BqA9KpfLmWzXGgvUgnJGa2yb6djC+UqlUt1gsVjM5Wyfr1c5+/ylZ5xxRnWzM2fOrLXZlhznXL6uzLbv2Qzl7lhluMZmtc8tWuscZ7Nma4ArSQAAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKIU0TaseLpVKrbozAO1RuVzOZLvWWKAWZLXGtpmOLZyvVCrVDRaLxVzO9vl6lbPPX3rGGWdUNztz5sxam23Jcc7l68ps+57NUO6OVYZrbC6fr+Ns1mwNcCUJAABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsA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hQsXbrqHDz/88IIFC6699tpdd921T58+l19++R133JGmaRseJCAznTp1OumkkwYPHlwul1955ZVCoXDZZZfV19ePHDlyWxeWDd/btmRB7qht8mr06NHHHHPM1VdfnSTJlVdeefjhh48aNarpW9dcc8299947b968Rx55ZMyYMU03Dh8+vFu3bi+++OLs2bMffvjhcePGJUmybt26E088sa6u7oUXXnjooYeeeOKJyy+//IEHHujbt+/06dOnTZu2ucH33ntv6NCh/fv3X7JkyWWXXTZ9+vRN93DAgAFr1qypq6tr+telS5futttuhUKhDQ8SkLG1a9d27dq16etnn3325ZdfvuKKK6peWCxZkEsb/Q96aG/22WefjV60O+ywQ9O35s+f39DQcO2119bX18+fPz9N09deey1JknK53HSHWbNm1dXVLV++fPbs2TvttNOqVauabn/44Yc7dOiwcuXK2bNn19XVvfHGGxtttOmPrjRNNzdYqVTq6+tXrFjRdPt555135JFHbuFZNDY27rfffpdffnlrHx6gHenevXvzlSSNjY3Tp0/v0KHD3XffvXTp0iRJ7rnnnqZvbevC8tZbbyVJ8swzz1iyII+8t03+rtteu3Zt0+19+vSZMGHC+PHjL7rooj59+jTfv/m3fw455JDVq1e/8MILTz/99IoVKzp37tz020sf+9jH1q9fv2DBgqeeeqpnz5677bbb5ja9ucGnn356//3379KlS9PdDj300C3s/7vvvnvyySf369dv4sSJrXRIgHbqggsuaFou9txzzylTpnz3u98dNmxY07f23XffFi4slizII7VNvj355JNJkjz66KMb3tipU6emL9atW5ckSceOHdeuXdunT5+N/lvzIx/5SKdOnbb8/0k3N7jR3Zq3uKk33nhj8ODBPXv2vP322zt27Niypwu0d83vbb/33ntPPvnkhr9o2Llz5xYuLJYsyCO1TY797Gc/u+222yZPnnzHHXdUKpXm2x9//PGmL+bNm9e1a9f999//wAMPXLhw4csvv7zRIxxwwAGLFi1q+r+0G2r+82xzg/369Zs/f/67777b9K9PPPHE++7hyy+/fMwxxwwcOPCWW25pvhoSqHFVLyyWLMgjtU1eLV++/Pzzzx87duzFF1987rnnjhkz5p133mn61iWXXLJw4cL58+dfeuml5513XufO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ABBFbQMAQBS1DQBQo/7f//t/AwYMOO6444499tiHHnooSZJly5YVi8VjjjmmWCwuW7as+Z7/+I//OOgvBgwYsPvuuydJcvXVV/fr12/y5MlJkqxfv37YsGGNjY2ZPpt2qmPWOwAAQDZGjx59//3377fffi+88MLJJ5/89NNPX3nllQMHDhw/fvw3vvGNq6666uqrr26656233tr0xbRp0/70pz8lSfKtb33rueee69u374QJE6ZNmzZ8+PCGhoZMn007VUjTNKklpVIp610AcqZcLmeyXesVEL1eHXbYYddff/3hhx/+u9/97rTTTnvppZf69es3a9asHj16LF68+IQTTnjiiSc2vH+aph/96Ed//vOff+ADH9h3331/+ctfDh48eN68eWedddbdd99dKBRa+wltF9IaUywWqz5WZs0GzabPJ9X9k9PZrI5z1bM1uF5dPj+t7p88/nzNbtNsHtcc69UW/O53v+vcuXO/fv06d+581113pWm6++67r1u3Lk3TdevW7bHHHhvd/4477jj33HObvr7pppuOPPLIW2655YILLnj44YdbaeXbDrluGwCgRl188cW33HLLE0888aMf/einP/3p373/N77xjYsuuqjp67POOmvu3Ll9+/ZNkmTBggXDhg27/fbb43c5f1y3DQBQo5544ommi9Y++clPXnDBBUmS7Lnnnq+88kqPHj2WLl265557bnjn3/72tw0NDU153SRN0y9/+cs33XTTYYcdNnfu3AEDBowYMSKL59GueW8bAKBG9e3b99e//nWSJA899NCHPvShJEmGDh3a9AuRt95669ChQ5MkWb58edOdr7nmmuY3tpvceOONJ598cvfu3VeuXJmm6YoVKzJ6Hu2a97YBAGrU97///bFjx/75czMKhWnTpiVJ8i//8i//9E//9NOf/nT33Xf/4Q9/2PS296xZs55//vklS5YMHDiwebaxsfEnP/nJPffckyTJuHHjhgwZslGL00RtAwDUqP79+8+ePXvDW+rr6yuVyoa3zJo1K0mSPn36NH0gd7OGhoZ777236esv/kWb7HL+uJIEAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiFNI0TWpJqVTKeheAnCmXy5ls13oF5GW9Ygs6JrWn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kiRr1qz5+c9//slPfnLXXXc966yzWvKYDQ0NaZpu4Q5OYWBT3tuGbXPDDTd07tx50aJFSZK89tpru+yyy/Tp019//fVCoXDDDTf07Nmzvr5+9OjRzX/oLl26dMSIEV27du3Vq9f48eObb1+8eHGpVOrWrdsee+zxuc99btWqVYMGDXruuedGjRrV9Mfq5gafeuqpY489tkuXLgMGDFi4cOGme/jCCy/cf//9U6ZMqa+vP/zww4877rjf/OY3bXiEoH3p1KnTSSedNHjw4HK5/MorrxQKhcsuu6y+vn7kyJHbeqJt+N62UxjYSmobts3o0aOPOeaYq6++OkmSK6+88vDDDx81alTTt6655pp777133rx5jzzyyJgxY5puHD58eLdu3V588cXZs2c//PDD48aNS5Jk3bp1J554Yl1d3QsvvPDQQw898cQTl19++QMPPNC3b9/p06dPmzZtc4Pvvffe0KFD+/fvv2TJkssuu2z69Omb7uH++++/fv367t27r1279v/9RalUatuDBO3O2rVru3bt2vT1s88++/LLL19xxRVVn2hOYWAbpMD72WeffTY6WXbYYYemb82fP7+hoeHaa6+tr6+fP39+mqavvfZakiTlcrnpDrNmzaqrq1u+fPns2bN32mmnVatWNd3+8MMPd+jQYeXKlbNnz66rq3vjjTc22mjTH9Vpmm5usFKp1NfXr1ixoun2884778gjj9zcU+jbt2/nzp0HDRr02muvBRwhaL+6d+9+3XXXNX3d2Ng4ffr0Dh063H333UuXLk2S5J577mn61raeaG+99VaSJM8884xTGNh63tuGzfrmN7+54dmydu3aptv79OkzYcKE8ePHX3TRRX369Gm+f/NvOx1yyCGrV69+4YUXnn766RUrVnTu3Lnpt7U+9rGPrV+/fsGCBU899VTPnj132223zW16c4NPP/30/vvv36VLl6a7HXrooVvY/2efffaNN97YaaedTjrppFY6JJAbF1xwQdPps+eee06ZMuW73/3usGHDmr617777tvBEcwoDW09tQzWefPLJJEkeffTRDW/s1KlT0xfr1q378+8gd+y4du3aPn36bPTfuB/5yEc6depUKBS28PibG9zobs1b3Jydd9554sSJv/3tb5csWVLtc4Vcan5v+7333nvyySebfmOySefOnVt4ojmFga2ntmGb/exn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JZc88MAD48aN+8pXvrKFe37rW9/6zW9+c+211yZJMm3atOHDhzc0NGT6bGgX/O02AAB/dcstt/zwhz9MkmTYsGHz589PkuQPf/jDoEGDkiQZNGjQ5z73uS3cs1OnTv/1X/9VV1f35ptv3nHHHXfffXemT4X2wnvbAAB/9cc//vHOO+8cNGjQpz/96U996lNJkhx88MF33nln018Cv+GVJJve88orrzzzzDOvuuqqiRMnfvWrXy0UCpk+FdoLtQ0A8FerV6/+4Ac/+MADD5x55pmjR49uuibkpptuOu6441566aW6urot3POss86aO3du3759kyRZsGDBsGHDbr/99kyfDe2CK0kAAP5qzz33LBaLSZIUi8Xzzz8/SZIf//jHt912W11d3fz588vl8hbumSRJmqZf/vKXb7rppsMOO2zu3LkDBgwYMWJEds+GdsF72wAAf3X88cfPmTMnSZI5c+b0798/SZLf//7399xzT5IkM2bMOP3005MkWb58+fveM0mSG2+88eSTT+7evfvKlSvTNF2xYkXWT4jseW8bAOCvrrjiitGjR19xxRUdO3a8/vrrkyS55pprRo4c+fWvf/3www//P//n/yRJ8slPfnLWrFmb3rOxsfEnP/lJU5qPGzduyJAhF110UdZPiOypbQCAv/rABz5w1113bXhLnz59HnzwwQ1vmTVr1vves6Gh4d577236+ot/0Sa7THvnShIAAIiitgEAIIraBgCAKIU0TcMenOyVSqWsdwFyb8PP/GpLzl/I7/kLzfyW5PavUqlUN1gsFlsyu2BiY3WzvSc1tGR2xpyx1c2OHDjVbNvMtuTnm8nrOUO1dv5m9XzNbv1s7n6+kDlXkgAAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUQppmoY9ONkrlUpZ7wLkXrlczmS7zl/I7/kLzTr+7Uu2U5VKpbrBYrHYktkFExurm+09qWHGnLHVzY4cONVs+59tyWsjk9dzhvJ4/ma1z1nNtuRcyOPzzd1rAzLnShIAAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIEohTdOwByd7pVIp612A3CuXy5ls1/kL+T1/oVnHv33JdqpSqVQ3WCwWWzK7YGJjdbO9JzXMmDO2utmRA6fmcbYlx6rWZjN5PWcoj+dvVvvcknMwq2NVa7O1dv5CE1eSAABAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABRCmmahj042SuVSlnvAuReuVzOZLvOX8jv+QvNOv7tS7ZTlUqlusFisdiS2QUTG6ub7T2pYcacsdXNjhw4NY+zLTlWWf18a2o2Q3k8f3P383Wstu9ZyJwrSQAAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKIU0TcMenOyVSqWsdwFyr1wuZ7Jd5y/k9/yFZh3/9iXbqUqlUt1gsVhsyeyCiY3Vzfae1GB262ez+vnW1GyGnL/b92zuzoU8zkLmXEkCAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAEQppGka9uBkr1QqZb0LkHvlcjmT7Tp/Ib/nL/xNynatWCwm1TJr1mwT569Zs/mdzer8hWauJAEAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAohTSNA17cLJXKpWy3gXIvXK5nMl2nb+Q3/MX/iZlu1YsFpNqmTVrtonz16zZ/M5mdf5CM1eSAABAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABRCmmahj04AADUNO9tAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAACRB/n+15RY5M4KyIgAAAABJRU5ErkJggg=="
            },
            {
              "type": "input_text",
              "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
            }
          ],
          "solved_count": 0,
          "total_training_examples": 3,
          "pixel_accuracy": 0.8232373386295928
        },
        "test_result": {
          "correct": false,
          "pixel_accuracy": 0.7596153846153846,
          "total_pixels": 624,
          "correct_pixels": 474,
          "error": null
        },
        "status": "failed_test",
        "feedback_sent": true
      },
      {
        "turn_number": 5,
        "timestamp": "2025-07-10T13:43:28.972162",
        "input_tokens": 43626,
        "output_tokens": 1411,
        "turn_cost": 0.019708,
        "program_extracted": true,
        "program": "def transform(grid):\n    import numpy as np\n    from collections import deque, Counter\n\n    grid = np.array(grid)\n    h, w = grid.shape\n    output = grid.copy()\n\n    def neighbors(r, c):\n        for nr, nc in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\n            if 0 <= nr < h and 0 <= nc < w:\n                yield nr, nc\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def bfs_component(sr, sc):\n        q = deque([(sr, sc)])\n        comp_pixels = []\n        visited[sr, sc] = True\n        while q:\n            r, c = q.popleft()\n            comp_pixels.append((r, c))\n            for nr, nc in neighbors(r, c):\n                if not visited[nr, nc] and grid[nr, nc] != 0:\n                    visited[nr, nc] = True\n                    q.append((nr, nc))\n        return comp_pixels\n\n    def find_outline_pixels(component):\n        comp_set = set(component)\n        outline = set()\n        for (r, c) in component:\n            for nr, nc in neighbors(r, c):\n                if (nr, nc) not in comp_set:\n                    outline.add((r, c))\n                    break\n        return outline\n\n    # Find connected components of outlines\n    components = []\n    for r in range(h):\n        for c in range(w):\n            if grid[r, c] != 0 and not visited[r, c]:\n                comp = bfs_component(r, c)\n                components.append(comp)\n\n    for comp in components:\n        comp_set = set(comp)\n        outline_set = find_outline_pixels(comp)\n\n        # Determine outline color (majority color in component)\n        colors_in_comp = [grid[r, c] for r, c in comp]\n        outline_color = Counter(colors_in_comp).most_common(1)[0][0]\n\n        rows = [r for r, c in comp]\n        cols = [c for r, c in comp]\n        rmin, rmax = max(min(rows), 0), min(max(rows), h - 1)\n        cmin, cmax = max(min(cols), 0), min(max(cols), w - 1)\n\n        box_h = rmax - rmin + 1\n        box_w = cmax - cmin + 1\n\n        mask = np.zeros((box_h, box_w), dtype=np.int8)\n\n        for (r, c) in comp_set:\n            rr, cc = r - rmin, c - cmin\n            if (r, c) in outline_set:\n                mask[rr, cc] = 1  # outline\n            else:\n                mask[rr, cc] = 2  # possible interior\n\n        # Flood fill mask from bounding box edges where mask == 0\n        visited_box = np.zeros_like(mask, dtype=bool)\n        q = deque()\n        for rr in range(box_h):\n            for cc in [0, box_w - 1]:\n                if mask[rr, cc] == 0 and not visited_box[rr, cc]:\n                    q.append((rr, cc))\n                    visited_box[rr, cc] = True\n        for cc in range(box_w):\n            for rr in [0, box_h - 1]:\n                if mask[rr, cc] == 0 and not visited_box[rr, cc]:\n                    q.append((rr, cc))\n                    visited_box[rr, cc] = True\n\n        while q:\n            rr, cc = q.popleft()\n            for nr, nc in ((rr-1, cc), (rr+1, cc), (rr, cc-1), (rr, cc+1)):\n                if 0 <= nr < box_h and 0 <= nc < box_w:\n                    if not visited_box[nr, nc] and mask[nr, nc] == 0:\n                        visited_box[nr, nc] = True\n                        q.append((nr, nc))\n\n        # Interior pixels: mask==2 and not reachable from outside (visited_box==False)\n        interior_pixels = []\n        for rr in range(box_h):\n            for cc in range(box_w):\n                if mask[rr, cc] == 2 and not visited_box[rr, cc]:\n                    interior_pixels.append((rr + rmin, cc + cmin))\n\n        # Determine fill color:\n        # 1. Most common nonzero color inside interior pixels excluding outline color\n        # 2. If none found, most common nonzero color including outline\n        # 3. Else fallback to outline color\n        interior_colors = [grid[r, c] for r, c in interior_pixels if grid[r, c] != 0 and grid[r, c] != outline_color]\n\n        if interior_colors:\n            fill_color = Counter(interior_colors).most_common(1)[0][0]\n        else:\n            interior_colors_alt = [grid[r, c] for r, c in interior_pixels if grid[r, c] != 0]\n            if interior_colors_alt:\n                fill_color = Counter(interior_colors_alt).most_common(1)[0][0]\n            else:\n                fill_color = outline_color\n\n        # Fill all interior pixels in output\n        for r, c in interior_pixels:\n            output[r, c] = fill_color\n\n    return output.tolist()",
        "training_feedback": {
          "feedback_messages": [
            {
              "type": "input_text",
              "text": "Training results: 0/3 examples solved, 82.3% pixel accuracy - Good partial progress! Your approach is capturing some patterns. Next, try to identify a transformation that solves at least one of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 1, 1, 1, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 5, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 0, 8, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 8, 0, 0, 8, 2, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 3, 0, 8, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 1, 1, 1, 0, 0, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 5, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 5, 0, 5, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 90.0%\n\nTraining Example 2 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 6, 6, 6, 0, 0], [0, 0, 2, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 2, 2, 2, 3, 3, 3, 3, 3, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 6, 6, 6, 6, 6], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 3, 0, 2, 0, 0, 6, 6, 6, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 6, 0, 3, 0, 0], [0, 0, 2, 2, 2, 0, 3, 0, 0, 0, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 6, 6, 6, 6, 6], [0, 0, 0, 0, 2, 0, 0, 0, 8, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 8, 0], [3, 0, 0, 0, 0, 0, 0, 4, 8, 0, 3, 0, 8, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 8, 0, 4, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 80.7%\n\nTraining Example 3 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 3, 3, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 3, 3, 6, 6, 6, 6, 6, 6, 3, 3, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 3, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0], [0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 3, 0, 0, 0, 8, 0, 0, 8, 0, 3, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 0, 3, 0, 6, 0, 0, 2, 0, 0, 3, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 3, 0, 0, 0, 0, 6, 0, 0, 0, 3, 0, 0], [0, 0, 3, 0, 0, 6, 0, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 69.6%\n\n"
            },
            {
              "type": "input_image",
              "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA88AAAUtCAIAAABNteEnAABUgklEQVR4nO3de5xVdb34/7URBlFwRtFUBEsk0R58RdO8kHJQ+D5S8LJ3YB1NPXBQ035IgaLZ4WT5xTQhO9HF/IZCpqQnT3t7OWbkN4UsKVPyrqGgIaDH26AIcl2/R01n4oAQ7Jn3rFns5/PhH+Oe/d5r7TV7fXi5XbMppGmaAAAAATpEPCgAAKC2AQAgkNoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAaJe1PWbMmMLmnXnmme97n7q6ur322uuUU0559NFHN33MX/ziF4VCYbfddnvvvfc2+tbtt99eKBSmTZvW9K8jR44sFAqTJ0/e6G4vv/xyoVCYOHFiS6aavPfee9dff/1xxx3Xo0ePzp079+jR47TTTvvVr361hWMyceLEzR2QJ598cssHbciQIX/3wDbf55xzztnw9qbdGz58+EMPPbTh/hSLxY3utt9++40dO/att97apoPf5PXXX580adKhhx5aX1+/8847H3HEEdOmTUvTdKPNbTT+yCOP7LHHHt26dbv//vu3cOgAALY/Gby3vWbNmldfffWuu+467rjjFixYsNF3b7zxxiRJ3nrrrdtuu21rHu3LX/7ys88+u637sDVTL7744tFHH33++ec/8MADS5cuXb169dKlS2+//faBAwdee+21STvTtHs//elPjznmmFtuuWULd3vxxRe//e1vn3DCCevXr9+mg//QQw/179//X//1X//whz+8/fbbK1asePjhh88999zRo0dvYcd++ctfHnfccevWrbvvvvuOO+64FjxFAIAaq+3vfOc76X/7yU9+kiTJ9OnTm2+5+eabm++5cOHC5tvfe++9Z5555owzznj77bevu+66DR+wsbGxUqmcdtppu+222/e///2t2YfVq1ePHDly3bp127Tnf3dqzZo1I0aM+MMf/jBgwIA777zz9ddfX7NmzZ/+9Kfvfe97u+222yWXXNL0RvXmzJs3L91Ev3793veANLvvvvs2fJCtuc/SpUubbl+5cuXzzz//xS9+MU3Tf/7nf37ppZc2vNvKlSs3PPhDhgz53e9+94tf/GLrD/5//dd/lUqlJUuWnH766XPnzn377bfffPPNSqXSu3fv6dOnX3/99e97HMrl8tChQ3faaacHHnjgyCOP3MIRAwDYLmXw3nbnzp0PPPDAr3/960mSbPTe9syZM997773Pfvazo0aNmjt37uOPP/53H+3CCy/87W9/+41vfGOb9uHvTv3whz985JFHhgwZMmfOnJNPPrl79+4dO3bs1avXBRdc8NOf/nTdunU//vGPk/Zkxx133H///a+66qovf/nLq1ev/rd/+7ctHPwvfOELTaW+9Qf/2muvffXVV8eNGzdz5swjjzyyW7duu+6666mnnjp79uydd9752muv3fB6kiY33HDDaaed9oEPfOBXv/rVwQcf3Hz7jBkzCoXCd77znVY9AAAA7VEGtb1q1aqnnnpq/PjxSZIccMABG35r+vTpBx100PHHH3/BBRfssMMOW/P29te+9rU+ffp8+ctffuaZZ7Z+H/7u1MyZMwuFwv/9v/93hx122Ohb//AP//D0009PmjQpaZcuuuiinXba6ec///n7fnfNmjV//OMfp06d2rFjx3/4h3/Y+oP/7//+7126dLniiis2esCePXs++OCDDzzwQKFQ2PD2a6655pxzzundu/eDDz744Q9/uPWeHwBAnrRRbe+3337Nv6i344479uvX7yc/+cnuu+/++c9/vvk+Tz755O9///sJEyYUCoX999//tNNOu+WWW5YvX77lR95pp52mT5++Zs2abbqe5O9OzZs376CDDtpvv/3ed/yggw7aKC43cuihh270240PPvjg5g5IswceeGBb77Opbt26ffjDH97ofxp06dKlabyurq5v376//vWvf/jDH2747LZ88NesWfPiiy8eccQRXbt23XSLhxxyyN57773hLZdccsmll16aJMmxxx677777bnT/kSNHpmk6ZsyYLT8RAIDtQDafALjPPvv88z//82OPPbbXXns133jjjTfus88+n/nMZ5r+9bLLLnvnnXe25oKNY445ZuzYsb/73e+mTJmy9fuwhak1a9Y0NjbuueeeG9640eeEfOhDH0raq+7du6/6i83dYd26dXPnzl2zZs1WHvzGxsY0Tbt3776VO/Dtb3/76KOPHjJkyI033vjTn/60Zc8GACDH2qi2m37hb/Xq1bfeemvTm69XX311jx49mu+wZs2am2++efHixZ07d27K2f79+6dpupW/K/m1r33twx/+8OWXX/70009v/V5tbqpTp07dunV77bXXkmpt+luSxxxzzN/9DchBgwZt633e11tvvdWpU6fOnTtv+luSq1evXrBgwf/3//1/3/72ty+++OKtPPi77bZbhw4dtv6AjBo16oEHHrjpppt22223c889d/HixVs5CACwnWnT97Y7der06U9/+rbbbps9e/YJJ5yw4acy33333e8bc48++ujDDz/8dx+5S5cuVVxPsoWp//W//tfTTz/9pz/96X0/gOWwww5L2qvly5c/+eSTBx100Pt+t1OnTvvtt9+UKVP69es3Y8aMrTz4O+yww0EHHfT73/9+xYoVm97tqquuOvvss5csWdJ8y/e+9726urq99977O9/5zptvvnn22Wdv+mmDAAC1IIMrSU488cQLL7zw0UcfbX5vtelKhh133HHZsmUbvo/7m9/8JkmSzX263EY+/vGPf/7zn3/44Yc3/Ztrqpj6zGc+s379+s997nPv2+6bfv5G+/HNb35zzZo1J5xwwpbv1qFDh+XLl69du3YrD36xWFy5cuVXvvKVjR7nxRdfvOaaa+6+++73vc7k9NNPHzFixC9/+cttusgHAGC7kc1121/72tf23Xff66677re//W2SJK+88sq999578skn77LLLhve7eijj+7bt++Pf/zjZcuWbc3DXnnllR/+8Ie/973vbdPOvO/UOeecc9hhh/3nf/7nEUcc8e///u+vvPLKmjVrmv52m2HDhj366KMdOrSvv/R+1apVzz333MSJE7/61a/utNNOm/sdxDRNX3755QkTJjz++OOHHnpox44dt/Lgjxs3rnv37pMnTz777LN///vfr1y58tVXX505c+agQYMaGxsnTJiw4YUrG7ruuuv23HPPiRMnPvLIIzFPHQCg/comGXfeeedvf/vb69ev/+xnP7t27dqbbrpp7dq1zb+it6F/+qd/WrFixY9+9KOtvzJky58WspVTdXV1lUrl6KOPfvTRRz/96U/vvffedXV1TX9z+z333NO3b9+t/KsuN+d9P2+kUChs+BksW3Ofvffeu/mTXg488MArr7yy6a+p79Wr10bPseluHTp06NWr15QpUzp06ND0IYZbefC7d+9+2223devW7Uc/+tHHPvaxnXbaaa+99vrMZz7z0ksvlUqlSy65ZHPPdPfdd//BD36wZs2aM84449133/V52wBATcnsDdpTTjmlWCw+9thj//Zv/zZjxoxdd931xBNP3PRuZ599docOHbbyYpKmK0Oa/uqWbfK+Uz179vzVr3518803Dx06tGfPnnV1dXvuuefQoUN/+MMfPvnkkx/72MeS9qRTp069evX6x3/8x1//+tenn3765u62ww47fOADHxg2bNgvfvGLpqtNtv7gDx48eN68eWPHjj3wwAO7du3apUuXI488ctq0af/xH/+x6aeSb+jkk08eOXLkH//4xw0/8BEAoBYU2vMlyAAAkGvt6+JjAADYnqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqmxx74403nn322az3AmC7ZZmFllPbtI6ePXsWNnHzzTeHbnTIkCFz587d+vtPmTLlqKOO2tx3Gxsbe/fuvU0PCNA2dt999+alta6u7qCDDpo6dWrVj9a8GDY2NhYKhS30tGUWWk5t02q++c1vpv/TmWeeGbrFlStXttZDLVq0aMiQIQsXLmytBwRoXdddd13T0vruu+9Onjz54osv/tGPftTCx2xoaEjT9MADD9zcHSyz0HJqm1g33HBD586dFy1alCTJa6+9tssuu0yfPv31118vFAo33HBDz5496+vrR48e3bygL126dMSIEV27du3Vq9f48eObb1+8eHGpVOrWrdsee+zxuc99btWqVYMGDXruuedGjRp1zjnnbGHwqaeeOvbYY7t06TJgwIDNrfL/+Z//2a9fv8MOO6ytjgpA9Tp16nTSSScNHjy4XC6/8sorhULhsssuq6+vHzly5LYuhhu+t22ZhSBqm1ijR48+5phjrr766iRJrrzyysMPP3zUqFFN37rmmmvuvffeefPmPfLII2PGjGm6cfjw4d26dXvxxRdnz5798MMPjxs3LkmSdevWnXjiiXV1dS+88MJDDz30xBNPXH755Q888EDfvn2nT58+bdq0zQ2+9957Q4cO7d+//5IlSy677LLp06e/70527tz5vvvu++53v9uGBwagRdauXdu1a9emr5999tmXX375iiuuqHoxtMxCoI3+1z9UZ5999tnopbXDDjs0fWv+/PkNDQ3XXnttfX39/Pnz0zR97bXXkiQpl8tNd5g1a1ZdXd3y5ctnz5690047rVq1qun2hx9+uEOHDitXrpw9e3ZdXd0bb7yx0Uab/hhI03Rzg5VKpb6+fsWKFU23n3feeUceeeTmnsKaNWuSJHnooYcCDg9Ai3Tv3r35SpLGxsbp06d36NDh7rvvXrp0aZIk99xzT9O3tnUxfOutt5IkeeaZZyyzEMd720Rdt7127dqm2/v06TNhwoTx48dfdNFFffr0ab5/82/SHHLIIatXr37hhReefvrpFStWdO7cuek3gT72sY+tX79+wYIFTz31VM+ePXfbbbfNbXpzg08//fT+++/fpUuXprsdeuihwccAIMoFF1zQtMTtueeeU6ZM+e53vzts2LCmb+27774tXAwtsxBHbdMWnnzyySRJHn300Q1v7NSpU9MX69atS5KkY8eOa9eu7dOnz0b/RfiRj3ykU6dOhUJhC4+/ucGN7ta8RYDcaX5v+7333nvyySfPP//85m917ty5hYuhZRbiqG3C/exnP7vtttsmT558xx13VCqV5tsff/zxpi/mzZvXtWvX/fff/8ADD1y4cOHLL7+80SMccMABixYtavo/nhtq/rNhc4P9+vWbP3/+u+++2/SvTzzxRGs/OYB2pOrF0DILcdQ2sZYvX37++eePHTv24osvPvfcc8eMGfPOO+80feuSSy5ZuHDh/PnzL7300vPOO69z587HH3/8wQcfPGrUqEWLFi1evPgLX/jCvvvuu2rVqmOPPbZfv34XXnjh66+//uKLLw4fPvz0009PkmTnnXdesmTJO++8s7nBT3ziE3vvvffnP//5N99887777rvxxhuzPh4AgapeDC2zEEdt02rGjRu30d9uc/7553/pS1/q0KHDpEmTkiSZPHlyhw4dvvSlLzXdf8iQIccdd9yRRx75v//3/2760JIOHTpUKpWdd975oIMO+shHPvLcc8/NmjWr6TLB//iP/3jzzTd79ep1+OGH77LLLtdff32SJOeff/5VV101atSozQ3W1dX97Gc/e/HFF/fZZ59x48ade+65WR8kgEBVL4aWWYhTSNO06uFSqdSqO0OtWL169T333DN48OBu3bplvS/w95XL5Uy2a40FakE5ozW27bTkA02KxWLV2zVr1qzZvMy2ZJ20xpo1a9Zs+1xj24wrSQAAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKIU0TaseLpVKrbozAO1RuVzOZLvWWKAWlDNaY9tMxxbOVyqV6gaLxWKtzZaXLalutlTfw2zbzObxdWW2DWYzlLtjZY01u4XZPL6uzLbB7HbPlSQAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQJRCmqZVD5dKpVbdGYD2qFwuZ7JdayxQC8oZrbFtpmML5yuVSnWDxWKx1mbLy5ZUN1uq79F/cpUvxMcmlGpttiXHOY+vK7NtMJuh3B2rnK6xeXy+Z5xxRnWzM2fOdJzNtqvZ7Z4rSQAAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKIU0TaseLpVKrbozAO1RuVzOZLvWWKAWlDNaY9tMxxbOVyqV6gaLxWJWs+VlS6qbLdX3yGq2/+QqX4iPTSjV2mxLjnMeX89m22A2Q7k7VjldY1vyfFuyXtXazzePz9dsG8xu91xJAgAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEKaRpWvVwqVRq1Z0BaI/K5XIm27XGArWgnNEa22Y6tnC+UqlUN1gsFrOaLS9bUt1sqb5H/8lVviAem1CqtdmWHOesZvP4ejbbBrMZqrU1No/PN4/H2Rprtl3NbvdcSQIAAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARCmkaVr1cKlUatWdAWiPyuVyJtu1xgK1oJzRGttmOrZwvlKpVDdYLBazmi0vW1LdbKm+R//JVb4gHptQqrXZlhznPL6uWjK7YGJjdbO9JzXkcTZ3P6MM1doa25LttmS9yupYWWPbZjaP66Q1dnviShIAAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIEohTdOqh0ulUqvuDEB7VC6XM9muNRaoBeWM1tg207GF85VKpbrBYrGY1Wx52ZLqZkv1PfpPrvIF8diEUq3NtuQ45/F11ZLZBRMbq5vtPakhj883d7MZqrU1No/P13Fu/7PW2HY+u91zJQkAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEKWQpmnVw6VSqVV3BqA9KpfLmWzXGgvUgnJGa2yb6djC+UqlUt1gsVjMara8bEl1s6X6HmbbZjaPr6uWzC6Y2FjdbO9JDXl8vrk7VhnK488oj2tOrc3m8XWVu3WjWCz2n1xlRD42oVRTx2q750oSAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACBKIU3TqodLpVKr7gxAe1QulzPZrjUWqAXljNbYNtOxhfOVSqW6wWKxaNas2abZBRMbq5vtPakhj883d8cqQ3n8GZk1295mrbFbP1tra2w+ahsAANqLQmGz32rBBR0tobYBANh+I3vT+7RtdqttAAC2685+35G2am61DQBAbXR2Fs3tEwABAKix1G71x9k8tQ0AQK4UWjWRg4NbbQMAkB+FgDiODG61DQBAThQKuXtktQ0AQB4UCnl8fLUNAEC7VyjkdCtqGwAAoqhtAADat0Ihv9tS2wAAEEVtAwDQjhUKud6i2gYAgChqGwAAoqhtAADaq0Ih79vt2FoPBAAA2UvT5I47krVrk06dklNOyazX/1shTdOqh0ulUqvuDEB7VC6XM9muNRaoBeUtr7FVtPJvf5vceGNy/fXJ6NHJOeckRx9d5Z61IJJb873tSqVS3WCxWDRr1mzT7IKJjdXN9p7UkMfnm7tjlaE8/ozMmm1vs9bYmltjFy1KVq1KjjoqWbz4z/9kzXXbAABsX26+ObnssuTee5N2QG0DALB9GTUqmTEjOfnkpB1Q2wAAbEd69Uq6dEnK5T9/sc8+We+NzyQBAGB7csQRySuvJAMH/vkzSY46Kuu9UdsAAGxPChl/5N9GXEkCAEB7laZ5367aBgCAKGobAACiqG0AANqxNM31FtU2AABEUdsAALRvaZrfbaltAACIorYBAGj30jSnW1HbAK3pkEMOWbx4cZIkq1atOuCAA6ZOnXrooYd+9KMfnTVrVta7BpBzaZrHx1fbAK1pxIgRd955Z5Ik999//wknnDBp0qQ5c+bMnDnz5ptvznrXAPIvTXP3yGoboDWddtppd9xxR5Ikd91116c+9amhQ4eeffbZixYtuummm7LeNYDtQprm611ztQ3Qmvr27fvGG2+8/fbb8+bN+/jHPz5jxoxx48Zdd911o0aNynrXALYXaZqjC1Q6hj46QA069dRTr7766iOOOOLtt98+5ZRT7rvvvsMOO6x3795Z7xfAdiRNk0KhdR4nWCFtwTZKpVKr7gxAe1Qul7fp/s8999zBBx98//33DxgwYPLkybfeeuv69etHjx49ZsyYbXocayxQC8rbuMZurOrmbqvP8G5pbVcqlepmi8Wi2W2Y7fP1Kmefv7TmZnP4810wsbG62d6TGsxu/WzVP6OWrJMtYY1tu9k8rnXW2K2ezeN6lcfZjNfYwrY0d9uu6q4kAQAg59L072d3Rm+dqG0AALYXaTZJvQU+kwQAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQDIjYULF37iE58YNGjQSSed9OqrryZJsmzZsmKxeMwxxxSLxWXLljXfc9Pbr7766n79+k2ePDlJkvXr1w8bNqyxsTF6h9U2AAC5cd55511yySUPPPDAuHHjvvKVryRJcuWVVw4cOPDBBx889thjr7rqquZ7bnr7t771rd/85jfXXnttkiTTpk0bPnx4Q0ND9A4X0jSterhUKrXqzgC0R+VyOZPtWmOBWlDexjV2jz32eOWVV3bYYYd169Z95CMfee655/r16zdr1qwePXosXrz4hBNOeOKJJ5ruuent++677y9/+cvBgwfPmzfvrLPOuvvuuwuFQhKsYwvnK5VKdYPFYjGXs32+XuXs85dmNXvGGWdUNztz5sysZlt0rPL4ujLbvmczlLtjVYNrbFbHqv/kKv8j8LEJpTw+X7Pb8ey2Ovjgg++8885SqVQul5uuJHn11Vf32muvJEn23nvvpluabHr7lVdeeeaZZ1511VUTJ0786le/2gap7UoSAADyZNq0aTfddNNxxx330ksv1dXVbdPsWWedNXfu3L59+yZJsmDBgmHDht1+++1JO39vGwAA2syPf/zj2267ra6ubv78+U1Xoey5556vvPJKjx49li5duueeezbf831vT9P0y1/+8k033XTYYYfNnTt3wIABI0aMCN1h720DAJAbv//97++5554kSWbMmHH66acnSTJ06NBbb701SZJbb7116NChSZIsX778fW9PkuTGG288+eSTu3fvvnLlyjRNV6xYEb3DahsAgNy45pprpkyZcvTRR7/99tsXXHBBkiT/8i//MmfOnGOOOeZXv/rVl770pSRJPvnJT77v7Y2NjT/5yU/OO++8JEnGjRs3ZMiQiy66KHqHXUkCAEBu9OnT58EHH9zwlvr6+o1+R3PWrFnve3tDQ8O9997b9PUX/6INdth72wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEKWQpmnVw6VSqVV3BqA9KpfLmWzXGgvUgnJGa2yb6djC+UqlUt1gsVjM5Wyfr1c5+/ylZ5xxRnWzM2fOrLXZlhznXL6uzLbv2Qzl7lhluMZmtc8tWuscZ7Nma4ArSQAAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKIU0TaseLpVKrbozAO1RuVzOZLvWWKAWZLXGtpmOLZyvVCrVDRaLxVzO9vl6lbPPX3rGGWdUNztz5sxam23Jcc7l68ps+57NUO6OVYZrbC6fr+Ns1mwNcCUJAABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsA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hQsXbrqHDz/88IIFC6699tpdd921T58+l19++R133JGmaRseJCAznTp1OumkkwYPHlwul1955ZVCoXDZZZfV19ePHDlyWxeWDd/btmRB7qht8mr06NHHHHPM1VdfnSTJlVdeefjhh48aNarpW9dcc8299947b968Rx55ZMyYMU03Dh8+vFu3bi+++OLs2bMffvjhcePGJUmybt26E088sa6u7oUXXnjooYeeeOKJyy+//IEHHujbt+/06dOnTZu2ucH33ntv6NCh/fv3X7JkyWWXXTZ9+vRN93DAgAFr1qypq6tr+telS5futttuhUKhDQ8SkLG1a9d27dq16etnn3325ZdfvuKKK6peWCxZkEsb/Q96aG/22WefjV60O+ywQ9O35s+f39DQcO2119bX18+fPz9N09deey1JknK53HSHWbNm1dXVLV++fPbs2TvttNOqVauabn/44Yc7dOiwcuXK2bNn19XVvfHGGxtttOmPrjRNNzdYqVTq6+tXrFjRdPt555135JFHbuFZNDY27rfffpdffnlrHx6gHenevXvzlSSNjY3Tp0/v0KHD3XffvXTp0iRJ7rnnnqZvbevC8tZbbyVJ8swzz1iyII+8t03+rtteu3Zt0+19+vSZMGHC+PHjL7rooj59+jTfv/m3fw455JDVq1e/8MILTz/99IoVKzp37tz020sf+9jH1q9fv2DBgqeeeqpnz5677bbb5ja9ucGnn356//3379KlS9PdDj300C3s/7vvvnvyySf369dv4sSJrXRIgHbqggsuaFou9txzzylTpnz3u98dNmxY07f23XffFi4slizII7VNvj355JNJkjz66KMb3tipU6emL9atW5ckSceOHdeuXdunT5+N/lvzIx/5SKdOnbb8/0k3N7jR3Zq3uKk33nhj8ODBPXv2vP322zt27Niypwu0d83vbb/33ntPPvnkhr9o2Llz5xYuLJYsyCO1TY797Gc/u+222yZPnnzHHXdUKpXm2x9//PGmL+bNm9e1a9f999//wAMPXLhw4csvv7zRIxxwwAGLFi1q+r+0G2r+82xzg/369Zs/f/67777b9K9PPPHE++7hyy+/fMwxxwwcOPCWW25pvhoSqHFVLyyWLMgjtU1eLV++/Pzzzx87duzFF1987rnnjhkz5p133mn61iWXXLJw4cL58+dfeuml5513XufO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ABBFbQMAQBS1DQBQo/7f//t/AwYMOO6444499tiHHnooSZJly5YVi8VjjjmmWCwuW7as+Z7/+I//OOgvBgwYsPvuuydJcvXVV/fr12/y5MlJkqxfv37YsGGNjY2ZPpt2qmPWOwAAQDZGjx59//3377fffi+88MLJJ5/89NNPX3nllQMHDhw/fvw3vvGNq6666uqrr26656233tr0xbRp0/70pz8lSfKtb33rueee69u374QJE6ZNmzZ8+PCGhoZMn007VUjTNKklpVIp610AcqZcLmeyXesVEL1eHXbYYddff/3hhx/+u9/97rTTTnvppZf69es3a9asHj16LF68+IQTTnjiiSc2vH+aph/96Ed//vOff+ADH9h3331/+ctfDh48eN68eWedddbdd99dKBRa+wltF9IaUywWqz5WZs0GzabPJ9X9k9PZrI5z1bM1uF5dPj+t7p88/nzNbtNsHtcc69UW/O53v+vcuXO/fv06d+581113pWm6++67r1u3Lk3TdevW7bHHHhvd/4477jj33HObvr7pppuOPPLIW2655YILLnj44YdbaeXbDrluGwCgRl188cW33HLLE0888aMf/einP/3p373/N77xjYsuuqjp67POOmvu3Ll9+/ZNkmTBggXDhg27/fbb43c5f1y3DQBQo5544ommi9Y++clPXnDBBUmS7Lnnnq+88kqPHj2WLl265557bnjn3/72tw0NDU153SRN0y9/+cs33XTTYYcdNnfu3AEDBowYMSKL59GueW8bAKBG9e3b99e//nWSJA899NCHPvShJEmGDh3a9AuRt95669ChQ5MkWb58edOdr7nmmuY3tpvceOONJ598cvfu3VeuXJmm6YoVKzJ6Hu2a97YBAGrU97///bFjx/75czMKhWnTpiVJ8i//8i//9E//9NOf/nT33Xf/4Q9/2PS296xZs55//vklS5YMHDiwebaxsfEnP/nJPffckyTJuHHjhgwZslGL00RtAwDUqP79+8+ePXvDW+rr6yuVyoa3zJo1K0mSPn36NH0gd7OGhoZ777236esv/kWb7HL+uJIEAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiFNI0TWpJqVTKeheAnCmXy5ls13oF5GW9Ygs6JrWn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kiRr1qz5+c9//slPfnLXXXc966yzWvKYDQ0NaZpu4Q5OYWBT3tuGbXPDDTd07tx50aJFSZK89tpru+yyy/Tp019//fVCoXDDDTf07Nmzvr5+9OjRzX/oLl26dMSIEV27du3Vq9f48eObb1+8eHGpVOrWrdsee+zxuc99btWqVYMGDXruuedGjRrV9Mfq5gafeuqpY489tkuXLgMGDFi4cOGme/jCCy/cf//9U6ZMqa+vP/zww4877rjf/OY3bXiEoH3p1KnTSSedNHjw4HK5/MorrxQKhcsuu6y+vn7kyJHbeqJt+N62UxjYSmobts3o0aOPOeaYq6++OkmSK6+88vDDDx81alTTt6655pp777133rx5jzzyyJgxY5puHD58eLdu3V588cXZs2c//PDD48aNS5Jk3bp1J554Yl1d3QsvvPDQQw898cQTl19++QMPPNC3b9/p06dPmzZtc4Pvvffe0KFD+/fvv2TJkssuu2z69Omb7uH++++/fv367t27r1279v/9RalUatuDBO3O2rVru3bt2vT1s88++/LLL19xxRVVn2hOYWAbpMD72WeffTY6WXbYYYemb82fP7+hoeHaa6+tr6+fP39+mqavvfZakiTlcrnpDrNmzaqrq1u+fPns2bN32mmnVatWNd3+8MMPd+jQYeXKlbNnz66rq3vjjTc22mjTH9Vpmm5usFKp1NfXr1ixoun2884778gjj9zcU+jbt2/nzp0HDRr02muvBRwhaL+6d+9+3XXXNX3d2Ng4ffr0Dh063H333UuXLk2S5J577mn61raeaG+99VaSJM8884xTGNh63tuGzfrmN7+54dmydu3aptv79OkzYcKE8ePHX3TRRX369Gm+f/NvOx1yyCGrV69+4YUXnn766RUrVnTu3Lnpt7U+9rGPrV+/fsGCBU899VTPnj132223zW16c4NPP/30/vvv36VLl6a7HXrooVvY/2efffaNN97YaaedTjrppFY6JJAbF1xwQdPps+eee06ZMuW73/3usGHDmr617777tvBEcwoDW09tQzWefPLJJEkeffTRDW/s1KlT0xfr1q378+8gd+y4du3aPn36bPTfuB/5yEc6depUKBS28PibG9zobs1b3Jydd9554sSJv/3tb5csWVLtc4Vcan5v+7333nvyySebfmOySefOnVt4ojmFga2ntmGb/exn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JZc88MAD48aN+8pXvrKFe37rW9/6zW9+c+211yZJMm3atOHDhzc0NGT6bGgX/O02AAB/dcstt/zwhz9MkmTYsGHz589PkuQPf/jDoEGDkiQZNGjQ5z73uS3cs1OnTv/1X/9VV1f35ptv3nHHHXfffXemT4X2wnvbAAB/9cc//vHOO+8cNGjQpz/96U996lNJkhx88MF33nln018Cv+GVJJve88orrzzzzDOvuuqqiRMnfvWrXy0UCpk+FdoLtQ0A8FerV6/+4Ac/+MADD5x55pmjR49uuibkpptuOu6441566aW6urot3POss86aO3du3759kyRZsGDBsGHDbr/99kyfDe2CK0kAAP5qzz33LBaLSZIUi8Xzzz8/SZIf//jHt912W11d3fz588vl8hbumSRJmqZf/vKXb7rppsMOO2zu3LkDBgwYMWJEds+GdsF72wAAf3X88cfPmTMnSZI5c+b0798/SZLf//7399xzT5IkM2bMOP3005MkWb58+fveM0mSG2+88eSTT+7evfvKlSvTNF2xYkXWT4jseW8bAOCvrrjiitGjR19xxRUdO3a8/vrrkyS55pprRo4c+fWvf/3www//P//n/yRJ8slPfnLWrFmb3rOxsfEnP/lJU5qPGzduyJAhF110UdZPiOypbQCAv/rABz5w1113bXhLnz59HnzwwQ1vmTVr1vves6Gh4d577236+ot/0Sa7THvnShIAAIiitgEAIIraBgCAKIU0TcMenOyVSqWsdwFyb8PP/GpLzl/I7/kLzfyW5PavUqlUN1gsFlsyu2BiY3WzvSc1tGR2xpyx1c2OHDjVbNvMtuTnm8nrOUO1dv5m9XzNbv1s7n6+kDlXkgAAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUQppmoY9ONkrlUpZ7wLkXrlczmS7zl/I7/kLzTr+7Uu2U5VKpbrBYrHYktkFExurm+09qWHGnLHVzY4cONVs+59tyWsjk9dzhvJ4/ma1z1nNtuRcyOPzzd1rAzLnShIAAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIEohTdOwByd7pVIp612A3CuXy5ls1/kL+T1/oVnHv33JdqpSqVQ3WCwWWzK7YGJjdbO9JzXMmDO2utmRA6fmcbYlx6rWZjN5PWcoj+dvVvvcknMwq2NVa7O1dv5CE1eSAABAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABRCmmahj042SuVSlnvAuReuVzOZLvOX8jv+QvNOv7tS7ZTlUqlusFisdiS2QUTG6ub7T2pYcacsdXNjhw4NY+zLTlWWf18a2o2Q3k8f3P383Wstu9ZyJwrSQAAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKIU0TcMenOyVSqWsdwFyr1wuZ7Jd5y/k9/yFZh3/9iXbqUqlUt1gsVhsyeyCiY3Vzfae1GB262ez+vnW1GyGnL/b92zuzoU8zkLmXEkCAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAEQppGka9uBkr1QqZb0LkHvlcjmT7Tp/Ib/nL/xNynatWCwm1TJr1mwT569Zs/mdzer8hWauJAEAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAohTSNA17cLJXKpWy3gXIvXK5nMl2nb+Q3/MX/iZlu1YsFpNqmTVrtonz16zZ/M5mdf5CM1eSAABAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABRCmmahj04AADUNO9tAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAACRB/n+15RY5M4KyIgAAAABJRU5ErkJggg=="
            },
            {
              "type": "input_text",
              "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
            }
          ],
          "solved_count": 0,
          "total_training_examples": 3,
          "pixel_accuracy": 0.8232373386295928
        },
        "test_result": {
          "correct": false,
          "pixel_accuracy": 0.7596153846153846,
          "total_pixels": 624,
          "correct_pixels": 474,
          "error": null
        },
        "status": "failed_test",
        "feedback_sent": true
      },
      {
        "turn_number": 6,
        "timestamp": "2025-07-10T13:43:58.583489",
        "input_tokens": 53481,
        "output_tokens": 1493,
        "turn_cost": 0.023781200000000002,
        "program_extracted": true,
        "program": "def transform(grid):\n    import numpy as np\n    from collections import deque, Counter\n\n    grid = np.array(grid)\n    h, w = grid.shape\n    output = grid.copy()\n\n    def neighbors(r, c):\n        for nr, nc in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\n            if 0 <= nr < h and 0 <= nc < w:\n                yield nr, nc\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def bfs_component(sr, sc):\n        q = deque([(sr, sc)])\n        comp_pixels = []\n        visited[sr, sc] = True\n        while q:\n            r, c = q.popleft()\n            comp_pixels.append((r, c))\n            for nr, nc in neighbors(r, c):\n                if not visited[nr, nc] and grid[nr, nc] != 0:\n                    visited[nr, nc] = True\n                    q.append((nr, nc))\n        return comp_pixels\n\n    def find_outline_pixels(component):\n        comp_set = set(component)\n        outline = set()\n        for (r, c) in component:\n            for nr, nc in neighbors(r, c):\n                if (nr, nc) not in comp_set:\n                    outline.add((r, c))\n                    break\n        return outline\n\n    components = []\n    for r in range(h):\n        for c in range(w):\n            if grid[r, c] != 0 and not visited[r, c]:\n                comp = bfs_component(r, c)\n                components.append(comp)\n\n    for comp in components:\n        comp_set = set(comp)\n        outline_set = find_outline_pixels(comp)\n\n        # Majority outline color\n        colors_in_comp = [grid[r, c] for r, c in comp]\n        outline_color = Counter(colors_in_comp).most_common(1)[0][0]\n\n        rows = [r for r, c in comp]\n        cols = [c for r, c in comp]\n        rmin, rmax = max(min(rows), 0), min(max(rows), h - 1)\n        cmin, cmax = max(min(cols), 0), min(max(cols), w - 1)\n\n        box_h = rmax - rmin + 1\n        box_w = cmax - cmin + 1\n\n        mask = np.zeros((box_h, box_w), dtype=np.int8)\n\n        for (r, c) in comp_set:\n            rr, cc = r - rmin, c - cmin\n            if (r, c) in outline_set:\n                mask[rr, cc] = 1  # outline\n            else:\n                mask[rr, cc] = 2  # candidate interior\n\n        # Flood fill exterior (mask==0) from bounding box edges\n        visited_box = np.zeros_like(mask, dtype=bool)\n        q = deque()\n        for rr in range(box_h):\n            for cc in [0, box_w - 1]:\n                if mask[rr, cc] == 0 and not visited_box[rr, cc]:\n                    q.append((rr, cc))\n                    visited_box[rr, cc] = True\n        for cc in range(box_w):\n            for rr in [0, box_h - 1]:\n                if mask[rr, cc] == 0 and not visited_box[rr, cc]:\n                    q.append((rr, cc))\n                    visited_box[rr, cc] = True\n\n        while q:\n            rr, cc = q.popleft()\n            for nr, nc in ((rr-1, cc), (rr+1, cc), (rr, cc-1), (rr, cc+1)):\n                if 0 <= nr < box_h and 0 <= nc < box_w:\n                    if not visited_box[nr, nc] and mask[nr, nc] == 0:\n                        visited_box[nr, nc] = True\n                        q.append((nr, nc))\n\n        # Interior: mask==2 and not reachable outside\n        interior_pixels = []\n        for rr in range(box_h):\n            for cc in range(box_w):\n                if mask[rr, cc] == 2 and not visited_box[rr, cc]:\n                    interior_pixels.append((rr + rmin, cc + cmin))\n\n        # Candidate interior colors excluding outline & zero\n        interior_colors = [grid[r, c] for r, c in interior_pixels if grid[r, c] != 0 and grid[r, c] != outline_color]\n\n        if interior_colors:\n            fill_color = Counter(interior_colors).most_common(1)[0][0]\n        else:\n            # fallback: include outline color if no other interior color found\n            alt_colors = [grid[r, c] for r, c in interior_pixels if grid[r, c] != 0]\n            if alt_colors:\n                fill_color = Counter(alt_colors).most_common(1)[0][0]\n            else:\n                fill_color = outline_color  # fallback: fill with outline color\n\n        for r, c in interior_pixels:\n            output[r, c] = fill_color\n\n    return output.tolist()",
        "training_feedback": {
          "feedback_messages": [
            {
              "type": "input_text",
              "text": "Training results: 0/3 examples solved, 82.3% pixel accuracy - Good partial progress! Your approach is capturing some patterns. Next, try to identify a transformation that solves at least one of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 1, 1, 1, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 5, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 0, 8, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 8, 0, 0, 8, 2, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 3, 0, 8, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 1, 1, 1, 0, 0, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 5, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 5, 0, 5, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 90.0%\n\nTraining Example 2 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 6, 6, 6, 0, 0], [0, 0, 2, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 2, 2, 2, 3, 3, 3, 3, 3, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 6, 6, 6, 6, 6], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 3, 0, 2, 0, 0, 6, 6, 6, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 6, 0, 3, 0, 0], [0, 0, 2, 2, 2, 0, 3, 0, 0, 0, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 6, 6, 6, 6, 6], [0, 0, 0, 0, 2, 0, 0, 0, 8, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 8, 0], [3, 0, 0, 0, 0, 0, 0, 4, 8, 0, 3, 0, 8, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 8, 0, 4, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 80.7%\n\nTraining Example 3 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 3, 3, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 3, 3, 6, 6, 6, 6, 6, 6, 3, 3, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 3, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0], [0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 3, 0, 0, 0, 8, 0, 0, 8, 0, 3, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 0, 3, 0, 6, 0, 0, 2, 0, 0, 3, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 3, 0, 0, 0, 0, 6, 0, 0, 0, 3, 0, 0], [0, 0, 3, 0, 0, 6, 0, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 69.6%\n\n"
            },
            {
              "type": "input_image",
              "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA88AAAUtCAIAAABNteEnAABUgklEQVR4nO3de5xVdb34/7URBlFwRtFUBEsk0R58RdO8kHJQ+D5S8LJ3YB1NPXBQ035IgaLZ4WT5xTQhO9HF/IZCpqQnT3t7OWbkN4UsKVPyrqGgIaDH26AIcl2/R01n4oAQ7Jn3rFns5/PhH+Oe/d5r7TV7fXi5XbMppGmaAAAAATpEPCgAAKC2AQAgkNoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAaJe1PWbMmMLmnXnmme97n7q6ur322uuUU0559NFHN33MX/ziF4VCYbfddnvvvfc2+tbtt99eKBSmTZvW9K8jR44sFAqTJ0/e6G4vv/xyoVCYOHFiS6aavPfee9dff/1xxx3Xo0ePzp079+jR47TTTvvVr361hWMyceLEzR2QJ598cssHbciQIX/3wDbf55xzztnw9qbdGz58+EMPPbTh/hSLxY3utt9++40dO/att97apoPf5PXXX580adKhhx5aX1+/8847H3HEEdOmTUvTdKPNbTT+yCOP7LHHHt26dbv//vu3cOgAALY/Gby3vWbNmldfffWuu+467rjjFixYsNF3b7zxxiRJ3nrrrdtuu21rHu3LX/7ys88+u637sDVTL7744tFHH33++ec/8MADS5cuXb169dKlS2+//faBAwdee+21STvTtHs//elPjznmmFtuuWULd3vxxRe//e1vn3DCCevXr9+mg//QQw/179//X//1X//whz+8/fbbK1asePjhh88999zRo0dvYcd++ctfHnfccevWrbvvvvuOO+64FjxFAIAaq+3vfOc76X/7yU9+kiTJ9OnTm2+5+eabm++5cOHC5tvfe++9Z5555owzznj77bevu+66DR+wsbGxUqmcdtppu+222/e///2t2YfVq1ePHDly3bp127Tnf3dqzZo1I0aM+MMf/jBgwIA777zz9ddfX7NmzZ/+9Kfvfe97u+222yWXXNL0RvXmzJs3L91Ev3793veANLvvvvs2fJCtuc/SpUubbl+5cuXzzz//xS9+MU3Tf/7nf37ppZc2vNvKlSs3PPhDhgz53e9+94tf/GLrD/5//dd/lUqlJUuWnH766XPnzn377bfffPPNSqXSu3fv6dOnX3/99e97HMrl8tChQ3faaacHHnjgyCOP3MIRAwDYLmXw3nbnzp0PPPDAr3/960mSbPTe9syZM997773Pfvazo0aNmjt37uOPP/53H+3CCy/87W9/+41vfGOb9uHvTv3whz985JFHhgwZMmfOnJNPPrl79+4dO3bs1avXBRdc8NOf/nTdunU//vGPk/Zkxx133H///a+66qovf/nLq1ev/rd/+7ctHPwvfOELTaW+9Qf/2muvffXVV8eNGzdz5swjjzyyW7duu+6666mnnjp79uydd9752muv3fB6kiY33HDDaaed9oEPfOBXv/rVwQcf3Hz7jBkzCoXCd77znVY9AAAA7VEGtb1q1aqnnnpq/PjxSZIccMABG35r+vTpBx100PHHH3/BBRfssMMOW/P29te+9rU+ffp8+ctffuaZZ7Z+H/7u1MyZMwuFwv/9v/93hx122Ohb//AP//D0009PmjQpaZcuuuiinXba6ec///n7fnfNmjV//OMfp06d2rFjx3/4h3/Y+oP/7//+7126dLniiis2esCePXs++OCDDzzwQKFQ2PD2a6655pxzzundu/eDDz744Q9/uPWeHwBAnrRRbe+3337Nv6i344479uvX7yc/+cnuu+/++c9/vvk+Tz755O9///sJEyYUCoX999//tNNOu+WWW5YvX77lR95pp52mT5++Zs2abbqe5O9OzZs376CDDtpvv/3ed/yggw7aKC43cuihh270240PPvjg5g5IswceeGBb77Opbt26ffjDH97ofxp06dKlabyurq5v376//vWvf/jDH2747LZ88NesWfPiiy8eccQRXbt23XSLhxxyyN57773hLZdccsmll16aJMmxxx677777bnT/kSNHpmk6ZsyYLT8RAIDtQDafALjPPvv88z//82OPPbbXXns133jjjTfus88+n/nMZ5r+9bLLLnvnnXe25oKNY445ZuzYsb/73e+mTJmy9fuwhak1a9Y0NjbuueeeG9640eeEfOhDH0raq+7du6/6i83dYd26dXPnzl2zZs1WHvzGxsY0Tbt3776VO/Dtb3/76KOPHjJkyI033vjTn/60Zc8GACDH2qi2m37hb/Xq1bfeemvTm69XX311jx49mu+wZs2am2++efHixZ07d27K2f79+6dpupW/K/m1r33twx/+8OWXX/70009v/V5tbqpTp07dunV77bXXkmpt+luSxxxzzN/9DchBgwZt633e11tvvdWpU6fOnTtv+luSq1evXrBgwf/3//1/3/72ty+++OKtPPi77bZbhw4dtv6AjBo16oEHHrjpppt22223c889d/HixVs5CACwnWnT97Y7der06U9/+rbbbps9e/YJJ5yw4acy33333e8bc48++ujDDz/8dx+5S5cuVVxPsoWp//W//tfTTz/9pz/96X0/gOWwww5L2qvly5c/+eSTBx100Pt+t1OnTvvtt9+UKVP69es3Y8aMrTz4O+yww0EHHfT73/9+xYoVm97tqquuOvvss5csWdJ8y/e+9726urq99977O9/5zptvvnn22Wdv+mmDAAC1IIMrSU488cQLL7zw0UcfbX5vtelKhh133HHZsmUbvo/7m9/8JkmSzX263EY+/vGPf/7zn3/44Yc3/Ztrqpj6zGc+s379+s997nPv2+6bfv5G+/HNb35zzZo1J5xwwpbv1qFDh+XLl69du3YrD36xWFy5cuVXvvKVjR7nxRdfvOaaa+6+++73vc7k9NNPHzFixC9/+cttusgHAGC7kc1121/72tf23Xff66677re//W2SJK+88sq999578skn77LLLhve7eijj+7bt++Pf/zjZcuWbc3DXnnllR/+8Ie/973vbdPOvO/UOeecc9hhh/3nf/7nEUcc8e///u+vvPLKmjVrmv52m2HDhj366KMdOrSvv/R+1apVzz333MSJE7/61a/utNNOm/sdxDRNX3755QkTJjz++OOHHnpox44dt/Lgjxs3rnv37pMnTz777LN///vfr1y58tVXX505c+agQYMaGxsnTJiw4YUrG7ruuuv23HPPiRMnPvLIIzFPHQCg/comGXfeeedvf/vb69ev/+xnP7t27dqbbrpp7dq1zb+it6F/+qd/WrFixY9+9KOtvzJky58WspVTdXV1lUrl6KOPfvTRRz/96U/vvffedXV1TX9z+z333NO3b9+t/KsuN+d9P2+kUChs+BksW3Ofvffeu/mTXg488MArr7yy6a+p79Wr10bPseluHTp06NWr15QpUzp06ND0IYZbefC7d+9+2223devW7Uc/+tHHPvaxnXbaaa+99vrMZz7z0ksvlUqlSy65ZHPPdPfdd//BD36wZs2aM84449133/V52wBATcnsDdpTTjmlWCw+9thj//Zv/zZjxoxdd931xBNP3PRuZ599docOHbbyYpKmK0Oa/uqWbfK+Uz179vzVr3518803Dx06tGfPnnV1dXvuuefQoUN/+MMfPvnkkx/72MeS9qRTp069evX6x3/8x1//+tenn3765u62ww47fOADHxg2bNgvfvGLpqtNtv7gDx48eN68eWPHjj3wwAO7du3apUuXI488ctq0af/xH/+x6aeSb+jkk08eOXLkH//4xw0/8BEAoBYU2vMlyAAAkGvt6+JjAADYnqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqmxx74403nn322az3AmC7ZZmFllPbtI6ePXsWNnHzzTeHbnTIkCFz587d+vtPmTLlqKOO2tx3Gxsbe/fuvU0PCNA2dt999+alta6u7qCDDpo6dWrVj9a8GDY2NhYKhS30tGUWWk5t02q++c1vpv/TmWeeGbrFlStXttZDLVq0aMiQIQsXLmytBwRoXdddd13T0vruu+9Onjz54osv/tGPftTCx2xoaEjT9MADD9zcHSyz0HJqm1g33HBD586dFy1alCTJa6+9tssuu0yfPv31118vFAo33HBDz5496+vrR48e3bygL126dMSIEV27du3Vq9f48eObb1+8eHGpVOrWrdsee+zxuc99btWqVYMGDXruuedGjRp1zjnnbGHwqaeeOvbYY7t06TJgwIDNrfL/+Z//2a9fv8MOO6ytjgpA9Tp16nTSSScNHjy4XC6/8sorhULhsssuq6+vHzly5LYuhhu+t22ZhSBqm1ijR48+5phjrr766iRJrrzyysMPP3zUqFFN37rmmmvuvffeefPmPfLII2PGjGm6cfjw4d26dXvxxRdnz5798MMPjxs3LkmSdevWnXjiiXV1dS+88MJDDz30xBNPXH755Q888EDfvn2nT58+bdq0zQ2+9957Q4cO7d+//5IlSy677LLp06e/70527tz5vvvu++53v9uGBwagRdauXdu1a9emr5999tmXX375iiuuqHoxtMxCoI3+1z9UZ5999tnopbXDDjs0fWv+/PkNDQ3XXnttfX39/Pnz0zR97bXXkiQpl8tNd5g1a1ZdXd3y5ctnz5690047rVq1qun2hx9+uEOHDitXrpw9e3ZdXd0bb7yx0Uab/hhI03Rzg5VKpb6+fsWKFU23n3feeUceeeTmnsKaNWuSJHnooYcCDg9Ai3Tv3r35SpLGxsbp06d36NDh7rvvXrp0aZIk99xzT9O3tnUxfOutt5IkeeaZZyyzEMd720Rdt7127dqm2/v06TNhwoTx48dfdNFFffr0ab5/82/SHHLIIatXr37hhReefvrpFStWdO7cuek3gT72sY+tX79+wYIFTz31VM+ePXfbbbfNbXpzg08//fT+++/fpUuXprsdeuihwccAIMoFF1zQtMTtueeeU6ZM+e53vzts2LCmb+27774tXAwtsxBHbdMWnnzyySRJHn300Q1v7NSpU9MX69atS5KkY8eOa9eu7dOnz0b/RfiRj3ykU6dOhUJhC4+/ucGN7ta8RYDcaX5v+7333nvyySfPP//85m917ty5hYuhZRbiqG3C/exnP7vtttsmT558xx13VCqV5tsff/zxpi/mzZvXtWvX/fff/8ADD1y4cOHLL7+80SMccMABixYtavo/nhtq/rNhc4P9+vWbP3/+u+++2/SvTzzxRGs/OYB2pOrF0DILcdQ2sZYvX37++eePHTv24osvPvfcc8eMGfPOO+80feuSSy5ZuHDh/PnzL7300vPOO69z587HH3/8wQcfPGrUqEWLFi1evPgLX/jCvvvuu2rVqmOPPbZfv34XXnjh66+//uKLLw4fPvz0009PkmTnnXdesmTJO++8s7nBT3ziE3vvvffnP//5N99887777rvxxhuzPh4AgapeDC2zEEdt02rGjRu30d9uc/7553/pS1/q0KHDpEmTkiSZPHlyhw4dvvSlLzXdf8iQIccdd9yRRx75v//3/2760JIOHTpUKpWdd975oIMO+shHPvLcc8/NmjWr6TLB//iP/3jzzTd79ep1+OGH77LLLtdff32SJOeff/5VV101atSozQ3W1dX97Gc/e/HFF/fZZ59x48ade+65WR8kgEBVL4aWWYhTSNO06uFSqdSqO0OtWL169T333DN48OBu3bplvS/w95XL5Uy2a40FakE5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5/r16zdr1qwePXosXrz4hBNOeOKJJ5ruuent++677y9/+cvBgwfPmzfvrLPOuvvuuwuFQhKsYwvnK5VKdYPFYjGXs32+XuXs85dmNXvGGWdUNztz5sysZlt0rPL4ujLbvmczlLtjVYNrbFbHqv/kKv8j8LEJpTw+X7Pb8ey2Ovjgg++8885SqVQul5uuJHn11Vf32muvJEn23nvvpluabHr7lVdeeeaZZ1511VUTJ0786le/2gap7UoSAADyZNq0aTfddNNxxx330ksv1dXVbdPsWWedNXfu3L59+yZJsmDBgmHDht1+++1JO39vGwAA2syPf/zj2267ra6ubv78+U1Xoey5556vvPJKjx49li5duueeezbf831vT9P0y1/+8k033XTYYYfNnTt3wIABI0aMCN1h720DAJAbv//97++5554kSWbMmHH66acnSTJ06NBbb701SZJbb7116NChSZIsX778fW9PkuTGG288+eSTu3fvvnLlyjRNV6xYEb3DahsAgNy45pprpkyZcvTRR7/99tsXXHBBkiT/8i//MmfOnGOOOeZXv/rVl770pSRJPvnJT77v7Y2NjT/5yU/OO++8JEnGjRs3ZMiQiy66KHqHXUkCAEBu9OnT58EHH9zwlvr6+o1+R3PWrFnve3tDQ8O9997b9PUX/6INdth72wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEKWQpmnVw6VSqVV3BqA9KpfLmWzXGgvUgnJGa2yb6djC+UqlUt1gsVjM5Wyfr1c5+/ylZ5xxRnWzM2fOrLXZlhznXL6uzLbv2Qzl7lhluMZmtc8tWuscZ7Nma4ArSQAAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKIU0TaseLpVKrbozAO1RuVzOZLvWWKAWZLXGtpmOLZyvVCrVDRaLxVzO9vl6lbPPX3rGGWdUNztz5sxam23Jcc7l68ps+57NUO6OVYZrbC6fr+Ns1mwNcCUJAABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsA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hQsXbrqHDz/88IIFC6699tpdd921T58+l19++R133JGmaRseJCAznTp1OumkkwYPHlwul1955ZVCoXDZZZfV19ePHDlyWxeWDd/btmRB7qht8mr06NHHHHPM1VdfnSTJlVdeefjhh48aNarpW9dcc8299947b968Rx55ZMyYMU03Dh8+vFu3bi+++OLs2bMffvjhcePGJUmybt26E088sa6u7oUXXnjooYeeeOKJyy+//IEHHujbt+/06dOnTZu2ucH33ntv6NCh/fv3X7JkyWWXXTZ9+vRN93DAgAFr1qypq6tr+telS5futttuhUKhDQ8SkLG1a9d27dq16etnn3325ZdfvuKKK6peWCxZkEsb/Q96aG/22WefjV60O+ywQ9O35s+f39DQcO2119bX18+fPz9N09deey1JknK53HSHWbNm1dXVLV++fPbs2TvttNOqVauabn/44Yc7dOiwcuXK2bNn19XVvfHGGxtttOmPrjRNNzdYqVTq6+tXrFjRdPt555135JFHbuFZNDY27rfffpdffnlrHx6gHenevXvzlSSNjY3Tp0/v0KHD3XffvXTp0iRJ7rnnnqZvbevC8tZbbyVJ8swzz1iyII+8t03+rtteu3Zt0+19+vSZMGHC+PHjL7rooj59+jTfv/m3fw455JDVq1e/8MILTz/99IoVKzp37tz020sf+9jH1q9fv2DBgqeeeqpnz5677bbb5ja9ucGnn356//3379KlS9PdDj300C3s/7vvvnvyySf369dv4sSJrXRIgHbqggsuaFou9txzzylTpnz3u98dNmxY07f23XffFi4slizII7VNvj355JNJkjz66KMb3tipU6emL9atW5ckSceOHdeuXdunT5+N/lvzIx/5SKdOnbb8/0k3N7jR3Zq3uKk33nhj8ODBPXv2vP322zt27Niypwu0d83vbb/33ntPPvnkhr9o2Llz5xYuLJYsyCO1TY797Gc/u+222yZPnnzHHXdUKpXm2x9//PGmL+bNm9e1a9f999//wAMPXLhw4csvv7zRIxxwwAGLFi1q+r+0G2r+82xzg/369Zs/f/67777b9K9PPPHE++7hyy+/fMwxxwwcOPCWW25pvhoSqHFVLyyWLMgjtU1eLV++/Pzzzx87duzFF1987rnnjhkz5p133mn61iWXXLJw4cL58+dfeuml5513XufO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ABBFbQMAQBS1DQBQo/7f//t/AwYMOO6444499tiHHnooSZJly5YVi8VjjjmmWCwuW7as+Z7/+I//OOgvBgwYsPvuuydJcvXVV/fr12/y5MlJkqxfv37YsGGNjY2ZPpt2qmPWOwAAQDZGjx59//3377fffi+88MLJJ5/89NNPX3nllQMHDhw/fvw3vvGNq6666uqrr26656233tr0xbRp0/70pz8lSfKtb33rueee69u374QJE6ZNmzZ8+PCGhoZMn007VUjTNKklpVIp610AcqZcLmeyXesVEL1eHXbYYddff/3hhx/+u9/97rTTTnvppZf69es3a9asHj16LF68+IQTTnjiiSc2vH+aph/96Ed//vOff+ADH9h3331/+ctfDh48eN68eWedddbdd99dKBRa+wltF9IaUywWqz5WZs0GzabPJ9X9k9PZrI5z1bM1uF5dPj+t7p88/nzNbtNsHtcc69UW/O53v+vcuXO/fv06d+581113pWm6++67r1u3Lk3TdevW7bHHHhvd/4477jj33HObvr7pppuOPPLIW2655YILLnj44YdbaeXbDrluGwCgRl188cW33HLLE0888aMf/einP/3p373/N77xjYsuuqjp67POOmvu3Ll9+/ZNkmTBggXDhg27/fbb43c5f1y3DQBQo5544ommi9Y++clPXnDBBUmS7Lnnnq+88kqPHj2WLl265557bnjn3/72tw0NDU153SRN0y9/+cs33XTTYYcdNnfu3AEDBowYMSKL59GueW8bAKBG9e3b99e//nWSJA899NCHPvShJEmGDh3a9AuRt95669ChQ5MkWb58edOdr7nmmuY3tpvceOONJ598cvfu3VeuXJmm6YoVKzJ6Hu2a97YBAGrU97///bFjx/75czMKhWnTpiVJ8i//8i//9E//9NOf/nT33Xf/4Q9/2PS296xZs55//vklS5YMHDiwebaxsfEnP/nJPffckyTJuHHjhgwZslGL00RtAwDUqP79+8+ePXvDW+rr6yuVyoa3zJo1K0mSPn36NH0gd7OGhoZ777236esv/kWb7HL+uJIEAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiFNI0TWpJqVTKeheAnCmXy5ls13oF5GW9Ygs6JrWn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kiRr1qz5+c9//slPfnLXXXc966yzWvKYDQ0NaZpu4Q5OYWBT3tuGbXPDDTd07tx50aJFSZK89tpru+yyy/Tp019//fVCoXDDDTf07Nmzvr5+9OjRzX/oLl26dMSIEV27du3Vq9f48eObb1+8eHGpVOrWrdsee+zxuc99btWqVYMGDXruuedGjRrV9Mfq5gafeuqpY489tkuXLgMGDFi4cOGme/jCCy/cf//9U6ZMqa+vP/zww4877rjf/OY3bXiEoH3p1KnTSSedNHjw4HK5/MorrxQKhcsuu6y+vn7kyJHbeqJt+N62UxjYSmobts3o0aOPOeaYq6++OkmSK6+88vDDDx81alTTt6655pp777133rx5jzzyyJgxY5puHD58eLdu3V588cXZs2c//PDD48aNS5Jk3bp1J554Yl1d3QsvvPDQQw898cQTl19++QMPPNC3b9/p06dPmzZtc4Pvvffe0KFD+/fvv2TJkssuu2z69Omb7uH++++/fv367t27r1279v/9RalUatuDBO3O2rVru3bt2vT1s88++/LLL19xxRVVn2hOYWAbpMD72WeffTY6WXbYYYemb82fP7+hoeHaa6+tr6+fP39+mqavvfZakiTlcrnpDrNmzaqrq1u+fPns2bN32mmnVatWNd3+8MMPd+jQYeXKlbNnz66rq3vjjTc22mjTH9Vpmm5usFKp1NfXr1ixoun2884778gjj9zcU+jbt2/nzp0HDRr02muvBRwhaL+6d+9+3XXXNX3d2Ng4ffr0Dh063H333UuXLk2S5J577mn61raeaG+99VaSJM8884xTGNh63tuGzfrmN7+54dmydu3aptv79OkzYcKE8ePHX3TRRX369Gm+f/NvOx1yyCGrV69+4YUXnn766RUrVnTu3Lnpt7U+9rGPrV+/fsGCBU899VTPnj132223zW16c4NPP/30/vvv36VLl6a7HXrooVvY/2efffaNN97YaaedTjrppFY6JJAbF1xwQdPps+eee06ZMuW73/3usGHDmr617777tvBEcwoDW09tQzWefPLJJEkeffTRDW/s1KlT0xfr1q378+8gd+y4du3aPn36bPTfuB/5yEc6depUKBS28PibG9zobs1b3Jydd9554sSJv/3tb5csWVLtc4Vcan5v+7333nvyySebfmOySefOnVt4ojmFga2ntmGb/exnP7vtttsmT558xx13VCqV5tsff/zxpi/mzZvXtWvX/fff/8ADD1y4cOHLL7+80SMccMABixYtavq/0htq/vN7c4P9+vWbP3/+u+++2/SvTzzxxKa7d++999bX169atarpX998880ddtihoaGhZU8atkNVn2hOYWDrqW3YNsuXLz///PPHjh178cUXn3vuuWPGjHnnnXeavnXJJZcsXLhw/vz5l1566Xnnnde5c+fjjz/+4IMPHjVq1KJFixYvXvyFL3xh3333XbVq1bHHHtuvX78LL7zw9ddff/HFF4cPH3766ac3vY+1ZMmSd955Z3ODn/jEJ/bee+/Pf/7zb7755n333XfjjTduuoeDBg3aa6+9xo8fv2zZsscff3zChAmjRo3aaaed2vxQQXtX9YnmFAa2wTZc4w21/VuSSZJ89rOfvfDCCz/0oQ8tX748TdNly5b16tVrzJgxTb8l+cUvfvGDH/zgrrvuOn78+NWrVzc9zksvvXTqqafuvPPOu+yyywknnPDMM8803b5w4cITTzxxxx137N69+8iRI5ctW5am6Q9+8IOuXbsOHz58C4MvvPDC4MGDd9xxx379+o0fP/59f8Xq+eefHzp06C677LLvvvtedtllK1eubMMjB+3rtyQ31PRbkk2/3Nxkm0605t+SdAoDW6+w5Q/qJ+98blTbWL169T333DN48OBu3bplvS+0vnK5nMl2nb+Q3/MX/mYbypwcKhaLSbXMbr2hQ4dmsl2zbTPr/DVrNr+zWZ2/0Mx12wAAEEVtQyuoq6vLehcAgPZIbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABClkKZp2IOTvVKplPUuQO6Vy+VMtuv8hfyev9Cs49++ZDtVqVSqGywWi1nNLpjYWN1s70kNZtv/bO5ekxnK3bFy/m73s7l7TULmXEkCAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAEQppGka9uBkr1QqZb0LkHvlcjmT7Tp/Ib/nLzTr+Lcv2U5VKpXqBovFYlazCyY2Vjfbe1LDjDljq5sdOXCq2a2fbcnPKHevyQzV2vmb1T6Xly2pbrZU38PPaOu3W2vnLzRxJQkAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEKWQpmnYg5O9UqmU9S5A7pXL5Uy26/yF/J6/0Kzj375kO1WpVKobLBaLCyY2Vjfbe1JDVrMz5oytbnbkwKlmt362JT+jlrwmM5nNUK2dv7l7beR0tqZ+RpA5V5IAAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFEKaZqGPTjZK5VKWe8C5F65XM5ku85fyO/5C806/u1LtlOVSqW6wWKxuGBiY3WzvSc1zJgztrrZkQOnmm3/sy15bbTkNZnJbA2ev7n7GRWLxf6Tq4yqxyaUam2fa+q1AZlzJQkAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEKWQpmnYg5O9UqmU9S5A7pXL5Uy26/yF/J6/0Kzj375kO1WpVKobLBaLCyY2Vjfbe1LDjDljq5sdOXCq2fY/25LXRktek5nM1uD5m7ufkdltmq2p1wZkzpUkAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUf3M7AMDWKRQ2+600bdM9IT/UNgBAtZG96X1kN/+T2gYAaEFnv++I5ua/qW0AgNbo7E3HNTd+SxIAoJVTu9UfhzxT2wAAYYksuGue2gYAiIxjwV3b1DYAQHAWC+4aVkhdv79dK5VKWe8C5F65XM5ku85faNPztw2CWHTVJJ9Jsv2rVCrVDRaLxQUTG6ub7T2pIavZGXPGVjc7cuBUs1s/m9XPtyWv56pnM1Rr528mP98anK2pn2/7eu+5UBDcNciVJAAAEEVtAwC1rS0vqnYBd+1R2wAAEEVtAwA1rO3fbPb2do1R2wAAEEVtAwBAFLUNANSqrC7qcDFJLfF52wAAWy1NkzvuSNauTTp1Sk45RTfzd3lvGwBgq/3ud8nPfpaMGJHceWcyd27We0MOqG0AgK22aFGyalVy1FHJ4sV//gf+HrUNALAtbr45ueyy5N57s94P8kFtAwBsi1GjkhkzkpNPzno/yAe1DQCw1Xr1Srp0ScrlP3+xzz5Z7w054DNJAAC22hFHJK+8kgwc+OfPJDnqqKz3hhxQ2wAAW81H/rGNXEkCANSqNK2t7ZIFtQ0AAFHUNgAARCmk/l/Gdq1UKmW9C5B75XI5k+06f6GNzt82vhRbetUYvyW5/atUKtUNFovFrGYXTGysbrb3pIYZc8ZWNzty4FSzbTPbkp9vJq/JDNXa+duS7bbkNZnVsSovW1LdbKm+R639fPN4/kITV5IAALWtLd9s9sZ27VHbAAAQRW0DADWvbd5y9sZ2TVLbAK3pkEMOWbx4cZIkq1atOuCAA6ZOnXrooYd+9KMfnTVrVta7BmSawlK7VqltgNY0YsSIO++8M0mS+++//4QTTpg0adKcOXNmzpx58803Z71rQHZBLLVrmNoGaE2nnXbaHXfckSTJXXfd9alPfWro0KFnn332okWLbrrppqx3Dcgoi6V2bVPbAK2pb9++b7zxxttvvz1v3ryPf/zjM2bMGDdu3HXXXTdq1Kisdw3IIo6lds3zedsArezUU0+9+uqrjzjiiLfffvuUU0657777DjvssN69e2e9X8BWS9PW+StvpDZqG6DVnXbaaQcffPD9999fX19/0kknHXXUUevXr//Xf/3XrPcL2PZQrrq5dTb/TW0DtLK+ffuuWrWq6esJf5H1HgFt2Nw6m/9JbQMAbF1AbyG7RTabobYBALaOpGbb+UwSAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACBKIfVZNtu1UqmU9S5A7pXL5Uy26/yF/J6/0MznbW//KpVKdYPFYjGr2QUTG6ub7T2pYcacsdXNjhw41WzbzLbk55vJazJDtXb+5vH51tps7n6+kDlXkgAAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AMBfrV+/fuzYsUcfffTAgQMXLFiQJMnChQs/8YlPDBo06KSTTnr11Ve3cM+rr766X79+kydPbvrusGHDGhur/MBEtidqGwDgr77//e9369btoYceGjdu3MUXX5wkyXnnnXfJJZc88MAD48aN+8pXvrKFe37rW9/6zW9+c+211yZJMm3atOHDhzc0NGT6bGgX/O02AAB/dcstt/zwhz9MkmTYsGHz589PkuQPf/jDoEGDkiQZNGjQ5z73uS3cs1OnTv/1X/9VV1f35ptv3nHHHXfffXemT4X2wnvbAAB/9cc//vHOO+8cNGjQpz/96U996lNJkhx88MF33nln018Cv+GVJJve88orrzzzzDOvuuqqiRMnfvWrXy0UCpk+FdoLtQ0A8FerV6/+4Ac/+MADD5x55pmjR49uuibkpptuOu6441566aW6urot3POss86aO3du3759kyRZsGDBsGHDbr/99kyfDe2CK0kAAP5qzz33LBaLSZIUi8Xzzz8/SZIf//jHt912W11d3fz588vl8hbumSRJmqZf/vKXb7rppsMOO2zu3LkDBgwYMWJEds+GdsF72wAAf3X88cfPmTMnSZI5c+b0798/SZLf//7399xzT5IkM2bMOP3005MkWb58+fveM0mSG2+88eSTT+7evfvKlSvTNF2xYkXWT4jseW8bAOCvrrjiitGjR19xxRUdO3a8/vrrkyS55pprRo4c+fWvf/3www//P//n/yRJ8slPfnLWrFmb3rOxsfEnP/lJU5qPGzduyJAhF110UdZPiOypbQCAv/rABz5w1113bXhLnz59HnzwwQ1vmTVr1vves6Gh4d577236+ot/0Sa7THvnShIAAIiitgEAIIraBgCAKIU0TcMenOyVSqWsdwFyb8PP/GpLzl/I7/kLzfyW5PavUqlUN1gsFlsyu2BiY3WzvSc1tGR2xpyx1c2OHDjVbNvMtuTnm8nrOUO1dv5m9XzNbv1s7n6+kDlXkgAAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUQppmoY9ONkrlUpZ7wLkXrlczmS7zl/I7/kLzTr+7Uu2U5VKpbrBYrHYktkFExurm+09qWHGnLHVzY4cONVs+59tyWsjk9dzhvJ4/ma1z1nNtuRcyOPzzd1rAzLnShIAAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIEohTdOwByd7pVIp612A3CuXy5ls1/kL+T1/oVnHv33JdqpSqVQ3WCwWWzK7YGJjdbO9JzXMmDO2utmRA6fmcbYlx6rWZjN5PWcoj+dvVvvcknMwq2NVa7O1dv5CE1eSAABAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABRCmmahj042SuVSlnvAuReuVzOZLvOX8jv+QvNOv7tS7ZTlUqlusFisdiS2QUTG6ub7T2pYcacsdXNjhw4NY+zLTlWWf18a2o2Q3k8f3P383Wstu9ZyJwrSQAAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKIU0TcMenOyVSqWsdwFyr1wuZ7Jd5y/k9/yFZh3/9iXbqUqlUt1gsVhsyeyCiY3Vzfae1GB262ez+vnW1GyGnL/b92zuzoU8zkLmXEkCAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAEQppGka9uBkr1QqZb0LkHvlcjmT7Tp/Ib/nL/xNynatWCwm1TJr1mwT569Zs/mdzer8hWauJAEAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAohTSNA17cLJXKpWy3gXIvXK5nMl2nb+Q3/MX/iZlu1YsFpNqmTVrtonz16zZ/M5mdf5CM1eSAABAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABRCmmahj04AADUNO9tAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAACRB/n+15RY5M4KyIgAAAABJRU5ErkJggg=="
            },
            {
              "type": "input_text",
              "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
            }
          ],
          "solved_count": 0,
          "total_training_examples": 3,
          "pixel_accuracy": 0.8232373386295928
        },
        "test_result": {
          "correct": false,
          "pixel_accuracy": 0.7596153846153846,
          "total_pixels": 624,
          "correct_pixels": 474,
          "error": null
        },
        "status": "failed_test",
        "feedback_sent": true
      },
      {
        "turn_number": 7,
        "timestamp": "2025-07-10T13:44:36.504734",
        "input_tokens": 63418,
        "output_tokens": 1792,
        "turn_cost": 0.028234400000000003,
        "program_extracted": true,
        "program": "def transform(grid):\n    import numpy as np\n    from collections import deque, Counter\n\n    grid = np.array(grid)\n    h, w = grid.shape\n    output = grid.copy()\n\n    # 8-directional neighbors for better flood fill accuracy\n    def neighbors8(r, c):\n        for dr in [-1,0,1]:\n            for dc in [-1,0,1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r+dr, c+dc\n                if 0 <= nr < h and 0 <= nc < w:\n                    yield nr, nc\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    # Extract connected outline components (using 4-connectivity)\n    def neighbors4(r, c):\n        for nr, nc in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\n            if 0 <= nr < h and 0 <= nc < w:\n                yield nr, nc\n\n    def bfs_component(sr, sc):\n        q = deque([(sr, sc)])\n        comp_pixels = []\n        visited[sr, sc] = True\n        while q:\n            r, c = q.popleft()\n            comp_pixels.append((r, c))\n            for nr, nc in neighbors4(r, c):\n                if not visited[nr, nc] and grid[nr, nc] != 0:\n                    visited[nr, nc] = True\n                    q.append((nr, nc))\n        return comp_pixels\n\n    def find_outline_pixels(component):\n        comp_set = set(component)\n        outline = set()\n        for (r, c) in component:\n            for nr, nc in neighbors8(r, c):\n                if (nr, nc) not in comp_set:\n                    outline.add((r, c))\n                    break\n        return outline\n\n    components = []\n    for r in range(h):\n        for c in range(w):\n            if grid[r, c] != 0 and not visited[r, c]:\n                comp = bfs_component(r, c)\n                components.append(comp)\n\n    for comp in components:\n        comp_set = set(comp)\n        outline_set = find_outline_pixels(comp)\n\n        # Majority outline color\n        colors_in_comp = [grid[r, c] for r, c in comp]\n        outline_color = Counter(colors_in_comp).most_common(1)[0][0]\n\n        rows = [r for r, c in comp]\n        cols = [c for r, c in comp]\n        rmin, rmax = max(min(rows), 0), min(max(rows), h - 1)\n        cmin, cmax = max(min(cols), 0), min(max(cols), w - 1)\n\n        box_h = rmax - rmin + 1\n        box_w = cmax - cmin + 1\n\n        mask = np.zeros((box_h, box_w), dtype=np.int8)\n\n        for (r, c) in comp_set:\n            rr, cc = r - rmin, c - cmin\n            if (r, c) in outline_set:\n                mask[rr, cc] = 1  # outline\n            else:\n                mask[rr, cc] = 2  # candidate interior\n\n        # Flood fill exterior on mask==0 from bounding box edges - 8 connectivity for exterior flood fill\n        visited_box = np.zeros_like(mask, dtype=bool)\n        q = deque()\n        for rr in range(box_h):\n            for cc in [0, box_w - 1]:\n                if mask[rr, cc] == 0 and not visited_box[rr, cc]:\n                    q.append((rr, cc))\n                    visited_box[rr, cc] = True\n        for cc in range(box_w):\n            for rr in [0, box_h - 1]:\n                if mask[rr, cc] == 0 and not visited_box[rr, cc]:\n                    q.append((rr, cc))\n                    visited_box[rr, cc] = True\n\n        while q:\n            rr, cc = q.popleft()\n            for dr in [-1,0,1]:\n                for dc in [-1,0,1]:\n                    nr, nc = rr+dr, cc+dc\n                    if (dr == 0 and dc == 0) or nr < 0 or nr >= box_h or nc < 0 or nc >= box_w:\n                        continue\n                    if not visited_box[nr, nc] and mask[nr, nc] == 0:\n                        visited_box[nr, nc] = True\n                        q.append((nr, nc))\n\n        # Find all interior pixels: mask==2 & not reachable from outside\n        all_interior_pixels = []\n        for rr in range(box_h):\n            for cc in range(box_w):\n                if mask[rr, cc] == 2 and not visited_box[rr, cc]:\n                    all_interior_pixels.append((rr + rmin, cc + cmin))\n\n        if not all_interior_pixels:\n            continue  # no interior pixels, skip\n\n        # To handle multiple interior blobs, find connected interior components (4-connectivity)\n        interior_visited = set()\n        interior_groups = []\n\n        pixel_set = set(all_interior_pixels)\n\n        def bfs_interior(sr, sc):\n            q = deque([(sr, sc)])\n            group = []\n            interior_visited.add((sr, sc))\n            while q:\n                r, c = q.popleft()\n                group.append((r, c))\n                for nr, nc in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\n                    if (nr, nc) in pixel_set and (nr, nc) not in interior_visited:\n                        interior_visited.add((nr, nc))\n                        q.append((nr, nc))\n            return group\n\n        for p in all_interior_pixels:\n            if p not in interior_visited:\n                grp = bfs_interior(*p)\n                interior_groups.append(grp)\n\n        # For each interior group, pick fill color and fill\n        for group in interior_groups:\n            colors_in_group = [grid[r, c] for r, c in group if grid[r, c] != 0 and grid[r, c] != outline_color]\n            if colors_in_group:\n                fill_color = Counter(colors_in_group).most_common(1)[0][0]\n            else:\n                alt_colors = [grid[r, c] for r, c in group if grid[r, c] != 0]\n                if alt_colors:\n                    fill_color = Counter(alt_colors).most_common(1)[0][0]\n                else:\n                    fill_color = outline_color\n\n            for r, c in group:\n                output[r, c] = fill_color\n\n    return output.tolist()",
        "training_feedback": {
          "feedback_messages": [
            {
              "type": "input_text",
              "text": "Training results: 0/3 examples solved, 82.3% pixel accuracy - Good partial progress! Your approach is capturing some patterns. Next, try to identify a transformation that solves at least one of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 1, 1, 1, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 5, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 0, 8, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 8, 0, 0, 8, 2, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 3, 0, 8, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 1, 1, 1, 0, 0, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 5, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 5, 0, 5, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 90.0%\n\nTraining Example 2 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 6, 6, 6, 0, 0], [0, 0, 2, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 2, 2, 2, 3, 3, 3, 3, 3, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 6, 6, 6, 6, 6], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 3, 0, 2, 0, 0, 6, 6, 6, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 6, 0, 3, 0, 0], [0, 0, 2, 2, 2, 0, 3, 0, 0, 0, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 6, 6, 6, 6, 6], [0, 0, 0, 0, 2, 0, 0, 0, 8, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 8, 0], [3, 0, 0, 0, 0, 0, 0, 4, 8, 0, 3, 0, 8, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 8, 0, 4, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 80.7%\n\nTraining Example 3 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 3, 3, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 3, 3, 6, 6, 6, 6, 6, 6, 3, 3, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 3, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0], [0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 3, 0, 0, 0, 8, 0, 0, 8, 0, 3, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 0, 3, 0, 6, 0, 0, 2, 0, 0, 3, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 3, 0, 0, 0, 0, 6, 0, 0, 0, 3, 0, 0], [0, 0, 3, 0, 0, 6, 0, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 69.6%\n\n"
            },
            {
              "type": "input_image",
              "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA88AAAUtCAIAAABNteEnAABUgklEQVR4nO3de5xVdb34/7URBlFwRtFUBEsk0R58RdO8kHJQ+D5S8LJ3YB1NPXBQ035IgaLZ4WT5xTQhO9HF/IZCpqQnT3t7OWbkN4UsKVPyrqGgIaDH26AIcl2/R01n4oAQ7Jn3rFns5/PhH+Oe/d5r7TV7fXi5XbMppGmaAAAAATpEPCgAAKC2AQAgkNoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAaJe1PWbMmMLmnXnmme97n7q6ur322uuUU0559NFHN33MX/ziF4VCYbfddnvvvfc2+tbtt99eKBSmTZvW9K8jR44sFAqTJ0/e6G4vv/xyoVCYOHFiS6aavPfee9dff/1xxx3Xo0ePzp079+jR47TTTvvVr361hWMyceLEzR2QJ598cssHbciQIX/3wDbf55xzztnw9qbdGz58+EMPPbTh/hSLxY3utt9++40dO/att97apoPf5PXXX580adKhhx5aX1+/8847H3HEEdOmTUvTdKPNbTT+yCOP7LHHHt26dbv//vu3cOgAALY/Gby3vWbNmldfffWuu+467rjjFixYsNF3b7zxxiRJ3nrrrdtuu21rHu3LX/7ys88+u637sDVTL7744tFHH33++ec/8MADS5cuXb169dKlS2+//faBAwdee+21STvTtHs//elPjznmmFtuuWULd3vxxRe//e1vn3DCCevXr9+mg//QQw/179//X//1X//whz+8/fbbK1asePjhh88999zRo0dvYcd++ctfHnfccevWrbvvvvuOO+64FjxFAIAaq+3vfOc76X/7yU9+kiTJ9OnTm2+5+eabm++5cOHC5tvfe++9Z5555owzznj77bevu+66DR+wsbGxUqmcdtppu+222/e///2t2YfVq1ePHDly3bp127Tnf3dqzZo1I0aM+MMf/jBgwIA777zz9ddfX7NmzZ/+9Kfvfe97u+222yWXXNL0RvXmzJs3L91Ev3793veANLvvvvs2fJCtuc/SpUubbl+5cuXzzz//xS9+MU3Tf/7nf37ppZc2vNvKlSs3PPhDhgz53e9+94tf/GLrD/5//dd/lUqlJUuWnH766XPnzn377bfffPPNSqXSu3fv6dOnX3/99e97HMrl8tChQ3faaacHHnjgyCOP3MIRAwDYLmXw3nbnzp0PPPDAr3/960mSbPTe9syZM997773Pfvazo0aNmjt37uOPP/53H+3CCy/87W9/+41vfGOb9uHvTv3whz985JFHhgwZMmfOnJNPPrl79+4dO3bs1avXBRdc8NOf/nTdunU//vGPk/Zkxx133H///a+66qovf/nLq1ev/rd/+7ctHPwvfOELTaW+9Qf/2muvffXVV8eNGzdz5swjjzyyW7duu+6666mnnjp79uydd9752muv3fB6kiY33HDDaaed9oEPfOBXv/rVwQcf3Hz7jBkzCoXCd77znVY9AAAA7VEGtb1q1aqnnnpq/PjxSZIccMABG35r+vTpBx100PHHH3/BBRfssMMOW/P29te+9rU+ffp8+ctffuaZZ7Z+H/7u1MyZMwuFwv/9v/93hx122Ohb//AP//D0009PmjQpaZcuuuiinXba6ec///n7fnfNmjV//OMfp06d2rFjx3/4h3/Y+oP/7//+7126dLniiis2esCePXs++OCDDzzwQKFQ2PD2a6655pxzzundu/eDDz744Q9/uPWeHwBAnrRRbe+3337Nv6i344479uvX7yc/+cnuu+/++c9/vvk+Tz755O9///sJEyYUCoX999//tNNOu+WWW5YvX77lR95pp52mT5++Zs2abbqe5O9OzZs376CDDtpvv/3ed/yggw7aKC43cuihh270240PPvjg5g5IswceeGBb77Opbt26ffjDH97ofxp06dKlabyurq5v376//vWvf/jDH2747LZ88NesWfPiiy8eccQRXbt23XSLhxxyyN57773hLZdccsmll16aJMmxxx677777bnT/kSNHpmk6ZsyYLT8RAIDtQDafALjPPvv88z//82OPPbbXXns133jjjTfus88+n/nMZ5r+9bLLLnvnnXe25oKNY445ZuzYsb/73e+mTJmy9fuwhak1a9Y0NjbuueeeG9640eeEfOhDH0raq+7du6/6i83dYd26dXPnzl2zZs1WHvzGxsY0Tbt3776VO/Dtb3/76KOPHjJkyI033vjTn/60Zc8GACDH2qi2m37hb/Xq1bfeemvTm69XX311jx49mu+wZs2am2++efHixZ07d27K2f79+6dpupW/K/m1r33twx/+8OWXX/70009v/V5tbqpTp07dunV77bXXkmpt+luSxxxzzN/9DchBgwZt633e11tvvdWpU6fOnTtv+luSq1evXrBgwf/3//1/3/72ty+++OKtPPi77bZbhw4dtv6AjBo16oEHHrjpppt22223c889d/HixVs5CACwnWnT97Y7der06U9/+rbbbps9e/YJJ5yw4acy33333e8bc48++ujDDz/8dx+5S5cuVVxPsoWp//W//tfTTz/9pz/96X0/gOWwww5L2qvly5c/+eSTBx100Pt+t1OnTvvtt9+UKVP69es3Y8aMrTz4O+yww0EHHfT73/9+xYoVm97tqquuOvvss5csWdJ8y/e+9726urq99977O9/5zptvvnn22Wdv+mmDAAC1IIMrSU488cQLL7zw0UcfbX5vtelKhh133HHZsmUbvo/7m9/8JkmSzX263EY+/vGPf/7zn3/44Yc3/Ztrqpj6zGc+s379+s997nPv2+6bfv5G+/HNb35zzZo1J5xwwpbv1qFDh+XLl69du3YrD36xWFy5cuVXvvKVjR7nxRdfvOaaa+6+++73vc7k9NNPHzFixC9/+cttusgHAGC7kc1121/72tf23Xff66677re//W2SJK+88sq999578skn77LLLhve7eijj+7bt++Pf/zjZcuWbc3DXnnllR/+8Ie/973vbdPOvO/UOeecc9hhh/3nf/7nEUcc8e///u+vvPLKmjVrmv52m2HDhj366KMdOrSvv/R+1apVzz333MSJE7/61a/utNNOm/sdxDRNX3755QkTJjz++OOHHnpox44dt/Lgjxs3rnv37pMnTz777LN///vfr1y58tVXX505c+agQYMaGxsnTJiw4YUrG7ruuuv23HPPiRMnPvLIIzFPHQCg/comGXfeeedvf/vb69ev/+xnP7t27dqbbrpp7dq1zb+it6F/+qd/WrFixY9+9KOtvzJky58WspVTdXV1lUrl6KOPfvTRRz/96U/vvffedXV1TX9z+z333NO3b9+t/KsuN+d9P2+kUChs+BksW3Ofvffeu/mTXg488MArr7yy6a+p79Wr10bPseluHTp06NWr15QpUzp06ND0IYZbefC7d+9+2223devW7Uc/+tHHPvaxnXbaaa+99vrMZz7z0ksvlUqlSy65ZHPPdPfdd//BD36wZs2aM84449133/V52wBATcnsDdpTTjmlWCw+9thj//Zv/zZjxoxdd931xBNP3PRuZ599docOHbbyYpKmK0Oa/uqWbfK+Uz179vzVr3518803Dx06tGfPnnV1dXvuuefQoUN/+MMfPvnkkx/72MeS9qRTp069evX6x3/8x1//+tenn3765u62ww47fOADHxg2bNgvfvGLpqtNtv7gDx48eN68eWPHjj3wwAO7du3apUuXI488ctq0af/xH/+x6aeSb+jkk08eOXLkH//4xw0/8BEAoBYU2vMlyAAAkGvt6+JjAADYnqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqmxx74403nn322az3AmC7ZZmFllPbtI6ePXsWNnHzzTeHbnTIkCFz587d+vtPmTLlqKOO2tx3Gxsbe/fuvU0PCNA2dt999+alta6u7qCDDpo6dWrVj9a8GDY2NhYKhS30tGUWWk5t02q++c1vpv/TmWeeGbrFlStXttZDLVq0aMiQIQsXLmytBwRoXdddd13T0vruu+9Onjz54osv/tGPftTCx2xoaEjT9MADD9zcHSyz0HJqm1g33HBD586dFy1alCTJa6+9tssuu0yfPv31118vFAo33HBDz5496+vrR48e3bygL126dMSIEV27du3Vq9f48eObb1+8eHGpVOrWrdsee+zxuc99btWqVYMGDXruuedGjRp1zjnnbGHwqaeeOvbYY7t06TJgwIDNrfL/+Z//2a9fv8MOO6ytjgpA9Tp16nTSSScNHjy4XC6/8sorhULhsssuq6+vHzly5LYuhhu+t22ZhSBqm1ijR48+5phjrr766iRJrrzyysMPP3zUqFFN37rmmmvuvffeefPmPfLII2PGjGm6cfjw4d26dXvxxRdnz5798MMPjxs3LkmSdevWnXjiiXV1dS+88MJDDz30xBNPXH755Q888EDfvn2nT58+bdq0zQ2+9957Q4cO7d+//5IlSy677LLp06e/70527tz5vvvu++53v9uGBwagRdauXdu1a9emr5999tmXX375iiuuqHoxtMxCoI3+1z9UZ5999tnopbXDDjs0fWv+/PkNDQ3XXnttfX39/Pnz0zR97bXXkiQpl8tNd5g1a1ZdXd3y5ctnz5690047rVq1qun2hx9+uEOHDitXrpw9e3ZdXd0bb7yx0Uab/hhI03Rzg5VKpb6+fsWKFU23n3feeUceeeTmnsKaNWuSJHnooYcCDg9Ai3Tv3r35SpLGxsbp06d36NDh7rvvXrp0aZIk99xzT9O3tnUxfOutt5IkeeaZZyyzEMd720Rdt7127dqm2/v06TNhwoTx48dfdNFFffr0ab5/82/SHHLIIatXr37hhReefvrpFStWdO7cuek3gT72sY+tX79+wYIFTz31VM+ePXfbbbfNbXpzg08//fT+++/fpUuXprsdeuihwccAIMoFF1zQtMTtueeeU6ZM+e53vzts2LCmb+27774tXAwtsxBHbdMWnnzyySRJHn300Q1v7NSpU9MX69atS5KkY8eOa9eu7dOnz0b/RfiRj3ykU6dOhUJhC4+/ucGN7ta8RYDcaX5v+7333nvyySfPP//85m917ty5hYuhZRbiqG3C/exnP7vtttsmT558xx13VCqV5tsff/zxpi/mzZvXtWvX/fff/8ADD1y4cOHLL7+80SMccMABixYtavo/nhtq/rNhc4P9+vWbP3/+u+++2/SvTzzxRGs/OYB2pOrF0DILcdQ2sZYvX37++eePHTv24osvPvfcc8eMGfPOO+80feuSSy5ZuHDh/PnzL7300vPOO69z587HH3/8wQcfPGrUqEWLFi1evPgLX/jCvvvuu2rVqmOPPbZfv34XXnjh66+//uKLLw4fPvz0009PkmTnnXdesmTJO++8s7nBT3ziE3vvvffnP//5N99887777rvxxhuzPh4AgapeDC2zEEdt02rGjRu30d9uc/7553/pS1/q0KHDpEmTkiSZPHlyhw4dvvSlLzXdf8iQIccdd9yRRx75v//3/2760JIOHTpUKpWdd975oIMO+shHPvLcc8/NmjWr6TLB//iP/3jzzTd79ep1+OGH77LLLtdff32SJOeff/5VV101atSozQ3W1dX97Gc/e/HFF/fZZ59x48ade+65WR8kgEBVL4aWWYhTSNO06uFSqdSqO0OtWL169T333DN48OBu3bplvS/w95XL5Uy2a40FakE5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5/r16zdr1qwePXosXrz4hBNOeOKJJ5ruuent++677y9/+cvBgwfPmzfvrLPOuvvuuwuFQhKsYwvnK5VKdYPFYjGXs32+XuXs85dmNXvGGWdUNztz5sysZlt0rPL4ujLbvmczlLtjVYNrbFbHqv/kKv8j8LEJpTw+X7Pb8ey2Ovjgg++8885SqVQul5uuJHn11Vf32muvJEn23nvvpluabHr7lVdeeeaZZ1511VUTJ0786le/2gap7UoSAADyZNq0aTfddNNxxx330ksv1dXVbdPsWWedNXfu3L59+yZJsmDBgmHDht1+++1JO39vGwAA2syPf/zj2267ra6ubv78+U1Xoey5556vvPJKjx49li5duueeezbf831vT9P0y1/+8k033XTYYYfNnTt3wIABI0aMCN1h720DAJAbv//97++5554kSWbMmHH66acnSTJ06NBbb701SZJbb7116NChSZIsX778fW9PkuTGG288+eSTu3fvvnLlyjRNV6xYEb3DahsAgNy45pprpkyZcvTRR7/99tsXXHBBkiT/8i//MmfOnGOOOeZXv/rVl770pSRJPvnJT77v7Y2NjT/5yU/OO++8JEnGjRs3ZMiQiy66KHqHXUkCAEBu9OnT58EHH9zwlvr6+o1+R3PWrFnve3tDQ8O9997b9PUX/6INdth72wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEKWQpmnVw6VSqVV3BqA9KpfLmWzXGgvUgnJGa2yb6djC+UqlUt1gsVjM5Wyfr1c5+/ylZ5xxRnWzM2fOrLXZlhznXL6uzLbv2Qzl7lhluMZmtc8tWuscZ7Nma4ArSQAAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKIU0TaseLpVKrbozAO1RuVzOZLvWWKAWZLXGtpmOLZyvVCrVDRaLxVzO9vl6lbPPX3rGGWdUNztz5sxam23Jcc7l68ps+57NUO6OVYZrbC6fr+Ns1mwNcCUJAABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABClkKZp1cOlUqlVdwagPSqXy5ls1xoL1IJyRmtsm+nYwvlKpVLdYLFYzOVsn69XOfv8pWeccUZ1szNnzqy12ZYc51y+rsy279kM5e5YZbjGtmS7LVqvcrhda6zZdjW73XMlCQAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQpZCmadXDpVKpVXcGoD0ql8uZbNcaC9SCckZrbJvp2ML5SqVS3WCxWMzlbJ+vVzn7/KVnnHFGdbMzZ86stdmWHOdcvq7Mtu/ZDOXuWGW4xuby+TrOZs3WAFeSAABAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABRCmmaVj1cKpVadWcA2qNyuZzJdq2xQC0oZ7TGtpmOLZyvVCrVDRaLxVzO9vl6lbPPX1prs2eccUZ1szNnzmzRPufxdWW2fc9mKHfHyhrbdrNZHec8vq7Mtu/Z7Z4rSQAAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKIU0TaseLpVKrbozAO1RuVzOZLvWWKAWlDNaY9tMxxbOVyqV6gaLxaLZHMz2+XqVs89fmtlsHo+z2fY9m6HcHSuz2zZrjTVrtga4kgQAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiFJI07Tq4VKp1Ko7A9AelcvlTLZrjQVqQTmjNbbtpC1QLBar3q5Zs2bN5mW2JeukNdasWbNm2+ca22ZcSQIAAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARCmkaVr1cKlUatWdAWiPyuVyJtu1xgK1oJzRGtt20hYoFotVb9esWbNm8zLbknXSGmvWrFmz7XONbTOuJAEAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAohTSNK16uFQqterOALRH5XI5k+1aY4FaUM5ojW07aQsUi8Wqt2vWrFmzeZltyTppjTVr1qzZ9rnGthlXkgAAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUQppmoY9OAAA1DTvbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdvwPt54441nn302670A2CqWLGjP1DbtXc+ePQubuPnmm0M3OmTIkLlz5279/adMmXLUUUdtevv8+fNPOumkhoaGvffe+7Of/ezbb7/dqrsJtC+777578zJVV1d30EEHTZ06tepHa15YGhsbC4XCFnrakgXtmdomB775zW+m/9OZZ54ZusWVK1e2/EHWrFlz0kknfehDH1q4cOGvfvWrRx555Pzzz2+NvQPar+uuu65pmXr33XcnT5588cUX/+hHP2rhYzY0NKRpeuCBB27uDpYsaM/UNnl1ww03dO7cedGiRUmSvPbaa7vsssv06dNff/31QqFwww039OzZs76+fvTo0c1/CC1dunTEiBFdu3bt1avX+PHjm29fvHhxqVTq1q3bHnvs8bnPfW7VqlWDBg167rnnRo0adc4552xh8Kmnnjr22GO7dOkyYMCAhQsXbrqHDz/88IIFC6699tpdd921T58+l19++R133JGmaRseJCAznTp1OumkkwYPHlwul1955ZVCoXDZZZfV19ePHDlyWxeWDd/btmRB7qht8mr06NHHHHPM1VdfnSTJlVdeefjhh48aNarpW9dcc8299947b968Rx55ZMyYMU03Dh8+vFu3bi+++OLs2bMffvjhcePGJUmybt26E088sa6u7oUXXnjooYeeeOKJyy+//IEHHujbt+/06dOnTZu2ucH33ntv6NCh/fv3X7JkyWWXXTZ9+vRN93DAgAFr1qypq6tr+telS5futttuhUKhDQ8SkLG1a9d27dq16etnn3325ZdfvuKKK6peWCxZkEsb/Q96aG/22WefjV60O+ywQ9O35s+f39DQcO2119bX18+fPz9N09deey1JknK53HSHWbNm1dXVLV++fPbs2TvttNOqVauabn/44Yc7dOiwcuXK2bNn19XVvfHGGxtttOmPrjRNNzdYqVTq6+tXrFjRdPt555135JFHbuFZNDY27rfffpdffnlrHx6gHenevXvzlSSNjY3Tp0/v0KHD3XffvXTp0iRJ7rnnnqZvbevC8tZbbyVJ8swzz1iyII+8t03+rtteu3Zt0+19+vSZMGHC+PHjL7rooj59+jTfv/m3fw455JDVq1e/8MILTz/99IoVKzp37tz020sf+9jH1q9fv2DBgqeeeqpnz5677bbb5ja9ucGnn356//3379KlS9PdDj300C3s/7vvvnvyySf369dv4sSJrXRIgHbqggsuaFou9txzzylTpnz3u98dNmxY07f23XffFi4slizII7VNvj355JNJkjz66KMb3tipU6emL9atW5ckSceOHdeuXdunT5+N/lvzIx/5SKdOnbb8/0k3N7jR3Zq3uKk33nhj8ODBPXv2vP322zt27Niypwu0d83vbb/33ntPPvnkhr9o2Llz5xYuLJYsyCO1TY797Gc/u+222yZPnnzHHXdUKpXm2x9//PGmL+bNm9e1a9f999//wAMPXLhw4csvv7zRIxxwwAGLFi1q+r+0G2r+82xzg/369Zs/f/67777b9K9PPPHE++7hyy+/fMwxxwwcOPCWW25pvhoSqHFVLyyWLMgjtU1eLV++/Pzzzx87duzFF1987rnnjhkz5p133mn61iWXXLJw4cL58+dfeuml5513XufO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ABBFbQMAQBS1DQBQo/7f//t/AwYMOO6444499tiHHnooSZJly5YVi8VjjjmmWCwuW7as+Z7/+I//OOgvBgwYsPvuuydJcvXVV/fr12/y5MlJkqxfv37YsGGNjY2ZPpt2qmPWOwAAQDZGjx59//3377fffi+88MLJJ5/89NNPX3nllQMHDhw/fvw3vvGNq6666uqrr26656233tr0xbRp0/70pz8lSfKtb33rueee69u374QJE6ZNmzZ8+PCGhoZMn007VUjTNKklpVIp610AcqZcLmeyXesVEL1eHXbYYddff/3hhx/+u9/97rTTTnvppZf69es3a9asHj16LF68+IQTTnjiiSc2vH+aph/96Ed//vOff+ADH9h3331/+ctfDh48eN68eWedddbdd99dKBRa+wltF9IaUywWqz5WZs0GzabPJ9X9k9PZrI5z1bM1uF5dPj+t7p88/nzNbtNsHtcc69UW/O53v+vcuXO/fv06d+581113pWm6++67r1u3Lk3TdevW7bHHHhvd/4477jj33HObvr7pppuOPPLIW2655YILLnj44YdbaeXbDrluGwCgRl188cW33HLLE0888aMf/einP/3p373/N77xjYsuuqjp67POOmvu3Ll9+/ZNkmTBggXDhg27/fbb43c5f1y3DQBQo5544ommi9Y++clPXnDBBUmS7Lnnnq+88kqPHj2WLl265557bnjn3/72tw0NDU153SRN0y9/+cs33XTTYYcdNnfu3AEDBowYMSKL59GueW8bAKBG9e3b99e//nWSJA899NCHPvShJEmGDh3a9AuRt95669ChQ5MkWb58edOdr7nmmuY3tpvceOONJ598cvfu3VeuXJmm6YoVKzJ6Hu2a97YBAGrU97///bFjx/75czMKhWnTpiVJ8i//8i//9E//9NOf/nT33Xf/4Q9/2PS296xZs55//vklS5YMHDiwebaxsfEnP/nJPffckyTJuHHjhgwZslGL00RtAwDUqP79+8+ePXvDW+rr6yuVyoa3zJo1K0mSPn36NH0gd7OGhoZ777236esv/kWb7HL+uJIEAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiFNI0TWpJqVTKeheAnCmXy5ls13oF5GW9Ygs6JrWn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kiRr1qz5+c9//slPfnLXXXc966yzWvKYDQ0NaZpu4Q5OYWBT3tuGbXPDDTd07tx50aJFSZK89tpru+yyy/Tp019//fVCoXDDDTf07Nmzvr5+9OjRzX/oLl26dMSIEV27du3Vq9f48eObb1+8eHGpVOrWrdsee+zxuc99btWqVYMGDXruuedGjRrV9Mfq5gafeuqpY489tkuXLgMGDFi4cOGme/jCCy/cf//9U6ZMqa+vP/zww4877rjf/OY3bXiEoH3p1KnTSSedNHjw4HK5/MorrxQKhcsuu6y+vn7kyJHbeqJt+N62UxjYSmobts3o0aOPOeaYq6++OkmSK6+88vDDDx81alTTt6655pp777133rx5jzzyyJgxY5puHD58eLdu3V588cXZs2c//PDD48aNS5Jk3bp1J554Yl1d3QsvvPDQQw898cQTl19++QMPPNC3b9/p06dPmzZtc4Pvvffe0KFD+/fvv2TJkssuu2z69Omb7uH++++/fv367t27r1279v/9RalUatuDBO3O2rVru3bt2vT1s88++/LLL19xxRVVn2hOYWAbpMD72WeffTY6WXbYYYemb82fP7+hoeHaa6+tr6+fP39+mqavvfZakiTlcrnpDrNmzaqrq1u+fPns2bN32mmnVatWNd3+8MMPd+jQYeXKlbNnz66rq3vjjTc22mjTH9Vpmm5usFKp1NfXr1ixoun2884778gjj9zcU+jbt2/nzp0HDRr02muvBRwhaL+6d+9+3XXXNX3d2Ng4ffr0Dh063H333UuXLk2S5J577mn61raeaG+99VaSJM8884xTGNh63tuGzfrmN7+54dmydu3aptv79OkzYcKE8ePHX3TRRX369Gm+f/NvOx1yyCGrV69+4YUXnn766RUrVnTu3Lnpt7U+9rGPrV+/fsGCBU899VTPnj132223zW16c4NPP/30/vvv36VLl6a7HXrooVvY/2efffaNN97YaaedTjrppFY6JJAbF1xwQdPps+eee06ZMuW73/3usGHDmr617777tvBEcwoDW09tQzWefPLJJEkeffTRDW/s1KlT0xfr1q378+8gd+y4du3aPn36bPTfuB/5yEc6depUKBS28PibG9zobs1b3Jydd9554sSJv/3tb5csWVLtc4Vcan5v+7333nvyySebfmOySefOnVt4ojmFga2ntmGb/exn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JZc88MAD48aN+8pXvrKFe37rW9/6zW9+c+211yZJMm3atOHDhzc0NGT6bGgX/O02AAB/dcstt/zwhz9MkmTYsGHz589PkuQPf/jDoEGDkiQZNGjQ5z73uS3cs1OnTv/1X/9VV1f35ptv3nHHHXfffXemT4X2wnvbAAB/9cc//vHOO+8cNGjQpz/96U996lNJkhx88MF33nln018Cv+GVJJve88orrzzzzDOvuuqqiRMnfvWrXy0UCpk+FdoLtQ0A8FerV6/+4Ac/+MADD5x55pmjR49uuibkpptuOu6441566aW6urot3POss86aO3du3759kyRZsGDBsGHDbr/99kyfDe2CK0kAAP5qzz33LBaLSZIUi8Xzzz8/SZIf//jHt912W11d3fz588vl8hbumSRJmqZf/vKXb7rppsMOO2zu3LkDBgwYMWJEds+GdsF72wAAf3X88cfPmTMnSZI5c+b0798/SZLf//7399xzT5IkM2bMOP3005MkWb58+fveM0mSG2+88eSTT+7evfvKlSvTNF2xYkXWT4jseW8bAOCvrrjiitGjR19xxRUdO3a8/vrrkyS55pprRo4c+fWvf/3www//P//n/yRJ8slPfnLWrFmb3rOxsfEnP/lJU5qPGzduyJAhF110UdZPiOypbQCAv/rABz5w1113bXhLnz59HnzwwQ1vmTVr1vves6Gh4d577236+ot/0Sa7THvnShIAAIiitgEAIIraBgCAKIU0TcMenOyVSqWsdwFyb8PP/GpLzl/I7/kLzfyW5PavUqlUN1gsFlsyu2BiY3WzvSc1tGR2xpyx1c2OHDjVbNvMtuTnm8nrOUO1dv5m9XzNbv1s7n6+kDlXkgAAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUQppmoY9ONkrlUpZ7wLkXrlczmS7zl/I7/kLzTr+7Uu2U5VKpbrBYrHYktkFExurm+09qWHGnLHVzY4cONVs+59tyWsjk9dzhvJ4/ma1z1nNtuRcyOPzzd1rAzLnShIAAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIEohTdOwByd7pVIp612A3CuXy5ls1/kL+T1/oVnHv33JdqpSqVQ3WCwWWzK7YGJjdbO9JzXMmDO2utmRA6fmcbYlx6rWZjN5PWcoj+dvVvvcknMwq2NVa7O1dv5CE1eSAABAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABRCmmahj042SuVSlnvAuReuVzOZLvOX8jv+QvNOv7tS7ZTlUqlusFisdiS2QUTG6ub7T2pYcacsdXNjhw4NY+zLTlWWf18a2o2Q3k8f3P383Wstu9ZyJwrSQAAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKIU0TcMenOyVSqWsdwFyr1wuZ7Jd5y/k9/yFZh3/9iXbqUqlUt1gsVhsyeyCiY3Vzfae1GB262ez+vnW1GyGnL/b92zuzoU8zkLmXEkCAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAEQppGka9uBkr1QqZb0LkHvlcjmT7Tp/Ib/nL/xNynatWCwm1TJr1mwT569Zs/mdzer8hWauJAEAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAohTSNA17cLJXKpWy3gXIvXK5nMl2nb+Q3/MX/iZlu1YsFpNqmTVrtonz16zZ/M5mdf5CM1eSAABAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABRCmmahj04AADUNO9tAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAACRB/n+15RY5M4KyIgAAAABJRU5ErkJggg=="
            },
            {
              "type": "input_text",
              "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
            }
          ],
          "solved_count": 0,
          "total_training_examples": 3,
          "pixel_accuracy": 0.8232373386295928
        },
        "test_result": {
          "correct": false,
          "pixel_accuracy": 0.7596153846153846,
          "total_pixels": 624,
          "correct_pixels": 474,
          "error": null
        },
        "status": "failed_test",
        "feedback_sent": true
      },
      {
        "turn_number": 8,
        "timestamp": "2025-07-10T13:45:22.977190",
        "input_tokens": 73654,
        "output_tokens": 1529,
        "turn_cost": 0.031908,
        "program_extracted": true,
        "program": "def transform(grid):\n    import numpy as np\n    from collections import deque, Counter\n\n    grid = np.array(grid)\n    h, w = grid.shape\n    output = grid.copy()\n\n    def neighbors4(r, c):\n        for nr, nc in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\n            if 0 <= nr < h and 0 <= nc < w:\n                yield nr, nc\n\n    def neighbors8(r, c):\n        for dr in [-1,0,1]:\n            for dc in [-1,0,1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r+dr, c+dc\n                if 0 <= nr < h and 0 <= nc < w:\n                    yield nr, nc\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    # Find connected outline components using 4-connectivity\n    def bfs_component(sr, sc):\n        q = deque([(sr, sc)])\n        comp = []\n        visited[sr, sc] = True\n        while q:\n            r, c = q.popleft()\n            comp.append((r, c))\n            for nr, nc in neighbors4(r, c):\n                if not visited[nr, nc] and grid[nr, nc] != 0:\n                    visited[nr, nc] = True\n                    q.append((nr, nc))\n        return comp\n\n    # Identify outline pixels of the component\n    def find_outline_pixels(component):\n        comp_set = set(component)\n        outline = set()\n        for r, c in component:\n            for nr, nc in neighbors8(r, c):\n                if (nr, nc) not in comp_set:\n                    outline.add((r, c))\n                    break\n        return outline\n\n    components = []\n    for r in range(h):\n        for c in range(w):\n            if grid[r, c] != 0 and not visited[r, c]:\n                comp = bfs_component(r, c)\n                components.append(comp)\n\n    for comp in components:\n        comp_set = set(comp)\n        outline_set = find_outline_pixels(comp)\n\n        # Majority outline color\n        outline_colors = [grid[r, c] for r, c in comp]\n        outline_color = Counter(outline_colors).most_common(1)[0][0]\n\n        rows = [r for r, _ in comp]\n        cols = [c for _, c in comp]\n        rmin, rmax = max(min(rows), 0), min(max(rows), h - 1)\n        cmin, cmax = max(min(cols), 0), min(max(cols), w - 1)\n\n        box_h = rmax - rmin + 1\n        box_w = cmax - cmin + 1\n\n        mask = np.zeros((box_h, box_w), dtype=np.int8)\n\n        for r, c in comp_set:\n            rr, cc = r - rmin, c - cmin\n            if (r, c) in outline_set:\n                mask[rr, cc] = 1  # outline\n            else:\n                mask[rr, cc] = 2  # candidate interior\n\n        # Flood fill exterior (mask==0) from box edges using 8-connectivity\n        visited_box = np.zeros_like(mask, dtype=bool)\n        q = deque()\n        for rr in range(box_h):\n            for cc in [0, box_w - 1]:\n                if mask[rr, cc] == 0 and not visited_box[rr, cc]:\n                    q.append((rr, cc))\n                    visited_box[rr, cc] = True\n        for cc in range(box_w):\n            for rr in [0, box_h - 1]:\n                if mask[rr, cc] == 0 and not visited_box[rr, cc]:\n                    q.append((rr, cc))\n                    visited_box[rr, cc] = True\n\n        while q:\n            rr, cc = q.popleft()\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    nr, nc = rr + dr, cc + dc\n                    if dr == 0 and dc == 0:\n                        continue\n                    if 0 <= nr < box_h and 0 <= nc < box_w:\n                        if not visited_box[nr, nc] and mask[nr, nc] == 0:\n                            visited_box[nr, nc] = True\n                            q.append((nr, nc))\n\n        # Interior pixels: mask==2 and not reachable from outside\n        interior_pixels = []\n        for rr in range(box_h):\n            for cc in range(box_w):\n                if mask[rr, cc] == 2 and not visited_box[rr, cc]:\n                    interior_pixels.append((rr + rmin, cc + cmin))\n\n        if not interior_pixels:\n            continue\n\n        # Find connected interior regions (4-connectivity) and fill each\n        interior_pixel_set = set(interior_pixels)\n        interior_visited = set()\n        def bfs_interior(sr, sc):\n            q = deque([(sr, sc)])\n            group = []\n            interior_visited.add((sr, sc))\n            while q:\n                r, c = q.popleft()\n                group.append((r, c))\n                for nr, nc in neighbors4(r, c):\n                    if (nr, nc) in interior_pixel_set and (nr, nc) not in interior_visited:\n                        interior_visited.add((nr, nc))\n                        q.append((nr, nc))\n            return group\n\n        groups = []\n        for pix in interior_pixels:\n            if pix not in interior_visited:\n                groups.append(bfs_interior(*pix))\n\n        # For each group, determine fill color and fill\n        for group in groups:\n            non_outline_colors = [grid[r, c] for r, c in group if grid[r, c] != 0 and grid[r, c] != outline_color]\n            if non_outline_colors:\n                fill_color = Counter(non_outline_colors).most_common(1)[0][0]\n            else:\n                alt_colors = [grid[r, c] for r, c in group if grid[r, c] != 0]\n                if alt_colors:\n                    fill_color = Counter(alt_colors).most_common(1)[0][0]\n                else:\n                    fill_color = outline_color\n            for r, c in group:\n                output[r, c] = fill_color\n\n    return output.tolist()",
        "training_feedback": {
          "feedback_messages": [
            {
              "type": "input_text",
              "text": "Training results: 0/3 examples solved, 82.3% pixel accuracy - Good partial progress! Your approach is capturing some patterns. Next, try to identify a transformation that solves at least one of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 1, 1, 1, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 5, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 0, 8, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 8, 0, 0, 8, 2, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 3, 0, 8, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 1, 1, 1, 0, 0, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 5, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 5, 0, 5, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 90.0%\n\nTraining Example 2 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 6, 6, 6, 0, 0], [0, 0, 2, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 2, 2, 2, 3, 3, 3, 3, 3, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 6, 6, 6, 6, 6], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 3, 0, 2, 0, 0, 6, 6, 6, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 6, 0, 3, 0, 0], [0, 0, 2, 2, 2, 0, 3, 0, 0, 0, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 6, 6, 6, 6, 6], [0, 0, 0, 0, 2, 0, 0, 0, 8, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 8, 0], [3, 0, 0, 0, 0, 0, 0, 4, 8, 0, 3, 0, 8, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 8, 0, 4, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 80.7%\n\nTraining Example 3 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 3, 3, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 3, 3, 6, 6, 6, 6, 6, 6, 3, 3, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 3, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0], [0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 3, 0, 0, 0, 8, 0, 0, 8, 0, 3, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 0, 3, 0, 6, 0, 0, 2, 0, 0, 3, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 3, 0, 0, 0, 0, 6, 0, 0, 0, 3, 0, 0], [0, 0, 3, 0, 0, 6, 0, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 69.6%\n\n"
            },
            {
              "type": "input_image",
              "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA88AAAUtCAIAAABNteEnAABUgklEQVR4nO3de5xVdb34/7URBlFwRtFUBEsk0R58RdO8kHJQ+D5S8LJ3YB1NPXBQ035IgaLZ4WT5xTQhO9HF/IZCpqQnT3t7OWbkN4UsKVPyrqGgIaDH26AIcl2/R01n4oAQ7Jn3rFns5/PhH+Oe/d5r7TV7fXi5XbMppGmaAAAAATpEPCgAAKC2AQAgkNoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAaJe1PWbMmMLmnXnmme97n7q6ur322uuUU0559NFHN33MX/ziF4VCYbfddnvvvfc2+tbtt99eKBSmTZvW9K8jR44sFAqTJ0/e6G4vv/xyoVCYOHFiS6aavPfee9dff/1xxx3Xo0ePzp079+jR47TTTvvVr361hWMyceLEzR2QJ598cssHbciQIX/3wDbf55xzztnw9qbdGz58+EMPPbTh/hSLxY3utt9++40dO/att97apoPf5PXXX580adKhhx5aX1+/8847H3HEEdOmTUvTdKPNbTT+yCOP7LHHHt26dbv//vu3cOgAALY/Gby3vWbNmldfffWuu+467rjjFixYsNF3b7zxxiRJ3nrrrdtuu21rHu3LX/7ys88+u637sDVTL7744tFHH33++ec/8MADS5cuXb169dKlS2+//faBAwdee+21STvTtHs//elPjznmmFtuuWULd3vxxRe//e1vn3DCCevXr9+mg//QQw/179//X//1X//whz+8/fbbK1asePjhh88999zRo0dvYcd++ctfHnfccevWrbvvvvuOO+64FjxFAIAaq+3vfOc76X/7yU9+kiTJ9OnTm2+5+eabm++5cOHC5tvfe++9Z5555owzznj77bevu+66DR+wsbGxUqmcdtppu+222/e///2t2YfVq1ePHDly3bp127Tnf3dqzZo1I0aM+MMf/jBgwIA777zz9ddfX7NmzZ/+9Kfvfe97u+222yWXXNL0RvXmzJs3L91Ev3793veANLvvvvs2fJCtuc/SpUubbl+5cuXzzz//xS9+MU3Tf/7nf37ppZc2vNvKlSs3PPhDhgz53e9+94tf/GLrD/5//dd/lUqlJUuWnH766XPnzn377bfffPPNSqXSu3fv6dOnX3/99e97HMrl8tChQ3faaacHHnjgyCOP3MIRAwDYLmXw3nbnzp0PPPDAr3/960mSbPTe9syZM997773Pfvazo0aNmjt37uOPP/53H+3CCy/87W9/+41vfGOb9uHvTv3whz985JFHhgwZMmfOnJNPPrl79+4dO3bs1avXBRdc8NOf/nTdunU//vGPk/Zkxx133H///a+66qovf/nLq1ev/rd/+7ctHPwvfOELTaW+9Qf/2muvffXVV8eNGzdz5swjjzyyW7duu+6666mnnjp79uydd9752muv3fB6kiY33HDDaaed9oEPfOBXv/rVwQcf3Hz7jBkzCoXCd77znVY9AAAA7VEGtb1q1aqnnnpq/PjxSZIccMABG35r+vTpBx100PHHH3/BBRfssMMOW/P29te+9rU+ffp8+ctffuaZZ7Z+H/7u1MyZMwuFwv/9v/93hx122Ohb//AP//D0009PmjQpaZcuuuiinXba6ec///n7fnfNmjV//OMfp06d2rFjx3/4h3/Y+oP/7//+7126dLniiis2esCePXs++OCDDzzwQKFQ2PD2a6655pxzzundu/eDDz744Q9/uPWeHwBAnrRRbe+3337Nv6i344479uvX7yc/+cnuu+/++c9/vvk+Tz755O9///sJEyYUCoX999//tNNOu+WWW5YvX77lR95pp52mT5++Zs2abbqe5O9OzZs376CDDtpvv/3ed/yggw7aKC43cuihh270240PPvjg5g5IswceeGBb77Opbt26ffjDH97ofxp06dKlabyurq5v376//vWvf/jDH2747LZ88NesWfPiiy8eccQRXbt23XSLhxxyyN57773hLZdccsmll16aJMmxxx677777bnT/kSNHpmk6ZsyYLT8RAIDtQDafALjPPvv88z//82OPPbbXXns133jjjTfus88+n/nMZ5r+9bLLLnvnnXe25oKNY445ZuzYsb/73e+mTJmy9fuwhak1a9Y0NjbuueeeG9640eeEfOhDH0raq+7du6/6i83dYd26dXPnzl2zZs1WHvzGxsY0Tbt3776VO/Dtb3/76KOPHjJkyI033vjTn/60Zc8GACDH2qi2m37hb/Xq1bfeemvTm69XX311jx49mu+wZs2am2++efHixZ07d27K2f79+6dpupW/K/m1r33twx/+8OWXX/70009v/V5tbqpTp07dunV77bXXkmpt+luSxxxzzN/9DchBgwZt633e11tvvdWpU6fOnTtv+luSq1evXrBgwf/3//1/3/72ty+++OKtPPi77bZbhw4dtv6AjBo16oEHHrjpppt22223c889d/HixVs5CACwnWnT97Y7der06U9/+rbbbps9e/YJJ5yw4acy33333e8bc48++ujDDz/8dx+5S5cuVVxPsoWp//W//tfTTz/9pz/96X0/gOWwww5L2qvly5c/+eSTBx100Pt+t1OnTvvtt9+UKVP69es3Y8aMrTz4O+yww0EHHfT73/9+xYoVm97tqquuOvvss5csWdJ8y/e+9726urq99977O9/5zptvvnn22Wdv+mmDAAC1IIMrSU488cQLL7zw0UcfbX5vtelKhh133HHZsmUbvo/7m9/8JkmSzX263EY+/vGPf/7zn3/44Yc3/Ztrqpj6zGc+s379+s997nPv2+6bfv5G+/HNb35zzZo1J5xwwpbv1qFDh+XLl69du3YrD36xWFy5cuVXvvKVjR7nxRdfvOaaa+6+++73vc7k9NNPHzFixC9/+cttusgHAGC7kc1121/72tf23Xff66677re//W2SJK+88sq999578skn77LLLhve7eijj+7bt++Pf/zjZcuWbc3DXnnllR/+8Ie/973vbdPOvO/UOeecc9hhh/3nf/7nEUcc8e///u+vvPLKmjVrmv52m2HDhj366KMdOrSvv/R+1apVzz333MSJE7/61a/utNNOm/sdxDRNX3755QkTJjz++OOHHnpox44dt/Lgjxs3rnv37pMnTz777LN///vfr1y58tVXX505c+agQYMaGxsnTJiw4YUrG7ruuuv23HPPiRMnPvLIIzFPHQCg/comGXfeeedvf/vb69ev/+xnP7t27dqbbrpp7dq1zb+it6F/+qd/WrFixY9+9KOtvzJky58WspVTdXV1lUrl6KOPfvTRRz/96U/vvffedXV1TX9z+z333NO3b9+t/KsuN+d9P2+kUChs+BksW3Ofvffeu/mTXg488MArr7yy6a+p79Wr10bPseluHTp06NWr15QpUzp06ND0IYZbefC7d+9+2223devW7Uc/+tHHPvaxnXbaaa+99vrMZz7z0ksvlUqlSy65ZHPPdPfdd//BD36wZs2aM84449133/V52wBATcnsDdpTTjmlWCw+9thj//Zv/zZjxoxdd931xBNP3PRuZ599docOHbbyYpKmK0Oa/uqWbfK+Uz179vzVr3518803Dx06tGfPnnV1dXvuuefQoUN/+MMfPvnkkx/72MeS9qRTp069evX6x3/8x1//+tenn3765u62ww47fOADHxg2bNgvfvGLpqtNtv7gDx48eN68eWPHjj3wwAO7du3apUuXI488ctq0af/xH/+x6aeSb+jkk08eOXLkH//4xw0/8BEAoBYU2vMlyAAAkGvt6+JjAADYnqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqmxx74403nn322az3AmC7ZZmFllPbtI6ePXsWNnHzzTeHbnTIkCFz587d+vtPmTLlqKOO2tx3Gxsbe/fuvU0PCNA2dt999+alta6u7qCDDpo6dWrVj9a8GDY2NhYKhS30tGUWWk5t02q++c1vpv/TmWeeGbrFlStXttZDLVq0aMiQIQsXLmytBwRoXdddd13T0vruu+9Onjz54osv/tGPftTCx2xoaEjT9MADD9zcHSyz0HJqm1g33HBD586dFy1alCTJa6+9tssuu0yfPv31118vFAo33HBDz5496+vrR48e3bygL126dMSIEV27du3Vq9f48eObb1+8eHGpVOrWrdsee+zxuc99btWqVYMGDXruuedGjRp1zjnnbGHwqaeeOvbYY7t06TJgwIDNrfL/+Z//2a9fv8MOO6ytjgpA9Tp16nTSSScNHjy4XC6/8sorhULhsssuq6+vHzly5LYuhhu+t22ZhSBqm1ijR48+5phjrr766iRJrrzyysMPP3zUqFFN37rmmmvuvffeefPmPfLII2PGjGm6cfjw4d26dXvxxRdnz5798MMPjxs3LkmSdevWnXjiiXV1dS+88MJDDz30xBNPXH755Q888EDfvn2nT58+bdq0zQ2+9957Q4cO7d+//5IlSy677LLp06e/70527tz5vvvu++53v9uGBwagRdauXdu1a9emr5999tmXX375iiuuqHoxtMxCoI3+1z9UZ5999tnopbXDDjs0fWv+/PkNDQ3XXnttfX39/Pnz0zR97bXXkiQpl8tNd5g1a1ZdXd3y5ctnz5690047rVq1qun2hx9+uEOHDitXrpw9e3ZdXd0bb7yx0Uab/hhI03Rzg5VKpb6+fsWKFU23n3feeUceeeTmnsKaNWuSJHnooYcCDg9Ai3Tv3r35SpLGxsbp06d36NDh7rvvXrp0aZIk99xzT9O3tnUxfOutt5IkeeaZZyyzEMd720Rdt7127dqm2/v06TNhwoTx48dfdNFFffr0ab5/82/SHHLIIatXr37hhReefvrpFStWdO7cuek3gT72sY+tX79+wYIFTz31VM+ePXfbbbfNbXpzg08//fT+++/fpUuXprsdeuihwccAIMoFF1zQtMTtueeeU6ZM+e53vzts2LCmb+27774tXAwtsxBHbdMWnnzyySRJHn300Q1v7NSpU9MX69atS5KkY8eOa9eu7dOnz0b/RfiRj3ykU6dOhUJhC4+/ucGN7ta8RYDcaX5v+7333nvyySfPP//85m917ty5hYuhZRbiqG3C/exnP7vtttsmT558xx13VCqV5tsff/zxpi/mzZvXtWvX/fff/8ADD1y4cOHLL7+80SMccMABixYtavo/nhtq/rNhc4P9+vWbP3/+u+++2/SvTzzxRGs/OYB2pOrF0DILcdQ2sZYvX37++eePHTv24osvPvfcc8eMGfPOO+80feuSSy5ZuHDh/PnzL7300vPOO69z587HH3/8wQcfPGrUqEWLFi1evPgLX/jCvvvuu2rVqmOPPbZfv34XXnjh66+//uKLLw4fPvz0009PkmTnnXdesmTJO++8s7nBT3ziE3vvvffnP//5N99887777rvxxhuzPh4AgapeDC2zEEdt02rGjRu30d9uc/7553/pS1/q0KHDpEmTkiSZPHlyhw4dvvSlLzXdf8iQIccdd9yRRx75v//3/2760JIOHTpUKpWdd975oIMO+shHPvLcc8/NmjWr6TLB//iP/3jzzTd79ep1+OGH77LLLtdff32SJOeff/5VV101atSozQ3W1dX97Gc/e/HFF/fZZ59x48ade+65WR8kgEBVL4aWWYhTSNO06uFSqdSqO0OtWL169T333DN48OBu3bplvS/w95XL5Uy2a40FakE5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5/r16zdr1qwePXosXrz4hBNOeOKJJ5ruuent++677y9/+cvBgwfPmzfvrLPOuvvuuwuFQhKsYwvnK5VKdYPFYjGXs32+XuXs85dmNXvGGWdUNztz5sysZlt0rPL4ujLbvmczlLtjVYNrbFbHqv/kKv8j8LEJpTw+X7Pb8ey2Ovjgg++8885SqVQul5uuJHn11Vf32muvJEn23nvvpluabHr7lVdeeeaZZ1511VUTJ0786le/2gap7UoSAADyZNq0aTfddNNxxx330ksv1dXVbdPsWWedNXfu3L59+yZJsmDBgmHDht1+++1JO39vGwAA2syPf/zj2267ra6ubv78+U1Xoey5556vvPJKjx49li5duueeezbf831vT9P0y1/+8k033XTYYYfNnTt3wIABI0aMCN1h720DAJAbv//97++5554kSWbMmHH66acnSTJ06NBbb701SZJbb7116NChSZIsX778fW9PkuTGG288+eSTu3fvvnLlyjRNV6xYEb3DahsAgNy45pprpkyZcvTRR7/99tsXXHBBkiT/8i//MmfOnGOOOeZXv/rVl770pSRJPvnJT77v7Y2NjT/5yU/OO++8JEnGjRs3ZMiQiy66KHqHXUkCAEBu9OnT58EHH9zwlvr6+o1+R3PWrFnve3tDQ8O9997b9PUX/6INdth72wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEKWQpmnVw6VSqVV3BqA9KpfLmWzXGgvUgnJGa2yb6djC+UqlUt1gsVjM5Wyfr1c5+/ylZ5xxRnWzM2fOrLXZlhznXL6uzLbv2Qzl7lhluMZmtc8tWuscZ7Nma4ArSQAAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKIU0TaseLpVKrbozAO1RuVzOZLvWWKAWZLXGtpmOLZyvVCrVDRaLxVzO9vl6lbPPX3rGGWdUNztz5sxam23Jcc7l68ps+57NUO6OVYZrbC6fr+Ns1mwNcCUJAABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsA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hQsXbrqHDz/88IIFC6699tpdd921T58+l19++R133JGmaRseJCAznTp1OumkkwYPHlwul1955ZVCoXDZZZfV19ePHDlyWxeWDd/btmRB7qht8mr06NHHHHPM1VdfnSTJlVdeefjhh48aNarpW9dcc8299947b968Rx55ZMyYMU03Dh8+vFu3bi+++OLs2bMffvjhcePGJUmybt26E088sa6u7oUXXnjooYeeeOKJyy+//IEHHujbt+/06dOnTZu2ucH33ntv6NCh/fv3X7JkyWWXXTZ9+vRN93DAgAFr1qypq6tr+telS5futttuhUKhDQ8SkLG1a9d27dq16etnn3325ZdfvuKKK6peWCxZkEsb/Q96aG/22WefjV60O+ywQ9O35s+f39DQcO2119bX18+fPz9N09deey1JknK53HSHWbNm1dXVLV++fPbs2TvttNOqVauabn/44Yc7dOiwcuXK2bNn19XVvfHGGxtttOmPrjRNNzdYqVTq6+tXrFjRdPt555135JFHbuFZNDY27rfffpdffnlrHx6gHenevXvzlSSNjY3Tp0/v0KHD3XffvXTp0iRJ7rnnnqZvbevC8tZbbyVJ8swzz1iyII+8t03+rtteu3Zt0+19+vSZMGHC+PHjL7rooj59+jTfv/m3fw455JDVq1e/8MILTz/99IoVKzp37tz020sf+9jH1q9fv2DBgqeeeqpnz5677bbb5ja9ucGnn356//3379KlS9PdDj300C3s/7vvvnvyySf369dv4sSJrXRIgHbqggsuaFou9txzzylTpnz3u98dNmxY07f23XffFi4slizII7VNvj355JNJkjz66KMb3tipU6emL9atW5ckSceOHdeuXdunT5+N/lvzIx/5SKdOnbb8/0k3N7jR3Zq3uKk33nhj8ODBPXv2vP322zt27Niypwu0d83vbb/33ntPPvnkhr9o2Llz5xYuLJYsyCO1TY797Gc/u+222yZPnnzHHXdUKpXm2x9//PGmL+bNm9e1a9f999//wAMPXLhw4csvv7zRIxxwwAGLFi1q+r+0G2r+82xzg/369Zs/f/67777b9K9PPPHE++7hyy+/fMwxxwwcOPCWW25pvhoSqHFVLyyWLMgjtU1eLV++/Pzzzx87duzFF1987rnnjhkz5p133mn61iWXXLJw4cL58+dfeuml5513XufO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ABBFbQMAQBS1DQBQo/7f//t/AwYMOO6444499tiHHnooSZJly5YVi8VjjjmmWCwuW7as+Z7/+I//OOgvBgwYsPvuuydJcvXVV/fr12/y5MlJkqxfv37YsGGNjY2ZPpt2qmPWOwAAQDZGjx59//3377fffi+88MLJJ5/89NNPX3nllQMHDhw/fvw3vvGNq6666uqrr26656233tr0xbRp0/70pz8lSfKtb33rueee69u374QJE6ZNmzZ8+PCGhoZMn007VUjTNKklpVIp610AcqZcLmeyXesVEL1eHXbYYddff/3hhx/+u9/97rTTTnvppZf69es3a9asHj16LF68+IQTTnjiiSc2vH+aph/96Ed//vOff+ADH9h3331/+ctfDh48eN68eWedddbdd99dKBRa+wltF9IaUywWqz5WZs0GzabPJ9X9k9PZrI5z1bM1uF5dPj+t7p88/nzNbtNsHtcc69UW/O53v+vcuXO/fv06d+581113pWm6++67r1u3Lk3TdevW7bHHHhvd/4477jj33HObvr7pppuOPPLIW2655YILLnj44YdbaeXbDrluGwCgRl188cW33HLLE0888aMf/einP/3p373/N77xjYsuuqjp67POOmvu3Ll9+/ZNkmTBggXDhg27/fbb43c5f1y3DQBQo5544ommi9Y++clPXnDBBUmS7Lnnnq+88kqPHj2WLl265557bnjn3/72tw0NDU153SRN0y9/+cs33XTTYYcdNnfu3AEDBowYMSKL59GueW8bAKBG9e3b99e//nWSJA899NCHPvShJEmGDh3a9AuRt95669ChQ5MkWb58edOdr7nmmuY3tpvceOONJ598cvfu3VeuXJmm6YoVKzJ6Hu2a97YBAGrU97///bFjx/75czMKhWnTpiVJ8i//8i//9E//9NOf/nT33Xf/4Q9/2PS296xZs55//vklS5YMHDiwebaxsfEnP/nJPffckyTJuHHjhgwZslGL00RtAwDUqP79+8+ePXvDW+rr6yuVyoa3zJo1K0mSPn36NH0gd7OGhoZ777236esv/kWb7HL+uJIEAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiFNI0TWpJqVTKeheAnCmXy5ls13oF5GW9Ygs6JrWn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kiRr1qz5+c9//slPfnLXXXc966yzWvKYDQ0NaZpu4Q5OYWBT3tuGbXPDDTd07tx50aJFSZK89tpru+yyy/Tp019//fVCoXDDDTf07Nmzvr5+9OjRzX/oLl26dMSIEV27du3Vq9f48eObb1+8eHGpVOrWrdsee+zxuc99btWqVYMGDXruuedGjRrV9Mfq5gafeuqpY489tkuXLgMGDFi4cOGme/jCCy/cf//9U6ZMqa+vP/zww4877rjf/OY3bXiEoH3p1KnTSSedNHjw4HK5/MorrxQKhcsuu6y+vn7kyJHbeqJt+N62UxjYSmobts3o0aOPOeaYq6++OkmSK6+88vDDDx81alTTt6655pp777133rx5jzzyyJgxY5puHD58eLdu3V588cXZs2c//PDD48aNS5Jk3bp1J554Yl1d3QsvvPDQQw898cQTl19++QMPPNC3b9/p06dPmzZtc4Pvvffe0KFD+/fvv2TJkssuu2z69Omb7uH++++/fv367t27r1279v/9RalUatuDBO3O2rVru3bt2vT1s88++/LLL19xxRVVn2hOYWAbpMD72WeffTY6WXbYYYemb82fP7+hoeHaa6+tr6+fP39+mqavvfZakiTlcrnpDrNmzaqrq1u+fPns2bN32mmnVatWNd3+8MMPd+jQYeXKlbNnz66rq3vjjTc22mjTH9Vpmm5usFKp1NfXr1ixoun2884778gjj9zcU+jbt2/nzp0HDRr02muvBRwhaL+6d+9+3XXXNX3d2Ng4ffr0Dh063H333UuXLk2S5J577mn61raeaG+99VaSJM8884xTGNh63tuGzfrmN7+54dmydu3aptv79OkzYcKE8ePHX3TRRX369Gm+f/NvOx1yyCGrV69+4YUXnn766RUrVnTu3Lnpt7U+9rGPrV+/fsGCBU899VTPnj132223zW16c4NPP/30/vvv36VLl6a7HXrooVvY/2efffaNN97YaaedTjrppFY6JJAbF1xwQdPps+eee06ZMuW73/3usGHDmr617777tvBEcwoDW09tQzWefPLJJEkeffTRDW/s1KlT0xfr1q378+8gd+y4du3aPn36bPTfuB/5yEc6depUKBS28PibG9zobs1b3Jydd9554sSJv/3tb5csWVLtc4Vcan5v+7333nvyySebfmOySefOnVt4ojmFga2ntmGb/exn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JZc88MAD48aN+8pXvrKFe37rW9/6zW9+c+211yZJMm3atOHDhzc0NGT6bGgX/O02AAB/dcstt/zwhz9MkmTYsGHz589PkuQPf/jDoEGDkiQZNGjQ5z73uS3cs1OnTv/1X/9VV1f35ptv3nHHHXfffXemT4X2wnvbAAB/9cc//vHOO+8cNGjQpz/96U996lNJkhx88MF33nln018Cv+GVJJve88orrzzzzDOvuuqqiRMnfvWrXy0UCpk+FdoLtQ0A8FerV6/+4Ac/+MADD5x55pmjR49uuibkpptuOu6441566aW6urot3POss86aO3du3759kyRZsGDBsGHDbr/99kyfDe2CK0kAAP5qzz33LBaLSZIUi8Xzzz8/SZIf//jHt912W11d3fz588vl8hbumSRJmqZf/vKXb7rppsMOO2zu3LkDBgwYMWJEds+GdsF72wAAf3X88cfPmTMnSZI5c+b0798/SZLf//7399xzT5IkM2bMOP3005MkWb58+fveM0mSG2+88eSTT+7evfvKlSvTNF2xYkXWT4jseW8bAOCvrrjiitGjR19xxRUdO3a8/vrrkyS55pprRo4c+fWvf/3www//P//n/yRJ8slPfnLWrFmb3rOxsfEnP/lJU5qPGzduyJAhF110UdZPiOypbQCAv/rABz5w1113bXhLnz59HnzwwQ1vmTVr1vves6Gh4d577236+ot/0Sa7THvnShIAAIiitgEAIIraBgCAKIU0TcMenOyVSqWsdwFyb8PP/GpLzl/I7/kLzfyW5PavUqlUN1gsFlsyu2BiY3WzvSc1tGR2xpyx1c2OHDjVbNvMtuTnm8nrOUO1dv5m9XzNbv1s7n6+kDlXkgAAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUQppmoY9ONkrlUpZ7wLkXrlczmS7zl/I7/kLzTr+7Uu2U5VKpbrBYrHYktkFExurm+09qWHGnLHVzY4cONVs+59tyWsjk9dzhvJ4/ma1z1nNtuRcyOPzzd1rAzLnShIAAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIEohTdOwByd7pVIp612A3CuXy5ls1/kL+T1/oVnHv33JdqpSqVQ3WCwWWzK7YGJjdbO9JzXMmDO2utmRA6fmcbYlx6rWZjN5PWcoj+dvVvvcknMwq2NVa7O1dv5CE1eSAABAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABRCmmahj042SuVSlnvAuReuVzOZLvOX8jv+QvNOv7tS7ZTlUqlusFisdiS2QUTG6ub7T2pYcacsdXNjhw4NY+zLTlWWf18a2o2Q3k8f3P383Wstu9ZyJwrSQAAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKIU0TcMenOyVSqWsdwFyr1wuZ7Jd5y/k9/yFZh3/9iXbqUqlUt1gsVhsyeyCiY3Vzfae1GB262ez+vnW1GyGnL/b92zuzoU8zkLmXEkCAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAEQppGka9uBkr1QqZb0LkHvlcjmT7Tp/Ib/nL/xNynatWCwm1TJr1mwT569Zs/mdzer8hWauJAEAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAohTSNA17cLJXKpWy3gXIvXK5nMl2nb+Q3/MX/iZlu1YsFpNqmTVrtonz16zZ/M5mdf5CM1eSAABAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABRCmmahj04AADUNO9tAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAACRB/n+15RY5M4KyIgAAAABJRU5ErkJggg=="
            },
            {
              "type": "input_text",
              "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
            }
          ],
          "solved_count": 0,
          "total_training_examples": 3,
          "pixel_accuracy": 0.8232373386295928
        },
        "test_result": {
          "correct": false,
          "pixel_accuracy": 0.7596153846153846,
          "total_pixels": 624,
          "correct_pixels": 474,
          "error": null
        },
        "status": "failed_test"
      }
    ],
    "total_turns": 8,
    "conversation_history": [
      {
        "role": "system",
        "content": "You are an expert at solving abstract reasoning puzzles. Write clean, efficient Python code."
      },
      {
        "role": "user",
        "content": [
          {
            "type": "input_text",
            "text": "You are solving an ARC (Abstraction and Reasoning Corpus) task. \nI will show you training examples with input and output grids, plus a test input grid. Your task is to:\n\n1. **Analyze the training examples** to discover patterns that map input grids to output grids\n2. **Write a Python program** that implements your best understanding of the transformation  \n3. **DO NOT predict or generate the test output** - your job is only to write the transformation program\n4. **Attempt a solution** - even if the pattern isn't completely clear, provide your best hypothesis\n5. **Do not repeat the same transformation** - if you have already tried a transformation, do not repeat it.\n\n**IMPORTANT: Your transformation must always produce a 21\u00d721 output grid.**\n\nThe test input is shown for context so you understand what type of grid your program will eventually process. Focus on learning patterns from training examples and writing code that captures your understanding.\n\nTraining Examples:\n\nExample 1:\nInput:\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 2 0 0 0 5 0 2 0 0 0 0 0 0 0 0 0\n0 0 0 2 2 2 0 8 0 0 0 2 0 0 0 0 0 0 0 0 0\n0 0 0 2 0 0 0 0 0 2 2 2 0 0 0 0 0 0 0 0 0\n0 0 0 2 0 8 0 0 8 2 0 0 0 0 3 3 3 3 0 0 0\n0 0 0 2 0 0 0 0 0 2 0 0 0 0 3 0 0 0 0 0 0\n0 0 0 2 2 2 2 2 2 2 0 0 0 0 3 0 8 0 0 3 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 3 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 3 0\n0 0 0 0 0 0 1 1 1 1 1 0 0 0 3 3 3 3 3 3 0\n0 0 0 0 1 1 1 0 0 8 1 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 1 0 0 5 0 0 1 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 1 0 5 0 5 0 1 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 1 1 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\nOutput:\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 2 8 8 8 8 8 2 0 0 0 0 0 0 0 0 0\n0 0 0 2 2 2 8 8 8 8 8 2 0 0 0 0 0 0 0 0 0\n0 0 0 2 8 8 8 8 8 2 2 2 0 0 0 0 0 0 0 0 0\n0 0 0 2 8 8 8 8 8 2 0 0 0 0 3 3 3 3 0 0 0\n0 0 0 2 8 8 8 8 8 2 0 0 0 0 3 0 0 0 0 0 0\n0 0 0 2 2 2 2 2 2 2 0 0 0 0 3 0 0 0 0 3 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 3 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 3 0\n0 0 0 0 0 0 1 1 1 1 1 0 0 0 3 3 3 3 3 3 0\n0 0 0 0 1 1 1 5 5 5 1 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 1 5 5 5 5 5 1 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 1 5 5 5 5 5 1 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 1 5 5 5 5 5 1 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 1 5 5 5 5 5 1 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 1 1 1 1 1 5 1 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\nExample 2:\nInput:\n0 0 0 0 0 0 2 2 2 2 2 0 0 0 0 0 0 0\n0 0 2 2 2 2 2 0 0 0 2 0 0 0 0 0 0 0\n0 0 2 0 0 0 0 0 3 0 2 0 0 6 6 6 0 0\n0 0 2 0 0 0 0 0 0 0 2 0 0 6 0 3 0 0\n0 0 2 2 2 0 3 0 0 0 2 0 0 6 0 0 0 0\n0 0 0 0 2 0 0 0 0 0 2 0 0 6 6 6 6 6\n0 0 0 0 2 0 0 0 8 0 2 0 0 0 0 0 0 0\n0 0 0 0 2 0 0 0 0 0 2 0 0 0 0 0 0 0\n0 0 0 0 2 2 2 2 2 2 2 0 0 0 0 0 0 3\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 8 0 0 0 0 0 0 0 0 4 4 4 4 0 0 0\n0 0 0 0 0 0 0 4 4 4 4 4 0 0 4 0 0 0\n0 0 0 0 0 0 0 4 0 0 0 0 0 0 4 0 8 0\n3 0 0 0 0 0 0 4 8 0 3 0 8 0 4 0 0 0\n0 0 0 0 0 0 0 4 0 0 0 0 0 0 4 0 0 0\n0 0 0 0 0 0 0 4 0 0 0 0 8 0 4 0 0 0\n0 0 0 3 0 0 0 4 4 4 4 4 0 0 4 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 4 4 4 4 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\nOutput:\n0 0 0 0 0 0 2 2 2 2 2 0 0 0 0 0 0 0\n0 0 2 2 2 2 2 3 3 3 2 0 0 0 0 0 0 0\n0 0 2 3 3 3 3 3 3 3 2 0 0 6 6 6 0 0\n0 0 2 3 3 3 3 3 3 3 2 0 0 6 0 0 0 0\n0 0 2 2 2 3 3 3 3 3 2 0 0 6 0 0 0 0\n0 0 0 0 2 3 3 3 3 3 2 0 0 6 6 6 6 6\n0 0 0 0 2 3 3 3 3 3 2 0 0 0 0 0 0 0\n0 0 0 0 2 3 3 3 3 3 2 0 0 0 0 0 0 0\n0 0 0 0 2 2 2 2 2 2 2 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 4 4 4 4 0 0 0\n0 0 0 0 0 0 0 4 4 4 4 4 8 8 4 0 0 0\n0 0 0 0 0 0 0 4 8 8 8 8 8 8 4 0 0 0\n0 0 0 0 0 0 0 4 8 8 8 8 8 8 4 0 0 0\n0 0 0 0 0 0 0 4 8 8 8 8 8 8 4 0 0 0\n0 0 0 0 0 0 0 4 8 8 8 8 8 8 4 0 0 0\n0 0 0 0 0 0 0 4 4 4 4 4 8 8 4 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 4 4 4 4 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\nExample 3:\nInput:\n0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 3 3 3 3 3 3 3 3 0 0 0\n0 0 0 3 0 0 2 0 0 0 3 0 0 0\n0 3 3 3 0 0 0 0 0 0 3 0 0 0\n0 3 0 0 0 8 0 0 8 0 3 0 0 0\n0 3 0 0 0 0 0 0 0 0 3 0 0 0\n0 3 3 3 0 0 0 0 0 0 3 3 0 0\n0 0 0 3 0 6 0 0 2 0 0 3 0 0\n0 0 0 3 0 0 0 0 0 0 0 3 0 0\n0 0 3 3 0 0 0 0 0 0 0 3 0 0\n0 0 3 0 0 0 0 6 0 0 0 3 0 0\n0 0 3 0 0 6 0 3 3 3 3 3 0 0\n0 0 3 0 0 0 0 3 0 0 0 0 0 0\n0 0 3 3 3 3 3 3 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0\nOutput:\n0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 3 3 3 3 3 3 3 3 0 0 0\n0 0 0 3 6 6 6 6 6 6 3 0 0 0\n0 3 3 3 6 6 6 6 6 6 3 0 0 0\n0 3 6 6 6 6 6 6 6 6 3 0 0 0\n0 3 6 6 6 6 6 6 6 6 3 0 0 0\n0 3 3 3 6 6 6 6 6 6 3 3 0 0\n0 0 0 3 6 6 6 6 6 6 6 3 0 0\n0 0 0 3 6 6 6 6 6 6 6 3 0 0\n0 0 3 3 6 6 6 6 6 6 6 3 0 0\n0 0 3 6 6 6 6 6 6 6 6 3 0 0\n0 0 3 6 6 6 6 3 3 3 3 3 0 0\n0 0 3 6 6 6 6 3 0 0 0 0 0 0\n0 0 3 3 3 3 3 3 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\nTest Input:\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 2 2 2 2 2 2 2 0 0 0 1 0 0 3 3 3 3 3 3 0 1\n0 0 0 2 0 0 0 0 0 2 2 2 0 0 0 0 3 0 0 0 0 3 0 0\n0 0 0 2 0 6 0 0 8 0 0 2 0 0 0 0 3 0 0 6 0 3 0 0\n0 0 0 2 0 0 1 0 0 0 0 2 0 0 3 3 3 0 0 0 0 3 0 0\n0 2 2 2 0 0 0 0 0 0 1 2 0 0 3 0 0 0 0 8 0 3 0 0\n0 2 0 0 1 0 6 0 0 0 0 2 0 0 3 8 0 0 0 0 0 3 0 0\n0 2 0 0 0 0 0 2 2 2 2 2 0 0 3 0 0 0 8 0 0 3 0 0\n0 2 0 0 0 0 0 2 0 0 0 0 0 0 3 0 0 0 0 1 0 3 0 0\n0 2 2 2 2 2 2 2 0 0 0 0 0 0 3 0 0 0 0 0 0 3 0 0\n0 0 0 0 0 0 0 0 0 0 0 1 0 0 3 3 3 3 0 0 0 3 0 0\n0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 8 0 3 0 0\n0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0\n0 0 0 0 0 0 0 8 8 8 8 8 0 0 0 0 0 3 3 3 3 3 0 0\n0 0 0 0 0 0 0 8 0 0 0 8 0 0 1 0 0 0 0 0 0 0 0 0\n0 0 8 8 8 8 8 8 0 8 0 8 0 0 0 0 3 0 0 0 0 0 0 0\n0 0 8 0 0 0 0 0 0 0 0 8 0 0 0 0 0 0 0 0 0 0 0 1\n0 0 8 0 4 0 0 0 0 3 0 8 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 8 0 0 0 4 0 0 0 0 8 0 0 0 7 7 7 7 7 7 7 0 0\n0 0 8 0 3 0 0 0 0 4 0 8 0 0 0 7 0 0 0 0 0 7 0 0\n0 0 8 0 0 0 0 0 0 0 0 8 0 0 0 7 0 2 0 1 0 7 0 0\n0 0 8 0 0 8 8 8 8 0 0 8 0 0 0 7 0 0 0 0 0 7 0 0\n0 0 8 8 8 8 0 0 8 8 8 8 0 0 0 7 0 1 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 7 7 7 7 0 0 0 0\n0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 3 0 0 0\n\nAnalyze the patterns in the training examples and write a Python function that performs this transformation.\n\n**Approach Guidelines:**\n- Look for patterns in shapes, colors, positions, sizes, rotations, reflections, etc.\n- Even if you can't solve all training examples perfectly, implement what patterns you do observe\n- A partial solution that captures some aspects is better than returning the input unchanged\n- If the pattern is unclear, make your best educated guess based on what you can see\n\nRequirements:\n- The function takes a 2D list (grid) where grid[row][col] gives the value at that position\n- Values are integers from 0-9\n- Return a new grid (2D list) with the transformation applied\n- You can use numpy if needed - just add 'import numpy as np' at the start of your function\n- Aim to handle the training examples as well as possible, even if not perfectly\n- Your function should attempt some meaningful transformation based on the patterns you observe\n\nYou MUST end your response with the following exact format:\n\nFinal answer:\n```python\ndef transform(grid):\n    # Your transformation logic here (implement your best understanding)\n    return transformed_grid\n```\n"
          },
          {
            "type": "input_image",
            "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA6wAAAd2CAIAAACGs7dJAABbMklEQVR4nO3de5hcdZ3g/yookpAQukFmhAQl6cQF3GiDyFUGwQSdUcFzdlA0sGtHIjAjYlYJ2fGJuqsRCWHGFUGFjSRoDAosp55x5GHHOIvgzqgRMCgh3BLkEhS5dORiyO38npne7Se/EGPXqU6fPv15vR7/CJX69PnWqT7fvC1Omnqe5zUAAIhkj7IXAAAAQ00EAwAQjggGACAcEQwAQDgiGACAcEQwAADhiGAAAMIRwQAAhCOCAQAIRwQDABCOCAYAIBwRDABAOCIYAIBw2orgCy64oP6HnX322Tt9zqhRow488MDTTz/9rrvueuXX/P73v1+v1/fff/+NGzfu8Fs33XRTvV5fvHhx3z/29PTU6/VFixbt8LTHH3+8Xq/Pnz+/nak+GzduvPrqq0855ZQJEyaMHj16woQJ733ve++4445i52TGjBm1Wu2ZZ56ZMGHCfvvt9/jjj+8w+x/+w38YNWrUz372swGekPe///31er3RaPz2t7995UqmTZtWr9d7enr6/nH27NnbL2bPPffcd999jz322K9//ev9I0mS1Ov1Vx5ogC+tz9NPP33xxRcfdthhe++9d2dn5wknnPDVr35169atuzhpAAAj/5PgzZs3/+Y3v/nud797yimnrF27doffvfbaa2u12nPPPfed73xnIF/t05/+9Jo1a1pdw0CmHnnkkeOPP/7888+/7bbbnnzyyU2bNj355JM33XTTSSed9Hd/93e1ol71qldde+21vb29s2bNyvO8//Grrroqy7JLLrnkzW9+c0snZOvWrTfffPMOD/7iF7+49957d7GMbdu2Pf/88z/96U9nz5592WWX1QbJb3/726OPPnrRokX333//xo0bN2zY8C//8i9//dd//d73vnf7FwsAUOEIvvLKK/P/58Ybb6zVakuWLOl/ZNmyZf3PXLduXf/jGzduvO+++2bOnPm73/3uq1/96vZfsLe3t9lsvve9791///2/9rWvDWQNmzZt6unpafWDxj86tXnz5jPOOOPnP//5CSec8Pd///dPP/305s2bH3300a985Sv777//xRdf/Mtf/nIXX3/719tvxYoVfb/753/+5x/5yEdWrFhx5ZVX9j2yatWqT3ziE29/+9s/8YlPtHRC9txzz0MPPfSGG27Y4fFvf/vb//7f//tXPv/JJ5/sW8y2bdteeOGF5cuXjxkz5vOf//zLL7+8yxM20Jd2xRVXPPLII2ecccaqVatefPHF3t7ef/qnfzryyCOzLPvud787wEMAAIzAT4JHjx592GGHLVy4sFar7fBJ8PLlyzdu3HjeeefNmjXrxz/+8T333PNHv9pHP/rRn/zkJ3/7t3/b0hr+6NR111135513zpgx4/bbbz/ttNNe9apXNRqN17zmNX/1V3918803b9269frrr6+1YdGiRYcddti8efPuv//+F1544X3ve19HR8c3vvGNer3e6gl53/ve98Mf/vCpp57a/sHvfOc7Z5555i4WUK/Xx40b94EPfOD973//7373uwceeKA2GNasWdNoNJYtW/bGN75x7NixHR0dp5xySt8H1bfeemvfc5YuXVqv1/v/DwAAQIgIfvnll++9996Pf/zjtVrt3/27f7f9by1ZsuTwww9/29ve9ld/9Vd77rnnQD4MvuSSS6ZOnfrpT3/6vvvuG/ga/ujU8uXL6/X6Nddcs+eee+7wW29961tXr169YMGCWhv23nvvb33rW1u2bDn77LPPP//8Bx988Bvf+MarX/3qHZ42kBPyvve9b4c7In76058+/PDD73vf+waykr7PgF/5Movp7u7esmVLlmXbPzhp0qQ8z7/yla8MyiEAACoTwZMnT+7/S1RjxoyZNm3ajTfeeMABB3zsYx/rf84vf/nLn/3sZ3Pnzq3X61OmTHnve9/7rW9964UXXtj1Vx47duySJUs2b97c0k0Rf3Tq7rvvPvzwwydPnrzT8cMPP3yHj2x38Xr73Xbbbds/501vetN//a//9Wc/+9m3vvWtj3/84+94xzt2+CIDPCHTpk17/etf33c7Sp9vf/vbb37zm6dMmbKLFW7dunX9+vVf+tKXbrjhhj/90z899NBDd/Hkgb+0OXPmnHjiiR/4wAe6urpmz559zTXXvPLW5J6enjzPL7jgggEeEQBghPyItIkTJ37oQx9atWrVgQce2P/gtddeO3HixLPOOqvvH//mb/7m+eefH8hdByeeeOKFF17405/+9PLLLx/4GnYxtXnz5t7e3h0+l93hZyNMmjSp1rb3vOc9fTF94oknvvJ3B35Ctr8jIs/zG2644Q/dC3HQQQf1rb/RaEycOHHOnDlbt2695JJLBuuT4H322ee2225btmxZd3d3s9k877zzpk2bNnny5Ouuu25Qvj4AQJUiuO9vU23atOnb3/72+PHjX/e611166aUTJkzof8LmzZuXLVv2xBNPjB49uq/Suru78zwf4F+Pu+SSS173utd95jOfWb169cBX9Yem9tprr/Hjx+/0546187fHTj755O2fs3HjxpkzZ3Z0dIwfP/68887b4abelk7ImWee2X9HxO23375+/fo/ei/EHnvssf/++0+fPr3ZbJ5zzjmD+NL23HPPs846K8uyp59++sEHH1yyZMmrX/3qnp6eL37xiwM/CgDAyPkkeK+99jrzzDO/853v/PCHP/zzP//z7X8e7T/8wz/sNDrvuuuulStX/tGvvPfeexe4KWIXU294wxtWr1796KOP7vRHYRx11FG1ts2ZM+eee+654t889dRTH/rQh7b/3ZZOyGGHHfaGN7yh72dEfOc73znuuONe+9rX7vSg/T8dYuvWrc8888yKFSve85731HabqVOn9vT0/OhHPzryyCPbvIsaAKDat0P8xV/8xUc/+tG77rrroosu6n/w2muvHTNmzIYNG7b/fPGf//mfa7Xa1VdfPZAv+5a3vOVjH/vYypUrX/kfwigwddZZZ23btu2v//qvd5rU7f/I2xtvvPHqq6+eOXPmf/yP/7Gnp+cv//Ivv/e9723/A+NaPSFnnnnm7bff3veTjHf9cyF2nyeeeKJer8+ePXuHxxuNxhve8Ibe3t5NmzaVsjAAgGFxT/All1zy2te+9qtf/epPfvKTWq3261//+tZbbz3ttNP23Xff7Z92/PHHH3rooddff/2GDRsG8mU///nPv+51r2v1pxDsdGr27NlHHXXU9773vWOOOeaGG2749a9/vXnz5r7EfNe73nXXXXftsUfxU7du3boPf/jDkydP7q/eq6+++qCDDvrEJz7R95/wKHBC+u6ImDNnztNPP/3e9763VoaJEye+6U1vuvbaay+44IJ/+Zd/+c1vfrNx48aHH374K1/5yo033njMMceMGjWqlIUBAAyLCB43btyXv/zlbdu2nXfeeVu2bPnGN76xZcuW/r8Btr0PfvCDL7300je/+c2B396w65/bMMCpUaNGNZvN448//q677jrzzDMPOuigUaNG9f1nk2+55ZZDDz101/9Bu53+CIV6vf7CCy9s3rz5zDPPfPHFF7/1rW/1N+6rXvWqpUuXbty48ayzztq8eXOBEzJ16tQjjzzyhhtu+LM/+7Ptb7YuYO+9995h2UuXLh3IS+v7ALuzs/Oqq6464YQTDjzwwL333nvq1Kkf+chHGo1G/w8G9nOCAYCgEVyr1U4//fQkSVatWvXf//t/X7p06X777fcXf/EXr3zaf/pP/2mPPfYY4B0Rfbc3zJkzp9XF7HTq4IMPvuOOO5YtW/bOd77z4IMPHjVq1Ktf/ep3vvOd11133S9/+cujjz66Vsh/+S//ZeXKlZ/5zGeOP/747R9/+9vffsEFF9x1113z588vdkL67oIY4I8H3k26u7vvvffeT3ziE9OmTdt3331HjRo1adKkc8899xe/+MWg3EgNADAo6u3f3goAANVS2ifBAABQFhEMAEA4IhgAgHBEMAAA4YhgAADCEcEAAIQjggEACEcEAwAQjggGACAcEQwAQDgiGACAcEQwAADhiGAAAMIRwQAAhCOCAQAIRwQDABCOCAYAIBwRDABAOCIYAIBwRDAAAOGIYAAAwhHBAACEI4IBAAhHBAMAEI4IBgAgHBEMAEA4IhgAgHBEMAAA4YhgAADCEcEAAIQjggEACEcEAwAQjggGACAcEQwAQDgiGACAcEQwAADhiGBGgmeeeWbNmjVlrwIghHa2XNs1w4cIZqglSdLT0zO4X3PGjBk//vGP/9Dv9vb2dnV17eIJADE99thjH/7whydOnDhmzJiurq6LLrro2WefbXPLbWfWds1QEsGMBL///e//0G899thjM2bMWLdu3dCuCGC4e+CBB4466qjnnnvulltuefbZZ2+++eb77rvvqKOOevLJJwtvuX+U7ZrhQwRTmqeffrper1911VWTJk0aM2bMO97xjieeeKL/8a9//esHH3xwR0fHOeec07dpPv744/V6/ZFHHukbv/zyy4877rharXbyySfff//9s2bNmj179g6H+N73vjdt2rSjjjqqjNcHMKzNnj37rW9960033dTd3T127Ngjjjjiu9/97oEHHnjhhRcOcMu1XVNpIpiSXXfddT/4wQ/WrFmzfv36z372s/2PX3bZZbfeeuvdd9995513XnDBBbv4Crfddtuhhx66ZMmSxYsX7/Bbo0ePXrFixVVXXbXblg9QSb/61a/uuOOOHXbXPfbYY86cOc1m87nnnhv4lmu7pqJEMCX71Kc+NWXKlEmTJvX09KxcubL/8YULF06bNq2rq2vRokXLli178cUXC3zxGTNmHH300YO6XoCRYPXq1bVa7fDDD9/h8e7u7i1btjz00EMD/1K2aypKBFOySZMm9f1i3Lhxmzdv7n+879+d1Wq1I444YtOmTQ8//HBJCwQYger1eq1W27p16w6Pv/zyy61+Kds1FSWCKdlee+3V/+s8z1/5eN8e3Wg0+rbsfq/cuwEYoL7PgPs+D97emjVrGo3G1KlTB77l2q6pKBHMMHXPPff0/eLuu+/eZ599pkyZMmrUqFqt1v8v2h599NH+J++w4QKwa4cccsj06dMvvfTS7R/ctm3bZZdddvrpp++3334D33Jt11SUCGaYuvjii9etW/fggw/Omzfv3HPPHT169AEHHDB58uSrr776pZdeWrFixfXXX9//5HHjxq1fv/75558vdckAVXLNNdfce++9Z5999gMPPLB58+bVq1efccYZTz311Je//OVarTbwLdd2TUWJYIapGTNmnHLKKccee+ypp57a91lFvV5fvHjxihUr9t9//8997nOf/OQn+598/vnnf+ELX5g1a1apSwaokq6urrvuuquzs/PUU08dP378u971rkMOOeTnP//5hAkTWtpybddUVH37uzBblabpoC4G/tWmTZtuueWW6dOnjx8/vuy1wL/KsqxWNfZnhoDtmmrvz3kbkiQpfFyzZv+Qd77znaUc16zZ3bFPlqWK59msWbNmW9XOPul2CAAAwhHBDDt9f60YAGD3EcEAAIQjggEACEcEAwAQjggGACAcEQwAQDgiGACAcEQwAADhiGAAAMIRwQAAhCOCAQAIRwQDABCOCAYAIBwRDABAOCIYAIBwRDAAAOGIYAAAwqnneV54OE3TQV0MwHCUZVmtauzPQARZG/tzo81jN5vNYoNJkkSbzTasLzabdkwwOzSzVfy+MjsEsxVVufNsfza7i9kqfl+ZHeb7s9shAAAIRwQDABCOCAYAIBwRDABAOCIYAIBwRDAAAOGIYAAAwhHBAACEI4IBAAhHBAMAEI4IBgAgHBEMAEA4IhgAgHBEMAAA4YhgAADCEcEAAIQjggEACEcEAwAQTj3P88LDaZoO6mIAhqMsy2pVY38GIsja2J8bbR672WwWG0ySJNpstmF9sdm0Y0IVX+/MmTOLzS5fvtx5NjusZiuqcue5ovtz96KC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3e+eNGnSunXr7rjjjjvvvPP8888vY3XAyPfAAw8cddRRzz333C233PLss8/efPPN991331FHHfXkk08W2L4GyNZHCDmMFO95z3s++MEP5nn+29/+tlarXXnllYcccsjo0aPf/va3P/744/2PL168eOLEifvuu++HPvShl156Kc/zxx57rFarrVu3ru/rLFq06Nhjj83z/K1vfWvfZXLOOedsf6D/83/+T6PRePnll/v+8e///u/Hjh27bdu2Ml40MML92Z/92RlnnLH9I1u3bj3uuOP6HhzI9mXrg53ySTAj1nXXXfeDH/xgzZo169ev/+xnP9v/+GWXXXbrrbfefffdd9555wUXXLCLr3DbbbcdeuihS5YsWbx48faPn3DCCZs3bx41alTfPz755JP7779/vV7fbS8FCOpXv/rVHXfcscNOtccee8yZM6fZbD733HMD375sfbADEcyI9alPfWrKlCmTJk3q6elZuXJl/+MLFy6cNm1aV1fXokWLli1b9uKLL7ZzlA0bNlx66aXnnHPOYCwZ4P9n9erVtVrt8MMP3+Hx7u7uLVu2PPTQQwP/UrY+2IEIZsSaNGlS3y/GjRu3efPm/sePO+64vl8cccQRmzZtevjhhwsf4sUXXzzttNOmTZs2f/78ttcLsKO+z1m3bt26w+Mvv/xyq1/K1gc7EMGMWHvttVf/r/M8f+XjfX+uNBqNHf513iv/vNmpZ555Zvr06QcffPBNN93UaDQGb+EA/1ffZ8B9nwdvb82aNY1GY+rUqQPfvmx9sAMRTDj33HNP3y/uvvvuffbZZ8qUKX23uPX/y8FHH320/8l/6Ha3xx9//MQTTzzppJO+9a1v9d8hBzC4DjnkkOnTp1966aXbP7ht27bLLrvs9NNP32+//Qa+fdn6YAcimHAuvvjidevWPfjgg/PmzTv33HNHjx59wAEHTJ48+eqrr37ppZdWrFhx/fXX9z953Lhx69evf/7557f/Cr29vW9729tOP/30yy67zF8KAXara6655t577z377LMfeOCBzZs3r169+owzznjqqae+/OUv12q1gW9ftj7YgQgmnBkzZpxyyinHHnvsqaee2vf5Sr1eX7x48YoVK/bff//Pfe5zn/zkJ/uffP7553/hC1+YNWvW9l/ha1/72oMPPtj3x0C/F154oYxXA4xwXV1dd911V2dn56mn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EQwAQDgiGACAcEQwAADhiGAAAMIRwQAAhCOCAQAIRwQDABCOCAYAIBwRDABAOCIYhqNnnnlmzZo1Za8CKPlythXA7iOCoV1JkvT09Azu15wxY8aPf/zjVz7+m9/85owzzth3331f85rXLFiwYHAPCuzaY4899uEPf3jixIljxozp6uq66KKLnn322cKX80DYCmD3EcEwHP3+97/f6eMzZ84cP378Y489lmXZl770pcWLFw/50iCoBx544KijjnruueduueWWZ5999uabb77vvvuOOuqoJ598stjlPBC2Ath9RDAMmqeffrper1911VWTJk0aM2bMO97xjieeeKL/8a9//esHH3xwR0fHOeec0/cH2+OPP16v1x955JG+8csvv/y4446r1Wonn3zy/fffP2vWrNmzZ2//9R9++OH//b//9+WXX97R0fHmN7/5lFNO+ed//ueSXiuEM3v27Le+9a033XRTd3f32LFjjzjiiO9+97sHHnjghRdeOMDL2VYAw4oIhkF23XXX/eAHP1izZs369es/+9nP9j9+2WWX3XrrrXffffedd955wQUX7OIr3HbbbYceeuiSJUt2+HRnypQp27Zte9WrXrVly5Yf/Js0TXfnSwH+r1/96ld33HHHDlfuHnvsMWfOnGaz+dxzzw38crYVwDAhgmGQfepTn5oyZcqkSZN6enpWrlzZ//jChQunTZvW1dW1aNGiZcuWvfjii4UPMW3atHe9611vfOMbjz/++EFaNbArq1evrtVqhx9++A6Pd3d3b9my5aGHHhr4l7IVwDAhgmGQTZo0qe8X48aN27x5c//jff9+s1arHXHEEZs2bXr44YcLH2LNmjXPPPPM2LFj3/3ud7e9XuCPq9frtVpt69atOzz+8ssvt/qlbAUwTIhgGGR77bVX/6/zPH/l431/jjYajb4/Vvu98s/XXRg3btz8+fN/8pOfrF+/fjBWDexK32fAfZ8Hb2/NmjWNRmPq1KkDv5xtBTBMiGAYIvfcc0/fL+6+++599tlnypQpo0aNqtVq/f8y9NFHH+1/8g5/KPa59dZbOzo6+j95evbZZ/fcc8/Ozs4hWT6Edsghh0yfPv3SSy/d/sFt27Zddtllp59++n777Tfwy9lWAMOECIYhcvHFF69bt+7BBx+cN2/eueeeO3r06AMOOGDy5MlXX331Sy+9tGLFiuuv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1uv1K6+8chC/JgAAlYng7u7uLVu2ZFm2/YOTJk3K8/wrX/nKIB7okksumTp16qc//en77ruvpcG+z4D33HPPQVwMAAAjPIInT578yr8fdtttt/X97pw5c0488cQPfOADXV1ds2fPvuaaa+69997dsYyxY8cuWbJk8+bNA7kpolarbd26df369V/60pduuOGGP/3TPz300EMHcTE9PT15nl9wwQWD+DUBAKjMJ8H77LPPbbfdtmzZsu7u7mazed55502bNm3y5MnXXXfdoB/rxBNPvPDCC3/6059efvnlf+g5Bx10UF+mNxqNiRMnzpkzZ+vWrZdccolPggEARoYhiuCd/sW4k08+uf8Je+6551lnnZVl2dNPP/3ggw8uWbLk1a9+dU9Pzxe/+MVBX8wll1zyute97jOf+czq1at3/cw99thj//33nz59erPZPOecc/oebDT+9UdqbN68eYcn9z3S97sAAAxnw+KT4B1MnTq1p6fnRz/60ZFHHrlgwYJB//p77733rm+K6P/pEFu3bn3mmWdWrFjxnve8p/93Ozo6arXaU089tcPUr3/96/7fBQBgOCs/gp944ol6vT579uwdHm80Gm94wxt6e3s3bdo06Ad9y1ve8rGPfWzlypWv/M9n/FGTJ0/e6Y+t6Hukq6tr8JYJAMBuUf6/u584ceKb3vSma6+9dsyYMWeddVZXV1dHR8cTTzzxv/7X/7rxxhuPOeaYUaNG7Y7jfv7zn/+Hf/iHAj994tRTT91rr70uu+yyjo6Os84660/+5E9+85vffPvb3/7yl788duzYt73tbbtjtQAAjJCfDlGv11944YVarXbttdd2dnZeddVVJ5xwwoEHHrj33ntPnTr1Ix/5SKPR2H0/RrfvpogC/zm6iRMn/rf/9t82bdo0d+7cCRMm7LXXXgcffPBFF120ZcuWv/u7v/uTP/mTAX4dPycYACD6zwm+9957P/GJT0ybNm3fffcdNWrUpEmTzj333F/84hdHHXXU7jvuW97yljlz5hQY/Ju/+Ztms/mOd7zj1a9+9V577XXQQQeddtppK1asOO+883bDMgEAGGT1PM8H+2sCAMCwNiw+CQYAgKEkggEACEcEAwAQjggGACAcEQwAQDgiGACAcEQwAADhiGAAAMIRwQAAhCOCAQAIRwQDABCOCAYAIBwRDABAOCIYAIBwRDAAAOGIYAAAwhHBAACEI4IBAAhHBAMAEI4IBgAgHBEMAEA4IhgAgHBEMAAA4YhgAADCEcEAAIQjggEACEcEAwAQjggGACAcEQwAQDgiGACAcEQwAADhiGAAAMIRwQAAhCOCAQAIRwQDABCOCAYAIBwRDDAUnnnmmTVr1oy8YwFUlAgG+IPOOOOM+s6sWLGi1S81Y8aMH//4x698PEmSnp6eQVrvHzkWAP1EMMAfdNNNN+X/ZsmSJePGjev7dZ7nM2bMaPVL/f73v989ayz5WAAVJYIBCnryySfPOOOMffbZ5zWvec3HP/7x/vT82te+1tXVNX78+KOPPvrmm2+u1Wonn3zy/fffP2vWrNmzZ/+hr/b000/X6/Wrrrpq0qRJY8aMecc73vHEE0/0P/71r3/94IMP7ujoOOecc/oO9Pjjj9fr9UceeaRv/PLLLz/uuOMGeCwARDBAQX/5l385fvz4Rx555Ic//OHKlSv/83/+z7Va7Z577rn44otvuummp59++mMf+9jMmTOfe+6522677dBDD12yZMnixYt3/TWvu+66H/zgB2vWrFm/fv1nP/vZ/scvu+yyW2+99e67777zzjsvuOCCXXyFgR8LIDIRDFDE7bffvmrVqquvvvqAAw7o6ur64he/+D/+x//YuHHjr371q1qtNm7cuNGjR5999tkbN27cb7/9Bv5lP/WpT02ZMmXSpEk9PT0rV67sf3zhwoXTpk3r6upatGjRsmXLXnzxxd3zsgCiEMEARaxevfqll14aPXp031+VO/roo7dt27Z27dpTTz31mGOOOfzww4855pjPfe5zjz/+eEtfdtKkSX2/GDdu3ObNm/sf77vVoVarHXHEEZs2bXr44YcH9dUAhCOCAYrYsmXL1KlT8/+/17/+9WPGjPn+97//ox/9aPr06d/85jePPPLIBx98cOBfdq+99ur/dZ7nr3x869attVqt0WjU6/XtB/seB2CARDBAEYcddti6det2+kFvvV4/4YQTvvCFL6xevXrs2LH/+I//2PdgO4e75557+n5x991377PPPlOmTBk1alStVuu/L+LRRx/dfgHtHAsgAhEMUMTb3va2N77xjbNmzXrssceeeOKJOXPmvPa1r3355Ze/+c1vTpo06Ze//OWmTZvuuOOOp5566k1velPf7Q3r169//vnnix3u4osvXrdu3YMPPjhv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"
          },
          {
            "type": "input_text",
            "text": "Above is a visual representation of all the training examples and the test input. Each grid cell is colored according to its value (0-9), with clear labels and arrows showing input\u2192output transformations. Use both the textual and visual information to understand the pattern."
          }
        ]
      },
      {
        "type": "message",
        "role": "assistant",
        "content": [
          "Analysis:\n- Each training example shows grids with colored outlines that contain smaller colored shapes or points inside.\n- The transformation fills the area inside the outlined shape with a single uniform color (filling the interior pixels).\n- The fill color corresponds to one of the colors that appeared inside the shape's outline in the input.\n- The outline color remains unchanged.\n- Interior pixels colored differently or zero in the input become the fill color in output.\n- Colors outside the outlined shapes remain unchanged or zero.\n- The output grid size matches the input grid size (all 21\u00d721).\n- The fills do not overflow outside the outline but fully fill the enclosed region.\n- No other shapes or colors outside the outlines change.\n\nHypothesis for transformation:\n- For each connected outline shape in the input:\n  - Detect the outline pixels.\n  - Find the enclosed region inside this outline.\n  - Determine the fill color by majority or a prominent interior color inside the outline.\n  - Fill the enclosed region (interior, not outline) with this color.\n- Keep all other pixels outside outlines unchanged or zero.\n- Maintain original outline color unchanged.\n\nTo implement this, steps:\n- Use flood fill / connected component analysis.\n- Extract connected components corresponding to outlines.\n- For each outline component, find enclosed pixels by flood fill from inside.\n- Determine fill color by analyzing interior pixels.\n- Update interior to fill color while preserving the outline color.\n\n---\n\nBelow is a Python implementation applying the above logic using numpy and scipy.ndimage for connected components and flood fill.\n\nFinal answer:\n```python\nimport numpy as np\nfrom scipy.ndimage import label, binary_fill_holes\n\ndef transform(grid):\n    grid = np.array(grid)\n    h, w = grid.shape\n\n    # Output grid starts as copy of input\n    output = grid.copy()\n\n    # Get all nonzero pixels (potential outlines)\n    nonzero_mask = grid != 0\n\n    # Label connected components of nonzero pixels\n    labeled, num_features = label(nonzero_mask)\n\n    for comp_id in range(1, num_features + 1):\n        comp_mask = (labeled == comp_id)\n\n        # Determine the outline pixels for this component:\n        # Outline pixels are component pixels that have at least one neighbor outside component\n        # Use binary erosion to find inner pixels, outline = comp_mask - eroded\n        from scipy.ndimage import binary_erosion\n\n        eroded = binary_erosion(comp_mask, structure=np.ones((3,3)))\n        outline_mask = comp_mask & (~eroded)\n\n        # Identify enclosed region by filling holes inside the component mask\n        # Using binary_fill_holes\n        filled_mask = binary_fill_holes(comp_mask)\n\n        # Interior pixels = filled_mask but not outline nor component itself? \n        # Actually, outline within component, so interior = filled_mask & ~outline_mask\n\n        # Pixels strictly inside the outline are those in filled_mask but not on the outline\n        interior_mask = filled_mask & (~outline_mask)\n\n        # The shape interior includes the component pixels (outline + interior inside)\n        # But only fill interior pixels (inside area)\n\n        # Determine fill color: pick the most frequent nonzero color in the interior area inside the component\n        # Usually the interior in input has scattered points - pick dominant color inside interior_mask\n\n        # Get colors in interior\n        interior_colors = grid[interior_mask]\n        # Ignore zero colors\n        interior_colors = interior_colors[interior_colors != 0]\n\n        if len(interior_colors) == 0:\n            # No interior colors inside, maybe fill with 0 (leave unchanged)\n            fill_color = 0\n        else:\n            # Use mode (most frequent color) as fill color\n            vals, counts = np.unique(interior_colors, return_counts=True)\n            fill_color = vals[np.argmax(counts)]\n\n        # Apply fill color to interior pixels in output\n        output[interior_mask] = fill_color\n\n        # Outline pixels remains original color (already preserved)\n\n    # Return result as list of lists\n    return output.tolist()\n```"
        ]
      },
      {
        "role": "user",
        "content": [
          {
            "type": "input_text",
            "text": "Please analyze the training feedback and programs from all prior turns, and write an improved transformation.\n\n**Important**:\n1. Always start by attempting to find a complete rule that solves all training examples and should generalize to the test input.\n2. If you cannot find a perfect solution, provide your best attempt at a transformation that solves as many training examples as possible - ideally more than in the best previous turn.\n3. Even if your solution doesn't solve all examples perfectly, ensure it demonstrates meaningful pattern recognition and provides reasonable outputs that minimize pixel-level errors.\n\nFinal answer:\n```python\ndef transform(grid):\n    # Your improved transformation logic here (even if partial)\n    return transformed_grid\n```"
          },
          {
            "type": "input_text",
            "text": "Training results: 0/3 examples solved, 0.0% pixel accuracy - Keep experimenting! Try a different approach to the transformation.\n\nTraining Example 1 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 1, 1, 1, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nError: Traceback (most recent call last):\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmpg4v0cmnn.py\", line 30, in <module>\n    from scipy.ndimage import label, binary_fill_holes\nModuleNotFoundError: No module named 'scipy'\n\n\nTraining Example 2 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 6, 6, 6, 0, 0], [0, 0, 2, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 2, 2, 2, 3, 3, 3, 3, 3, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 6, 6, 6, 6, 6], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nError: Traceback (most recent call last):\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmpw5jmu2fu.py\", line 30, in <module>\n    from scipy.ndimage import label, binary_fill_holes\nModuleNotFoundError: No module named 'scipy'\n\n\nTraining Example 3 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 3, 3, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 3, 3, 6, 6, 6, 6, 6, 6, 3, 3, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 3, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nError: Traceback (most recent call last):\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmpenxxjshv.py\", line 30, in <module>\n    from scipy.ndimage import label, binary_fill_holes\nModuleNotFoundError: No module named 'scipy'\n\n\n"
          },
          {
            "type": "input_image",
            "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAj8AAAUtCAIAAACcd7J+AABEVklEQVR4nO3de5SU9Zng8beUiyjYLcRRuUURQXPwgsQbQUYD5yxi1HoVHaPRhWA0MV4xeEkYs9kD0QQXJyYnbjYqxCGMjm6qMIlx0RMVHUNilPGuQRoNAjKIdiOCze3dY/oswzYXm+pL1dP9+Rz/aN6up+rXb73dX+vtt7tzWZYlABDKHuVeAADsNvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QKgg9XriiuuyO3cV77ylR3epkuXLgceeOCZZ575/PPPb3+fjz76aC6X69mz58cff9zoXQ8++GAul7vrrrsa/jl+/PhcLjd9+vRGN3vnnXdyudyUKVOaM9Xg448//tnPfnbqqaf27t27a9euvXv3Pvfcc5966qld7JMpU6bsbIe8/PLLu95po0eP/tQdu/U2l1xyybbbG5Z3zjnn/OEPf9h2Pfl8vtHNDjnkkKuuuuqDDz7YrZ3f4L333ps6derQoUOrqqr22Wef448//q677tr2zxQ0PFyj8eeee27//ffv0aPH448/votdB1DRr702bty4cuXKX//616eeempNTU2j995zzz1JknzwwQf3339/U+7t5ptvfv3113d3DU2Zeuutt0466aSvf/3rTzzxxIoVKzZs2LBixYoHH3xw5MiRM2bMSCpMw/J+9atfjRgx4pe//OUubvbWW2/9+Mc/HjNmzJYtW3Zr5//hD384+uij//Ef//Hf//3f16xZs27dumefffZrX/vaxIkTd7Gw3//+96eeeurmzZsfe+yxU089tRkfIkAL1esnP/lJ9v888MADSZLMnDlz65bZs2dvveWSJUu2bv/4449fe+21Cy64YM2aNXfeeee2d1hbW1ssFs8999yePXv+z//5P5uyhg0bNowfP37z5s27tfJPndq4ceO4ceP+/d//ffjw4Q899NB77723cePGv/71rz/96U979ux5/fXXN7yQ2pmFCxdm2xkyZMgOd8hWjz322LZ30pTbrFixomH7+vXr33zzzRtvvDHLsq9+9atvv/32tjdbv379tjt/9OjRf/rTnx599NGm7/z/+I//SNN0+fLlX/7ylxcsWLBmzZr333+/WCwOGDBg5syZP/vZz3a4HwqFwtixY/fee+8nnnjihBNO2MUeA6j0115du3Y9/PDDf/CDHyRJ0ui115w5cz7++OPLLrtswoQJCxYsePHFFz/13q688so//vGP/+N//I/dWsOnTv3iF7947rnnRo8ePX/+/DPOOKNXr16dOnXq16/fN77xjV/96lebN2/+l3/5l6SS7LXXXoceeugtt9xy8803b9iw4Z/+6Z92sfOvueaahvI1fefPmDFj5cqV11577Zw5c0444YQePXrst99+Z5111pNPPrnPPvvMmDFj+z9zevfdd5977rl/93d/99RTTx111FFbt8+aNSuXy/3kJz9p0R0AdCxlqFd9ff0rr7wyadKkJEkGDRq07btmzpx5xBFHfPGLX/zGN76x5557NuXl1/e///2BAwfefPPNr732WtPX8KlTc+bMyeVy/+t//a8999yz0bv+/u///tVXX506dWpSka677rq99977//yf/7PD927cuPEvf/nLHXfc0alTp7//+79v+s7/13/9127duv33//7fG91h3759n3766SeeeCKXy227/Yc//OEll1wyYMCAp59++rDDDmu5jw+gDet1yCGHbL1wYK+99hoyZMgDDzzwmc985uqrr956m5dffvnPf/7z5MmTc7ncoYceeu655/7yl79cu3btru957733njlz5saNG3fr/OGnTi1cuPCII4445JBDdjh+xBFHNPpi3cjQoUMbXW3x9NNP72yHbPXEE0/s7m2216NHj8MOO6zRi9pu3bo1jHfp0mXw4MH/9m//9otf/GLbj27XO3/jxo1vvfXW8ccf37179+0f8ZhjjjnooIO23XL99dffcMMNSZKcfPLJ/fv3b3T78ePHZ1l2xRVX7PoDAai4K+b79Onz1a9+9YUXXjjwwAO3brznnnv69Olz4YUXNvzzpptu+vDDD5tygm7EiBFXXXXVn/70p9tuu63pa9jF1MaNG2traw844IBtNza6DvDggw9OKlWvXr3q/2ZnN9i8efOCBQs2btzYxJ1fW1ubZVmvXr2auIAf//jHJ5100ujRo++5555f/epXzftoAMpXr4YLEDZs2HDfffc1vDi49dZbe/fuvfUGGzdunD179rJly7p27dqQh6OPPjrLsiZeu/H973//sMMO++53v/vqq682fVU7m+rcuXOPHj1WrVqVlGr7qzZGjBjxqVdknHLKKbt7mx364IMPOnfu3LVr1+2v2tiwYUNNTc03v/nNH//4x9/61reauPN79uy5xx57NH2HTJgw4Yknnrj33nt79uz5ta99bdmyZU0cBKjE116dO3f+h3/4h/vvv//JJ58cM2bMtj8V9Jvf/GaHXxyff/75Z5999lPvuVu3biWcP9zF1JFHHvnqq6/+9a9/3eEFlsOGDUsq1dq1a19++eUjjjhih+/t3LnzIYcccttttw0ZMmTWrFlN3Pl77rnnEUcc8ec//3ndunXb3+yWW265+OKLly9fvnXLT3/60y5duhx00EE/+clP3n///Ysvvnj7q/MBgp05PO2006688srnn39+6//7N5y52muvverq6rZ9nfHMM88kSbKzq7Eb+cIXvnD11Vc/++yz2/8kcglTF1544ZYtWy6//PIdtnD76+sqx+23375x48YxY8bs+mZ77LHH2rVrN23a1MSdn8/n169f/9/+239rdD9vvfXWD3/4w9/85jc7PK/45S9/edy4cb///e9366QuQIV+3+v73/9+//7977zzzj/+8Y9Jkrz77ruPPPLIGWecse+++257s5NOOmnw4MH/8i//UldX15S7nTZt2mGHHfbTn/50txazw6lLLrlk2LBhv/3tb48//vh//dd/fffddzdu3Njw08qnn376888/v8celfVLturr6994440pU6Z873vf23vvvXd2TUSWZe+8887kyZNffPHFoUOHdurUqYk7/9prr+3Vq9f06dMvvvjiP//5z+vXr1+5cuWcOXNOOeWU2trayZMnb3uiclt33nnnAQccMGXKlOeee651PnSgIyrPl+B99tnnxz/+8ZYtWy677LJNmzbde++9mzZt2nrJwLb+63/9r+vWrfvnf/7npp8J3PXVgE2c6tKlS7FYPOmkk55//vl/+Id/OOigg7p06dLwm6IefvjhwYMHN/FXgezMDq8nzOVy215j2ZTbHHTQQVuv5Dz88MOnTZvW8Gux+vXr1+hjbLjZHnvs0a9fv9tuu22PPfZouOi/iTu/V69e999/f48ePf75n//5uOOO23vvvQ888MALL7zw7bffTtP0+uuv39lH+pnPfObnP//5xo0bL7jggo8++sjPewEtomwvIM4888x8Pv/CCy/80z/906xZs/bbb7/TTjtt+5tdfPHFe+yxRxNPHjacCWz4UdzdssOpvn37PvXUU7Nnzx47dmzfvn27dOlywAEHjB079he/+MXLL7983HHHJZWkc+fO/fr1O//88//t3/7ty1/+8s5utueee/7d3/3d6aef/uijjzacXWz6zh81atTChQuvuuqqww8/vHv37t26dTvhhBPuuuuu//2///f2PxW3rTPOOGP8+PF/+ctftv0BCYDmyFXyt3AAYIcq65s3ANAU6gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqRWCrV69+/fXXy70KqAirO9ing3rRMvr27ZvbzuzZs1v1QUePHr1gwYKm3/6222478cQTd/be2traAQMG7NYdQmvbetDW1tbmcrld9Gn0bn46RNep3Aug/bj99tuvueaatnzE9evXt9RdLV26NE3TJUuWtNQdQsuqrq7OsqxtPh1C8NqL1nX33Xd37dp16dKlSZKsWrVq3333nTlz5nvvvZfL5e6+++6+fftWVVVNnDhx6yfeihUrxo0b17179379+k2aNGnr9mXLlqVp2qNHj/333//yyy+vr68/5ZRT3njjjQkTJlxyySW7GHzllVdOPvnkbt26DR8+fGdx+u1vfztkyJBhw4a11V6BJtn2oN32tdeyJnw6JO1eBi2hT58+t99++w7f9cUvfvHyyy/Psuzqq68+9dRTsyxbtWpVkiSDBg166aWXFi9efPTRR3/1q19tuPFJJ500fvz4VatWLV68eMSIEZdddlmWZZs2bTryyCPPO++8lStXLlq0aMSIETfccEOWZYMHD545c+YuBtevX9+/f/9vfvOb77///kMPPdStW7cTTjhh+xU++uijf/rTnzZu3JgkyR/+8IfW3E+wG7Y9aD/44IMkSV577bUmfjpk7Z160TL69OnT6H+M9txzz4Z3LVq0qLq6esaMGVVVVYsWLdpar0Kh0HCDefPmdenSZe3atU8++eTee+9dX1/fsP3ZZ5/dY4891q9f/+STT3bp0mX16tWNHnTrp+vOBovFYlVV1bp16xq2X3rppTusVwP1ogJtPWi31quJnw5Ze+fMIS2m0WuvTZs2NWwfOHDg5MmTJ02adN111w0cOHDr7bdeQHHMMcds2LBh8eLFr7766rp167p27dpw0cdxxx23ZcuWmpqaV155pW/fvj179tzZQ+9s8NVXXz300EO7devWcLOhQ4e28j6AFrb9QdvET4ekvVMv2sLLL7+cJMnzzz+/7cbOnTs3vLF58+ZPriDq1GnTpk0DBw5s9H9Yn/vc5zp37pzL5XZx/zsbbHSzrY8IUWx/0Dbx0yFp79SLVve73/3u/vvvnz59+ty5c4vF4tbtL774YsMbCxcu7N69+6GHHnr44YcvWbLknXfeaXQPgwYNWrp0acOZk21t/Rze2eCQIUMWLVr00UcfNfzzpZdeaukPDlrX9gdtEz8dkvZOvWhda9eu/frXv37VVVd961vf+trXvnbFFVd8+OGHDe+6/vrrlyxZsmjRohtuuOHSSy/t2rXrF7/4xaOOOmrChAlLly5dtmzZNddc079///r6+pNPPnnIkCFXXnnle++999Zbb51zzjlf/vKXkyTZZ599li9f/uGHH+5s8L/8l/9y0EEHXX311e+///5jjz12zz33lHt/wG7Y4UHbxE+HpN1r/W+t0UGv2kiS5LLLLrvyyisPPvjgtWvXZllWV1fXr1+/K664ouGqjRtvvPGzn/3sfvvtN2nSpA0bNjTcz9tvv33WWWfts88+++6775gxY1577bWG7UuWLDnttNP22muvXr16jR8/vq6uLsuyn//85927dz/nnHN2Mbh48eJRo0bttddeQ4YMmTRpkqs2CGTbg3brVRtN/HTI2rvcrn/8bdfSNG1eOumgNmzY8PDDD48aNapHjx7lXgt8ukKhUO4lsJ3mpC+fzyelMmvWrNkosy33goEW4/teAMSjXgDEo14AxKNeAMSjXgDEo14AxKNeAMSjXgDEo14AxKNeAMSjXgDEo14AxKNeAMSjXgDEo14AxKNeAMSjXgDEo14AxJPLsqzk4TRNW3QxAJWoUCiUewk01ilpnmKxWNpgPp/vaLOFuuWlzaZVvc22zWzE48psG8xSgZw5BCAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIJ5clmUlD6dp2qKLAahEhUKh3EugsU5J8xSLxdIG8/l8R5st1C0vbTat6n309BI/eV6YnHa02ebs54jHldk2mKUCOXMIQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPLksy0oeTtO0RRcDUIkKhUK5l0BjnZLmKRaLpQ3m8/lyzRbqlpc2m1b1Ltfs0dNL/OR5YXLa0Wabs58jHs9m22CWCuTMIQDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPHksiwreThN0xZdDEAlKhQK5V4CjXVKmqdYLJY2mM/nyzVbqFte2mxa1fvo6SUexC9MTjvabHP2c7lmIx7PZttglgrkzCEA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDx5LIsK3k4TdMWXQxAJSoUCuVeAo11SpqnWCyWNpjP58s1W6hbXtpsWtX76OklHsQvTE472mxz9nPE46o5szVTakubHTC1OuJsuOeICuTMIQDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPHksiwreThN0xZdDEAlKhQK5V4CjXVKmqdYLJY2mM/nyzVbqFte2mxa1fvo6SUexC9MTjvabHP2c8TjqjmzNVNqS5sdMLU64scbbpYK5MwhAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8eSyLCt5OE3TFl0MQCUqFArlXgKNdUqap1gsljaYz+fLNVuoW17abFrV22zbzEY8rpozWzOltrTZAVOrI3684fYVFciZQwDiUS8A4lEvAOJRLwDiUS8A4lEvAOJRLwDiUS8A4lEvAOJRLwDiUS8A4lEvAOJRLwDiUS8A4lEvAOJRLwDiUS8A4lEvAOLJZVlW8nCapi26GIBKVCgUyr0EGuuUNE+xWCxtMJ/PmzVrtmG2ZkptabMDplZH/HjD7SvaYb0AaP9yuZ2+qxkn8JpDvQDY/Whtf5u2zZh6AVBSt3Y40lYNUy8AmtetcjTMFfMAtFC6Wvx+dk69AGiF5LRywNQLgKRVYtOaAVMvgA4vlwt3z+oF0LHlchHvX70AOrBcLuijqBcA8agXQEeVy8V9LPUCIB71AuiQcrnQj6heAMSjXgDEo14AHU8uF/1x/Y55AJogy5K5c5NNm5LOnZMzzyxb//6fXNaM32OfpmmLLgagEhUKhaSdye1+e/74x+See5Kf/SyZODG55JLkpJNKfOgW+uMpzX3tVSwWSxvM5/NmzZptmK2ZUlva7ICp1RE/3nD7ik8sXZrU1ycnnpgsW/bJf+Xm+14ANM3s2clNNyWPPJJUAPUCoGkmTEhmzUrOOCOpAOoFQBP065d065YUCp+80adPUm6uOQSgCY4/Pnn33WTkyE+uOTzxxKTc1AuAJij3JfKNOHMI0PFkWfTHVS8A4lEvAOJRL4AOKctCP6J6ARCPegF0VFkW97HUC4B41AugA8uyoI+iXgAt6Zhjjln2t1/BXl9fP2jQoDvuuGPo0KHHHnvsvHnzko4ZsKxV7l+9AFrSuHHjHnrooSRJHn/88TFjxkydOnX+/Plz5syZPXt2UrGyLNw9qxdASzr33HPnzp2bJMmvf/3r8847b+zYsRdffPHSpUvvvffepJJlWaxXdeoF0JIGDx68evXqNWvWLFy48Atf+MKsWbOuvfbaO++8c8KECUmFy7JAJyT9ll6AFnbWWWfdeuutxx9//Jo1a84888zHHnts2LBhAwYMSCpflrXMb+Nt/YtBclkzHiNN0xZdDEAlKhQKu3X7N95446ijjnr88ceHDx8+ffr0++67b8uWLRMnTrziiiuSKHK5Cv8ZsubWq1gsljabz+fN7sbswB+UOPvmDR1uNuDzWzOltrTZAVOrzTZ9tuTnqDlfJ2PL7U7D2nYvOXMIwKcFaRcZK1Pa1QuAT1N5rz5dcwhAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBcB/qqury+fzI0aMyOfzdXV1u9h+6623DhkyZPr06UmSbNmy5fTTT6+tLfFvh5ZAvQD4T9OmTRs5cuTTTz998skn33LLLbvY/qMf/eiZZ56ZMWNGkiR33XXXOeecU11dnbSVXHP+4nWapi26GIBKVCgUkg5jyJAh8+bN692797Jly8aMGfPSSy/tbHv//v1///vfjxo1auHChRdddNFvfvOb3C7+BHOl/W3lYrFY2mA+nw85O/AHJc6+eUO5Zi+44ILSZufMmVOu2Wbtq4jHldnKnu1QVq5ceeCBByZJctBBB61cuXIX26dNm/aVr3zllltumTJlyve+9722TJczhwCU6KKLLlqwYMHgwYOTJKmpqTn99NMffPDBJMprLwDakwMOOODdd9/t3bv3ihUrDjjggF1vz7Ls5ptvvvfee4cNG7ZgwYLhw4ePGzeubdbptRcA/2ns2LH33XdfkiT33Xff2LFjkyRZu3btDrcnSXLPPfecccYZvXr1Wr9+fZZl69atS9qKegHwn77zne/Mnz9/xIgRTz311Le//e0kSc4+++wdbq+trX3ggQcuvfTSJEmuvfba0aNHX3fddUlbceYQgP9UVVXV6PKWefPm7XB7dXX1I4880vD2jX+TtCGvvQCIR70AiEe9AIhHvQCIR70AiEe9AIhHvQCIR70AiEe9AIhHvQCIR70AiEe9AIhHvQCIJ5dlWcnDaZq26GIAKlGhUCj3Emjpv5DS6BfmN10+nw85O/AHJc6+ecMFF1xQ2uycOXM62mxz9nPI48psZc9SgZw5BCAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIJ5clmUlD6dp2qKLAahEhUKh3EugsU5J8xSLxdIG8/l8yNmBPyhx9s0bLrjggtJm58yZ09Fmm7OfQx5XZit7lgrkzCEA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDx5LIsK3k4TdMWXQxAJSoUCuVeAo11SpqnWCyWNpjP50PODvxBibNv3nDBBReUNjtnzpyONtuc/RzyuDJb2bNUIGcOAYhHvQCIR70AiEe9AIhHvQCIR70AiEe9AIhHvQCIR70AiEe9AIhHvQCIR70AiEe9AIhHvQCIR70AiEe9AIhHvQCIR70AiCeXZVnJw2matuhiACpRoVAo9xJorFPSPMVisbTBfD4fcnbgD0qcffOGCy64oLTZOXPmdLTZ5uznkMeV2cqepQI5cwhAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA8uSzLSh5O07RFFwNQiQqFQrmXQGOdkuYpFoulDebz+ZCzA39Q4uybN3S02QsuuKC02Tlz5jRrzRGPK7OVPUsFcuYQgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeHJZlpU8nKZpiy4GoBIVCoVyL4HGOiXNUywWSxvM5/NmA8wO/EGJs2/eULbZiPvZbGXPUoGcOQQgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiCeXJZlJQ+nadqiiwGoRIVCodxLYDtZM+Tz+aRUZs2aNRtltjlfJ2klzhwCEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQTy7LspKH0zRt0cUAVKJCoVDuJbCdrBny+XxSKrNmzZqNMtucr5O0EmcOAYhHvQCIR70AiEe9AIhHvQCIR70AiEe9AIhHvQCIR70AiEe9AIhHvQCIR70AiEe9AIhHvQCIR70AiEe9AIhHvQCIR70AiCeXZVnJw2matuhiACpRoVAo9xLYTtYM+Xw+KZVZs2bNRpltztdJWokzhwDEo14AxKNeAMSjXgDEo14AxKNeAMSjXgDEo14AxKNeAMSjXgDEo14AxKNeAMSjXgDEo14AxKNeAMSjXgDEo14AxKNeAMSTy7Ks3GsAgN3jtRcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXga1evfr1118v9ypgNzhoW4p60TL69u2b287s2bNb9UFHjx69YMGCpt/+tttuO/HEE7ffvmjRoi996UvV1dUHHXTQZZddtmbNmhZdJu3f1kOrtrY2l8vtok+7e9CyM+pFi7n99tuz/99XvvKVVn3E9evXN/9ONm7c+KUvfenggw9esmTJU0899dxzz339619vidXREVVXV2dZdvjhh7fqQYt60eruvvvurl27Ll26NEmSVatW7bvvvjNnznzvvfdyudzdd9/dt2/fqqqqiRMnbv2UXrFixbhx47p3796vX79JkyZt3b5s2bI0TXv06LH//vtffvnl9fX1p5xyyhtvvDFhwoRLLrlkF4OvvPLKySef3K1bt+HDhy9ZsmT7FT777LM1NTUzZszYb7/9Bg4c+N3vfnfu3LlZlrXhTiK2bQ+tbV97NeWgLffaA1MvWtfEiRNHjBhx6623Jkkybdq0z3/+8xMmTGh41w9/+MNHHnlk4cKFzz333BVXXNGw8ZxzzunRo8dbb7315JNPPvvss9dee22SJJs3bz7ttNO6dOmyePHiP/zhDy+99NJ3v/vdJ554YvDgwTNnzrzrrrt2Nvjxxx+PHTv26KOPXr58+U033TRz5sztVzh8+PCNGzd26dKl4Z8rVqzo2bNnLpdrw51EbDs8tJp40JZpye1Co1M9UJo+ffo0OrT23HPPhnctWrSourp6xowZVVVVixYtyrJs1apVSZIUCoWGG8ybN69Lly5r16598skn99577/r6+obtzz777B577LF+/fonn3yyS5cuq1evbvSgDV8Isizb2WCxWKyqqlq3bl3D9ksvvfSEE07YxUdRW1t7yCGHfPe7323p3UM7t/XQ+uCDD5Ikee2115p40JZpve2B11601ve9Nm3a1LB94MCBkydPnjRp0nXXXTdw4MCtt996AcUxxxyzYcOGxYsXv/rqq+vWrevatWvDRR/HHXfcli1bampqXnnllb59+/bs2XNnD72zwVdfffXQQw/t1q1bw82GDh26i/V/9NFHZ5xxxpAhQ6ZMmdJCu4SOYvtDq4kHbesvrd1SL9rCyy+/nCTJ888/v+3Gzp07N7yxefPmJEk6deq0adOmgQMHNvo/rM997nOdO3fe9am8nQ02utnWR9ze6tWrR40a1bdv3wcffLBTp07N+3DpcLY/tJp40Lbyutoz9aLV/e53v7v//vunT58+d+7cYrG4dfuLL77Y8MbChQu7d+9+6KGHHn744UuWLHnnnXca3cOgQYOWLl3acE5mW1u/OuxscMiQIYsWLfroo48a/vnSSy/tcIXvvPPOiBEjRo4c+ctf/nLrN8Cg6bY/tJp40LbVAtuj1j85SYfQp0+f7a+Yz7Lsww8/7N+//zXXXNPwvYE+ffqsWbOm4ften//852tqav7yl78ceeSRkyZNyrJs8+bNQ4cOHT169F//+td33nnn6quv7tev38cff7xly5Zjjz32wgsvXLVq1ZIlS84+++zzzz8/y7Jhw4ZNmzZtzZo1Oxusr68fNGjQxIkTV69e/eijj/bo0WP773t98MEHhx122PXXX99Wu4r2ZttDa+v3vZp40JZ77YGpF6111UaSJJdddtmVV1558MEHr127Nsuyurq6fv36XXHFFQ31uvHGGz/72c/ut99+kyZN2rBhQ8P9vP3222edddY+++yz7777jhkz5rXXXmvYvmTJktNOO22vvfbq1avX+PHj6+rqsiz7+c9/3r1793POOWcXg4sXLx41atRee+01ZMiQSZMmbV+vW265ZfuVf/jhh227/whs20Nra72aeNCWe+2B5Srz51rSNC33EmhFGzZsePjhh0eNGtWjR49yr4X2o1AolHsJtJ3K/e70tt8g2S35fN5s02cLdctLm02repc8e3q3zyRJ8pO1qw7f8mFbPm4zZyM+vx1qlg7FVRsAxFO5r71ox7p06ZKdeny5VwEE5rUXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPHksixLKk+apuVeAhBMoVAo9xJoO5X7t5WLxWJpg/l8vjmzhbrlpc2mVb072mzNlNrSZgdMrS7XbHM+3nIdk2Zhe84cAhCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEE8uy7Kk8qRpWu4lAMEUCoVyL4G20ympVMVisbTBfD7fnNlC3fLSZtOq3jVTakubHTC12mzbzDbn+S3XMTlr/lWlzY4feUe5Zsuyr+hQnDkEIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgnlyWZUnlSdO03EsAgikUCuVeAm2nU1KpisViaYP5fL45s4W65aXNplW9a6bUljY7YGq12baZbc7zW65jctb8q0qbHT/yjnKtuSyzdCjOHAIQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARBPLsuypPKkaVruJQDBFAqFci+BttMpqVTFYrG0wXw+35zZQt3y0mbTqt7lmq2ZUlva7ICp1R1ttjn7uVzH5Kz5V5U2O37kHeVac1lm6VCcOQQgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiCeXJZlSeVJ07TcSwCCKRQK5V4CbadTUqmKxWJpg/l8PuJsoW55abNpVe+aKbWlzQ6YWt3RZpuzn8t1bMyaf1Vps+NH3tGhZulQnDkEIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgnlyWZUnlSdO03EsAgikUCuVeAm2nU1KpisViaYP5fD7ibKFueWmzaVXvmim1pc0OmFrd0Wabs58jHlcdapYOxZlDAOJRLwDiUS8A4lEvAOJRLwDiUS8A4lEvAOJRLwDiUS8A4lEvAOJRLwDiUS8A4lEvAOJRLwDiUS8A4lEvAOJRLwDiUS8A4sllWZZUnjRNy70EIJhCoVDuJdB2OiWVqlgsljaYz+cjzhbqlpc2m1b1rplSW9rsgKnVHW22Ofs54nHVoWbpUCq3XgDsnlxup++qyNNszaFeAO03Wtvfpr1kTL0A2nW3djgSv2HqBdAxutW+GuaKeYAOlq4Wv59yUC+AUFo2ObmoAVMvgDhaIza5kAFTL4AgWi8zuXgBUy+ACFo7MLlgAVMvgIrXNmnJRQqYegEQj3oBVLa2fEmUC/PyS70AiEe9ACpY278YysV4+aVeAMSjXgDEo14AlapcJ/FyAU4e+h3zAO1IliVz5yabNiWdOydnnhmiQ6XJZRX5G/LTNC33EoBgCoVC0s6U0J4//jG5557kZz9LJk5MLrkkOemkEh+6ItMQ47VXsVgsbTCfz0ecLdQtL202repttm1mIx5XHWqWTyxdmtTXJyeemCxb9sl/7ZfvewG0L7NnJzfdlDzySNKuqRdA+zJhQjJrVnLGGUm7pl4A7Ui/fkm3bkmh8Mkbffok7Vflft8LgN12/PHJu+8mI0d+cs3hiScm7Zd6AbQjuXZ7iXwjzhwCVKpyXbaeVfrl8uoFQEjqBUA86gVQwdr+JF4W4LShegEQknoBVLa2fDGUxXjhpV4AhKReABWvbV4SZWFeeKkX0EEdc8wxy/72K9jr6+sHDRp0xx13DB069Nhjj503b15SmVo7LVmkdKkX0EGNGzfuoYceSpLk8ccfHzNmzNSpU+fPnz9nzpzZs2cnFav1ApMFS5d6AR3UueeeO3fu3CRJfv3rX5933nljx469+OKLly5deu+99yaVrDUyk8VLl3oBHdTgwYNXr169Zs2ahQsXfuELX5g1a9a111575513TpgwIalwLRubLGS6/JZeoOM666yzbr311uOPP37NmjVnnnnmY489NmzYsAEDBiSVL8ta5rfxhk3XJ7+OOKvI1adpWu4lAMEUCoXduv0bb7xx1FFHPf7448OHD58+ffp99923ZcuWiRMnXnHFFUkUuVIbVpFf+XdPVpHy+XzJH5FZs2Y75mzWYSXJbvzXXjhzCBBcln36S7F28GLr/6deAO1F1t4StQuuOQQgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71Aoinrq4un8+PGDEin8/X1dXtYvutt946ZMiQ6dOnJ0myZcuW008/vba2NolPvQDimTZt2siRI59++umTTz75lltu2cX2H/3oR88888yMGTOSJLnrrrvOOeec6urqJL7c3/6odMVJ07TcSwCCKRQKSYcxZMiQefPm9e7de9myZWPGjHnppZd2tr1///6///3vR40atXDhwosuuug3v/lNbhd/gjmQrCLl8/mSPyKzZltpNnszKe2/oLPl2s8lz2YdyWc+85nNmzdnWbZ58+b9999/F9vvvffeE0444Ze//OU3vvGNZ599NmsvnDkEaM8uuuiiBQsWDB48OEmSmpqa008//cEHH0zi61TuBQCw2w444IB33323d+/eK1asOOCAA3a9Pcuym2+++d577x02bNiCBQuGDx8+bty4JDivvQDiGTt27H333ZckyX333Td27NgkSdauXbvD7UmS3HPPPWeccUavXr3Wr1+fZdm6deuS+NQLIJ7vfOc78+fPHzFixFNPPfXtb387SZKzzz57h9tra2sfeOCBSy+9NEmSa6+9dvTo0dddd10SnzOHAPFUVVUVi8Vtt8ybN2+H26urqx955JGGt2/8m6Rd8NoLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHhyWZYllSdN03IvAQimUCiUewm0ncr9CymNfsl/0+XzebNtM1u4rcTZ9Fsdbvbo6SV+YX1hctqc2easOdwxSYfizCEA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDx5LIsSypPmqblXgIQTKFQKPcSaDudkkpVLBZLG8zn82bbZrZwW4mz6bfyR08v8QvNC5NTs02fbc5zFO6YpENx5hCAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B4clmWJZUnTdNyLwEIplAolHsJtJ1OSaUqFoulDebzebNtM1u4rcTZ9Fv5o6eX+IXmhcmp2abPNuc5CndM0qE4cwhAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA8uSzLksqTpmm5lwAEUygUyr0E2k6npFIVi8XSBvP5vNm2mS3cVuJs+q380dNL/ELzwuTUbNNnm/MchTsm6VCcOQQgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiCeXJZlSeVJ07TcSwCCKRQK5V4CbadTUqmKxWJpg/l83mzbzBZuK3E2/Vb+6OklfqF5YXJqtumzzXmOwh2TdCjOHAIQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARBPLsuypPKkaVruJQDBFAqFci+BttMpqVTFYrG0wXw+b7ZtZgu3lTibfqvDzR49vcQvrC9MTpsz25w1hzsm6VCcOQQgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiCeXJZlSeVJ07TcSwCCKRQK5V4CbSirSPl8vuSPyKzZVprN3kxK+y/obLn2c8mz5f66RZty5hCAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B4clmWJZUnTdNyLwEIplAolHsJtKGsIuXz+ZI/IrNmzXbM2XJ/3aJNOXMIQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPLksy8q9BgDYPV57ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPegEQj3oBEI96ARCPehHY6tWrX3/99XKvgpAcPNGpFy2jb9++ue3Mnj27VR909OjRCxYsaPrtb7vtthNPPHH77StXrhw3bty+++7br1+/qVOntugaaVNbn+La2tpcLreLPu3uwUOl6VTuBdB+3H777ddcc01bPuL69etb5H4uuOCC/v37L126dNGiRaeddtqBBx54ySWXtMg9Uy7V1dVZlrXBwUO5eO1F67r77ru7du26dOnSJElWrVq17777zpw587333svlcnfffXffvn2rqqomTpy49UvJihUrxo0b17179379+k2aNGnr9mXLlqVp2qNHj/333//yyy+vr68/5ZRT3njjjQkTJjSUZmeDr7zyysknn9ytW7fhw4cvWbJk+xUuXrz48ccfv+2226qqqj7/+c+feuqpzzzzTBvuIVrMtk/xtq+9mnLwlHvt7L4MWkKfPn1uv/32Hb7ri1/84uWXX55l2dVXX33qqadmWbZq1aokSQYNGvTSSy8tXrz46KOP/upXv9pw45NOOmn8+PGrVq1avHjxiBEjLrvssizLNm3adOSRR5533nkrV65ctGjRiBEjbrjhhizLBg8ePHPmzF0Mrl+/vn///t/85jfff//9hx56qFu3bieccMLOPoSNGzc+9thjPXv2fOihh1pnJ9G6tn2KP/jggyRJXnvttSYePOVeO7tNvWgZffr0afQ/RnvuuWfDuxYtWlRdXT1jxoyqqqpFixZtrVehUGi4wbx587p06bJ27donn3xy7733rq+vb9j+7LPP7rHHHuvXr3/yySe7dOmyevXqRg+69QvQzgaLxWJVVdW6desatl966aW7qNfgwYO7du16yimnrFq1qhX2EG1h61O8tV5NPHjKtF5K58whLabRa69NmzY1bB84cODkyZMnTZp03XXXDRw4cOvtt15Accwxx2zYsGHx4sWvvvrqunXrunbt2nDRx3HHHbdly5aamppXXnmlb9++PXv23NlD72zw1VdfPfTQQ7t169Zws6FDh+5i/a+//vrq1av33nvvL33pSy20S2hr2z/FTTx4Wn9ptDD1oi28/PLLSZI8//zz227s3LlzwxubN2/+5AqiTp02bdo0cODARv+H9bnPfa5z5865XG4X97+zwUY32/qIO7PPPvtMmTLlj3/84/Lly0v9WCmn7Z/iJh48rbwuWp560ep+97vf3X///dOnT587d26xWNy6/cUXX2x4Y+HChd27dz/00EMPP/zwJUuWvPPOO43uYdCgQUuXLm04F7StrV+VdjY4ZMiQRYsWffTRRw3/fOmll7Zf3iOPPFJVVVVfX9/wz/fff3/PPfesrq5u3gdNeWz/FDfx4GmrBdJymnHWET79qo0PP/ywf//+11xzTcP3JPr06bNmzZqG73t9/vOfr6mp+ctf/nLkkUdOmjQpy7LNmzcPHTp09OjRf/3rX995552rr766X79+H3/88ZYtW4499tgLL7xw1apVS5YsOfvss88///wsy4YNGzZt2rQ1a9bsbLC+vn7QoEETJ05cvXr1o48+2qNHj+2/77V+/fpBgwZdfvnltbW1L7zwwhFHHHHJJZe01W6jJW37FG/9vlcTD55yr53dpl601lUbSZJcdtllV1555cEHH7x27dosy+rq6vr163fFFVc01OvGG2/87Gc/u99++02aNGnDhg0N9/P222+fddZZ++yzz7777jtmzJjXXnutYfuSJUtOO+20vfbaq1evXuPHj6+rq8uy7Oc//3n37t3POeecXQwuXrx41KhRe+2115AhQyZNmrTDqzbefPPNsWPH7rvvvv3797/pppvWr1/fhnuOFrPtU7y1Xk08eMq9dnZbbtc/0NfRpGla7iV0CBs2bHj44YdHjRrVo0ePcq+FllcoFMq9BDqA3Q9ee5bP50vek2abbuzYsWV5XLNtM1vuz2M6BFdtABCPelEGXbp0KfcSgNjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B4clmWlXsNFSRN03IvAcIrFArlXgLtX6dyL6DiFIvF0gbz+Xy5Zmum1JY2O2BqtdnKnw13TEIbcOYQgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeHJZlpV7DRUkTdNyLwHCKxQK5V4C7V+nci+g4hSLxdIG8/l8uWZrptSWNjtgavWs+VeVNjt+5B1mmz7bnOco3DEJbcCZQwDiUS8A4lEvAOJRLwDiUS8A4lEvAOJRLwDiUS8A4lEvAOJRLwDiUS8A4lEvAOJRLwDiUS8A4lEvAOJRLwDiUS8A4lEvAOLJZVlW7jVUkDRNy70ECK9QKJR7CbR/ncq9gIpTLBZLG8zn8zVTakubHTC1ulyzs+ZfVdrs+JF3mG36bHOeo+Yck2WZhTbgzCEA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDx5LIsK/caKkiapuVeAoRXKBTKvQTav07lXkDFKRaLpQ3m8/maKbWlzQ6YWj1r/lWlzY4feYfZyp9tzrHRnGOyLLPQBpw5BCAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIJ5clmXlXkMFSdO03EuA8AqFQrmXQPvXqdwLqDjFYrG0wXw+XzOltrTZAVOrZ82/qrTZ8SPvMFv5s805NppzTJZlFtqAM4cAxKNeAMSjXgDEo14AxKNeAMSjXgDEo14AxKNeAMSjXgDEo14AxOM3RQG0tFxup+/yq2VbiHoBtH60tr+NjDWPegG0Sbd2OKJhpVIvgLbt1vbjGrb7XLUBUKZ0tfj9dCTqBVAByRGw3aReAJURGwHbHeoFUDGZEbAmy2W+W7iNNE3LvQQIr1AoJO1YGwTGl+UmcM1hY8VisbTBfD5fM6W2tNkBU6vLNTtr/lWlzY4feYfZps+W6/ltzvFc8mx71javjXI5AftUzhwCEI96AVTeN6V8A+zTqBcA8agXQEW+GPLya5fUC4B41AuAeNQLoFJP4jl5uHN+3gugFWRZMndusmlT0rlzcuaZOtTivPYCaAV/+lPyu98l48YlDz2ULFhQ7tW0Q+oF0AqWLk3q65MTT0yWLfvkP1qaegG0jtmzk5tuSh55pNzraJ/UC6B1TJiQzJqVnHFGudfRPqkXQCvo1y/p1i0pFD55o0+fcq+mHXLNIUArOP745N13k5EjP7nm8MQTy72adki9AFqBS+RbmTOHAJ+mXH9ty1/52jn1AiAe9QIgnlzmlek20jQt9xIgvEKhkLRLbfytLF+cd8lVG40Vi8XSBvP5fLlma6bUljY7YGr1rPlXlTY7fuQdZttmtjnPb1mOSWgDzhwCVN6LIS+8Po16ARCPegFU2EsiL7yaQL2AcjrmmGOW/e1XsNfX1w8aNOiOO+4YOnToscceO2/evKQytXZapKtp1Asop3Hjxj300ENJkjz++ONjxoyZOnXq/Pnz58yZM3v27KRitV5gpKvJ1Asop3PPPXfu3LlJkvz6178+77zzxo4de/HFFy9duvTee+9NKllrZEa6dod6AeU0ePDg1atXr1mzZuHChV/4whdmzZp17bXX3nnnnRMmTEgqXMvGRrp2k5/3AsrsrLPOuvXWW48//vg1a9aceeaZjz322LBhwwYMGJBUvixrmR9hlq7dp15AmZ177rlHHXXU448/XlVV9aUvfenEE0/csmXLP/7jPyYhNISn5IbpVqnUCyizwYMH19fXN7w9+W+ScEpomG41j3oBtJCtQdpFxkSrhagXQEuTqNbnmkMA4lEvAOJRLwDiUS8A4lEvAOJRLwDiyWWu7NxGmqblXgKEVygUyr0E2j8/79VYsVgsbTCfz5drtmZKbWmzA6ZWz5p/VWmz40feYbZtZpvz/JblmIQ24MwhAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXQOnq6ury+fyIESPy+XxdXd0utt96661DhgyZPn16kiRbtmw5/fTTa2tL/FkI1AugWaZNmzZy5Minn3765JNPvuWWW3ax/Uc/+tEzzzwzY8aMJEnuuuuuc845p7q6uqxrj029AEr38MMPn3/++UmSnH/++b/97W93sb1z587/8R//0aVLl/fff3/u3LkTJkwo68LDUy+A0q1cufLAAw9MkuSggw5auXLlLrZPmzbtK1/5yi233DJlypTvfe97uVyurAsPT70A2sJFF120YMGCwYMHJ0lSU1Nz+umnP/jgg+VeVGB+zyFA6Q444IB33323d+/eK1asOOCAA3a9Pcuym2+++d577x02bNiCBQuGDx8+bty48q09Nq+9AEo3duzY++67L0mS++67b+zYsUmSrF27dofbkyS55557zjjjjF69eq1fvz7LsnXr1pV7+YGpF0DpvvOd78yfP3/EiBFPPfXUt7/97SRJzj777B1ur62tfeCBBy699NIkSa699trRo0dfd9115V5+YM4cApSuqqqq0Z+SmTdv3g63V1dXP/LIIw1v3/g3bbvS9sZrLwDiUS8A4lEvAOLJZVlW7jVUkDRNy70ECK9QKJR7CbR/rtporNE3Wpsun883Z7ZmSom/r3PA1OrmzM6af1Vps+NH3mG2bWab8/yW5XiGNuDMIQDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPGoFwDxqBcA8agXAPHksiwr9xoqSJqm5V4ChFcoFMq9BNq/TuVeQMUpFoulDebz+ebM1kypLW12wNTqWfOvKm12/Mg7zFb+bHOOjbIcz9AGnDkEIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgnlyWZeVeQwVJ07TcS4DwCoVCuZdA+9ep3AuoOMVisbTBfD7fnNmaKbWlzQ6YWj1r/lWlzY4feUfE2ebsq442W5bjGdqAM4cAxKNeAMSjXgDEo14AxKNeAMSjXgDEo14AxKNeAMSjXgDEo14AxKNeAMSjXgDEo14AxKNeAMSjXgDEo14AxKNeAMSjXgDEk8uyrNxrqCBpmpZ7CRBeoVAo9xJo/zqVewEVp1gsljaYz+ebM1szpba02QFTq2fNv6q02fEj74g425x9Va7nt0PNQhtw5hCAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B4clmWlXsNFSRN03IvAcIrFArlXgLtX6dyL6DiFIvF0gbz+XxzZmum1JY2O2Bqtdmmz5br+e1Qs9AGnDkEIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgnlyWZeVeQwVJ07TcS4DwCoVCuZdAB5CxjXw+X/KeNGvWbINyfx7TIThzCEA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDzqBUA86gVAPOoFQDy5LMvKvYYKkqZpuZcA4RUKhXIvgQ4gYxv5fL7kPWnWrNkG5f48pkNw5hCAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B41AuAeNQLgHjUC4B4clmWlXsNALB7vPYCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIB71AiAe9QIgHvUCIAnn/wIXNxxJtw6kZgAAAABJRU5ErkJggg=="
          },
          {
            "type": "input_text",
            "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
          }
        ]
      },
      {
        "type": "message",
        "role": "assistant",
        "content": [
          "The previous solution relied on scipy.ndimage functions (labeling and flood fill) which are not available in the execution environment. Without those, we must create an alternative approach using only standard Python and numpy.\n\n---\n\n**Refined understanding of the task:**\n\n1. The input contains polygonal outlines (connected lines) drawn in a unique color.\n2. Inside these outlines are some scattered colored pixels.\n3. The output reflects the same outlines but the interior is completely filled with a single color.\n4. The fill color chosen corresponds to a prominent interior color found inside that outline.\n5. Outlines must remain unchanged.\n6. The rest of the grid remains 0 (background).\n7. The output grid is the same size as input.\n\n---\n\n**Approach without scipy.ndimage:**\n\n- Use numpy for arrays and standard BFS/DFS for connectivity and flood-fill operations.\n- Identify outlines by finding connected components of nonzero pixels.\n- For each outline:\n  - Extract bounding box.\n  - Fill inside by polygon fill or flood fill, starting from some point inside the outline (e.g. center of bounding box).\n  - Determine fill color by the mode (most common) color of the interior pixels inside bounding box (excluding outline color and zero).\n- Construct final output replacing interior pixels with fill color while keeping outline color intact.\n\n---\n\n**Key Steps:**\n\n- Connected components extraction with BFS from all nonzero pixels.\n- For each component:\n  - Get pixels of component.\n  - Get bounding box.\n  - Find a seed position inside bounding box for flood fill that is not outline.\n  - Perform flood fill bounded by outline pixels.\n  - Determine fill color from input pixels inside flood fill.\n  - Fill flood fill area with fill color in output.\n- Maintain outline pixels as is.\n\nThis approach should generalize well.\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n    from collections import deque, Counter\n\n    grid = np.array(grid)\n    h, w = grid.shape\n    output = np.array(grid)  # start from input copy\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def neighbors(r, c):\n        for nr, nc in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\n            if 0 <= nr < h and 0 <= nc < w:\n                yield nr, nc\n\n    def bfs_component(sr, sc):\n        \"\"\"Get all connected pixels (4-dir) of nonzero pixels starting at (sr, sc).\"\"\"\n        q = deque()\n        q.append((sr, sc))\n        comp_pixels = []\n        visited[sr, sc] = True\n        while q:\n            r, c = q.popleft()\n            comp_pixels.append((r,c))\n            for nr, nc in neighbors(r,c):\n                if not visited[nr, nc] and grid[nr, nc] != 0:\n                    visited[nr, nc] = True\n                    q.append((nr, nc))\n        return comp_pixels\n\n    def flood_fill_inside(outline_set, start, outline_color):\n        \"\"\"Flood fill from start pixel inside the outline boundary.\n        outline_set: set of outline pixels (r,c)\n        fill inside only within bounding box limits.\n        Return set of filled pixels.\"\"\"\n        q = deque()\n        q.append(start)\n        filled = set()\n        filled.add(start)\n        while q:\n            r,c = q.popleft()\n            for nr,nc in neighbors(r,c):\n                if (nr,nc) in outline_set:\n                    continue\n                if (nr,nc) in filled:\n                    continue\n                # Must be inside bounding box and not on outline\n                # Also only fill pixels that are zero or inside area (not outside)\n                # We trust outline forms closed polygon so flood_fill won't leak outside\n                filled.add((nr,nc))\n                q.append((nr,nc))\n        return filled\n\n    # Find all connected components of nonzero pixels (likely outlines)\n    components = []\n    for r in range(h):\n        for c in range(w):\n            if grid[r,c] != 0 and not visited[r,c]:\n                comp = bfs_component(r,c)\n                components.append(comp)\n\n    # Process each component\n    for comp_pixels in components:\n        # Colors in component\n        comp_points = comp_pixels\n        comp_vals = [grid[r,c] for r,c in comp_points]\n        # Outline color: majority (likely uniform)\n        cnt = Counter(comp_vals)\n        outline_color, _ = cnt.most_common(1)[0]\n\n        # Make set of outline pixels for fast lookup\n        outline_set = set(comp_points)\n\n        # Get bounding box\n        rows = [p[0] for p in comp_points]\n        cols = [p[1] for p in comp_points]\n        rmin, rmax = min(rows), max(rows)\n        cmin, cmax = min(cols), max(cols)\n\n        # Find a seed point inside to flood fill from\n        # Try center point of bounding box\n        sr = (rmin + rmax) // 2\n        sc = (cmin + cmax) // 2\n\n        # If center is on outline, try to move inside (up to 10 steps)\n        found_seed = False\n        for dr in range(-5,6):\n            for dc in range(-5,6):\n                rr, cc = sr+dr, sc+dc\n                if rmin <= rr <= rmax and cmin <= cc <= cmax:\n                    if (rr, cc) not in outline_set:\n                        found_seed = True\n                        sr, sc = rr, cc\n                        break\n            if found_seed:\n                break\n        if not found_seed:\n            # Cannot find inside seed, skip filling this component\n            continue\n\n        # Get fill area by flood fill inside outline\n        fill_area = flood_fill_inside(outline_set, (sr, sc), outline_color)\n\n        # Determine fill color: most common nonzero color inside fill_area in input that is not outline_color\n        interior_colors = []\n        for (rr, cc) in fill_area:\n            v = grid[rr, cc]\n            # exclude outline color and zero\n            if v != 0 and v != outline_color:\n                interior_colors.append(v)\n        if interior_colors:\n            fill_color = Counter(interior_colors).most_common(1)[0][0]\n        else:\n            # If no other colors, as fallback try colors inside bounding box excluding outline pixels\n            # Just pick zero or outline_color otherwise\n            fill_color = 0\n\n        # Fill interior in output (keep outline pixels unchanged)\n        for (rr, cc) in fill_area:\n            output[rr, cc] = fill_color\n\n        # outline pixels remain unchanged, so nothing to do\n\n    return output.tolist()\n```"
        ]
      },
      {
        "role": "user",
        "content": [
          {
            "type": "input_text",
            "text": "Please analyze the training feedback and programs from all prior turns, and write an improved transformation.\n\n**Important**:\n1. Always start by attempting to find a complete rule that solves all training examples and should generalize to the test input.\n2. If you cannot find a perfect solution, provide your best attempt at a transformation that solves as many training examples as possible - ideally more than in the best previous turn.\n3. Even if your solution doesn't solve all examples perfectly, ensure it demonstrates meaningful pattern recognition and provides reasonable outputs that minimize pixel-level errors.\n\nFinal answer:\n```python\ndef transform(grid):\n    # Your improved transformation logic here (even if partial)\n    return transformed_grid\n```"
          },
          {
            "type": "input_text",
            "text": "Training results: 0/3 examples solved, 21.4% pixel accuracy - Good partial progress! Your approach is capturing some patterns. Next, try to identify a transformation that solves at least one of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 1, 1, 1, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]]\nPixel accuracy: 6.3%\n\nTraining Example 2 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 6, 6, 6, 0, 0], [0, 0, 2, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 2, 2, 2, 3, 3, 3, 3, 3, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 6, 6, 6, 6, 6], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]]\nPixel accuracy: 9.4%\n\nTraining Example 3 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 3, 3, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 3, 3, 6, 6, 6, 6, 6, 6, 3, 3, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 3, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0], [0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 3, 0, 0, 0, 8, 0, 0, 8, 0, 3, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 0, 3, 0, 6, 0, 0, 2, 0, 0, 3, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 3, 0, 0, 0, 0, 6, 0, 0, 0, 3, 0, 0], [0, 0, 3, 0, 0, 6, 0, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 69.6%\n\n"
          },
          {
            "type": "input_image",
            "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA88AAAUtCAIAAABNteEnAABTSElEQVR4nO3de5xVdb3w8bVxGETBGaUyEaiQRHvxeMm7qaHwvFLwsndgPZp64KCmhRQImufF0fJgmvBo0cV8UkAzypO1tpfMQ55E8ihlSt41EvQgox5vgyLIRdbzqulMHBCCPfOdNZv9fr/6Y9yzv3v9Zs1ei0+btTeFLMsSAAAgQJeIBwUAANQ2AAAEUtsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAnbK2x44dW9i000477T3vU19f/8EPfvDEE098+OGHN37MX/3qV4VCYZdddnnnnXc2+NYtt9xSKBSuu+66lv8cNWpUoVCYOnXqBnd74YUXCoXC5MmT2zLV4p133rn22muPPvro3r17d+vWrXfv3ieffPJvfvObzeyTyZMnb2qHPP7445vfaUOHDv27O7b1Pmeeeeb6t7csb8SIEQ888MD66ykWixvc7SMf+ci4cePeeOONrdr5LV599dUpU6bsv//+DQ0NO+6448EHH3zddddlWbbB5jYYf+ihh97//vf37Nnznnvu2cyuAwDY9uTw2vaaNWtefvnl22+//eijj160aNEG350xY0aSJG+88cbNN9+8JY928cUXP/3001u7hi2Zeu655w477LBzzjln7ty5L7744urVq1988cVbbrnlqKOOuuqqq5JOpmV5P//5z4844ogf/ehHm7nbc8899+1vf/vYY49dt27dVu38Bx54YN999/3nf/7nP/zhD2+++eaKFSsefPDBs846a8yYMZtZ2K9//eujjz763Xffvfvuu48++ug2/IgAADVW29/5zney//bTn/40SZKZM2e23nLTTTe13nPx4sWtt7/zzjtPPfXUqaee+uabb15zzTXrP2Bzc3O5XD755JN32WWX73//+1uyhtWrV48aNerdd9/dqpX/3ak1a9aMHDnyD3/4w+GHH37bbbe9+uqra9as+c///M/vfe97u+yyywUXXNDyQvWmLFiwINvIoEGD3nOHtLr77rvXf5Atuc+LL77YcvvKlSv/9Kc/feUrX8my7B//8R+ff/759e+2cuXK9Xf+0KFDf/e73/3qV7/a8p3/X//1X6VSqamp6ZRTTpk/f/6bb775+uuvl8vl/v37z5w589prr33P/ZCm6bBhw3bYYYe5c+cecsghm9ljAADbpBxe2+7Wrdtee+31jW98I0mSDV7bnj179jvvvPP5z39+9OjR8+fPf/TRR//uo5133nm//e1v/+///b9btYa/O3XDDTc89NBDQ4cOnTdv3gknnNCrV6+6urq+ffuee+65P//5z999990f//jHSWey/fbb77HHHpdffvnFF1+8evXqb37zm5vZ+V/+8pdbSn3Ld/5VV1318ssvjx8/fvbs2YccckjPnj133nnnk0466d57791xxx2vuuqq9a8naXH99deffPLJH/jAB37zm9/ss88+rbfPmjWrUCh85zvfadcdAADQGeVQ26tWrXriiScmTJiQJMmee+65/rdmzpy59957H3PMMeeee+522223JS9vf/3rXx8wYMDFF1/81FNPbfka/u7U7NmzC4XC//t//2+77bbb4Fuf/OQnn3zyySlTpiSd0vnnn7/DDjv827/923t+d82aNX/84x+nT59eV1f3yU9+cst3/r/+679279790ksv3eAB+/Tpc999982dO7dQKKx/+5VXXnnmmWf279//vvvu++hHP9p+Px8AQDXpoNr+yEc+0vpGve23337QoEE//elP3/e+933pS19qvc/jjz/++9//ftKkSYVCYY899jj55JN/9KMfLV++fPOPvMMOO8ycOXPNmjVbdT3J351asGDB3nvv/ZGPfOQ9x/fee+8N4nID+++//wbvbrzvvvs2tUNazZ07d2vvs7GePXt+9KMf3eAvDbp3794yXl9fP3DgwP/4j/+44YYb1v/pNr/z16xZ89xzzx188ME9evTYeIv77bffbrvttv4tF1xwwYUXXpgkyZFHHtmvX78N7j9q1Kgsy8aOHbv5HwQAYBuQzycA7r777v/4j//4yCOPfPCDH2y9ccaMGbvvvvvnPve5lv+86KKL3nrrrS25YOOII44YN27c7373u2nTpm35GjYztWbNmubm5l133XX9Gzf4nJAPf/jDSWfVq1evVX+xqTu8++678+fPX7NmzRbu/Obm5izLevXqtYUL+Pa3v33YYYcNHTp0xowZP//5z9v20wAAVLEOqu2WN/ytXr36Jz/5ScuLr1dccUXv3r1b77BmzZqbbrpp6dKl3bp1a8nZfffdN8uyLXyv5Ne//vWPfvSjl1xyyZNPPrnlq9rUVNeuXXv27PnKK68kldr4XZJHHHHE330H5ODBg7f2Pu/pjTfe6Nq1a7du3TZ+l+Tq1asXLVr0xS9+8dvf/vbEiRO3cOfvsssuXbp02fIdMnr06Llz595444277LLLWWedtXTp0i0cBADYxnToa9tdu3b97Gc/e/PNN997773HHnvs+p/KfMcdd7xnzD388MMPPvjg333k7t27V3A9yWam/tf/+l9PPvnkf/7nf77nB7AccMABSWe1fPnyxx9/fO+9937P73bt2vUjH/nItGnTBg0aNGvWrC3c+dttt93ee+/9+9//fsWKFRvf7fLLLz/jjDOamppab/ne975XX1+/2267fec733n99dfPOOOMjT9tEACgFuRwJclxxx133nnnPfzww62vrbZcybD99tsvW7Zs/ddx77///iRJNvXpchv4xCc+8aUvfenBBx/c+F+uqWDqc5/73Lp1677whS+8Z7tv/PkbncfVV1+9Zs2aY489dvN369Kly/Lly9euXbuFO79YLK5cufKrX/3qBo/z3HPPXXnllXfcccd7XmdyyimnjBw58te//vVWXeQDALDNyOe67a9//ev9+vW75pprfvvb3yZJ8tJLL911110nnHDCTjvttP7dDjvssIEDB/74xz9etmzZljzsZZdd9tGPfvR73/veVi3mPafOPPPMAw444Be/+MXBBx/8r//6ry+99NKaNWta/nWb4cOHP/zww126dK5/9H7VqlXPPPPM5MmTv/a1r+2www6beg9ilmUvvPDCpEmTHn300f3337+urm4Ld/748eN79eo1derUM8444/e///3KlStffvnl2bNnDx48uLm5edKkSetfuLK+a665Ztddd508efJDDz0U86MDAHRe+STjjjvu+O1vf3vdunWf//zn165de+ONN65du7b1LXrr+4d/+IcVK1b88Ic/3PIrQzb/aSFbOFVfX18ulw877LCHH374s5/97G677VZfX9/yL7ffeeedAwcO3MJ/6nJT3vPzRgqFwvqfwbIl99ltt91aP+llr732uuyyy1r+mfq+fftu8DO23K1Lly59+/adNm1aly5dWj7EcAt3fq9evW6++eaePXv+8Ic/POigg3bYYYcPfvCDn/vc555//vlSqXTBBRds6id93/ve94Mf/GDNmjWnnnrq22+/7fO2AYCaktsLtCeeeGKxWHzkkUe++c1vzpo1a+eddz7uuOM2vtsZZ5zRpUuXLbyYpOXKkJZ/umWrvOdUnz59fvOb39x0003Dhg3r06dPfX39rrvuOmzYsBtuuOHxxx8/6KCDks6ka9euffv2/T//5//8x3/8xymnnLKpu2233XYf+MAHhg8f/qtf/arlapMt3/lDhgxZsGDBuHHj9tprrx49enTv3v2QQw657rrrfvazn238qeTrO+GEE0aNGvXHP/5x/Q98BACoBYXOfAkyAABUtc518TEAAGxL1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLVNFXvttdeefvrpvFcBsM1ymoW2U9u0jz59+hQ2ctNNN4VudOjQofPnz9/y+0+bNu3QQw/d1Hebm5v79++/VQ8I0DHe9773tZ5a6+vr99577+nTp1f8aK0nw+bm5kKhsJmedpqFtlPbtJurr746+59OO+200C2uXLmyvR5qyZIlQ4cOXbx4cXs9IED7uuaaa1pOrW+//fbUqVMnTpz4wx/+sI2P2djYmGXZXnvttak7OM1C26ltYl1//fXdunVbsmRJkiSvvPLKTjvtNHPmzFdffbVQKFx//fV9+vRpaGgYM2ZM6wn9xRdfHDlyZI8ePfr27TthwoTW25cuXVoqlXr27Pn+97//C1/4wqpVqwYPHvzMM8+MHj36zDPP3MzgE088ceSRR3bv3v3www/f1Fn+F7/4xaBBgw444ICO2isAlevatevxxx8/ZMiQNE1feumlQqFw0UUXNTQ0jBo1amtPhuu/tu00C0HUNrHGjBlzxBFHXHHFFUmSXHbZZQceeODo0aNbvnXllVfeddddCxYseOihh8aOHdty44gRI3r27Pncc8/de++9Dz744Pjx45Mkeffdd4877rj6+vpnn332gQceeOyxxy655JK5c+cOHDhw5syZ11133aYG33nnnWHDhu27775NTU0XXXTRzJkz33OR3bp1u/vuu7/73e924I4BaJO1a9f26NGj5eunn376hRdeuPTSSys+GTrNQqAN/uofKrP77rtv8NTabrvtWr61cOHCxsbGq666qqGhYeHChVmWvfLKK0mSpGnacoc5c+bU19cvX7783nvv3WGHHVatWtVy+4MPPtilS5eVK1fee++99fX1r7322gYbbfljIMuyTQ2Wy+WGhoYVK1a03H722Wcfcsghm/oR1qxZkyTJAw88ELB7ANqkV69erVeSNDc3z5w5s0uXLnfccceLL76YJMmdd97Z8q2tPRm+8cYbSZI89dRTTrMQx2vbRF23vXbt2pbbBwwYMGnSpAkTJpx//vkDBgxovX/rO2n222+/1atXP/vss08++eSKFSu6devW8k6ggw46aN26dYsWLXriiSf69Omzyy67bGrTmxp88skn99hjj+7du7fcbf/99w/eBwBRzj333JZT3K677jpt2rTvfve7w4cPb/lWv3792ngydJqFOGqbjvD4448nSfLwww+vf2PXrl1bvnj33XeTJKmrq1u7du2AAQM2+H+EH/vYx7p27VooFDbz+Jsa3OBurVsEqDqtr22/8847jz/++DnnnNP6rW7durXxZOg0C3HUNuF++ctf3nzzzVOnTr311lvL5XLr7Y8++mjLFwsWLOjRo8cee+yx1157LV68+IUXXtjgEfbcc88lS5a0/I3n+lr/bNjU4KBBgxYuXPj222+3/Odjjz3W3j8cQCdS8cnQaRbiqG1iLV++/Jxzzhk3btzEiRPPOuussWPHvvXWWy3fuuCCCxYvXrxw4cILL7zw7LPP7tat2zHHHLPPPvuMHj16yZIlS5cu/fKXv9yvX79Vq1YdeeSRgwYNOu+881599dXnnntuxIgRp5xySpIkO+64Y1NT01tvvbWpwU996lO77bbbl770pddff/3uu++eMWNG3vsDIFDFJ0OnWYijtmk348eP3+BftznnnHP+6Z/+qUuXLlOmTEmSZOrUqV26dPmnf/qnlvsPHTr06KOPPuSQQ/73//7fLR9a0qVLl3K5vOOOO+69994f+9jHnnnmmTlz5rRcJvizn/3s9ddf79u374EHHrjTTjtde+21SZKcc845l19++ejRozc1WF9f/8tf/vK5557bfffdx48ff9ZZZ+W9kwACVXwydJqFOIUsyyoeLpVK7boYasXq1avvvPPOIUOG9OzZM++1wN+Xpmku23WOBWpB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ydKlf/5f3ly3DQDAtuWmm5KLLkruuivpBNQ2AADbltGjk1mzkhNOSDoBtQ0AwDakb9+ke/ckTf/8xe67570an0kCAMC25OCDk5deSo466s+fSXLooXmvRm0DALAtKeT8kX8bcCUJAACdVZZV+3bVNgAARFHbAAAQRW0DANCJZVlVb1FtAwBAFLUNAEDnlmXVuy21DQAAUdQ2AACdXpZV6VbUNkB72m+//ZYuXZokyapVq/bcc8/p06fvv//+H//4x+fMmZP30gCqXJZV4+OrbYD2NHLkyNtuuy1JknvuuefYY4+dMmXKvHnzZs+efdNNN+W9NIDql2VV98hqG6A9nXzyybfeemuSJLfffvtnPvOZYcOGnXHGGUuWLLnxxhvzXhrANiHLqutVc7UN0J4GDhz42muvvfnmmwsWLPjEJz4xa9as8ePHX3PNNaNHj857aQDbiiyrogtU6kIfHaAGnXTSSVdcccXBBx/85ptvnnjiiXffffcBBxzQv3//vNcFsA3JsqRQaJ/HCVbI2rCNUqnUrosB6IzSNN2q+z/zzDP77LPPPffcc/jhh0+dOvUnP/nJunXrxowZM3bs2K16HOdYoBakW3mO3VDFzd1Rn+Hd1toul8uVzRaLRbNbMTvgGxXO/unCmputwt/vosnNlc32n9JodstnK/4dteU82RalUild1lThbENvs2bNmq2K2eTXv03abquau2PP6q4kAQCgymXZ38/unF46UdsAAGwrsnySejN8JgkAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBQfdatWzdu3LjDDjvsqKOOWrRoUevtK1as+OxnPzt48OADDjjgF7/4RZIkV1xxxaBBg6ZOndoyNXz48Obm5g5bp9oGAKD6fP/73+/Zs+cDDzwwfvz4iRMntt7+ne9856CDDpo7d+4dd9zxxS9+MUmSb33rW/fff/9VV12VJMl11103YsSIxsbGDltnIcuyiodLpVK7LgagM0rTNJftOscCtSCt9Bz7iU984oYbbhgwYMDq1au/+c1vXnDBBS23v/HGGzvuuGN9ff3dd9997rnnLly4sF+/fr/+9a+HDBmyYMGC008//Y477igUCklHqWvjfLlcrmywWCxW5eyAb1Q4+6cL85o99dRTK5udPXt2XrNt2lfV+Lwy27lnc5Qua6pssNTQ26xZs2arYrZif/zjH2/7i5133vnqq69uvX3nnXdOkuT000//+c9/fttttyVJctlll5122mmXX3755MmTv/a1r3VkaruSBACAqrR69eoPfehDc+fOPe2008aMGbPBd3/4wx/Onj37hhtuaCnv+fPnDxw4MEmSRYsWDR8+/JZbbumwdaptAACqz6677losFlv+9vLRRx9tvf28885bu3ZtkiTHH398y7skkyTJsuziiy/+l3/5lwsuuOD6669vveykA6htAACqzzHHHDNv3rwkSebNm7fvvvsmSbJ8+fIkSZYtW9Zy6eD999/f8np2kiQzZsw44YQTevXqtXLlyizLVqxYUTXXbQMAQMe79NJLx4wZc+mll9bV1V177bVJknz605+eM2fOlClT/uEf/uHb3/52fX39jBkzkiRpbm7+6U9/eueddyZJMn78+KFDh55//vkdtk61DQBA9fnABz5w++23r3/LnDlzkiTp16/fPffcs/7tjY2Nd911V8vXX/mLjlynK0kAACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACBKIcuyiodLpVK7LgagM0rTNJftOscCtSDN6RzbYeraOF8ulysbLBaLVTk74BsVzv7pwlNPPbWy2dmzZ9fabFv2c1U+r8x27tkcpcuaKhssNfQ2a9as2aqY3ea5kgQAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiFLIsqzi4VKp1K6LAeiM0jTNZbvOsUAtyOsc22Hq2jhfLpcrGywWi1U5O+AbFc7+6cJTTz21stnZs2fX2mxb9nNVPq/Mdu7ZHKXLmiobLDX0NmvWrNmqmN3muZIEAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIhSyLKs4uFSqdSuiwHojNI0zWW7zrFALUhzOsd2mLo2zpfL5coGi8ViVc4O+EaFs3+68NRTT61sdvbs2bU225b9XJXPK7OdezZH6bKmygZLDb3NmjVrtipmt3muJAEAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAohSyLKt4uFQqtetiADqjNE1z2a5zLFAL0pzOsR2mro3z5XK5ssFisViVswO+UeHsny489dRTK5udPXt2rc22ZT9X5fPKbOeezVG6rKmywVJDb7NmzZqtitltnitJAAAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAohSzLKh4ulUrtuhiAzihN01y26xwL1II0p3Nsh6lr43y5XK5ssFgsVuXsgG9UOPunC2tt9tRTT61sdvbs2W1aczU+r8x27tkcpcuaKhssNfQ2a9as2aqY3ea5kgQAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiFLIsqzi4VKp1K6LAeiM0jTNZbvOsUAtSHM6x3aYujbOl8vlygaLxaLZKpgd8I0KZ/90YW6z1bifzXbu2Ryly5oqGyw19DZr1qzZqpjd5rmSBAAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIUsiyrOLhUqnUrosB6IzSNM1lu86xQC1IczrHdpi6Ns6Xy+XKBovFolmzZs1WxWyO0mVNlQ2WGnqbNWvWbFXMbvNcSQIAAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARClkWVbxcKlUatfFAHRGaZrmsl3nWKAWpDmdYztMXRvny+VyZYPFYtGsWbNmq2I2R+mypsoGSw29zZo1a7YqZrd5riQBAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKIUsiyreLhUKrXrYgA6ozRNc9mucyxQC9KczrEdpq6N8+VyubLBYrFo1qxZs1Uxm6N0WVNlg6WG3mbNmjVbFbPbPFeSAABAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABRClmWhT04AADUNK9tAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2/AeXnvttaeffjrvVQBsEacs6MzUNp1dnz59Chu56aabQjc6dOjQ+fPnb/n9p02bduihh258+8KFC48//vjGxsbddtvt85///JtvvtmuywQ6l/e9732tp6n6+vq99957+vTpFT9a64mlubm5UChspqedsqAzU9tUgauvvjr7n0477bTQLa5cubLtD7JmzZrjjz/+wx/+8OLFi3/zm9889NBD55xzTnusDui8rrnmmpbT1Ntvvz116tSJEyf+8Ic/bONjNjY2Zlm21157beoOTlnQmaltqtX111/frVu3JUuWJEnyyiuv7LTTTjNnznz11VcLhcL111/fp0+fhoaGMWPGtP4h9OKLL44cObJHjx59+/adMGFC6+1Lly4tlUo9e/Z8//vf/4UvfGHVqlWDBw9+5plnRo8efeaZZ25m8IknnjjyyCO7d+9++OGHL168eOMVPvjgg4sWLbrqqqt23nnnAQMGXHLJJbfeemuWZR24k4DcdO3a9fjjjx8yZEiapi+99FKhULjooosaGhpGjRq1tSeW9V/bdsqCqqO2qVZjxow54ogjrrjiiiRJLrvssgMPPHD06NEt37ryyivvuuuuBQsWPPTQQ2PHjm25ccSIET179nzuuefuvffeBx98cPz48UmSvPvuu8cdd1x9ff2zzz77wAMPPPbYY5dccsncuXMHDhw4c+bM6667blOD77zzzrBhw/bdd9+mpqaLLrpo5syZG6/w8MMPX7NmTX19fct/vvjii7vsskuhUOjAnQTkbO3atT169Gj5+umnn37hhRcuvfTSik8sTllQlTb4C3robHbfffcNnrTbbbddy7cWLlzY2Nh41VVXNTQ0LFy4MMuyV155JUmSNE1b7jBnzpz6+vrly5ffe++9O+yww6pVq1puf/DBB7t06bJy5cp77723vr7+tdde22CjLX90ZVm2qcFyudzQ0LBixYqW288+++xDDjlkMz9Fc3PzRz7ykUsuuaS9dw/QifTq1av1SpLm5uaZM2d26dLljjvuePHFF5MkufPOO1u+tbUnljfeeCNJkqeeesopC6qR17apvuu2165d23L7gAEDJk2aNGHChPPPP3/AgAGt9299989+++23evXqZ5999sknn1yxYkW3bt1a3r100EEHrVu3btGiRU888USfPn122WWXTW16U4NPPvnkHnvs0b1795a77b///ptZ/9tvv33CCScMGjRo8uTJ7bRLgE7q3HPPbTld7LrrrtOmTfvud787fPjwlm/169evjScWpyyoRmqb6vb4448nSfLwww+vf2PXrl1bvnj33XeTJKmrq1u7du2AAQM2+P+aH/vYx7p27br5vyfd1OAGd2vd4sZee+21IUOG9OnT55Zbbqmrq2vbjwt0dq2vbb/zzjuPP/74+m807NatWxtPLE5ZUI3UNlXsl7/85c033zx16tRbb721XC633v7oo4+2fLFgwYIePXrssccee+211+LFi1944YUNHmHPPfdcsmRJy9/Srq/1z7NNDQ4aNGjhwoVvv/12y38+9thj77nCF1544YgjjjjqqKN+9KMftV4NCdS4ik8sTllQjdQ21Wr58uXnnHPOuHHjJk6ceNZZZ40dO/att95q+dYFF1ywePHihQsXXnjhhWeffXa3bt2OOeaYffbZZ/To0UuWLFm6dOmXv/zlfv36rVq16sgjjxw0aNB555336quvPvfccyNGjDjllFOSJNlx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0djYmNOqq0Mhy7KklpRKpbyXAFSZNE1z2a7zFdBh56v3v//9L7300nbbbffuu+9+7GMfe+aZZ9b/7he/+MVPfvKTZ599dnNzc79+/X79618PGTJkwYIFp59++h133FEoFNpp+dumuqT2lMvlygaLxaJZsxGz6bQKZ0sTq3K26n5HOUqXNVU2WGrobdas2Rqcrdg+++xz2223lUqlNE03uJLkvvvua2pq+sxnPnP22WcnSXLZZZeddtppl19++eTJk7/2ta9J7b/LlSQAALXuuuuuu/HGG48++ujnn3++vr6+9fZVq1ZNnDjxu9/9bustp59++vz58wcOHJgkyaJFi4YPH37LLbfktOrqUIuvbQMAsL4f//jHN998c319/cKFC9e/HOVnP/vZW2+9deqppyZJsnz58jPOOOPGG2/Msuziiy++8cYbDzjggPnz5x9++OEjR47Mdfmdmte2AQBq3e9///s777wzSZJZs2adcsopLW2dJMmpp576xBNPzP2LHj163HjjjUmSzJgx44QTTujVq9fKlSuzLFuxYkXey+/U1DYAQK278sorp02bdthhh7355pvnnntukiSf/vSn3/Oezc3NP/3pT1uu4R4/fvzQoUPPP//8Dl9vNXElCQBArRswYMB99923/i1z5szZ4D4tn6vd2Nh41113tdzylb/owGVWJa9tAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAlEKWZUktKZVKeS8BqDJpmuayXecroFrOV2xGXVJ7yuVyZYPFYtFsx8ym0yqcLU2sudl9p1Z4Yn1kUqkts21Zc9U9J3OULmuqbLDU0NusWbM1OEsn5EoSAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACBKIcuypJaUSqW8lwBUmTRNc9mu8xVQLecrNqMuqT3lcrmywWKxaLZjZtNpFc6WJhb3nVrhieaRSSWzWz7blt9R1T0nc5Qua6pssNTQ26xZszU4SyfkShIAAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIEohy7KklpRKpbyXAFSZNE1z2a7zFVAt5ys2oy6pPeVyubLBYrFotmNm02kVzpYmFvedWuGJ5pFJJbNbPtuW31HVPSdzlC5rqmyw1NDbrFmzNThLJ+RKEgAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgSiHLsqSWlEqlvJcAVJk0TXPZrvMVUC3nKzajLqk95XK5ssFisWi2Y2bTaRXOliYW951a4YnmkUkls1s+25bfUdU9J3OULmuqbLDU0NusWbM1OEsn5EoSAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACBKIcuypJaUSqW8lwBUmTRNc9mu8xVQLecrNqMuqT3lcrmywWKxaLZjZtNpFc6WJhb3nVrhieaRSSWzWz7blt9R1T0nc5Qua6pssNTQ26xZszU4SyfkShIAAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIEohy7KklpRKpbyXAFSZNE1z2a7zFVAt5ys2oy6pPeVyubLBYrFotmNm02kVzpYm1tzsvlMrPLE+MqnUltm2rLnqnpM5Spc1VTZYauht1qzZGpylE3IlCQAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQpZBlWVJLSqVS3ksAqkyaprls1/kKqJbzFZtRl9Secrlc2WCxWDRrNmI2nVbhbGliVc5W3e8oR+mypsoGSw29zZo1W4OzdEKuJAEAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAohSyLEtqSalUynsJQJVJ0zSX7TpfAdVyvmIz6pLaUy6XKxssFotmzZqtwdkcpcuaKhssNfQ2a9ZsDc7SCbmSBAAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIUsiyLOzBAQCgpnltGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2oZO5LXXXnv66afzXgVQIYcwsDG1De+tT58+hY3cdNNNoRsdOnTo/Pnzt/z+06ZNO/TQQze+/eWXXx45cuROO+3Ut2/fKVOmtOsaoQq8733vaz1s6+vr99577+nTp1f8aK0HWnNzc6FQ2ExPO4SBjdW9x23AX1x99dVf/vKXO3KLK1eubJfHOfXUU/v167dkyZKFCxced9xxH/zgB88888x2eWSoFtdcc80555yTJMmaNWv+7d/+7dOf/vTOO+98+umnt+UxGxsbsyzbzB0cwsDGvLYNW+f666/v1q3bkiVLkiR55ZVXdtppp5kzZ7766quFQuH666/v06dPQ0PDmDFjWv/QffHFF0eOHNmjR4++fftOmDCh9falS5eWSqWePXu+//3v/8IXvrBq1arBgwc/88wzo0ePbvljdVODTzzxxJFHHtm9e/fDDz988eLFG6/w2Wefveeee6ZNm9bQ0HDggQceffTR999/fwfuIehcunbtevzxxw8ZMiRN05deeqlQKFx00UUNDQ2jRo3a2gNt/de2HcLAFlLbsHXGjBlzxBFHXHHFFUmSXHbZZQceeODo0aNbvnXllVfeddddCxYseOihh8aOHdty44gRI3r27Pncc8/de++9Dz744Pjx45Mkeffdd4877rj6+vpnn332gQceeOyxxy655JK5c+cOHDhw5syZ11133aYG33nnnWHDhu27775NTU0XXXTRzJkzN17hHnvssW7dul69eq1du/bf/6JUKnXsToJOZ+3atT169Gj5+umnn37hhRcuvfTSig80hzCwFTLgvey+++4bHCzbbbddy7cWLlzY2Nh41VVXNTQ0LFy4MMuyV155JUmSNE1b7jBnzpz6+vrly5ffe++9O+yww6pVq1puf/DBB7t06bJy5cp77723vr7+tdde22CjLX9UZ1m2qcFyudzQ0LBixYqW288+++xDDjlkUz/CwIEDu3XrNnjw4FdeeSVgD0Hn1atXr2uuuabl6+bm5pkzZ3bp0uWOO+548cUXkyS58847W761tQfaG2+8kSTJU0895RAGtpzXtmGTrr766vWPlrVr17bcPmDAgEmTJk2YMOH8888fMGBA6/1b3+203377rV69+tlnn33yySdXrFjRrVu3lndrHXTQQevWrVu0aNETTzzRp0+fXXbZZVOb3tTgk08+uccee3Tv3r3lbvvvv/9m1v/000+/9tprO+yww/HHH99OuwSqxrnnntty+Oy6667Tpk377ne/O3z48JZv9evXr40HmkMY2HJqGyrx+OOPJ0ny8MMPr39j165dW7549913//we5Lq6tWvXDhgwYIP/j/uxj32sa9euhUJhM4+/qcEN7ta6xU3ZcccdJ0+e/Nvf/rapqanSnxWqUutr2++8887jjz/e8o7JFt26dWvjgeYQBrac2oat9stf/vLmm2+eOnXqrbfeWi6XW29/9NFHW75YsGBBjx499thjj7322mvx4sUvvPDCBo+w5557LlmypOVvpdfX+uf3pgYHDRq0cOHCt99+u+U/H3vssY2Xd9dddzU0NKxatarlP19//fXtttuusbGxbT80bIMqPtAcwsCWU9uwdZYvX37OOeeMGzdu4sSJZ5111tixY996662Wb11wwQWLFy9euHDhhRdeePbZZ3fr1u2YY47ZZ599Ro8evWTJkqVLl375y1/u16/fqlWrjjzyyEGDBp133nmvvvrqc889N2LEiFNOOaXldaympqa33nprU4Of+tSndtttty996Uuvv/763XffPWPGjI1XOHjw4A9+8IMTJkxYtmzZo48+OmnSpNGjR++www4dvqugs6v4QHMIA1thK67xhtp+l2SSJJ///OfPO++8D3/4w8uXL8+ybNmyZX379h07dmzLuyS/8pWvfOhDH9p5550nTJiwevXqlsd5/vnnTzrppB133HGnnXY69thjn3rqqZbbFy9efNxxx22//fa9evUaNWrUsmXLsiz7wQ9+0KNHjxEjRmxm8Nlnnx0yZMj2228/aNCgCRMmvOdbrP70pz8NGzZsp5126tev30UXXbRy5coO3HPQud4lub6Wd0m2vLm5xVYdaK3vknQIA1uusPkP6qfa+dyojrF69eo777xzyJAhPXv2zHsttL80TXPZruMXqvf4hb/ZijKnChWLxaRSZrfcsGHDctmu2Y6ZdfyaNVu9s3kdv9DKddsAABBFbUM7qK+vz3sJAEBnpLYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIUsiyLOzByV+pVMp7CVD10jTNZbuOX6je4xda1f3tS7ZR5XK5ssFisZjX7KLJzZXN9p/SaLbzz1bdczJHVbevHL/b/GzVPSchd64kAQCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiFLIsC3tw8lcqlfJeAlS9NE1z2a7jF6r3+IVWdX/7km1UuVyubLBYLOY1u2hyc2Wz/ac0zpo3rrLZUUdNN7vls235HVXdczJHtXb85rXmdFlTZbOlht5+R1u+3Vo7fqGFK0kAACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgCiFLMvCHpz8lUqlvJcAVS9N01y26/iF6j1+oVXd375kG1UulysbLBaLiyY3Vzbbf0pjXrOz5o2rbHbUUdPNbvlsW35HbXlO5jKbo1o7fqvuuVGlszX1O4LcuZIEAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIhSyLIs7MHJX6lUynsJUPXSNM1lu45fqN7jF1rV/e1LtlHlcrmywWKxuGhyc2Wz/ac0zpo3rrLZUUdNN9v5Z9vy3GjLczKX2Ro8fqvud1QsFvedWmFUPTKpVGtrrqnnBuTOlSQAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQJRClmVhD07+SqVS3kuAqpemaS7bdfxC9R6/0Krub1+yjSqXy5UNFovFRZObK5vtP6Vx1rxxlc2OOmq62c4/25bnRluek7nM1uDxW3W/I7NbNVtTzw3InStJAAAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAo/uV2AIAtUyhs8ltZ1qEroXqobQCASiN74/vIbv4ntQ0A0IbOfs8Rzc1/U9sAAO3R2RuPa268SxIAoJ1Tu90fh2qmtgEAwhJZcNc8tQ0AEBnHgru2qW0AgOAsFtw1rJC5fn+bViqV8l4CVL00TXPZruMXOvT47YAgFl01yWeSbPvK5XJlg8VicdHk5spm+09pzGt21rxxlc2OOmq62S2fzev325bnc8WzOaq14zeX328NztbU77dzvfZcKAjuGuRKEgAAiKK2AYDa1pEXVbuAu/aobQAAiKK2AYAa1vEvNnt5u8aobQAAiKK2AQAgitoGAGpVXhd1uJiklvi8bQCALZZlya23JmvXJl27JieeqJv5u7y2DQCwxX73u+SXv0xGjkxuuy2ZPz/v1VAF1DYAwBZbsiRZtSo59NBk6dI//w/+HrUNALA1bropueii5K678l4H1UFtAwBsjdGjk1mzkhNOyHsdVAe1DQCwxfr2Tbp3T9L0z1/svnveq6EK+EwSAIAtdvDByUsvJUcd9efPJDn00LxXQxVQ2wAAW8xH/rGVXEkCANSqLKut7ZIHtQ0AAFHUNgAARClk/i5jm1YqlfJeAlS9NE1z2a7jFzro+O3gS7GlV43xLsltX7lcrmywWCzmNbtocnNls/2nNM6aN66y2VFHTTfbMbNt+f3m8pzMUa0dv23Zbluek3ntq3RZU2WzpYbetfb7rcbjF1q4kgQAqG0d+WKzF7Zrj9oGAIAoahsAqHkd85KzF7ZrktoGaE/77bff0qVLkyRZtWrVnnvuOX369P333//jH//4nDlz8l4akGsKS+1apbYB2tPIkSNvu+22JEnuueeeY489dsqUKfPmzZs9e/ZNN92U99KA/IJYatcwtQ3Qnk4++eRbb701SZLbb7/9M5/5zLBhw84444wlS5bceOONeS8NyCmLpXZtU9sA7WngwIGvvfbam2++uWDBgk984hOzZs0aP378NddcM3r06LyXBuQRx1K75vm8bYB2dtJJJ11xxRUHH3zwm2++eeKJJ959990HHHBA//79814XsMWyrH3+yRupjdoGaHcnn3zyPvvsc8899zQ0NBx//PGHHnrounXr/vmf/znvdQFbH8oVN7fO5r+pbYB2NnDgwFWrVrV8Pekv8l4R0IHNrbP5n9Q2AMCWBfRmsltkswlqGwBgy0hqtp7PJAEAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAohQyn2WzTSuVSnkvAapemqa5bNfxC9V7/EIrn7e97SuXy5UNFovFvGYXTW6ubLb/lMZZ88ZVNjvqqOlmO2a2Lb/fXJ6TOaq147caf95am6263y/kzpUkAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0A8Ffr1q0bN27cYYcddtRRRy1atChJksWLF3/qU58aPHjw8ccf//LLL2/mnldcccWgQYOmTp3a8t3hw4c3N1f4gYlsS9Q2AMBfff/73+/Zs+cDDzwwfvz4iRMnJkly9tlnX3DBBXPnzh0/fvxXv/rVzdzzW9/61v3333/VVVclSXLdddeNGDGisbEx15+GTsG/bgMA8Fc/+tGPbrjhhiRJhg8fvnDhwiRJ/vCHPwwePDhJksGDB3/hC1/YzD27du36X//1X/X19a+//vqtt956xx135Pqj0Fl4bRsA4K/++Mc/3nbbbYMHD/7sZz/7mc98JkmSffbZ57bbbmv5R+DXv5Jk43tedtllp5122uWXXz558uSvfe1rhUIh1x+FzkJtAwD81erVqz/0oQ/NnTv3tNNOGzNmTMs1ITfeeOPRRx/9/PPP19fXb+aep59++vz58wcOHJgkyaJFi4YPH37LLbfk+tPQKbiSBADgr3bddddisZgkSbFYPOecc5Ik+fGPf3zzzTfX19cvXLgwTdPN3DNJkizLLr744htv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"
          },
          {
            "type": "input_text",
            "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
          }
        ]
      },
      {
        "type": "message",
        "role": "assistant",
        "content": [
          "The key insight from the training feedback is that the solution needs to clearly differentiate outlines from interiors, and fill the interiors with a single filled color corresponding to an interior color, without filling outside the outlines or over the outlines themselves. The last attempt did not do any filling and mostly returned input unchanged or incorrectly filled everything.\n\nTo improve this, I\u2019ll:\n- More robustly identify outline pixels per connected component.\n- Identify interior pixels as those enclosed by the outline (using a flood fill approach starting outside the outline to identify background, and define interior as non-outline pixels not reachable from outside).\n- Then fill only the interior pixels with the most frequent nonzero interior color.\n- Leave the outline and exterior pixels unchanged.\n\nThis approach matches the assumption the input polygons are closed loops, so inside vs outside can be separated by a flood fill from the outside.\n\nThis should produce correct hollow-to-filled polygon transformation matching training output examples.\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n    from collections import deque, Counter\n\n    grid = np.array(grid)\n    h, w = grid.shape\n    output = grid.copy()\n\n    # Step 1: Identify all nonzero connected components (these are candidate outlines)\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def neighbors(r, c):\n        for nr, nc in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\n            if 0 <= nr < h and 0 <= nc < w:\n                yield nr, nc\n\n    def bfs_component(sr, sc):\n        q = deque([(sr, sc)])\n        comp_pixels = []\n        visited[sr, sc] = True\n        while q:\n            r, c = q.popleft()\n            comp_pixels.append((r, c))\n            for nr, nc in neighbors(r, c):\n                if not visited[nr, nc] and grid[nr, nc] != 0:\n                    visited[nr, nc] = True\n                    q.append((nr, nc))\n        return comp_pixels\n\n    components = []\n    for r in range(h):\n        for c in range(w):\n            if grid[r, c] != 0 and not visited[r, c]:\n                comp = bfs_component(r, c)\n                components.append(comp)\n\n    # Helper: For a component, find outline pixels by checking neighbors outside component\n    def find_outline_pixels(component):\n        comp_set = set(component)\n        outline = set()\n        for (r, c) in component:\n            for nr, nc in neighbors(r, c):\n                if (nr, nc) not in comp_set:\n                    outline.add((r, c))\n                    break\n        return outline\n\n    # Step 2: For each component:\n    # - find outline pixels (on edges)\n    # - find bounding box\n    # - flood-fill from outside the bounding box to mark outside pixels (external background)\n    # - pixels inside bounding box that are not outline and not outside are interior\n    # - fill interior pixels with most common interior color (from input)\n    for comp in components:\n        comp_set = set(comp)\n        outline_set = find_outline_pixels(comp)\n\n        # Determine outline color as majority color in component pixels\n        colors_in_comp = [grid[r, c] for r, c in comp]\n        outline_color = Counter(colors_in_comp).most_common(1)[0][0]\n\n        rows = [r for r, c in comp]\n        cols = [c for r, c in comp]\n        rmin, rmax = max(min(rows), 0), min(max(rows), h - 1)\n        cmin, cmax = max(min(cols), 0), min(max(cols), w - 1)\n\n        # Create mask for bounding box: 0 = unknown, 1 = outline, 2 = component interior candidate\n        box_h = rmax - rmin + 1\n        box_w = cmax - cmin + 1\n        mask = np.zeros((box_h, box_w), dtype=np.int8)\n\n        for (r, c) in comp_set:\n            rr, cc = r - rmin, c - cmin\n            if (r, c) in outline_set:\n                mask[rr, cc] = 1  # outline\n            else:\n                mask[rr, cc] = 2  # possible interior\n\n        # Flood fill from outside bounding box on mask == 0 pixels to mark external background\n        visited_box = np.zeros_like(mask, dtype=bool)\n        q = deque()\n        # Initialize queue with bounding box edges that are 0 in mask (outside)\n        for rr in range(box_h):\n            for cc in [0, box_w - 1]:\n                if mask[rr, cc] == 0:\n                    q.append((rr, cc))\n                    visited_box[rr, cc] = True\n        for cc in range(box_w):\n            for rr in [0, box_h - 1]:\n                if mask[rr, cc] == 0:\n                    q.append((rr, cc))\n                    visited_box[rr, cc] = True\n\n        while q:\n            rr, cc = q.popleft()\n            for nr, nc in ((rr-1, cc), (rr+1, cc), (rr, cc-1), (rr, cc+1)):\n                if 0 <= nr < box_h and 0 <= nc < box_w:\n                    if not visited_box[nr, nc] and mask[nr, nc] == 0:\n                        visited_box[nr, nc] = True\n                        q.append((nr, nc))\n\n        # Interior pixels in bounding box: those with mask == 2 and not reachable from outside\n        interior_pixels = []\n        for rr in range(box_h):\n            for cc in range(box_w):\n                if mask[rr, cc] == 2 and not visited_box[rr, cc]:\n                    interior_pixels.append((rr + rmin, cc + cmin))\n\n        # Find fill color: majority nonzero color inside interior pixels in input\n        interior_colors = [grid[r, c] for r, c in interior_pixels if grid[r, c] != 0]\n\n        if interior_colors:\n            fill_color = Counter(interior_colors).most_common(1)[0][0]\n        else:\n            # Fallback: fill with outline color if no interior color found\n            fill_color = outline_color\n\n        # Fill interior pixels in output with fill color\n        for r, c in interior_pixels:\n            output[r, c] = fill_color\n\n        # Outline pixels remain unchanged, already in output\n\n    return output.tolist()\n```"
        ]
      },
      {
        "role": "user",
        "content": [
          {
            "type": "input_text",
            "text": "Please analyze the training feedback and programs from all prior turns, and write an improved transformation.\n\n**Important**:\n1. Always start by attempting to find a complete rule that solves all training examples and should generalize to the test input.\n2. If you cannot find a perfect solution, provide your best attempt at a transformation that solves as many training examples as possible - ideally more than in the best previous turn.\n3. Even if your solution doesn't solve all examples perfectly, ensure it demonstrates meaningful pattern recognition and provides reasonable outputs that minimize pixel-level errors.\n\nFinal answer:\n```python\ndef transform(grid):\n    # Your improved transformation logic here (even if partial)\n    return transformed_grid\n```"
          },
          {
            "type": "input_text",
            "text": "Training results: 0/3 examples solved, 82.3% pixel accuracy - Good partial progress! Your approach is capturing some patterns. Next, try to identify a transformation that solves at least one of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 1, 1, 1, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 5, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 0, 8, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 8, 0, 0, 8, 2, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 3, 0, 8, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 1, 1, 1, 0, 0, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 5, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 5, 0, 5, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 90.0%\n\nTraining Example 2 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 6, 6, 6, 0, 0], [0, 0, 2, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 2, 2, 2, 3, 3, 3, 3, 3, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 6, 6, 6, 6, 6], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 3, 0, 2, 0, 0, 6, 6, 6, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 6, 0, 3, 0, 0], [0, 0, 2, 2, 2, 0, 3, 0, 0, 0, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 6, 6, 6, 6, 6], [0, 0, 0, 0, 2, 0, 0, 0, 8, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 8, 0], [3, 0, 0, 0, 0, 0, 0, 4, 8, 0, 3, 0, 8, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 8, 0, 4, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 80.7%\n\nTraining Example 3 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 3, 3, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 3, 3, 6, 6, 6, 6, 6, 6, 3, 3, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 3, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0], [0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 3, 0, 0, 0, 8, 0, 0, 8, 0, 3, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 0, 3, 0, 6, 0, 0, 2, 0, 0, 3, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 3, 0, 0, 0, 0, 6, 0, 0, 0, 3, 0, 0], [0, 0, 3, 0, 0, 6, 0, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 69.6%\n\n"
          },
          {
            "type": "input_image",
            "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA88AAAUtCAIAAABNteEnAABUgklEQVR4nO3de5xVdb34/7URBlFwRtFUBEsk0R58RdO8kHJQ+D5S8LJ3YB1NPXBQ035IgaLZ4WT5xTQhO9HF/IZCpqQnT3t7OWbkN4UsKVPyrqGgIaDH26AIcl2/R01n4oAQ7Jn3rFns5/PhH+Oe/d5r7TV7fXi5XbMppGmaAAAAATpEPCgAAKC2AQAgkNoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAaJe1PWbMmMLmnXnmme97n7q6ur322uuUU0559NFHN33MX/ziF4VCYbfddnvvvfc2+tbtt99eKBSmTZvW9K8jR44sFAqTJ0/e6G4vv/xyoVCYOHFiS6aavPfee9dff/1xxx3Xo0ePzp079+jR47TTTvvVr361hWMyceLEzR2QJ598cssHbciQIX/3wDbf55xzztnw9qbdGz58+EMPPbTh/hSLxY3utt9++40dO/att97apoPf5PXXX580adKhhx5aX1+/8847H3HEEdOmTUvTdKPNbTT+yCOP7LHHHt26dbv//vu3cOgAALY/Gby3vWbNmldfffWuu+467rjjFixYsNF3b7zxxiRJ3nrrrdtuu21rHu3LX/7ys88+u637sDVTL7744tFHH33++ec/8MADS5cuXb169dKlS2+//faBAwdee+21STvTtHs//elPjznmmFtuuWULd3vxxRe//e1vn3DCCevXr9+mg//QQw/179//X//1X//whz+8/fbbK1asePjhh88999zRo0dvYcd++ctfHnfccevWrbvvvvuOO+64FjxFAIAaq+3vfOc76X/7yU9+kiTJ9OnTm2+5+eabm++5cOHC5tvfe++9Z5555owzznj77bevu+66DR+wsbGxUqmcdtppu+222/e///2t2YfVq1ePHDly3bp127Tnf3dqzZo1I0aM+MMf/jBgwIA777zz9ddfX7NmzZ/+9Kfvfe97u+222yWXXNL0RvXmzJs3L91Ev3793veANLvvvvs2fJCtuc/SpUubbl+5cuXzzz//xS9+MU3Tf/7nf37ppZc2vNvKlSs3PPhDhgz53e9+94tf/GLrD/5//dd/lUqlJUuWnH766XPnzn377bfffPPNSqXSu3fv6dOnX3/99e97HMrl8tChQ3faaacHHnjgyCOP3MIRAwDYLmXw3nbnzp0PPPDAr3/960mSbPTe9syZM997773Pfvazo0aNmjt37uOPP/53H+3CCy/87W9/+41vfGOb9uHvTv3whz985JFHhgwZMmfOnJNPPrl79+4dO3bs1avXBRdc8NOf/nTdunU//vGPk/Zkxx133H///a+66qovf/nLq1ev/rd/+7ctHPwvfOELTaW+9Qf/2muvffXVV8eNGzdz5swjjzyyW7duu+6666mnnjp79uydd9752muv3fB6kiY33HDDaaed9oEPfOBXv/rVwQcf3Hz7jBkzCoXCd77znVY9AAAA7VEGtb1q1aqnnnpq/PjxSZIccMABG35r+vTpBx100PHHH3/BBRfssMMOW/P29te+9rU+ffp8+ctffuaZZ7Z+H/7u1MyZMwuFwv/9v/93hx122Ohb//AP//D0009PmjQpaZcuuuiinXba6ec///n7fnfNmjV//OMfp06d2rFjx3/4h3/Y+oP/7//+7126dLniiis2esCePXs++OCDDzzwQKFQ2PD2a6655pxzzundu/eDDz744Q9/uPWeHwBAnrRRbe+3337Nv6i344479uvX7yc/+cnuu+/++c9/vvk+Tz755O9///sJEyYUCoX999//tNNOu+WWW5YvX77lR95pp52mT5++Zs2abbqe5O9OzZs376CDDtpvv/3ed/yggw7aKC43cuihh270240PPvjg5g5IswceeGBb77Opbt26ffjDH97ofxp06dKlabyurq5v376//vWvf/jDH2747LZ88NesWfPiiy8eccQRXbt23XSLhxxyyN57773hLZdccsmll16aJMmxxx677777bnT/kSNHpmk6ZsyYLT8RAIDtQDafALjPPvv88z//82OPPbbXXns133jjjTfus88+n/nMZ5r+9bLLLnvnnXe25oKNY445ZuzYsb/73e+mTJmy9fuwhak1a9Y0NjbuueeeG9640eeEfOhDH0raq+7du6/6i83dYd26dXPnzl2zZs1WHvzGxsY0Tbt3776VO/Dtb3/76KOPHjJkyI033vjTn/60Zc8GACDH2qi2m37hb/Xq1bfeemvTm69XX311jx49mu+wZs2am2++efHixZ07d27K2f79+6dpupW/K/m1r33twx/+8OWXX/70009v/V5tbqpTp07dunV77bXXkmpt+luSxxxzzN/9DchBgwZt633e11tvvdWpU6fOnTtv+luSq1evXrBgwf/3//1/3/72ty+++OKtPPi77bZbhw4dtv6AjBo16oEHHrjpppt22223c889d/HixVs5CACwnWnT97Y7der06U9/+rbbbps9e/YJJ5yw4acy33333e8bc48++ujDDz/8dx+5S5cuVVxPsoWp//W//tfTTz/9pz/96X0/gOWwww5L2qvly5c/+eSTBx100Pt+t1OnTvvtt9+UKVP69es3Y8aMrTz4O+yww0EHHfT73/9+xYoVm97tqquuOvvss5csWdJ8y/e+9726urq99977O9/5zptvvnn22Wdv+mmDAAC1IIMrSU488cQLL7zw0UcfbX5vtelKhh133HHZsmUbvo/7m9/8JkmSzX263EY+/vGPf/7zn3/44Yc3/Ztrqpj6zGc+s379+s997nPv2+6bfv5G+/HNb35zzZo1J5xwwpbv1qFDh+XLl69du3YrD36xWFy5cuVXvvKVjR7nxRdfvOaaa+6+++73vc7k9NNPHzFixC9/+cttusgHAGC7kc1121/72tf23Xff66677re//W2SJK+88sq999578skn77LLLhve7eijj+7bt++Pf/zjZcuWbc3DXnnllR/+8Ie/973vbdPOvO/UOeecc9hhh/3nf/7nEUcc8e///u+vvPLKmjVrmv52m2HDhj366KMdOrSvv/R+1apVzz333MSJE7/61a/utNNOm/sdxDRNX3755QkTJjz++OOHHnpox44dt/Lgjxs3rnv37pMnTz777LN///vfr1y58tVXX505c+agQYMaGxsnTJiw4YUrG7ruuuv23HPPiRMnPvLIIzFPHQCg/comGXfeeedvf/vb69ev/+xnP7t27dqbbrpp7dq1zb+it6F/+qd/WrFixY9+9KOtvzJky58WspVTdXV1lUrl6KOPfvTRRz/96U/vvffedXV1TX9z+z333NO3b9+t/KsuN+d9P2+kUChs+BksW3Ofvffeu/mTXg488MArr7yy6a+p79Wr10bPseluHTp06NWr15QpUzp06ND0IYZbefC7d+9+2223devW7Uc/+tHHPvaxnXbaaa+99vrMZz7z0ksvlUqlSy65ZHPPdPfdd//BD36wZs2aM84449133/V52wBATcnsDdpTTjmlWCw+9thj//Zv/zZjxoxdd931xBNP3PRuZ599docOHbbyYpKmK0Oa/uqWbfK+Uz179vzVr3518803Dx06tGfPnnV1dXvuuefQoUN/+MMfPvnkkx/72MeS9qRTp069evX6x3/8x1//+tenn3765u62ww47fOADHxg2bNgvfvGLpqtNtv7gDx48eN68eWPHjj3wwAO7du3apUuXI488ctq0af/xH/+x6aeSb+jkk08eOXLkH//4xw0/8BEAoBYU2vMlyAAAkGvt6+JjAADYnqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqmxx74403nn322az3AmC7ZZmFllPbtI6ePXsWNnHzzTeHbnTIkCFz587d+vtPmTLlqKOO2tx3Gxsbe/fuvU0PCNA2dt999+alta6u7qCDDpo6dWrVj9a8GDY2NhYKhS30tGUWWk5t02q++c1vpv/TmWeeGbrFlStXttZDLVq0aMiQIQsXLmytBwRoXdddd13T0vruu+9Onjz54osv/tGPftTCx2xoaEjT9MADD9zcHSyz0HJqm1g33HBD586dFy1alCTJa6+9tssuu0yfPv31118vFAo33HBDz5496+vrR48e3bygL126dMSIEV27du3Vq9f48eObb1+8eHGpVOrWrdsee+zxuc99btWqVYMGDXruuedGjRp1zjnnbGHwqaeeOvbYY7t06TJgwIDNrfL/+Z//2a9fv8MOO6ytjgpA9Tp16nTSSScNHjy4XC6/8sorhULhsssuq6+vHzly5LYuhhu+t22ZhSBqm1ijR48+5phjrr766iRJrrzyysMPP3zUqFFN37rmmmvuvffeefPmPfLII2PGjGm6cfjw4d26dXvxxRdnz5798MMPjxs3LkmSdevWnXjiiXV1dS+88MJDDz30xBNPXH755Q888EDfvn2nT58+bdq0zQ2+9957Q4cO7d+//5IlSy677LLp06e/70527tz5vvvu++53v9uGBwagRdauXdu1a9emr5999tmXX375iiuuqHoxtMxCoI3+1z9UZ5999tnopbXDDjs0fWv+/PkNDQ3XXnttfX39/Pnz0zR97bXXkiQpl8tNd5g1a1ZdXd3y5ctnz5690047rVq1qun2hx9+uEOHDitXrpw9e3ZdXd0bb7yx0Uab/hhI03Rzg5VKpb6+fsWKFU23n3feeUceeeTmnsKaNWuSJHnooYcCDg9Ai3Tv3r35SpLGxsbp06d36NDh7rvvXrp0aZIk99xzT9O3tnUxfOutt5IkeeaZZyyzEMd720Rdt7127dqm2/v06TNhwoTx48dfdNFFffr0ab5/82/SHHLIIatXr37hhReefvrpFStWdO7cuek3gT72sY+tX79+wYIFTz31VM+ePXfbbbfNbXpzg08//fT+++/fpUuXprsdeuihwccAIMoFF1zQtMTtueeeU6ZM+e53vzts2LCmb+27774tXAwtsxBHbdMWnnzyySRJHn300Q1v7NSpU9MX69atS5KkY8eOa9eu7dOnz0b/RfiRj3ykU6dOhUJhC4+/ucGN7ta8RYDcaX5v+7333nvyySfPP//85m917ty5hYuhZRbiqG3C/exnP7vtttsmT558xx13VCqV5tsff/zxpi/mzZvXtWvX/fff/8ADD1y4cOHLL7+80SMccMABixYtavo/nhtq/rNhc4P9+vWbP3/+u+++2/SvTzzxRGs/OYB2pOrF0DILcdQ2sZYvX37++eePHTv24osvPvfcc8eMGfPOO+80feuSSy5ZuHDh/PnzL7300vPOO69z587HH3/8wQcfPGrUqEWLFi1evPgLX/jCvvvuu2rVqmOPPbZfv34XXnjh66+//uKLLw4fPvz0009PkmTnnXdesmTJO++8s7nBT3ziE3vvvffnP//5N99887777rvxxhuzPh4AgapeDC2zEEdt02rGjRu30d9uc/7553/pS1/q0KHDpEmTkiSZPHlyhw4dvvSlLzXdf8iQIccdd9yRRx75v//3/2760JIOHTpUKpWdd975oIMO+shHPvLcc8/NmjWr6TLB//iP/3jzzTd79ep1+OGH77LLLtdff32SJOeff/5VV101atSozQ3W1dX97Gc/e/HFF/fZZ59x48ade+65WR8kgEBVL4aWWYhTSNO06uFSqdSqO0OtWL169T333DN48OBu3bplvS/w95XL5Uy2a40FakE5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5/r16zdr1qwePXosXrz4hBNOeOKJJ5ruuent++677y9/+cvBgwfPmzfvrLPOuvvuuwuFQhKsYwvnK5VKdYPFYjGXs32+XuXs85dmNXvGGWdUNztz5sysZlt0rPL4ujLbvmczlLtjVYNrbFbHqv/kKv8j8LEJpTw+X7Pb8ey2Ovjgg++8885SqVQul5uuJHn11Vf32muvJEn23nvvpluabHr7lVdeeeaZZ1511VUTJ0786le/2gap7UoSAADyZNq0aTfddNNxxx330ksv1dXVbdPsWWedNXfu3L59+yZJsmDBgmHDht1+++1JO39vGwAA2syPf/zj2267ra6ubv78+U1Xoey5556vvPJKjx49li5duueeezbf831vT9P0y1/+8k033XTYYYfNnTt3wIABI0aMCN1h720DAJAbv//97++5554kSWbMmHH66acnSTJ06NBbb701SZJbb7116NChSZIsX778fW9PkuTGG288+eSTu3fvvnLlyjRNV6xYEb3DahsAgNy45pprpkyZcvTRR7/99tsXXHBBkiT/8i//MmfOnGOOOeZXv/rVl770pSRJPvnJT77v7Y2NjT/5yU/OO++8JEnGjRs3ZMiQiy66KHqHXUkCAEBu9OnT58EHH9zwlvr6+o1+R3PWrFnve3tDQ8O9997b9PUX/6INdth72wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEKWQpmnVw6VSqVV3BqA9KpfLmWzXGgvUgnJGa2yb6djC+UqlUt1gsVjM5Wyfr1c5+/ylZ5xxRnWzM2fOrLXZlhznXL6uzLbv2Qzl7lhluMZmtc8tWuscZ7Nma4ArSQAAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKIU0TaseLpVKrbozAO1RuVzOZLvWWKAWZLXGtpmOLZyvVCrVDRaLxVzO9vl6lbPPX3rGGWdUNztz5sxam23Jcc7l68ps+57NUO6OVYZrbC6fr+Ns1mwNcCUJAABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsA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hQsXbrqHDz/88IIFC6699tpdd921T58+l19++R133JGmaRseJCAznTp1OumkkwYPHlwul1955ZVCoXDZZZfV19ePHDlyWxeWDd/btmRB7qht8mr06NHHHHPM1VdfnSTJlVdeefjhh48aNarpW9dcc8299947b968Rx55ZMyYMU03Dh8+vFu3bi+++OLs2bMffvjhcePGJUmybt26E088sa6u7oUXXnjooYeeeOKJyy+//IEHHujbt+/06dOnTZu2ucH33ntv6NCh/fv3X7JkyWWXXTZ9+vRN93DAgAFr1qypq6tr+telS5futttuhUKhDQ8SkLG1a9d27dq16etnn3325ZdfvuKKK6peWCxZkEsb/Q96aG/22WefjV60O+ywQ9O35s+f39DQcO2119bX18+fPz9N09deey1JknK53HSHWbNm1dXVLV++fPbs2TvttNOqVauabn/44Yc7dOiwcuXK2bNn19XVvfHGGxtttOmPrjRNNzdYqVTq6+tXrFjRdPt555135JFHbuFZNDY27rfffpdffnlrHx6gHenevXvzlSSNjY3Tp0/v0KHD3XffvXTp0iRJ7rnnnqZvbevC8tZbbyVJ8swzz1iyII+8t03+rtteu3Zt0+19+vSZMGHC+PHjL7rooj59+jTfv/m3fw455JDVq1e/8MILTz/99IoVKzp37tz020sf+9jH1q9fv2DBgqeeeqpnz5677bbb5ja9ucGnn356//3379KlS9PdDj300C3s/7vvvnvyySf369dv4sSJrXRIgHbqggsuaFou9txzzylTpnz3u98dNmxY07f23XffFi4slizII7VNvj355JNJkjz66KMb3tipU6emL9atW5ckSceOHdeuXdunT5+N/lvzIx/5SKdOnbb8/0k3N7jR3Zq3uKk33nhj8ODBPXv2vP322zt27Niypwu0d83vbb/33ntPPvnkhr9o2Llz5xYuLJYsyCO1TY797Gc/u+222yZPnnzHHXdUKpXm2x9//PGmL+bNm9e1a9f999//wAMPXLhw4csvv7zRIxxwwAGLFi1q+r+0G2r+82xzg/369Zs/f/67777b9K9PPPHE++7hyy+/fMwxxwwcOPCWW25pvhoSqHFVLyyWLMgjtU1eLV++/Pzzzx87duzFF1987rnnjhkz5p133mn61iWXXLJw4cL58+dfeuml5513XufO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ABBFbQMAQBS1DQBQo/7f//t/AwYMOO6444499tiHHnooSZJly5YVi8VjjjmmWCwuW7as+Z7/+I//OOgvBgwYsPvuuydJcvXVV/fr12/y5MlJkqxfv37YsGGNjY2ZPpt2qmPWOwAAQDZGjx59//3377fffi+88MLJJ5/89NNPX3nllQMHDhw/fvw3vvGNq6666uqrr26656233tr0xbRp0/70pz8lSfKtb33rueee69u374QJE6ZNmzZ8+PCGhoZMn007VUjTNKklpVIp610AcqZcLmeyXesVEL1eHXbYYddff/3hhx/+u9/97rTTTnvppZf69es3a9asHj16LF68+IQTTnjiiSc2vH+aph/96Ed//vOff+ADH9h3331/+ctfDh48eN68eWedddbdd99dKBRa+wltF9IaUywWqz5WZs0GzabPJ9X9k9PZrI5z1bM1uF5dPj+t7p88/nzNbtNsHtcc69UW/O53v+vcuXO/fv06d+581113pWm6++67r1u3Lk3TdevW7bHHHhvd/4477jj33HObvr7pppuOPPLIW2655YILLnj44YdbaeXbDrluGwCgRl188cW33HLLE0888aMf/einP/3p373/N77xjYsuuqjp67POOmvu3Ll9+/ZNkmTBggXDhg27/fbb43c5f1y3DQBQo5544ommi9Y++clPXnDBBUmS7Lnnnq+88kqPHj2WLl265557bnjn3/72tw0NDU153SRN0y9/+cs33XTTYYcdNnfu3AEDBowYMSKL59GueW8bAKBG9e3b99e//nWSJA899NCHPvShJEmGDh3a9AuRt95669ChQ5MkWb58edOdr7nmmuY3tpvceOONJ598cvfu3VeuXJmm6YoVKzJ6Hu2a97YBAGrU97///bFjx/75czMKhWnTpiVJ8i//8i//9E//9NOf/nT33Xf/4Q9/2PS296xZs55//vklS5YMHDiwebaxsfEnP/nJPffckyTJuHHjhgwZslGL00RtAwDUqP79+8+ePXvDW+rr6yuVyoa3zJo1K0mSPn36NH0gd7OGhoZ777236esv/kWb7HL+uJIEAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiFNI0TWpJqVTKeheAnCmXy5ls13oF5GW9Ygs6JrWnUqlUN1gsFs22zWx5SpWzpYtrbrb/5CoX1scmlFoy25J9zt1rMkO5O1Y1OJvHdSOr2Tz+jHL3mqQdciUJAABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABClkKZpUktKpVLWuwDkTLlczmS71isgL+sVW9AxqT2VSqW6wWKxaLZtZstTqpwtXVzsP7nKheaxCSWzWz/bkp9R7l6TGcrdsarB2Zo6F3I6m9XPqCVrbB7XKzbHlSQAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQJRCmqZJLSmVSlnvApAz5XI5k+1ar4C8rFdsQcek9lQqleoGi8Wi2baZLU+pcrZ0cbH/5CoXmscmlMxu/WxLfka5e01maMHExuoGe09qyN1xzulsVutVS/Y5q9dVVs/XekW2XEkCAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAEQppGma1JJSqZT1LgA5Uy6XM9mu9QrIy3rFFnRMak+lUqlusFgsmm2b2fKUKmdLFxf7T65yoXlsQsns1s+25GeUu9dkhnJ3rGpwtqbOhZzO1tTPiHbIlSQAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQJRCmqZJLSmVSlnvApAz5XI5k+1ar4C8rFdsQcek9lQqleoGi8Wi2baZLU+pcrZ0cbH/5CoXmscmlMxu/WxLfka5e01mKHfHqgZna+pcaOFsS9YcPyPyy5UkAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAECUQpqmSS0plUpZ7wKQM+VyOZPtWq+AvKxXbEHHpPZUKpXqBovFotm2mS1PqXK2dHHNzfafXOXC+tiEUktmW7LPuXtNZih3x6pYLC6Y2FjdbO9JDXl8vnlcN7KazePPKHevSdohV5IAAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFEKaZomtaRUKmW9C0DOlMvlTLZrvQLysl6xJWmNKRaLSbXMmg2aTZ9Pqvsnp7NZHeeqZ61XZs02z+ZxzbFekS1XkgAAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUQppmia1pFQqZb0LQM6Uy+VMtmu9AvKyXrElaY0pFotJtcyaNVubs9Yrs2bN5mU2q/WKLXAlCQAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQpZCmadiDAwBATfPeNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ3tyBtvvPHss89mvRdAlZzCwKbUNry/nj17FjZx8803h250yJAhc+fO3fr7T5ky5aijjtr09ldffXXEiBG77LJLr169Jk2a1Kr7CDmw++67N5+2dXV1Bx100NSpU6t+tOYTrbGxsVAobKGnncLApjq+z23AX3zzm9/8whe+0JZbXLlyZas8zhlnnLHvvvsuWrRo/vz5J5544l577XXOOee0yiNDXlx33XXnn39+kiRr1qz5+c9//slPfnLXXXc966yzWvKYDQ0NaZpu4Q5OYWBT3tuGbXPDDTd07tx50aJFSZK89tpru+yyy/Tp019//fVCoXDDDTf07Nmzvr5+9OjRzX/oLl26dMSIEV27du3Vq9f48eObb1+8eHGpVOrWrdsee+zxuc99btWqVYMGDXruuedGjRrV9Mfq5gafeuqpY489tkuXLgMGDFi4cOGme/jCCy/cf//9U6ZMqa+vP/zww4877rjf/OY3bXiEoH3p1KnTSSedNHjw4HK5/MorrxQKhcsuu6y+vn7kyJHbeqJt+N62UxjYSmobts3o0aOPOeaYq6++OkmSK6+88vDDDx81alTTt6655pp777133rx5jzzyyJgxY5puHD58eLdu3V588cXZs2c//PDD48aNS5Jk3bp1J554Yl1d3QsvvPDQQw898cQTl19++QMPPNC3b9/p06dPmzZtc4Pvvffe0KFD+/fvv2TJkssuu2z69Omb7uH++++/fv367t27r1279v/9RalUatuDBO3O2rVru3bt2vT1s88++/LLL19xxRVVn2hOYWAbpMD72WeffTY6WXbYYYemb82fP7+hoeHaa6+tr6+fP39+mqavvfZakiTlcrnpDrNmzaqrq1u+fPns2bN32mmnVatWNd3+8MMPd+jQYeXKlbNnz66rq3vjjTc22mjTH9Vpmm5usFKp1NfXr1ixoun2884778gjj9zcU+jbt2/nzp0HDRr02muvBRwhaL+6d+9+3XXXNX3d2Ng4ffr0Dh063H333UuXLk2S5J577mn61raeaG+99VaSJM8884xTGNh63tuGzfrmN7+54dmydu3aptv79OkzYcKE8ePHX3TRRX369Gm+f/NvOx1yyCGrV69+4YUXnn766RUrVnTu3Lnpt7U+9rGPrV+/fsGCBU899VTPnj132223zW16c4NPP/30/vvv36VLl6a7HXrooVvY/2efffaNN97YaaedTjrppFY6JJAbF1xwQdPps+eee06ZMuW73/3usGHDmr617777tvBEcwoDW09tQzWefPLJJEkeffTRDW/s1KlT0xfr1q378+8gd+y4du3aPn36bPTfuB/5yEc6depUKBS28PibG9zobs1b3Jydd9554sSJv/3tb5csWVLtc4Vcan5v+7333nvyySebfmOySefOnVt4ojmFga2ntmGb/exn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JZc88MAD48aN+8pXvrKFe37rW9/6zW9+c+211yZJMm3atOHDhzc0NGT6bGgX/O02AAB/dcstt/zwhz9MkmTYsGHz589PkuQPf/jDoEGDkiQZNGjQ5z73uS3cs1OnTv/1X/9VV1f35ptv3nHHHXfffXemT4X2wnvbAAB/9cc//vHOO+8cNGjQpz/96U996lNJkhx88MF33nln018Cv+GVJJve88orrzzzzDOvuuqqiRMnfvWrXy0UCpk+FdoLtQ0A8FerV6/+4Ac/+MADD5x55pmjR49uuibkpptuOu6441566aW6urot3POss86aO3du3759kyRZsGDBsGHDbr/99kyfDe2CK0kAAP5qzz33LBaLSZIUi8Xzzz8/SZIf//jHt912W11d3fz588vl8hbumSRJmqZf/vKXb7rppsMOO2zu3LkDBgwYMWJEds+GdsF72wAAf3X88cfPmTMnSZI5c+b0798/SZLf//7399xzT5IkM2bMOP3005MkWb58+fveM0mSG2+88eSTT+7evfvKlSvTNF2xYkXWT4jseW8bAOCvrrjiitGjR19xxRUdO3a8/vrrkyS55pprRo4c+fWvf/3www//P//n/yRJ8slPfnLWrFmb3rOxsfEnP/lJU5qPGzduyJAhF110UdZPiOypbQCAv/rABz5w1113bXhLnz59HnzwwQ1vmTVr1vves6Gh4d577236+ot/0Sa7THvnShIAAIiitgEAIIraBgCAKIU0TcMenOyVSqWsdwFyb8PP/GpLzl/I7/kLzfyW5PavUqlUN1gsFlsyu2BiY3WzvSc1tGR2xpyx1c2OHDjVbNvMtuTnm8nrOUO1dv5m9XzNbv1s7n6+kDlXkgAAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUQppmoY9ONkrlUpZ7wLkXrlczmS7zl/I7/kLzTr+7Uu2U5VKpbrBYrHYktkFExurm+09qWHGnLHVzY4cONVs+59tyWsjk9dzhvJ4/ma1z1nNtuRcyOPzzd1rAzLnShIAAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIEohTdOwByd7pVIp612A3CuXy5ls1/kL+T1/oVnHv33JdqpSqVQ3WCwWWzK7YGJjdbO9JzXMmDO2utmRA6fmcbYlx6rWZjN5PWcoj+dvVvvcknMwq2NVa7O1dv5CE1eSAABAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABRCmmahj042SuVSlnvAuReuVzOZLvOX8jv+QvNOv7tS7ZTlUqlusFisdiS2QUTG6ub7T2pYcacsdXNjhw4NY+zLTlWWf18a2o2Q3k8f3P383Wstu9ZyJwrSQAAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKIU0TcMenOyVSqWsdwFyr1wuZ7Jd5y/k9/yFZh3/9iXbqUqlUt1gsVhsyeyCiY3Vzfae1GB262ez+vnW1GyGnL/b92zuzoU8zkLmXEkCAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAEQppGka9uBkr1QqZb0LkHvlcjmT7Tp/Ib/nL/xNynatWCwm1TJr1mwT569Zs/mdzer8hWauJAEAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAohTSNA17cLJXKpWy3gXIvXK5nMl2nb+Q3/MX/iZlu1YsFpNqmTVrtonz16zZ/M5mdf5CM1eSAABAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABRCmmahj04AADUNO9tAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAACRB/n+15RY5M4KyIgAAAABJRU5ErkJggg=="
          },
          {
            "type": "input_text",
            "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
          }
        ]
      },
      {
        "type": "message",
        "role": "assistant",
        "content": [
          "The solution is approaching correctness but seems to fail in some cases at identifying the correct interior fill color or properly filling all interior pixels. It also struggles when there are no interior colors distinct from the outline color.\n\nFrom the feedback:\n\n- The outlines must not be covered or changed.\n- The interior fill uses a color that is always present in the interior pixels of the input, but not equal to the outline color.\n- Sometimes there are no interior pixels with colors distinct from the outline, in which case the fill is likely uniform zero or the outline color's \"fill equivalent\".\n- The overall shape edges must be preserved exactly.\n- The fill must stay strictly inside the outline (no spill outside).\n- The interior fill is uniform and occupies the full inside region.\n- Some shapes are irregular polygons, so bounding box flood fill must be careful.\n\n---\n\n**Improvements to be made:**\n\n1. **Fill color determination:**\n   - When no interior color other than the outline exists, check if there are pixels of a secondary \"special\" color inside the shape (e.g. a known fill color like 8 in first example).\n   - If no such pixels exist, fallback to just filling interior with the outline color itself (seems to happen in example 1 with blue outline and gray fill).\n   \n2. **Flood fill for exterior:**\n   - Flood fill is done from outside bounding box edges to reliably find exterior.\n   - Interior defined as inside bounding box pixels that are not outline and not exterior.\n   - This remains good but verify robustness.\n   \n3. **Better preservation of pixels outside outlines:**\n   - All pixels outside outlines remain unchanged at 0.\n   - Filling only strictly interior pixels.\n   \n4. **Fill interior fully:**\n   - Previous attempts may have missed filling some interior pixels.\n   - Ensure full interior fill by properly marking exterior pixels without missing any holes.\n\n---\n\nI will improve the fill color detection by adding logic to:\n\n- Detect most frequent interior color different from outline and zero.\n- If none found, check for most frequent interior color including outline color, but not zero.\n- Fill with that color to mimic the expected filled areas (especially example 1\u2019s blue outline with gray inside).\n\n---\n\nFinal improved code:\n\n```python\ndef transform(grid):\n    import numpy as np\n    from collections import deque, Counter\n\n    grid = np.array(grid)\n    h, w = grid.shape\n    output = grid.copy()\n\n    def neighbors(r, c):\n        for nr, nc in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\n            if 0 <= nr < h and 0 <= nc < w:\n                yield nr, nc\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def bfs_component(sr, sc):\n        q = deque([(sr, sc)])\n        comp_pixels = []\n        visited[sr, sc] = True\n        while q:\n            r, c = q.popleft()\n            comp_pixels.append((r, c))\n            for nr, nc in neighbors(r, c):\n                if not visited[nr, nc] and grid[nr, nc] != 0:\n                    visited[nr, nc] = True\n                    q.append((nr, nc))\n        return comp_pixels\n\n    def find_outline_pixels(component):\n        comp_set = set(component)\n        outline = set()\n        for (r, c) in component:\n            for nr, nc in neighbors(r, c):\n                if (nr, nc) not in comp_set:\n                    outline.add((r, c))\n                    break\n        return outline\n\n    # Find connected components of outlines\n    components = []\n    for r in range(h):\n        for c in range(w):\n            if grid[r, c] != 0 and not visited[r, c]:\n                comp = bfs_component(r, c)\n                components.append(comp)\n\n    for comp in components:\n        comp_set = set(comp)\n        outline_set = find_outline_pixels(comp)\n\n        # Determine outline color (majority color in component)\n        colors_in_comp = [grid[r, c] for r, c in comp]\n        outline_color = Counter(colors_in_comp).most_common(1)[0][0]\n\n        rows = [r for r, c in comp]\n        cols = [c for r, c in comp]\n        rmin, rmax = max(min(rows), 0), min(max(rows), h - 1)\n        cmin, cmax = max(min(cols), 0), min(max(cols), w - 1)\n\n        box_h = rmax - rmin + 1\n        box_w = cmax - cmin + 1\n\n        mask = np.zeros((box_h, box_w), dtype=np.int8)\n\n        for (r, c) in comp_set:\n            rr, cc = r - rmin, c - cmin\n            if (r, c) in outline_set:\n                mask[rr, cc] = 1  # outline\n            else:\n                mask[rr, cc] = 2  # possible interior\n\n        # Flood fill mask from outside bounding box edges where mask == 0 (exterior)\n        visited_box = np.zeros_like(mask, dtype=bool)\n        q = deque()\n        for rr in range(box_h):\n            for cc in [0, box_w - 1]:\n                if mask[rr, cc] == 0 and not visited_box[rr, cc]:\n                    q.append((rr, cc))\n                    visited_box[rr, cc] = True\n        for cc in range(box_w):\n            for rr in [0, box_h - 1]:\n                if mask[rr, cc] == 0 and not visited_box[rr, cc]:\n                    q.append((rr, cc))\n                    visited_box[rr, cc] = True\n\n        while q:\n            rr, cc = q.popleft()\n            for nr, nc in ((rr-1, cc), (rr+1, cc), (rr, cc-1), (rr, cc+1)):\n                if 0 <= nr < box_h and 0 <= nc < box_w:\n                    if not visited_box[nr, nc] and mask[nr, nc] == 0:\n                        visited_box[nr, nc] = True\n                        q.append((nr, nc))\n\n        # Interior pixels are mask==2 and not visited (not reachable from outside)\n        interior_pixels = []\n        for rr in range(box_h):\n            for cc in range(box_w):\n                if mask[rr, cc] == 2 and not visited_box[rr, cc]:\n                    interior_pixels.append((rr + rmin, cc + cmin))\n\n        # Build counts of colors in interior pixels excluding outline_color and zero\n        interior_colors = [grid[r, c] for r, c in interior_pixels if grid[r, c] != 0 and grid[r, c] != outline_color]\n\n        if interior_colors:\n            fill_color = Counter(interior_colors).most_common(1)[0][0]\n        else:\n            # If none found, try including outline color to fill interior (covers gray in ex1)\n            interior_colors_alt = [grid[r, c] for r, c in interior_pixels if grid[r, c] != 0]\n            if interior_colors_alt:\n                fill_color = Counter(interior_colors_alt).most_common(1)[0][0]\n            else:\n                # Fallback to outline color if no interior pixels or colors found\n                fill_color = outline_color\n\n        # Fill interior pixels in output with fill_color (do not overwrite outline pixels)\n        for r, c in interior_pixels:\n            output[r, c] = fill_color\n\n    return output.tolist()\n```\nThis version explicitly tries a fallback to fill interior with outline color when no other interior color is detected, which is crucial for the first training example where the output fills blue outline with gray.\n\nIt uses careful exterior flood-fills to identify interior pixels, avoiding any modification to outline or exterior pixels.\n\nThis should improve accuracy, potentially solving training example 1 fully and increasing overall performance.\n\n---\n\nFeel free to test this and feedback for further refinements."
        ]
      },
      {
        "role": "user",
        "content": [
          {
            "type": "input_text",
            "text": "Please analyze the training feedback and programs from all prior turns, and write an improved transformation.\n\n**Important**:\n1. Always start by attempting to find a complete rule that solves all training examples and should generalize to the test input.\n2. If you cannot find a perfect solution, provide your best attempt at a transformation that solves as many training examples as possible - ideally more than in the best previous turn.\n3. Even if your solution doesn't solve all examples perfectly, ensure it demonstrates meaningful pattern recognition and provides reasonable outputs that minimize pixel-level errors.\n\nFinal answer:\n```python\ndef transform(grid):\n    # Your improved transformation logic here (even if partial)\n    return transformed_grid\n```"
          },
          {
            "type": "input_text",
            "text": "Training results: 0/3 examples solved, 82.3% pixel accuracy - Good partial progress! Your approach is capturing some patterns. Next, try to identify a transformation that solves at least one of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 1, 1, 1, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 5, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 0, 8, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 8, 0, 0, 8, 2, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 3, 0, 8, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 1, 1, 1, 0, 0, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 5, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 5, 0, 5, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 90.0%\n\nTraining Example 2 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 6, 6, 6, 0, 0], [0, 0, 2, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 2, 2, 2, 3, 3, 3, 3, 3, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 6, 6, 6, 6, 6], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 3, 0, 2, 0, 0, 6, 6, 6, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 6, 0, 3, 0, 0], [0, 0, 2, 2, 2, 0, 3, 0, 0, 0, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 6, 6, 6, 6, 6], [0, 0, 0, 0, 2, 0, 0, 0, 8, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 8, 0], [3, 0, 0, 0, 0, 0, 0, 4, 8, 0, 3, 0, 8, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 8, 0, 4, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 80.7%\n\nTraining Example 3 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 3, 3, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 3, 3, 6, 6, 6, 6, 6, 6, 3, 3, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 3, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0], [0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 3, 0, 0, 0, 8, 0, 0, 8, 0, 3, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 0, 3, 0, 6, 0, 0, 2, 0, 0, 3, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 3, 0, 0, 0, 0, 6, 0, 0, 0, 3, 0, 0], [0, 0, 3, 0, 0, 6, 0, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 69.6%\n\n"
          },
          {
            "type": "input_image",
            "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA88AAAUtCAIAAABNteEnAABUgklEQVR4nO3de5xVdb34/7URBlFwRtFUBEsk0R58RdO8kHJQ+D5S8LJ3YB1NPXBQ035IgaLZ4WT5xTQhO9HF/IZCpqQnT3t7OWbkN4UsKVPyrqGgIaDH26AIcl2/R01n4oAQ7Jn3rFns5/PhH+Oe/d5r7TV7fXi5XbMppGmaAAAAATpEPCgAAKC2AQAgkNoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAaJe1PWbMmMLmnXnmme97n7q6ur322uuUU0559NFHN33MX/ziF4VCYbfddnvvvfc2+tbtt99eKBSmTZvW9K8jR44sFAqTJ0/e6G4vv/xyoVCYOHFiS6aavPfee9dff/1xxx3Xo0ePzp079+jR47TTTvvVr361hWMyceLEzR2QJ598cssHbciQIX/3wDbf55xzztnw9qbdGz58+EMPPbTh/hSLxY3utt9++40dO/att97apoPf5PXXX580adKhhx5aX1+/8847H3HEEdOmTUvTdKPNbTT+yCOP7LHHHt26dbv//vu3cOgAALY/Gby3vWbNmldfffWuu+467rjjFixYsNF3b7zxxiRJ3nrrrdtuu21rHu3LX/7ys88+u637sDVTL7744tFHH33++ec/8MADS5cuXb169dKlS2+//faBAwdee+21STvTtHs//elPjznmmFtuuWULd3vxxRe//e1vn3DCCevXr9+mg//QQw/179//X//1X//whz+8/fbbK1asePjhh88999zRo0dvYcd++ctfHnfccevWrbvvvvuOO+64FjxFAIAaq+3vfOc76X/7yU9+kiTJ9OnTm2+5+eabm++5cOHC5tvfe++9Z5555owzznj77bevu+66DR+wsbGxUqmcdtppu+222/e///2t2YfVq1ePHDly3bp127Tnf3dqzZo1I0aM+MMf/jBgwIA777zz9ddfX7NmzZ/+9Kfvfe97u+222yWXXNL0RvXmzJs3L91Ev3793veANLvvvvs2fJCtuc/SpUubbl+5cuXzzz//xS9+MU3Tf/7nf37ppZc2vNvKlSs3PPhDhgz53e9+94tf/GLrD/5//dd/lUqlJUuWnH766XPnzn377bfffPPNSqXSu3fv6dOnX3/99e97HMrl8tChQ3faaacHHnjgyCOP3MIRAwDYLmXw3nbnzp0PPPDAr3/960mSbPTe9syZM997773Pfvazo0aNmjt37uOPP/53H+3CCy/87W9/+41vfGOb9uHvTv3whz985JFHhgwZMmfOnJNPPrl79+4dO3bs1avXBRdc8NOf/nTdunU//vGPk/Zkxx133H///a+66qovf/nLq1ev/rd/+7ctHPwvfOELTaW+9Qf/2muvffXVV8eNGzdz5swjjzyyW7duu+6666mnnjp79uydd9752muv3fB6kiY33HDDaaed9oEPfOBXv/rVwQcf3Hz7jBkzCoXCd77znVY9AAAA7VEGtb1q1aqnnnpq/PjxSZIccMABG35r+vTpBx100PHHH3/BBRfssMMOW/P29te+9rU+ffp8+ctffuaZZ7Z+H/7u1MyZMwuFwv/9v/93hx122Ohb//AP//D0009PmjQpaZcuuuiinXba6ec///n7fnfNmjV//OMfp06d2rFjx3/4h3/Y+oP/7//+7126dLniiis2esCePXs++OCDDzzwQKFQ2PD2a6655pxzzundu/eDDz744Q9/uPWeHwBAnrRRbe+3337Nv6i344479uvX7yc/+cnuu+/++c9/vvk+Tz755O9///sJEyYUCoX999//tNNOu+WWW5YvX77lR95pp52mT5++Zs2abbqe5O9OzZs376CDDtpvv/3ed/yggw7aKC43cuihh270240PPvjg5g5IswceeGBb77Opbt26ffjDH97ofxp06dKlabyurq5v376//vWvf/jDH2747LZ88NesWfPiiy8eccQRXbt23XSLhxxyyN57773hLZdccsmll16aJMmxxx677777bnT/kSNHpmk6ZsyYLT8RAIDtQDafALjPPvv88z//82OPPbbXXns133jjjTfus88+n/nMZ5r+9bLLLnvnnXe25oKNY445ZuzYsb/73e+mTJmy9fuwhak1a9Y0NjbuueeeG9640eeEfOhDH0raq+7du6/6i83dYd26dXPnzl2zZs1WHvzGxsY0Tbt3776VO/Dtb3/76KOPHjJkyI033vjTn/60Zc8GACDH2qi2m37hb/Xq1bfeemvTm69XX311jx49mu+wZs2am2++efHixZ07d27K2f79+6dpupW/K/m1r33twx/+8OWXX/70009v/V5tbqpTp07dunV77bXXkmpt+luSxxxzzN/9DchBgwZt633e11tvvdWpU6fOnTtv+luSq1evXrBgwf/3//1/3/72ty+++OKtPPi77bZbhw4dtv6AjBo16oEHHrjpppt22223c889d/HixVs5CACwnWnT97Y7der06U9/+rbbbps9e/YJJ5yw4acy33333e8bc48++ujDDz/8dx+5S5cuVVxPsoWp//W//tfTTz/9pz/96X0/gOWwww5L2qvly5c/+eSTBx100Pt+t1OnTvvtt9+UKVP69es3Y8aMrTz4O+yww0EHHfT73/9+xYoVm97tqquuOvvss5csWdJ8y/e+9726urq99977O9/5zptvvnn22Wdv+mmDAAC1IIMrSU488cQLL7zw0UcfbX5vtelKhh133HHZsmUbvo/7m9/8JkmSzX263EY+/vGPf/7zn3/44Yc3/Ztrqpj6zGc+s379+s997nPv2+6bfv5G+/HNb35zzZo1J5xwwpbv1qFDh+XLl69du3YrD36xWFy5cuVXvvKVjR7nxRdfvOaaa+6+++73vc7k9NNPHzFixC9/+cttusgHAGC7kc1121/72tf23Xff66677re//W2SJK+88sq999578skn77LLLhve7eijj+7bt++Pf/zjZcuWbc3DXnnllR/+8Ie/973vbdPOvO/UOeecc9hhh/3nf/7nEUcc8e///u+vvPLKmjVrmv52m2HDhj366KMdOrSvv/R+1apVzz333MSJE7/61a/utNNOm/sdxDRNX3755QkTJjz++OOHHnpox44dt/Lgjxs3rnv37pMnTz777LN///vfr1y58tVXX505c+agQYMaGxsnTJiw4YUrG7ruuuv23HPPiRMnPvLIIzFPHQCg/comGXfeeedvf/vb69ev/+xnP7t27dqbbrpp7dq1zb+it6F/+qd/WrFixY9+9KOtvzJky58WspVTdXV1lUrl6KOPfvTRRz/96U/vvffedXV1TX9z+z333NO3b9+t/KsuN+d9P2+kUChs+BksW3Ofvffeu/mTXg488MArr7yy6a+p79Wr10bPseluHTp06NWr15QpUzp06ND0IYZbefC7d+9+2223devW7Uc/+tHHPvaxnXbaaa+99vrMZz7z0ksvlUqlSy65ZHPPdPfdd//BD36wZs2aM84449133/V52wBATcnsDdpTTjmlWCw+9thj//Zv/zZjxoxdd931xBNP3PRuZ599docOHbbyYpKmK0Oa/uqWbfK+Uz179vzVr3518803Dx06tGfPnnV1dXvuuefQoUN/+MMfPvnkkx/72MeS9qRTp069evX6x3/8x1//+tenn3765u62ww47fOADHxg2bNgvfvGLpqtNtv7gDx48eN68eWPHjj3wwAO7du3apUuXI488ctq0af/xH/+x6aeSb+jkk08eOXLkH//4xw0/8BEAoBYU2vMlyAAAkGvt6+JjAADYnqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqmxx74403nn322az3AmC7ZZmFllPbtI6ePXsWNnHzzTeHbnTIkCFz587d+vtPmTLlqKOO2tx3Gxsbe/fuvU0PCNA2dt999+alta6u7qCDDpo6dWrVj9a8GDY2NhYKhS30tGUWWk5t02q++c1vpv/TmWeeGbrFlStXttZDLVq0aMiQIQsXLmytBwRoXdddd13T0vruu+9Onjz54osv/tGPftTCx2xoaEjT9MADD9zcHSyz0HJqm1g33HBD586dFy1alCTJa6+9tssuu0yfPv31118vFAo33HBDz5496+vrR48e3bygL126dMSIEV27du3Vq9f48eObb1+8eHGpVOrWrdsee+zxuc99btWqVYMGDXruuedGjRp1zjnnbGHwqaeeOvbYY7t06TJgwIDNrfL/+Z//2a9fv8MOO6ytjgpA9Tp16nTSSScNHjy4XC6/8sorhULhsssuq6+vHzly5LYuhhu+t22ZhSBqm1ijR48+5phjrr766iRJrrzyysMPP3zUqFFN37rmmmvuvffeefPmPfLII2PGjGm6cfjw4d26dXvxxRdnz5798MMPjxs3LkmSdevWnXjiiXV1dS+88MJDDz30xBNPXH755Q888EDfvn2nT58+bdq0zQ2+9957Q4cO7d+//5IlSy677LLp06e/70527tz5vvvu++53v9uGBwagRdauXdu1a9emr5999tmXX375iiuuqHoxtMxCoI3+1z9UZ5999tnopbXDDjs0fWv+/PkNDQ3XXnttfX39/Pnz0zR97bXXkiQpl8tNd5g1a1ZdXd3y5ctnz5690047rVq1qun2hx9+uEOHDitXrpw9e3ZdXd0bb7yx0Uab/hhI03Rzg5VKpb6+fsWKFU23n3feeUceeeTmnsKaNWuSJHnooYcCDg9Ai3Tv3r35SpLGxsbp06d36NDh7rvvXrp0aZIk99xzT9O3tnUxfOutt5IkeeaZZyyzEMd720Rdt7127dqm2/v06TNhwoTx48dfdNFFffr0ab5/82/SHHLIIatXr37hhReefvrpFStWdO7cuek3gT72sY+tX79+wYIFTz31VM+ePXfbbbfNbXpzg08//fT+++/fpUuXprsdeuihwccAIMoFF1zQtMTtueeeU6ZM+e53vzts2LCmb+27774tXAwtsxBHbdMWnnzyySRJHn300Q1v7NSpU9MX69atS5KkY8eOa9eu7dOnz0b/RfiRj3ykU6dOhUJhC4+/ucGN7ta8RYDcaX5v+7333nvyySfPP//85m917ty5hYuhZRbiqG3C/exnP7vtttsmT558xx13VCqV5tsff/zxpi/mzZvXtWvX/fff/8ADD1y4cOHLL7+80SMccMABixYtavo/nhtq/rNhc4P9+vWbP3/+u+++2/SvTzzxRGs/OYB2pOrF0DILcdQ2sZYvX37++eePHTv24osvPvfcc8eMGfPOO+80feuSSy5ZuHDh/PnzL7300vPOO69z587HH3/8wQcfPGrUqEWLFi1evPgLX/jCvvvuu2rVqmOPPbZfv34XXnjh66+//uKLLw4fPvz0009PkmTnnXdesmTJO++8s7nBT3ziE3vvvffnP//5N99887777rvxxhuzPh4AgapeDC2zEEdt02rGjRu30d9uc/7553/pS1/q0KHDpEmTkiSZPHlyhw4dvvSlLzXdf8iQIccdd9yRRx75v//3/2760JIOHTpUKpWdd975oIMO+shHPvLcc8/NmjWr6TLB//iP/3jzzTd79ep1+OGH77LLLtdff32SJOeff/5VV101atSozQ3W1dX97Gc/e/HFF/fZZ59x48ade+65WR8kgEBVL4aWWYhTSNO06uFSqdSqO0OtWL169T333DN48OBu3bplvS/w95XL5Uy2a40FakE5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5/r16zdr1qwePXosXrz4hBNOeOKJJ5ruuent++677y9/+cvBgwfPmzfvrLPOuvvuuwuFQhKsYwvnK5VKdYPFYjGXs32+XuXs85dmNXvGGWdUNztz5sysZlt0rPL4ujLbvmczlLtjVYNrbFbHqv/kKv8j8LEJpTw+X7Pb8ey2Ovjgg++8885SqVQul5uuJHn11Vf32muvJEn23nvvpluabHr7lVdeeeaZZ1511VUTJ0786le/2gap7UoSAADyZNq0aTfddNNxxx330ksv1dXVbdPsWWedNXfu3L59+yZJsmDBgmHDht1+++1JO39vGwAA2syPf/zj2267ra6ubv78+U1Xoey5556vvPJKjx49li5duueeezbf831vT9P0y1/+8k033XTYYYfNnTt3wIABI0aMCN1h720DAJAbv//97++5554kSWbMmHH66acnSTJ06NBbb701SZJbb7116NChSZIsX778fW9PkuTGG288+eSTu3fvvnLlyjRNV6xYEb3DahsAgNy45pprpkyZcvTRR7/99tsXXHBBkiT/8i//MmfOnGOOOeZXv/rVl770pSRJPvnJT77v7Y2NjT/5yU/OO++8JEnGjRs3ZMiQiy66KHqHXUkCAEBu9OnT58EHH9zwlvr6+o1+R3PWrFnve3tDQ8O9997b9PUX/6INdth72wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEKWQpmnVw6VSqVV3BqA9KpfLmWzXGgvUgnJGa2yb6djC+UqlUt1gsVjM5Wyfr1c5+/ylZ5xxRnWzM2fOrLXZlhznXL6uzLbv2Qzl7lhluMZmtc8tWuscZ7Nma4ArSQAAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKIU0TaseLpVKrbozAO1RuVzOZLvWWKAWZLXGtpmOLZyvVCrVDRaLxVzO9vl6lbPPX3rGGWdUNztz5sxam23Jcc7l68ps+57NUO6OVYZrbC6fr+Ns1mwNcCUJAABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsA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hQsXbrqHDz/88IIFC6699tpdd921T58+l19++R133JGmaRseJCAznTp1OumkkwYPHlwul1955ZVCoXDZZZfV19ePHDlyWxeWDd/btmRB7qht8mr06NHHHHPM1VdfnSTJlVdeefjhh48aNarpW9dcc8299947b968Rx55ZMyYMU03Dh8+vFu3bi+++OLs2bMffvjhcePGJUmybt26E088sa6u7oUXXnjooYeeeOKJyy+//IEHHujbt+/06dOnTZu2ucH33ntv6NCh/fv3X7JkyWWXXTZ9+vRN93DAgAFr1qypq6tr+telS5futttuhUKhDQ8SkLG1a9d27dq16etnn3325ZdfvuKKK6peWCxZkEsb/Q96aG/22WefjV60O+ywQ9O35s+f39DQcO2119bX18+fPz9N09deey1JknK53HSHWbNm1dXVLV++fPbs2TvttNOqVauabn/44Yc7dOiwcuXK2bNn19XVvfHGGxtttOmPrjRNNzdYqVTq6+tXrFjRdPt555135JFHbuFZNDY27rfffpdffnlrHx6gHenevXvzlSSNjY3Tp0/v0KHD3XffvXTp0iRJ7rnnnqZvbevC8tZbbyVJ8swzz1iyII+8t03+rtteu3Zt0+19+vSZMGHC+PHjL7rooj59+jTfv/m3fw455JDVq1e/8MILTz/99IoVKzp37tz020sf+9jH1q9fv2DBgqeeeqpnz5677bbb5ja9ucGnn356//3379KlS9PdDj300C3s/7vvvnvyySf369dv4sSJrXRIgHbqggsuaFou9txzzylTpnz3u98dNmxY07f23XffFi4slizII7VNvj355JNJkjz66KMb3tipU6emL9atW5ckSceOHdeuXdunT5+N/lvzIx/5SKdOnbb8/0k3N7jR3Zq3uKk33nhj8ODBPXv2vP322zt27Niypwu0d83vbb/33ntPPvnkhr9o2Llz5xYuLJYsyCO1TY797Gc/u+222yZPnnzHHXdUKpXm2x9//PGmL+bNm9e1a9f999//wAMPXLhw4csvv7zRIxxwwAGLFi1q+r+0G2r+82xzg/369Zs/f/67777b9K9PPPHE++7hyy+/fMwxxwwcOPCWW25pvhoSqHFVLyyWLMgjtU1eLV++/Pzzzx87duzFF1987rnnjhkz5p133mn61iWXXLJw4cL58+dfeuml5513XufO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ABBFbQMAQBS1DQBQo/7f//t/AwYMOO6444499tiHHnooSZJly5YVi8VjjjmmWCwuW7as+Z7/+I//OOgvBgwYsPvuuydJcvXVV/fr12/y5MlJkqxfv37YsGGNjY2ZPpt2qmPWOwAAQDZGjx59//3377fffi+88MLJJ5/89NNPX3nllQMHDhw/fvw3vvGNq6666uqrr26656233tr0xbRp0/70pz8lSfKtb33rueee69u374QJE6ZNmzZ8+PCGhoZMn007VUjTNKklpVIp610AcqZcLmeyXesVEL1eHXbYYddff/3hhx/+u9/97rTTTnvppZf69es3a9asHj16LF68+IQTTnjiiSc2vH+aph/96Ed//vOff+ADH9h3331/+ctfDh48eN68eWedddbdd99dKBRa+wltF9IaUywWqz5WZs0GzabPJ9X9k9PZrI5z1bM1uF5dPj+t7p88/nzNbtNsHtcc69UW/O53v+vcuXO/fv06d+581113pWm6++67r1u3Lk3TdevW7bHHHhvd/4477jj33HObvr7pppuOPPLIW2655YILLnj44YdbaeXbDrluGwCgRl188cW33HLLE0888aMf/einP/3p373/N77xjYsuuqjp67POOmvu3Ll9+/ZNkmTBggXDhg27/fbb43c5f1y3DQBQo5544ommi9Y++clPXnDBBUmS7Lnnnq+88kqPHj2WLl265557bnjn3/72tw0NDU153SRN0y9/+cs33XTTYYcdNnfu3AEDBowYMSKL59GueW8bAKBG9e3b99e//nWSJA899NCHPvShJEmGDh3a9AuRt95669ChQ5MkWb58edOdr7nmmuY3tpvceOONJ598cvfu3VeuXJmm6YoVKzJ6Hu2a97YBAGrU97///bFjx/75czMKhWnTpiVJ8i//8i//9E//9NOf/nT33Xf/4Q9/2PS296xZs55//vklS5YMHDiwebaxsfEnP/nJPffckyTJuHHjhgwZslGL00RtAwDUqP79+8+ePXvDW+rr6yuVyoa3zJo1K0mSPn36NH0gd7OGhoZ777236esv/kWb7HL+uJIEAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiFNI0TWpJqVTKeheAnCmXy5ls13oF5GW9Ygs6JrWn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kiRr1qz5+c9//slPfnLXXXc966yzWvKYDQ0NaZpu4Q5OYWBT3tuGbXPDDTd07tx50aJFSZK89tpru+yyy/Tp019//fVCoXDDDTf07Nmzvr5+9OjRzX/oLl26dMSIEV27du3Vq9f48eObb1+8eHGpVOrWrdsee+zxuc99btWqVYMGDXruuedGjRrV9Mfq5gafeuqpY489tkuXLgMGDFi4cOGme/jCCy/cf//9U6ZMqa+vP/zww4877rjf/OY3bXiEoH3p1KnTSSedNHjw4HK5/MorrxQKhcsuu6y+vn7kyJHbeqJt+N62UxjYSmobts3o0aOPOeaYq6++OkmSK6+88vDDDx81alTTt6655pp777133rx5jzzyyJgxY5puHD58eLdu3V588cXZs2c//PDD48aNS5Jk3bp1J554Yl1d3QsvvPDQQw898cQTl19++QMPPNC3b9/p06dPmzZtc4Pvvffe0KFD+/fvv2TJkssuu2z69Omb7uH++++/fv367t27r1279v/9RalUatuDBO3O2rVru3bt2vT1s88++/LLL19xxRVVn2hOYWAbpMD72WeffTY6WXbYYYemb82fP7+hoeHaa6+tr6+fP39+mqavvfZakiTlcrnpDrNmzaqrq1u+fPns2bN32mmnVatWNd3+8MMPd+jQYeXKlbNnz66rq3vjjTc22mjTH9Vpmm5usFKp1NfXr1ixoun2884778gjj9zcU+jbt2/nzp0HDRr02muvBRwhaL+6d+9+3XXXNX3d2Ng4ffr0Dh063H333UuXLk2S5J577mn61raeaG+99VaSJM8884xTGNh63tuGzfrmN7+54dmydu3aptv79OkzYcKE8ePHX3TRRX369Gm+f/NvOx1yyCGrV69+4YUXnn766RUrVnTu3Lnpt7U+9rGPrV+/fsGCBU899VTPnj132223zW16c4NPP/30/vvv36VLl6a7HXrooVvY/2efffaNN97YaaedTjrppFY6JJAbF1xwQdPps+eee06ZMuW73/3usGHDmr617777tvBEcwoDW09tQzWefPLJJEkeffTRDW/s1KlT0xfr1q378+8gd+y4du3aPn36bPTfuB/5yEc6depUKBS28PibG9zobs1b3Jydd9554sSJv/3tb5csWVLtc4Vcan5v+7333nvyySebfmOySefOnVt4ojmFga2ntmGb/exnP7vtttsmT558xx13VCqV5tsff/zxpi/mzZvXtWvX/fff/8ADD1y4cOHLL7+80SMccMABixYtavq/0htq/vN7c4P9+vWbP3/+u+++2/SvTzzxxKa7d++999bX169atarpX998880ddtihoaGhZU8atkNVn2hOYWDrqW3YNsuXLz///PPHjh178cUXn3vuuWPGjHnnnXeavnXJJZcsXLhw/vz5l1566Xnnnde5c+fjjz/+4IMPHjVq1KJFixYvXvyFL3xh3333XbVq1bHHHtuvX78LL7zw9ddff/HFF4cPH3766ac3vY+1ZMmSd955Z3ODn/jEJ/bee+/Pf/7zb7755n333XfjjTduuoeDBg3aa6+9xo8fv2zZsscff3zChAmjRo3aaaed2vxQQXtX9YnmFAa2wTZc4w21/VuSSZJ89rOfvfDCCz/0oQ8tX748TdNly5b16tVrzJgxTb8l+cUvfvGDH/zgrrvuOn78+NWrVzc9zksvvXTqqafuvPPOu+yyywknnPDMM8803b5w4cITTzxxxx137N69+8iRI5ctW5am6Q9+8IOuXbsOHz58C4MvvPDC4MGDd9xxx379+o0fP/59f8Xq+eefHzp06C677LLvvvtedtllK1eubMMjB+3rtyQ31PRbkk2/3Nxkm0605t+SdAoDW6+w5Q/qJ+98blTbWL169T333DN48OBu3bplvS+0vnK5nMl2nb+Q3/MX/mYbypwcKhaLSbXMbr2hQ4dmsl2zbTPr/DVrNr+zWZ2/0Mx12wAAEEVtQyuoq6vLehcAgPZIbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABClkKZp2IOTvVKplPUuQO6Vy+VMtuv8hfyev9Cs49++ZDtVqVSqGywWi1nNLpjYWN1s70kNZtv/bO5ekxnK3bFy/m73s7l7TULmXEkCAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAEQppGka9uBkr1QqZb0LkHvlcjmT7Tp/Ib/nLzTr+Lcv2U5VKpXqBovFYlazCyY2Vjfbe1LDjDljq5sdOXCq2a2fbcnPKHevyQzV2vmb1T6Xly2pbrZU38PPaOu3W2vnLzRxJQkAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEKWQpmnYg5O9UqmU9S5A7pXL5Uy26/yF/J6/0Kzj375kO1WpVKobLBaLCyY2Vjfbe1JDVrMz5oytbnbkwKlmt362JT+jlrwmM5nNUK2dv7l7beR0tqZ+RpA5V5IAAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFEKaZqGPTjZK5VKWe8C5F65XM5ku85fyO/5C806/u1LtlOVSqW6wWKxuGBiY3WzvSc1zJgztrrZkQOnmm3/sy15bbTkNZnJbA2ev7n7GRWLxf6Tq4yqxyaUam2fa+q1AZlzJQkAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEKWQpmnYg5O9UqmU9S5A7pXL5Uy26/yF/J6/0Kzj375kO1WpVKobLBaLCyY2Vjfbe1LDjDljq5sdOXCq2fY/25LXRktek5nM1uD5m7ufkdltmq2p1wZkzpUkAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUf3M7AMDWKRQ2+600bdM9IT/UNgBAtZG96X1kN/+T2gYAaEFnv++I5ua/qW0AgNbo7E3HNTd+SxIAoJVTu9UfhzxT2wAAYYksuGue2gYAiIxjwV3b1DYAQHAWC+4aVkhdv79dK5VKWe8C5F65XM5ku85faNPztw2CWHTVJJ9Jsv2rVCrVDRaLxQUTG6ub7T2pIavZGXPGVjc7cuBUs1s/m9XPtyWv56pnM1Rr528mP98anK2pn2/7eu+5UBDcNciVJAAAEEVtAwC1rS0vqnYBd+1R2wAAEEVtAwA1rO3fbPb2do1R2wAAEEVtAwBAFLUNANSqrC7qcDFJLfF52wAAWy1NkzvuSNauTTp1Sk45RTfzd3lvGwBgq/3ud8nPfpaMGJHceWcyd27We0MOqG0AgK22aFGyalVy1FHJ4sV//gf+HrUNALAtbr45ueyy5N57s94P8kFtAwBsi1GjkhkzkpNPzno/yAe1DQCw1Xr1Srp0ScrlP3+xzz5Z7w054DNJAAC22hFHJK+8kgwc+OfPJDnqqKz3hhxQ2wAAW81H/rGNXEkCANSqNK2t7ZIFtQ0AAFHUNgAARCmk/l/Gdq1UKmW9C5B75XI5k+06f6GNzt82vhRbetUYvyW5/atUKtUNFovFrGYXTGysbrb3pIYZc8ZWNzty4FSzbTPbkp9vJq/JDNXa+duS7bbkNZnVsSovW1LdbKm+R639fPN4/kITV5IAALWtLd9s9sZ27VHbAAAQRW0DADWvbd5y9sZ2TVLbAK3pkEMOWbx4cZIkq1atOuCAA6ZOnXrooYd+9KMfnTVrVta7BmSawlK7VqltgNY0YsSIO++8M0mS+++//4QTTpg0adKcOXNmzpx58803Z71rQHZBLLVrmNoGaE2nnXbaHXfckSTJXXfd9alPfWro0KFnn332okWLbrrppqx3Dcgoi6V2bVPbAK2pb9++b7zxxttvvz1v3ryPf/zjM2bMGDdu3HXXXTdq1Kisdw3IIo6lds3zedsArezUU0+9+uqrjzjiiLfffvuUU0657777DjvssN69e2e9X8BWS9PW+StvpDZqG6DVnXbaaQcffPD9999fX19/0kknHXXUUevXr//Xf/3XrPcL2PZQrrq5dTb/TW0DtLK+ffuuWrWq6esJf5H1HgFt2Nw6m/9JbQMAbF1AbyG7RTabobYBALaOpGbb+UwSAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACBKIfVZNtu1UqmU9S5A7pXL5Uy26/yF/J6/0MznbW//KpVKdYPFYjGr2QUTG6ub7T2pYcacsdXNjhw41WzbzLbk55vJazJDtXb+5vH51tps7n6+kDlXkgAAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AMBfrV+/fuzYsUcfffTAgQMXLFiQJMnChQs/8YlPDBo06KSTTnr11Ve3cM+rr766X79+kydPbvrusGHDGhur/MBEtidqGwDgr77//e9369btoYceGjdu3MUXX5wkyXnnnXfJJZc88MAD48aN+8pXvrKFe37rW9/6zW9+c+211yZJMm3atOHDhzc0NGT6bGgX/O02AAB/dcstt/zwhz9MkmTYsGHz589PkuQPf/jDoEGDkiQZNGjQ5z73uS3cs1OnTv/1X/9VV1f35ptv3nHHHXfffXemT4X2wnvbAAB/9cc//vHOO+8cNGjQpz/96U996lNJkhx88MF33nln018Cv+GVJJve88orrzzzzDOvuuqqiRMnfvWrXy0UCpk+FdoLtQ0A8FerV6/+4Ac/+MADD5x55pmjR49uuibkpptuOu6441566aW6urot3POss86aO3du3759kyRZsGDBsGHDbr/99kyfDe2CK0kAAP5qzz33LBaLSZIUi8Xzzz8/SZIf//jHt912W11d3fz588vl8hbumSRJmqZf/vKXb7rppsMOO2zu3LkDBgwYMWJEds+GdsF72wAAf3X88cfPmTMnSZI5c+b0798/SZLf//7399xzT5IkM2bMOP3005MkWb58+fveM0mSG2+88eSTT+7evfvKlSvTNF2xYkXWT4jseW8bAOCvrrjiitGjR19xxRUdO3a8/vrrkyS55pprRo4c+fWvf/3www//P//n/yRJ8slPfnLWrFmb3rOxsfEnP/lJU5qPGzduyJAhF110UdZPiOypbQCAv/rABz5w1113bXhLnz59HnzwwQ1vmTVr1vves6Gh4d577236+ot/0Sa7THvnShIAAIiitgEAIIraBgCAKIU0TcMenOyVSqWsdwFyb8PP/GpLzl/I7/kLzfyW5PavUqlUN1gsFlsyu2BiY3WzvSc1tGR2xpyx1c2OHDjVbNvMtuTnm8nrOUO1dv5m9XzNbv1s7n6+kDlXkgAAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUQppmoY9ONkrlUpZ7wLkXrlczmS7zl/I7/kLzTr+7Uu2U5VKpbrBYrHYktkFExurm+09qWHGnLHVzY4cONVs+59tyWsjk9dzhvJ4/ma1z1nNtuRcyOPzzd1rAzLnShIAAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIEohTdOwByd7pVIp612A3CuXy5ls1/kL+T1/oVnHv33JdqpSqVQ3WCwWWzK7YGJjdbO9JzXMmDO2utmRA6fmcbYlx6rWZjN5PWcoj+dvVvvcknMwq2NVa7O1dv5CE1eSAABAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABRCmmahj042SuVSlnvAuReuVzOZLvOX8jv+QvNOv7tS7ZTlUqlusFisdiS2QUTG6ub7T2pYcacsdXNjhw4NY+zLTlWWf18a2o2Q3k8f3P383Wstu9ZyJwrSQAAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKIU0TcMenOyVSqWsdwFyr1wuZ7Jd5y/k9/yFZh3/9iXbqUqlUt1gsVhsyeyCiY3Vzfae1GB262ez+vnW1GyGnL/b92zuzoU8zkLmXEkCAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAEQppGka9uBkr1QqZb0LkHvlcjmT7Tp/Ib/nL/xNynatWCwm1TJr1mwT569Zs/mdzer8hWauJAEAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAohTSNA17cLJXKpWy3gXIvXK5nMl2nb+Q3/MX/iZlu1YsFpNqmTVrtonz16zZ/M5mdf5CM1eSAABAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABRCmmahj04AADUNO9tAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAACRB/n+15RY5M4KyIgAAAABJRU5ErkJggg=="
          },
          {
            "type": "input_text",
            "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
          }
        ]
      },
      {
        "type": "message",
        "role": "assistant",
        "content": [
          "The current best approach identifies outlines and fills interior regions with the most frequent interior color distinct from the outline color, falling back to outline color if needed. It uses a bounding-box flood fill starting from outside to separate exterior, outline, and interior regions.\n\nTo improve further:\n- In Example 2, some interior fill colors are missed (due to scattered interior pixels), so we should consider all inside pixels, including outline color pixels, when computing the fill color, and prioritize non-outline, non-zero colors but fallback sensibly.\n- In Example 3, the interior is fully filled with a single fill color that might not appear clearly as isolated interior pixels but is represented by the most common interior color.\n- Ensure that scattered inside color pixels are included in determining fill color, but exclude exterior background pixels, the outline pixels remain unchanged.\n- To minimize error, fill all interior pixels with the chosen fill color, ensuring solid fill, preserving outlines exactly as they are.\n  \nBelow is an improved version combining all insights:\n\n```python\ndef transform(grid):\n    import numpy as np\n    from collections import deque, Counter\n\n    grid = np.array(grid)\n    h, w = grid.shape\n    output = grid.copy()\n\n    def neighbors(r, c):\n        for nr, nc in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\n            if 0 <= nr < h and 0 <= nc < w:\n                yield nr, nc\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def bfs_component(sr, sc):\n        q = deque([(sr, sc)])\n        comp_pixels = []\n        visited[sr, sc] = True\n        while q:\n            r, c = q.popleft()\n            comp_pixels.append((r, c))\n            for nr, nc in neighbors(r, c):\n                if not visited[nr, nc] and grid[nr, nc] != 0:\n                    visited[nr, nc] = True\n                    q.append((nr, nc))\n        return comp_pixels\n\n    def find_outline_pixels(component):\n        comp_set = set(component)\n        outline = set()\n        for (r, c) in component:\n            for nr, nc in neighbors(r, c):\n                if (nr, nc) not in comp_set:\n                    outline.add((r, c))\n                    break\n        return outline\n\n    # Find connected components of outlines\n    components = []\n    for r in range(h):\n        for c in range(w):\n            if grid[r, c] != 0 and not visited[r, c]:\n                comp = bfs_component(r, c)\n                components.append(comp)\n\n    for comp in components:\n        comp_set = set(comp)\n        outline_set = find_outline_pixels(comp)\n\n        # Determine outline color (majority color in component)\n        colors_in_comp = [grid[r, c] for r, c in comp]\n        outline_color = Counter(colors_in_comp).most_common(1)[0][0]\n\n        rows = [r for r, c in comp]\n        cols = [c for r, c in comp]\n        rmin, rmax = max(min(rows), 0), min(max(rows), h - 1)\n        cmin, cmax = max(min(cols), 0), min(max(cols), w - 1)\n\n        box_h = rmax - rmin + 1\n        box_w = cmax - cmin + 1\n\n        mask = np.zeros((box_h, box_w), dtype=np.int8)\n\n        for (r, c) in comp_set:\n            rr, cc = r - rmin, c - cmin\n            if (r, c) in outline_set:\n                mask[rr, cc] = 1  # outline\n            else:\n                mask[rr, cc] = 2  # possible interior\n\n        # Flood fill mask from bounding box edges where mask == 0\n        visited_box = np.zeros_like(mask, dtype=bool)\n        q = deque()\n        for rr in range(box_h):\n            for cc in [0, box_w - 1]:\n                if mask[rr, cc] == 0 and not visited_box[rr, cc]:\n                    q.append((rr, cc))\n                    visited_box[rr, cc] = True\n        for cc in range(box_w):\n            for rr in [0, box_h - 1]:\n                if mask[rr, cc] == 0 and not visited_box[rr, cc]:\n                    q.append((rr, cc))\n                    visited_box[rr, cc] = True\n\n        while q:\n            rr, cc = q.popleft()\n            for nr, nc in ((rr-1, cc), (rr+1, cc), (rr, cc-1), (rr, cc+1)):\n                if 0 <= nr < box_h and 0 <= nc < box_w:\n                    if not visited_box[nr, nc] and mask[nr, nc] == 0:\n                        visited_box[nr, nc] = True\n                        q.append((nr, nc))\n\n        # Interior pixels: mask==2 and not reachable from outside (visited_box==False)\n        interior_pixels = []\n        for rr in range(box_h):\n            for cc in range(box_w):\n                if mask[rr, cc] == 2 and not visited_box[rr, cc]:\n                    interior_pixels.append((rr + rmin, cc + cmin))\n\n        # Determine fill color:\n        # 1. Most common nonzero color inside interior pixels excluding outline color\n        # 2. If none found, most common nonzero color including outline\n        # 3. Else fallback to outline color\n        interior_colors = [grid[r, c] for r, c in interior_pixels if grid[r, c] != 0 and grid[r, c] != outline_color]\n\n        if interior_colors:\n            fill_color = Counter(interior_colors).most_common(1)[0][0]\n        else:\n            interior_colors_alt = [grid[r, c] for r, c in interior_pixels if grid[r, c] != 0]\n            if interior_colors_alt:\n                fill_color = Counter(interior_colors_alt).most_common(1)[0][0]\n            else:\n                fill_color = outline_color\n\n        # Fill all interior pixels in output\n        for r, c in interior_pixels:\n            output[r, c] = fill_color\n\n    return output.tolist()\n```\n\nThis should better handle all three training examples, and generalize well to the test input by clearly filling polygon interiors with dominant interior colors, preserving outlines exactly and leaving outside areas unchanged.\n\n---\n\nIf needed, further refinements could include special casing for interior detected color being multiple, or small isolated pixels, but this general approach captures the main transformation rule observed."
        ]
      },
      {
        "role": "user",
        "content": [
          {
            "type": "input_text",
            "text": "Please analyze the training feedback and programs from all prior turns, and write an improved transformation.\n\n**Important**:\n1. Always start by attempting to find a complete rule that solves all training examples and should generalize to the test input.\n2. If you cannot find a perfect solution, provide your best attempt at a transformation that solves as many training examples as possible - ideally more than in the best previous turn.\n3. Even if your solution doesn't solve all examples perfectly, ensure it demonstrates meaningful pattern recognition and provides reasonable outputs that minimize pixel-level errors.\n\nFinal answer:\n```python\ndef transform(grid):\n    # Your improved transformation logic here (even if partial)\n    return transformed_grid\n```"
          },
          {
            "type": "input_text",
            "text": "Training results: 0/3 examples solved, 82.3% pixel accuracy - Good partial progress! Your approach is capturing some patterns. Next, try to identify a transformation that solves at least one of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 1, 1, 1, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 5, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 0, 8, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 8, 0, 0, 8, 2, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 3, 0, 8, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 1, 1, 1, 0, 0, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 5, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 5, 0, 5, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 90.0%\n\nTraining Example 2 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 6, 6, 6, 0, 0], [0, 0, 2, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 2, 2, 2, 3, 3, 3, 3, 3, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 6, 6, 6, 6, 6], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 3, 0, 2, 0, 0, 6, 6, 6, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 6, 0, 3, 0, 0], [0, 0, 2, 2, 2, 0, 3, 0, 0, 0, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 6, 6, 6, 6, 6], [0, 0, 0, 0, 2, 0, 0, 0, 8, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 8, 0], [3, 0, 0, 0, 0, 0, 0, 4, 8, 0, 3, 0, 8, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 8, 0, 4, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 80.7%\n\nTraining Example 3 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 3, 3, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 3, 3, 6, 6, 6, 6, 6, 6, 3, 3, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 3, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0], [0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 3, 0, 0, 0, 8, 0, 0, 8, 0, 3, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 0, 3, 0, 6, 0, 0, 2, 0, 0, 3, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 3, 0, 0, 0, 0, 6, 0, 0, 0, 3, 0, 0], [0, 0, 3, 0, 0, 6, 0, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 69.6%\n\n"
          },
          {
            "type": "input_image",
            "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA88AAAUtCAIAAABNteEnAABUgklEQVR4nO3de5xVdb34/7URBlFwRtFUBEsk0R58RdO8kHJQ+D5S8LJ3YB1NPXBQ035IgaLZ4WT5xTQhO9HF/IZCpqQnT3t7OWbkN4UsKVPyrqGgIaDH26AIcl2/R01n4oAQ7Jn3rFns5/PhH+Oe/d5r7TV7fXi5XbMppGmaAAAAATpEPCgAAKC2AQAgkNoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAaJe1PWbMmMLmnXnmme97n7q6ur322uuUU0559NFHN33MX/ziF4VCYbfddnvvvfc2+tbtt99eKBSmTZvW9K8jR44sFAqTJ0/e6G4vv/xyoVCYOHFiS6aavPfee9dff/1xxx3Xo0ePzp079+jR47TTTvvVr361hWMyceLEzR2QJ598cssHbciQIX/3wDbf55xzztnw9qbdGz58+EMPPbTh/hSLxY3utt9++40dO/att97apoPf5PXXX580adKhhx5aX1+/8847H3HEEdOmTUvTdKPNbTT+yCOP7LHHHt26dbv//vu3cOgAALY/Gby3vWbNmldfffWuu+467rjjFixYsNF3b7zxxiRJ3nrrrdtuu21rHu3LX/7ys88+u637sDVTL7744tFHH33++ec/8MADS5cuXb169dKlS2+//faBAwdee+21STvTtHs//elPjznmmFtuuWULd3vxxRe//e1vn3DCCevXr9+mg//QQw/179//X//1X//whz+8/fbbK1asePjhh88999zRo0dvYcd++ctfHnfccevWrbvvvvuOO+64FjxFAIAaq+3vfOc76X/7yU9+kiTJ9OnTm2+5+eabm++5cOHC5tvfe++9Z5555owzznj77bevu+66DR+wsbGxUqmcdtppu+222/e///2t2YfVq1ePHDly3bp127Tnf3dqzZo1I0aM+MMf/jBgwIA777zz9ddfX7NmzZ/+9Kfvfe97u+222yWXXNL0RvXmzJs3L91Ev3793veANLvvvvs2fJCtuc/SpUubbl+5cuXzzz//xS9+MU3Tf/7nf37ppZc2vNvKlSs3PPhDhgz53e9+94tf/GLrD/5//dd/lUqlJUuWnH766XPnzn377bfffPPNSqXSu3fv6dOnX3/99e97HMrl8tChQ3faaacHHnjgyCOP3MIRAwDYLmXw3nbnzp0PPPDAr3/960mSbPTe9syZM997773Pfvazo0aNmjt37uOPP/53H+3CCy/87W9/+41vfGOb9uHvTv3whz985JFHhgwZMmfOnJNPPrl79+4dO3bs1avXBRdc8NOf/nTdunU//vGPk/Zkxx133H///a+66qovf/nLq1ev/rd/+7ctHPwvfOELTaW+9Qf/2muvffXVV8eNGzdz5swjjzyyW7duu+6666mnnjp79uydd9752muv3fB6kiY33HDDaaed9oEPfOBXv/rVwQcf3Hz7jBkzCoXCd77znVY9AAAA7VEGtb1q1aqnnnpq/PjxSZIccMABG35r+vTpBx100PHHH3/BBRfssMMOW/P29te+9rU+ffp8+ctffuaZZ7Z+H/7u1MyZMwuFwv/9v/93hx122Ohb//AP//D0009PmjQpaZcuuuiinXba6ec///n7fnfNmjV//OMfp06d2rFjx3/4h3/Y+oP/7//+7126dLniiis2esCePXs++OCDDzzwQKFQ2PD2a6655pxzzundu/eDDz744Q9/uPWeHwBAnrRRbe+3337Nv6i344479uvX7yc/+cnuu+/++c9/vvk+Tz755O9///sJEyYUCoX999//tNNOu+WWW5YvX77lR95pp52mT5++Zs2abbqe5O9OzZs376CDDtpvv/3ed/yggw7aKC43cuihh270240PPvjg5g5IswceeGBb77Opbt26ffjDH97ofxp06dKlabyurq5v376//vWvf/jDH2747LZ88NesWfPiiy8eccQRXbt23XSLhxxyyN57773hLZdccsmll16aJMmxxx677777bnT/kSNHpmk6ZsyYLT8RAIDtQDafALjPPvv88z//82OPPbbXXns133jjjTfus88+n/nMZ5r+9bLLLnvnnXe25oKNY445ZuzYsb/73e+mTJmy9fuwhak1a9Y0NjbuueeeG9640eeEfOhDH0raq+7du6/6i83dYd26dXPnzl2zZs1WHvzGxsY0Tbt3776VO/Dtb3/76KOPHjJkyI033vjTn/60Zc8GACDH2qi2m37hb/Xq1bfeemvTm69XX311jx49mu+wZs2am2++efHixZ07d27K2f79+6dpupW/K/m1r33twx/+8OWXX/70009v/V5tbqpTp07dunV77bXXkmpt+luSxxxzzN/9DchBgwZt633e11tvvdWpU6fOnTtv+luSq1evXrBgwf/3//1/3/72ty+++OKtPPi77bZbhw4dtv6AjBo16oEHHrjpppt22223c889d/HixVs5CACwnWnT97Y7der06U9/+rbbbps9e/YJJ5yw4acy33333e8bc48++ujDDz/8dx+5S5cuVVxPsoWp//W//tfTTz/9pz/96X0/gOWwww5L2qvly5c/+eSTBx100Pt+t1OnTvvtt9+UKVP69es3Y8aMrTz4O+yww0EHHfT73/9+xYoVm97tqquuOvvss5csWdJ8y/e+9726urq99977O9/5zptvvnn22Wdv+mmDAAC1IIMrSU488cQLL7zw0UcfbX5vtelKhh133HHZsmUbvo/7m9/8JkmSzX263EY+/vGPf/7zn3/44Yc3/Ztrqpj6zGc+s379+s997nPv2+6bfv5G+/HNb35zzZo1J5xwwpbv1qFDh+XLl69du3YrD36xWFy5cuVXvvKVjR7nxRdfvOaaa+6+++73vc7k9NNPHzFixC9/+cttusgHAGC7kc1121/72tf23Xff66677re//W2SJK+88sq999578skn77LLLhve7eijj+7bt++Pf/zjZcuWbc3DXnnllR/+8Ie/973vbdPOvO/UOeecc9hhh/3nf/7nEUcc8e///u+vvPLKmjVrmv52m2HDhj366KMdOrSvv/R+1apVzz333MSJE7/61a/utNNOm/sdxDRNX3755QkTJjz++OOHHnpox44dt/Lgjxs3rnv37pMnTz777LN///vfr1y58tVXX505c+agQYMaGxsnTJiw4YUrG7ruuuv23HPPiRMnPvLIIzFPHQCg/comGXfeeedvf/vb69ev/+xnP7t27dqbbrpp7dq1zb+it6F/+qd/WrFixY9+9KOtvzJky58WspVTdXV1lUrl6KOPfvTRRz/96U/vvffedXV1TX9z+z333NO3b9+t/KsuN+d9P2+kUChs+BksW3Ofvffeu/mTXg488MArr7yy6a+p79Wr10bPseluHTp06NWr15QpUzp06ND0IYZbefC7d+9+2223devW7Uc/+tHHPvaxnXbaaa+99vrMZz7z0ksvlUqlSy65ZHPPdPfdd//BD36wZs2aM84449133/V52wBATcnsDdpTTjmlWCw+9thj//Zv/zZjxoxdd931xBNP3PRuZ599docOHbbyYpKmK0Oa/uqWbfK+Uz179vzVr3518803Dx06tGfPnnV1dXvuuefQoUN/+MMfPvnkkx/72MeS9qRTp069evX6x3/8x1//+tenn3765u62ww47fOADHxg2bNgvfvGLpqtNtv7gDx48eN68eWPHjj3wwAO7du3apUuXI488ctq0af/xH/+x6aeSb+jkk08eOXLkH//4xw0/8BEAoBYU2vMlyAAAkGvt6+JjAADYnqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqmxx74403nn322az3AmC7ZZmFllPbtI6ePXsWNnHzzTeHbnTIkCFz587d+vtPmTLlqKOO2tx3Gxsbe/fuvU0PCNA2dt999+alta6u7qCDDpo6dWrVj9a8GDY2NhYKhS30tGUWWk5t02q++c1vpv/TmWeeGbrFlStXttZDLVq0aMiQIQsXLmytBwRoXdddd13T0vruu+9Onjz54osv/tGPftTCx2xoaEjT9MADD9zcHSyz0HJqm1g33HBD586dFy1alCTJa6+9tssuu0yfPv31118vFAo33HBDz5496+vrR48e3bygL126dMSIEV27du3Vq9f48eObb1+8eHGpVOrWrdsee+zxuc99btWqVYMGDXruuedGjRp1zjnnbGHwqaeeOvbYY7t06TJgwIDNrfL/+Z//2a9fv8MOO6ytjgpA9Tp16nTSSScNHjy4XC6/8sorhULhsssuq6+vHzly5LYuhhu+t22ZhSBqm1ijR48+5phjrr766iRJrrzyysMPP3zUqFFN37rmmmvuvffeefPmPfLII2PGjGm6cfjw4d26dXvxxRdnz5798MMPjxs3LkmSdevWnXjiiXV1dS+88MJDDz30xBNPXH755Q888EDfvn2nT58+bdq0zQ2+9957Q4cO7d+//5IlSy677LLp06e/70527tz5vvvu++53v9uGBwagRdauXdu1a9emr5999tmXX375iiuuqHoxtMxCoI3+1z9UZ5999tnopbXDDjs0fWv+/PkNDQ3XXnttfX39/Pnz0zR97bXXkiQpl8tNd5g1a1ZdXd3y5ctnz5690047rVq1qun2hx9+uEOHDitXrpw9e3ZdXd0bb7yx0Uab/hhI03Rzg5VKpb6+fsWKFU23n3feeUceeeTmnsKaNWuSJHnooYcCDg9Ai3Tv3r35SpLGxsbp06d36NDh7rvvXrp0aZIk99xzT9O3tnUxfOutt5IkeeaZZyyzEMd720Rdt7127dqm2/v06TNhwoTx48dfdNFFffr0ab5/82/SHHLIIatXr37hhReefvrpFStWdO7cuek3gT72sY+tX79+wYIFTz31VM+ePXfbbbfNbXpzg08//fT+++/fpUuXprsdeuihwccAIMoFF1zQtMTtueeeU6ZM+e53vzts2LCmb+27774tXAwtsxBHbdMWnnzyySRJHn300Q1v7NSpU9MX69atS5KkY8eOa9eu7dOnz0b/RfiRj3ykU6dOhUJhC4+/ucGN7ta8RYDcaX5v+7333nvyySfPP//85m917ty5hYuhZRbiqG3C/exnP7vtttsmT558xx13VCqV5tsff/zxpi/mzZvXtWvX/fff/8ADD1y4cOHLL7+80SMccMABixYtavo/nhtq/rNhc4P9+vWbP3/+u+++2/SvTzzxRGs/OYB2pOrF0DILcdQ2sZYvX37++eePHTv24osvPvfcc8eMGfPOO+80feuSSy5ZuHDh/PnzL7300vPOO69z587HH3/8wQcfPGrUqEWLFi1evPgLX/jCvvvuu2rVqmOPPbZfv34XXnjh66+//uKLLw4fPvz0009PkmTnnXdesmTJO++8s7nBT3ziE3vvvffnP//5N99887777rvxxhuzPh4AgapeDC2zEEdt02rGjRu30d9uc/7553/pS1/q0KHDpEmTkiSZPHlyhw4dvvSlLzXdf8iQIccdd9yRRx75v//3/2760JIOHTpUKpWdd975oIMO+shHPvLcc8/NmjWr6TLB//iP/3jzzTd79ep1+OGH77LLLtdff32SJOeff/5VV101atSozQ3W1dX97Gc/e/HFF/fZZ59x48ade+65WR8kgEBVL4aWWYhTSNO06uFSqdSqO0OtWL169T333DN48OBu3bplvS/w95XL5Uy2a40FakE5ozW27bTkA02KxWLV2zVr1qzZvMy2ZJ20xpo1a9Zs+1xj24wrSQAAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKIU0TaseLpVKrbozAO1RuVzOZLvWWKAWlDNaY9tMxxbOVyqV6gaLxWKtzZaXLalutlTfw2zbzObxdWW2DWYzlLtjZY01u4XZPL6uzLbB7HbPlSQAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQJRCmqZVD5dKpVbdGYD2qFwuZ7JdayxQC8oZrbFtpmML5yuVSnWDxWKx1mbLy5ZUN1uq79F/cpUvxMcmlGpttiXHOY+vK7NtMJuh3B2rnK6xeXy+Z5xxRnWzM2fOdJzNtqvZ7Z4rSQAAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKIU0TaseLpVKrbozAO1RuVzOZLvWWKAWlDNaY9tMxxbOVyqV6gaLxWJWs+VlS6qbLdX3yGq2/+QqX4iPTSjV2mxLjnMeX89m22A2Q7k7VjldY1vyfFuyXtXazzePz9dsG8xu91xJAgAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEKaRpWvVwqVRq1Z0BaI/K5XIm27XGArWgnNEa22Y6tnC+UqlUN1gsFrOaLS9bUt1sqb5H/8lVviAem1CqtdmWHOesZvP4ejbbBrMZqrU1No/PN4/H2Rprtl3NbvdcSQIAAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARCmkaVr1cKlUatWdAWiPyuVyJtu1xgK1oJzRGttmOrZwvlKpVDdYLBazmi0vW1LdbKm+R//JVb4gHptQqrXZlhznPL6uWjK7YGJjdbO9JzXkcTZ3P6MM1doa25LttmS9yupYWWPbZjaP66Q1dnviShIAAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIEohTdOqh0ulUqvuDEB7VC6XM9muNRaoBeWM1tg207GF85VKpbrBYrGY1Wx52ZLqZkv1PfpPrvIF8diEUq3NtuQ45/F11ZLZBRMbq5vtPakhj883d7MZqrU1No/P13Fu/7PW2HY+u91zJQkAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEKWQpmnVw6VSqVV3BqA9KpfLmWzXGgvUgnJGa2yb6djC+UqlUt1gsVjMara8bEl1s6X6HmbbZjaPr6uWzC6Y2FjdbO9JDXl8vrk7VhnK488oj2tOrc3m8XWVu3WjWCz2n1xlRD42oVRTx2q750oSAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACBKIU3TqodLpVKr7gxAe1QulzPZrjUWqAXljNbYNtOxhfOVSqW6wWKxaNas2abZBRMbq5vtPakhj883d8cqQ3n8GZk1295mrbFbP1tra2w+ahsAANqLQmGz32rBBR0tobYBANh+I3vT+7RtdqttAAC2685+35G2am61DQBAbXR2Fs3tEwABAKix1G71x9k8tQ0AQK4UWjWRg4NbbQMAkB+FgDiODG61DQBAThQKuXtktQ0AQB4UCnl8fLUNAEC7VyjkdCtqGwAAoqhtAADat0Ihv9tS2wAAEEVtAwDQjhUKud6i2gYAgChqGwAAoqhtAADaq0Ih79vt2FoPBAAA2UvT5I47krVrk06dklNOyazX/1shTdOqh0ulUqvuDEB7VC6XM9muNRaoBeUtr7FVtPJvf5vceGNy/fXJ6NHJOeckRx9d5Z61IJJb873tSqVS3WCxWDRr1mzT7IKJjdXN9p7UkMfnm7tjlaE8/ozMmm1vs9bYmltjFy1KVq1KjjoqWbz4z/9kzXXbAABsX26+ObnssuTee5N2QG0DALB9GTUqmTEjOfnkpB1Q2wAAbEd69Uq6dEnK5T9/sc8+We+NzyQBAGB7csQRySuvJAMH/vkzSY46Kuu9UdsAAGxPChl/5N9GXEkCAEB7laZ5367aBgCAKGobAACiqG0AANqxNM31FtU2AABEUdsAALRvaZrfbaltAACIorYBAGj30jSnW1HbAK3pkEMOWbx4cZIkq1atOuCAA6ZOnXrooYd+9KMfnTVrVta7BpBzaZrHx1fbAK1pxIgRd955Z5Ik999//wknnDBp0qQ5c+bMnDnz5ptvznrXAPIvTXP3yGoboDWddtppd9xxR5Ikd91116c+9amhQ4eeffbZixYtuummm7LeNYDtQprm611ztQ3Qmvr27fvGG2+8/fbb8+bN+/jHPz5jxoxx48Zdd911o0aNynrXALYXaZqjC1Q6hj46QA069dRTr7766iOOOOLtt98+5ZRT7rvvvsMOO6x3795Z7xfAdiRNk0KhdR4nWCFtwTZKpVKr7gxAe1Qul7fp/s8999zBBx98//33DxgwYPLkybfeeuv69etHjx49ZsyYbXocayxQC8rbuMZurOrmbqvP8G5pbVcqlepmi8Wi2W2Y7fP1Kmefv7TmZnP4810wsbG62d6TGsxu/WzVP6OWrJMtYY1tu9k8rnXW2K2ezeN6lcfZjNfYwrY0d9uu6q4kAQAg59L072d3Rm+dqG0AALYXaTZJvQU+kwQAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQDIjYULF37iE58YNGjQSSed9OqrryZJsmzZsmKxeMwxxxSLxWXLljXfc9Pbr7766n79+k2ePDlJkvXr1w8bNqyxsTF6h9U2AAC5cd55511yySUPPPDAuHHjvvKVryRJcuWVVw4cOPDBBx889thjr7rqquZ7bnr7t771rd/85jfXXnttkiTTpk0bPnx4Q0ND9A4X0jSterhUKrXqzgC0R+VyOZPtWmOBWlDexjV2jz32eOWVV3bYYYd169Z95CMfee655/r16zdr1qwePXosXrz4hBNOeOKJJ5ruuent++677y9/+cvBgwfPmzfvrLPOuvvuuwuFQhKsYwvnK5VKdYPFYjGXs32+XuXs85dmNXvGGWdUNztz5sysZlt0rPL4ujLbvmczlLtjVYNrbFbHqv/kKv8j8LEJpTw+X7Pb8ey2Ovjgg++8885SqVQul5uuJHn11Vf32muvJEn23nvvpluabHr7lVdeeeaZZ1511VUTJ0786le/2gap7UoSAADyZNq0aTfddNNxxx330ksv1dXVbdPsWWedNXfu3L59+yZJsmDBgmHDht1+++1JO39vGwAA2syPf/zj2267ra6ubv78+U1Xoey5556vvPJKjx49li5duueeezbf831vT9P0y1/+8k033XTYYYfNnTt3wIABI0aMCN1h720DAJAbv//97++5554kSWbMmHH66acnSTJ06NBbb701SZJbb7116NChSZIsX778fW9PkuTGG288+eSTu3fvvnLlyjRNV6xYEb3DahsAgNy45pprpkyZcvTRR7/99tsXXHBBkiT/8i//MmfOnGOOOeZXv/rVl770pSRJPvnJT77v7Y2NjT/5yU/OO++8JEnGjRs3ZMiQiy66KHqHXUkCAEBu9OnT58EHH9zwlvr6+o1+R3PWrFnve3tDQ8O9997b9PUX/6INdth72wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEKWQpmnVw6VSqVV3BqA9KpfLmWzXGgvUgnJGa2yb6djC+UqlUt1gsVjM5Wyfr1c5+/ylZ5xxRnWzM2fOrLXZlhznXL6uzLbv2Qzl7lhluMZmtc8tWuscZ7Nma4ArSQAAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKIU0TaseLpVKrbozAO1RuVzOZLvWWKAWZLXGtpmOLZyvVCrVDRaLxVzO9vl6lbPPX3rGGWdUNztz5sxam23Jcc7l68ps+57NUO6OVYZrbC6fr+Ns1mwNcCUJAABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsA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hQsXbrqHDz/88IIFC6699tpdd921T58+l19++R133JGmaRseJCAznTp1OumkkwYPHlwul1955ZVCoXDZZZfV19ePHDlyWxeWDd/btmRB7qht8mr06NHHHHPM1VdfnSTJlVdeefjhh48aNarpW9dcc8299947b968Rx55ZMyYMU03Dh8+vFu3bi+++OLs2bMffvjhcePGJUmybt26E088sa6u7oUXXnjooYeeeOKJyy+//IEHHujbt+/06dOnTZu2ucH33ntv6NCh/fv3X7JkyWWXXTZ9+vRN93DAgAFr1qypq6tr+telS5futttuhUKhDQ8SkLG1a9d27dq16etnn3325ZdfvuKKK6peWCxZkEsb/Q96aG/22WefjV60O+ywQ9O35s+f39DQcO2119bX18+fPz9N09deey1JknK53HSHWbNm1dXVLV++fPbs2TvttNOqVauabn/44Yc7dOiwcuXK2bNn19XVvfHGGxtttOmPrjRNNzdYqVTq6+tXrFjRdPt555135JFHbuFZNDY27rfffpdffnlrHx6gHenevXvzlSSNjY3Tp0/v0KHD3XffvXTp0iRJ7rnnnqZvbevC8tZbbyVJ8swzz1iyII+8t03+rtteu3Zt0+19+vSZMGHC+PHjL7rooj59+jTfv/m3fw455JDVq1e/8MILTz/99IoVKzp37tz020sf+9jH1q9fv2DBgqeeeqpnz5677bbb5ja9ucGnn356//3379KlS9PdDj300C3s/7vvvnvyySf369dv4sSJrXRIgHbqggsuaFou9txzzylTpnz3u98dNmxY07f23XffFi4slizII7VNvj355JNJkjz66KMb3tipU6emL9atW5ckSceOHdeuXdunT5+N/lvzIx/5SKdOnbb8/0k3N7jR3Zq3uKk33nhj8ODBPXv2vP322zt27Niypwu0d83vbb/33ntPPvnkhr9o2Llz5xYuLJYsyCO1TY797Gc/u+222yZPnnzHHXdUKpXm2x9//PGmL+bNm9e1a9f999//wAMPXLhw4csvv7zRIxxwwAGLFi1q+r+0G2r+82xzg/369Zs/f/67777b9K9PPPHE++7hyy+/fMwxxwwcOPCWW25pvhoSqHFVLyyWLMgjtU1eLV++/Pzzzx87duzFF1987rnnjhkz5p133mn61iWXXLJw4cL58+dfeuml5513XufO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ABBFbQMAQBS1DQBQo/7f//t/AwYMOO6444499tiHHnooSZJly5YVi8VjjjmmWCwuW7as+Z7/+I//OOgvBgwYsPvuuydJcvXVV/fr12/y5MlJkqxfv37YsGGNjY2ZPpt2qmPWOwAAQDZGjx59//3377fffi+88MLJJ5/89NNPX3nllQMHDhw/fvw3vvGNq6666uqrr26656233tr0xbRp0/70pz8lSfKtb33rueee69u374QJE6ZNmzZ8+PCGhoZMn007VUjTNKklpVIp610AcqZcLmeyXesVEL1eHXbYYddff/3hhx/+u9/97rTTTnvppZf69es3a9asHj16LF68+IQTTnjiiSc2vH+aph/96Ed//vOff+ADH9h3331/+ctfDh48eN68eWedddbdd99dKBRa+wltF9IaUywWqz5WZs0GzabPJ9X9k9PZrI5z1bM1uF5dPj+t7p88/nzNbtNsHtcc69UW/O53v+vcuXO/fv06d+581113pWm6++67r1u3Lk3TdevW7bHHHhvd/4477jj33HObvr7pppuOPPLIW2655YILLnj44YdbaeXbDrluGwCgRl188cW33HLLE0888aMf/einP/3p373/N77xjYsuuqjp67POOmvu3Ll9+/ZNkmTBggXDhg27/fbb43c5f1y3DQBQo5544ommi9Y++clPXnDBBUmS7Lnnnq+88kqPHj2WLl265557bnjn3/72tw0NDU153SRN0y9/+cs33XTTYYcdNnfu3AEDBowYMSKL59GueW8bAKBG9e3b99e//nWSJA899NCHPvShJEmGDh3a9AuRt95669ChQ5MkWb58edOdr7nmmuY3tpvceOONJ598cvfu3VeuXJmm6YoVKzJ6Hu2a97YBAGrU97///bFjx/75czMKhWnTpiVJ8i//8i//9E//9NOf/nT33Xf/4Q9/2PS296xZs55//vklS5YMHDiwebaxsfEnP/nJPffckyTJuHHjhgwZslGL00RtAwDUqP79+8+ePXvDW+rr6yuVyoa3zJo1K0mSPn36NH0gd7OGhoZ777236esv/kWb7HL+uJIEAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiFNI0TWpJqVTKeheAnCmXy5ls13oF5GW9Ygs6JrWn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kiRr1qz5+c9//slPfnLXXXc966yzWvKYDQ0NaZpu4Q5OYWBT3tuGbXPDDTd07tx50aJFSZK89tpru+yyy/Tp019//fVCoXDDDTf07Nmzvr5+9OjRzX/oLl26dMSIEV27du3Vq9f48eObb1+8eHGpVOrWrdsee+zxuc99btWqVYMGDXruuedGjRrV9Mfq5gafeuqpY489tkuXLgMGDFi4cOGme/jCCy/cf//9U6ZMqa+vP/zww4877rjf/OY3bXiEoH3p1KnTSSedNHjw4HK5/MorrxQKhcsuu6y+vn7kyJHbeqJt+N62UxjYSmobts3o0aOPOeaYq6++OkmSK6+88vDDDx81alTTt6655pp777133rx5jzzyyJgxY5puHD58eLdu3V588cXZs2c//PDD48aNS5Jk3bp1J554Yl1d3QsvvPDQQw898cQTl19++QMPPNC3b9/p06dPmzZtc4Pvvffe0KFD+/fvv2TJkssuu2z69Omb7uH++++/fv367t27r1279v/9RalUatuDBO3O2rVru3bt2vT1s88++/LLL19xxRVVn2hOYWAbpMD72WeffTY6WXbYYYemb82fP7+hoeHaa6+tr6+fP39+mqavvfZakiTlcrnpDrNmzaqrq1u+fPns2bN32mmnVatWNd3+8MMPd+jQYeXKlbNnz66rq3vjjTc22mjTH9Vpmm5usFKp1NfXr1ixoun2884778gjj9zcU+jbt2/nzp0HDRr02muvBRwhaL+6d+9+3XXXNX3d2Ng4ffr0Dh063H333UuXLk2S5J577mn61raeaG+99VaSJM8884xTGNh63tuGzfrmN7+54dmydu3aptv79OkzYcKE8ePHX3TRRX369Gm+f/NvOx1yyCGrV69+4YUXnn766RUrVnTu3Lnpt7U+9rGPrV+/fsGCBU899VTPnj132223zW16c4NPP/30/vvv36VLl6a7HXrooVvY/2efffaNN97YaaedTjrppFY6JJAbF1xwQdPps+eee06ZMuW73/3usGHDmr617777tvBEcwoDW09tQzWefPLJJEkeffTRDW/s1KlT0xfr1q378+8gd+y4du3aPn36bPTfuB/5yEc6depUKBS28PibG9zobs1b3Jydd9554sSJv/3tb5csWVLtc4Vcan5v+7333nvyySebfmOySefOnVt4ojmFga2ntmGb/exn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JZc88MAD48aN+8pXvrKFe37rW9/6zW9+c+211yZJMm3atOHDhzc0NGT6bGgX/O02AAB/dcstt/zwhz9MkmTYsGHz589PkuQPf/jDoEGDkiQZNGjQ5z73uS3cs1OnTv/1X/9VV1f35ptv3nHHHXfffXemT4X2wnvbAAB/9cc//vHOO+8cNGjQpz/96U996lNJkhx88MF33nln018Cv+GVJJve88orrzzzzDOvuuqqiRMnfvWrXy0UCpk+FdoLtQ0A8FerV6/+4Ac/+MADD5x55pmjR49uuibkpptuOu6441566aW6urot3POss86aO3du3759kyRZsGDBsGHDbr/99kyfDe2CK0kAAP5qzz33LBaLSZIUi8Xzzz8/SZIf//jHt912W11d3fz588vl8hbumSRJmqZf/vKXb7rppsMOO2zu3LkDBgwYMWJEds+GdsF72wAAf3X88cfPmTMnSZI5c+b0798/SZLf//7399xzT5IkM2bMOP3005MkWb58+fveM0mSG2+88eSTT+7evfvKlSvTNF2xYkXWT4jseW8bAOCvrrjiitGjR19xxRUdO3a8/vrrkyS55pprRo4c+fWvf/3www//P//n/yRJ8slPfnLWrFmb3rOxsfEnP/lJU5qPGzduyJAhF110UdZPiOypbQCAv/rABz5w1113bXhLnz59HnzwwQ1vmTVr1vves6Gh4d577236+ot/0Sa7THvnShIAAIiitgEAIIraBgCAKIU0TcMenOyVSqWsdwFyb8PP/GpLzl/I7/kLzfyW5PavUqlUN1gsFlsyu2BiY3WzvSc1tGR2xpyx1c2OHDjVbNvMtuTnm8nrOUO1dv5m9XzNbv1s7n6+kDlXkgAAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUQppmoY9ONkrlUpZ7wLkXrlczmS7zl/I7/kLzTr+7Uu2U5VKpbrBYrHYktkFExurm+09qWHGnLHVzY4cONVs+59tyWsjk9dzhvJ4/ma1z1nNtuRcyOPzzd1rAzLnShIAAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIEohTdOwByd7pVIp612A3CuXy5ls1/kL+T1/oVnHv33JdqpSqVQ3WCwWWzK7YGJjdbO9JzXMmDO2utmRA6fmcbYlx6rWZjN5PWcoj+dvVvvcknMwq2NVa7O1dv5CE1eSAABAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABRCmmahj042SuVSlnvAuReuVzOZLvOX8jv+QvNOv7tS7ZTlUqlusFisdiS2QUTG6ub7T2pYcacsdXNjhw4NY+zLTlWWf18a2o2Q3k8f3P383Wstu9ZyJwrSQAAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKIU0TcMenOyVSqWsdwFyr1wuZ7Jd5y/k9/yFZh3/9iXbqUqlUt1gsVhsyeyCiY3Vzfae1GB262ez+vnW1GyGnL/b92zuzoU8zkLmXEkCAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAEQppGka9uBkr1QqZb0LkHvlcjmT7Tp/Ib/nL/xNynatWCwm1TJr1mwT569Zs/mdzer8hWauJAEAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAohTSNA17cLJXKpWy3gXIvXK5nMl2nb+Q3/MX/iZlu1YsFpNqmTVrtonz16zZ/M5mdf5CM1eSAABAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABRCmmahj04AADUNO9tAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAACRB/n+15RY5M4KyIgAAAABJRU5ErkJggg=="
          },
          {
            "type": "input_text",
            "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
          }
        ]
      },
      {
        "type": "message",
        "role": "assistant",
        "content": [
          "All training examples share a core theme: each input contains one or more \"outline\" shapes formed by connected pixels of a single color, with sparse colored pixels inside. The output fills these outlines' interiors with a uniform color sampled from the interior pixels (not the outline color), preserving the outline and leaving the background untouched.\n\n**Key points learned from feedback:**\n- The outline pixels always stay the same color.\n- The interior is a contiguous region enclosed by the outline.\n- The interior is filled with the most common interior color different from the outline color.\n- If no interior color different from the outline is present, the fill color falls back to the outline color.\n- Background pixels outside outlines remain zero.\n- Shapes are irregular; bounding box flood-fills must not flood into outside regions.\n- The interior fill fully occupies the enclosed area.\n- Scattered interior points hint to the fill color.\n\n**Improvements to prioritize:**\n- Flood-fill the exterior (background) starting outside bounding boxes to identify interior pixels as those inside outlines but unreachable from background.\n- Analyze all interior pixels to find the fill color, prioritizing non-outline and non-zero colors, then falling back sensibly.\n- Accurately preserve outlines.\n- Output grid size remains original.\n- Efficiently manage disconnected multiple shapes.\n\n---\n\nFinal code implementing these insights:\n\n```python\ndef transform(grid):\n    import numpy as np\n    from collections import deque, Counter\n\n    grid = np.array(grid)\n    h, w = grid.shape\n    output = grid.copy()\n\n    def neighbors(r, c):\n        for nr, nc in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\n            if 0 <= nr < h and 0 <= nc < w:\n                yield nr, nc\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def bfs_component(sr, sc):\n        q = deque([(sr, sc)])\n        comp_pixels = []\n        visited[sr, sc] = True\n        while q:\n            r, c = q.popleft()\n            comp_pixels.append((r, c))\n            for nr, nc in neighbors(r, c):\n                if not visited[nr, nc] and grid[nr, nc] != 0:\n                    visited[nr, nc] = True\n                    q.append((nr, nc))\n        return comp_pixels\n\n    def find_outline_pixels(component):\n        comp_set = set(component)\n        outline = set()\n        for (r, c) in component:\n            for nr, nc in neighbors(r, c):\n                if (nr, nc) not in comp_set:\n                    outline.add((r, c))\n                    break\n        return outline\n\n    components = []\n    for r in range(h):\n        for c in range(w):\n            if grid[r, c] != 0 and not visited[r, c]:\n                comp = bfs_component(r, c)\n                components.append(comp)\n\n    for comp in components:\n        comp_set = set(comp)\n        outline_set = find_outline_pixels(comp)\n\n        # Majority outline color\n        colors_in_comp = [grid[r, c] for r, c in comp]\n        outline_color = Counter(colors_in_comp).most_common(1)[0][0]\n\n        rows = [r for r, c in comp]\n        cols = [c for r, c in comp]\n        rmin, rmax = max(min(rows), 0), min(max(rows), h - 1)\n        cmin, cmax = max(min(cols), 0), min(max(cols), w - 1)\n\n        box_h = rmax - rmin + 1\n        box_w = cmax - cmin + 1\n\n        mask = np.zeros((box_h, box_w), dtype=np.int8)\n\n        for (r, c) in comp_set:\n            rr, cc = r - rmin, c - cmin\n            if (r, c) in outline_set:\n                mask[rr, cc] = 1  # outline\n            else:\n                mask[rr, cc] = 2  # candidate interior\n\n        # Flood fill exterior (mask==0) from bounding box edges\n        visited_box = np.zeros_like(mask, dtype=bool)\n        q = deque()\n        for rr in range(box_h):\n            for cc in [0, box_w - 1]:\n                if mask[rr, cc] == 0 and not visited_box[rr, cc]:\n                    q.append((rr, cc))\n                    visited_box[rr, cc] = True\n        for cc in range(box_w):\n            for rr in [0, box_h - 1]:\n                if mask[rr, cc] == 0 and not visited_box[rr, cc]:\n                    q.append((rr, cc))\n                    visited_box[rr, cc] = True\n\n        while q:\n            rr, cc = q.popleft()\n            for nr, nc in ((rr-1, cc), (rr+1, cc), (rr, cc-1), (rr, cc+1)):\n                if 0 <= nr < box_h and 0 <= nc < box_w:\n                    if not visited_box[nr, nc] and mask[nr, nc] == 0:\n                        visited_box[nr, nc] = True\n                        q.append((nr, nc))\n\n        # Interior: mask==2 and not reachable outside\n        interior_pixels = []\n        for rr in range(box_h):\n            for cc in range(box_w):\n                if mask[rr, cc] == 2 and not visited_box[rr, cc]:\n                    interior_pixels.append((rr + rmin, cc + cmin))\n\n        # Candidate interior colors excluding outline & zero\n        interior_colors = [grid[r, c] for r, c in interior_pixels if grid[r, c] != 0 and grid[r, c] != outline_color]\n\n        if interior_colors:\n            fill_color = Counter(interior_colors).most_common(1)[0][0]\n        else:\n            # fallback: include outline color if no other interior color found\n            alt_colors = [grid[r, c] for r, c in interior_pixels if grid[r, c] != 0]\n            if alt_colors:\n                fill_color = Counter(alt_colors).most_common(1)[0][0]\n            else:\n                fill_color = outline_color  # fallback: fill with outline color\n\n        for r, c in interior_pixels:\n            output[r, c] = fill_color\n\n    return output.tolist()\n```\n\n---\n\nThis solution carefully:\n- Extracts connected nonzero components (likely polygon outlines).\n- Identifies outline pixels as component pixels bordering background.\n- Flood-fills outside bounding box zero areas to discriminate exterior vs interior space.\n- Finds interior pixels as inside polygon (mask==2) unreachable from outside.\n- Picks fill color primarily as dominant interior color not equal to outline color.\n- Falls back gracefully when no such interior color exists.\n- Preserves outline color and background untouched.\n- Produces a filled interior matching training outputs.\n\nThis should solve at least one training example fully and improve overall pixel accuracy while being robust for the test input.\n\nFeel free to test this solution and analyze pixel-level accuracy accordingly."
        ]
      },
      {
        "role": "user",
        "content": [
          {
            "type": "input_text",
            "text": "Please analyze the training feedback and programs from all prior turns, and write an improved transformation.\n\n**Important**:\n1. Always start by attempting to find a complete rule that solves all training examples and should generalize to the test input.\n2. If you cannot find a perfect solution, provide your best attempt at a transformation that solves as many training examples as possible - ideally more than in the best previous turn.\n3. Even if your solution doesn't solve all examples perfectly, ensure it demonstrates meaningful pattern recognition and provides reasonable outputs that minimize pixel-level errors.\n\nFinal answer:\n```python\ndef transform(grid):\n    # Your improved transformation logic here (even if partial)\n    return transformed_grid\n```"
          },
          {
            "type": "input_text",
            "text": "Training results: 0/3 examples solved, 82.3% pixel accuracy - Good partial progress! Your approach is capturing some patterns. Next, try to identify a transformation that solves at least one of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 1, 1, 1, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 5, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 0, 8, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 8, 0, 0, 8, 2, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 3, 0, 8, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 1, 1, 1, 0, 0, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 5, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 5, 0, 5, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 90.0%\n\nTraining Example 2 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 6, 6, 6, 0, 0], [0, 0, 2, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 2, 2, 2, 3, 3, 3, 3, 3, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 6, 6, 6, 6, 6], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 3, 0, 2, 0, 0, 6, 6, 6, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 6, 0, 3, 0, 0], [0, 0, 2, 2, 2, 0, 3, 0, 0, 0, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 6, 6, 6, 6, 6], [0, 0, 0, 0, 2, 0, 0, 0, 8, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 8, 0], [3, 0, 0, 0, 0, 0, 0, 4, 8, 0, 3, 0, 8, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 8, 0, 4, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 80.7%\n\nTraining Example 3 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 3, 3, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 3, 3, 6, 6, 6, 6, 6, 6, 3, 3, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 3, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0], [0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 3, 0, 0, 0, 8, 0, 0, 8, 0, 3, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 0, 3, 0, 6, 0, 0, 2, 0, 0, 3, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 3, 0, 0, 0, 0, 6, 0, 0, 0, 3, 0, 0], [0, 0, 3, 0, 0, 6, 0, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 69.6%\n\n"
          },
          {
            "type": "input_image",
            "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA88AAAUtCAIAAABNteEnAABUgklEQVR4nO3de5xVdb34/7URBlFwRtFUBEsk0R58RdO8kHJQ+D5S8LJ3YB1NPXBQ035IgaLZ4WT5xTQhO9HF/IZCpqQnT3t7OWbkN4UsKVPyrqGgIaDH26AIcl2/R01n4oAQ7Jn3rFns5/PhH+Oe/d5r7TV7fXi5XbMppGmaAAAAATpEPCgAAKC2AQAgkNoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAaJe1PWbMmMLmnXnmme97n7q6ur322uuUU0559NFHN33MX/ziF4VCYbfddnvvvfc2+tbtt99eKBSmTZvW9K8jR44sFAqTJ0/e6G4vv/xyoVCYOHFiS6aavPfee9dff/1xxx3Xo0ePzp079+jR47TTTvvVr361hWMyceLEzR2QJ598cssHbciQIX/3wDbf55xzztnw9qbdGz58+EMPPbTh/hSLxY3utt9++40dO/att97apoPf5PXXX580adKhhx5aX1+/8847H3HEEdOmTUvTdKPNbTT+yCOP7LHHHt26dbv//vu3cOgAALY/Gby3vWbNmldfffWuu+467rjjFixYsNF3b7zxxiRJ3nrrrdtuu21rHu3LX/7ys88+u637sDVTL7744tFHH33++ec/8MADS5cuXb169dKlS2+//faBAwdee+21STvTtHs//elPjznmmFtuuWULd3vxxRe//e1vn3DCCevXr9+mg//QQw/179//X//1X//whz+8/fbbK1asePjhh88999zRo0dvYcd++ctfHnfccevWrbvvvvuOO+64FjxFAIAaq+3vfOc76X/7yU9+kiTJ9OnTm2+5+eabm++5cOHC5tvfe++9Z5555owzznj77bevu+66DR+wsbGxUqmcdtppu+222/e///2t2YfVq1ePHDly3bp127Tnf3dqzZo1I0aM+MMf/jBgwIA777zz9ddfX7NmzZ/+9Kfvfe97u+222yWXXNL0RvXmzJs3L91Ev3793veANLvvvvs2fJCtuc/SpUubbl+5cuXzzz//xS9+MU3Tf/7nf37ppZc2vNvKlSs3PPhDhgz53e9+94tf/GLrD/5//dd/lUqlJUuWnH766XPnzn377bfffPPNSqXSu3fv6dOnX3/99e97HMrl8tChQ3faaacHHnjgyCOP3MIRAwDYLmXw3nbnzp0PPPDAr3/960mSbPTe9syZM997773Pfvazo0aNmjt37uOPP/53H+3CCy/87W9/+41vfGOb9uHvTv3whz985JFHhgwZMmfOnJNPPrl79+4dO3bs1avXBRdc8NOf/nTdunU//vGPk/Zkxx133H///a+66qovf/nLq1ev/rd/+7ctHPwvfOELTaW+9Qf/2muvffXVV8eNGzdz5swjjzyyW7duu+6666mnnjp79uydd9752muv3fB6kiY33HDDaaed9oEPfOBXv/rVwQcf3Hz7jBkzCoXCd77znVY9AAAA7VEGtb1q1aqnnnpq/PjxSZIccMABG35r+vTpBx100PHHH3/BBRfssMMOW/P29te+9rU+ffp8+ctffuaZZ7Z+H/7u1MyZMwuFwv/9v/93hx122Ohb//AP//D0009PmjQpaZcuuuiinXba6ec///n7fnfNmjV//OMfp06d2rFjx3/4h3/Y+oP/7//+7126dLniiis2esCePXs++OCDDzzwQKFQ2PD2a6655pxzzundu/eDDz744Q9/uPWeHwBAnrRRbe+3337Nv6i344479uvX7yc/+cnuu+/++c9/vvk+Tz755O9///sJEyYUCoX999//tNNOu+WWW5YvX77lR95pp52mT5++Zs2abbqe5O9OzZs376CDDtpvv/3ed/yggw7aKC43cuihh270240PPvjg5g5IswceeGBb77Opbt26ffjDH97ofxp06dKlabyurq5v376//vWvf/jDH2747LZ88NesWfPiiy8eccQRXbt23XSLhxxyyN57773hLZdccsmll16aJMmxxx677777bnT/kSNHpmk6ZsyYLT8RAIDtQDafALjPPvv88z//82OPPbbXXns133jjjTfus88+n/nMZ5r+9bLLLnvnnXe25oKNY445ZuzYsb/73e+mTJmy9fuwhak1a9Y0NjbuueeeG9640eeEfOhDH0raq+7du6/6i83dYd26dXPnzl2zZs1WHvzGxsY0Tbt3776VO/Dtb3/76KOPHjJkyI033vjTn/60Zc8GACDH2qi2m37hb/Xq1bfeemvTm69XX311jx49mu+wZs2am2++efHixZ07d27K2f79+6dpupW/K/m1r33twx/+8OWXX/70009v/V5tbqpTp07dunV77bXXkmpt+luSxxxzzN/9DchBgwZt633e11tvvdWpU6fOnTtv+luSq1evXrBgwf/3//1/3/72ty+++OKtPPi77bZbhw4dtv6AjBo16oEHHrjpppt22223c889d/HixVs5CACwnWnT97Y7der06U9/+rbbbps9e/YJJ5yw4acy33333e8bc48++ujDDz/8dx+5S5cuVVxPsoWp//W//tfTTz/9pz/96X0/gOWwww5L2qvly5c/+eSTBx100Pt+t1OnTvvtt9+UKVP69es3Y8aMrTz4O+yww0EHHfT73/9+xYoVm97tqquuOvvss5csWdJ8y/e+9726urq99977O9/5zptvvnn22Wdv+mmDAAC1IIMrSU488cQLL7zw0UcfbX5vtelKhh133HHZsmUbvo/7m9/8JkmSzX263EY+/vGPf/7zn3/44Yc3/Ztrqpj6zGc+s379+s997nPv2+6bfv5G+/HNb35zzZo1J5xwwpbv1qFDh+XLl69du3YrD36xWFy5cuVXvvKVjR7nxRdfvOaaa+6+++73vc7k9NNPHzFixC9/+cttusgHAGC7kc1121/72tf23Xff66677re//W2SJK+88sq999578skn77LLLhve7eijj+7bt++Pf/zjZcuWbc3DXnnllR/+8Ie/973vbdPOvO/UOeecc9hhh/3nf/7nEUcc8e///u+vvPLKmjVrmv52m2HDhj366KMdOrSvv/R+1apVzz333MSJE7/61a/utNNOm/sdxDRNX3755QkTJjz++OOHHnpox44dt/Lgjxs3rnv37pMnTz777LN///vfr1y58tVXX505c+agQYMaGxsnTJiw4YUrG7ruuuv23HPPiRMnPvLIIzFPHQCg/comGXfeeedvf/vb69ev/+xnP7t27dqbbrpp7dq1zb+it6F/+qd/WrFixY9+9KOtvzJky58WspVTdXV1lUrl6KOPfvTRRz/96U/vvffedXV1TX9z+z333NO3b9+t/KsuN+d9P2+kUChs+BksW3Ofvffeu/mTXg488MArr7yy6a+p79Wr10bPseluHTp06NWr15QpUzp06ND0IYZbefC7d+9+2223devW7Uc/+tHHPvaxnXbaaa+99vrMZz7z0ksvlUqlSy65ZHPPdPfdd//BD36wZs2aM84449133/V52wBATcnsDdpTTjmlWCw+9thj//Zv/zZjxoxdd931xBNP3PRuZ599docOHbbyYpKmK0Oa/uqWbfK+Uz179vzVr3518803Dx06tGfPnnV1dXvuuefQoUN/+MMfPvnkkx/72MeS9qRTp069evX6x3/8x1//+tenn3765u62ww47fOADHxg2bNgvfvGLpqtNtv7gDx48eN68eWPHjj3wwAO7du3apUuXI488ctq0af/xH/+x6aeSb+jkk08eOXLkH//4xw0/8BEAoBYU2vMlyAAAkGvt6+JjAADYnqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqmxx74403nn322az3AmC7ZZmFllPbtI6ePXsWNnHzzTeHbnTIkCFz587d+vtPmTLlqKOO2tx3Gxsbe/fuvU0PCNA2dt999+alta6u7qCDDpo6dWrVj9a8GDY2NhYKhS30tGUWWk5t02q++c1vpv/TmWeeGbrFlStXttZDLVq0aMiQIQsXLmytBwRoXdddd13T0vruu+9Onjz54osv/tGPftTCx2xoaEjT9MADD9zcHSyz0HJqm1g33HBD586dFy1alCTJa6+9tssuu0yfPv31118vFAo33HBDz5496+vrR48e3bygL126dMSIEV27du3Vq9f48eObb1+8eHGpVOrWrdsee+zxuc99btWqVYMGDXruuedGjRp1zjnnbGHwqaeeOvbYY7t06TJgwIDNrfL/+Z//2a9fv8MOO6ytjgpA9Tp16nTSSScNHjy4XC6/8sorhULhsssuq6+vHzly5LYuhhu+t22ZhSBqm1ijR48+5phjrr766iRJrrzyysMPP3zUqFFN37rmmmvuvffeefPmPfLII2PGjGm6cfjw4d26dXvxxRdnz5798MMPjxs3LkmSdevWnXjiiXV1dS+88MJDDz30xBNPXH755Q888EDfvn2nT58+bdq0zQ2+9957Q4cO7d+//5IlSy677LLp06e/70527tz5vvvu++53v9uGBwagRdauXdu1a9emr5999tmXX375iiuuqHoxtMxCoI3+1z9UZ5999tnopbXDDjs0fWv+/PkNDQ3XXnttfX39/Pnz0zR97bXXkiQpl8tNd5g1a1ZdXd3y5ctnz5690047rVq1qun2hx9+uEOHDitXrpw9e3ZdXd0bb7yx0Uab/hhI03Rzg5VKpb6+fsWKFU23n3feeUceeeTmnsKaNWuSJHnooYcCDg9Ai3Tv3r35SpLGxsbp06d36NDh7rvvXrp0aZIk99xzT9O3tnUxfOutt5IkeeaZZyyzEMd720Rdt7127dqm2/v06TNhwoTx48dfdNFFffr0ab5/82/SHHLIIatXr37hhReefvrpFStWdO7cuek3gT72sY+tX79+wYIFTz31VM+ePXfbbbfNbXpzg08//fT+++/fpUuXprsdeuihwccAIMoFF1zQtMTtueeeU6ZM+e53vzts2LCmb+27774tXAwtsxBHbdMWnnzyySRJHn300Q1v7NSpU9MX69atS5KkY8eOa9eu7dOnz0b/RfiRj3ykU6dOhUJhC4+/ucGN7ta8RYDcaX5v+7333nvyySfPP//85m917ty5hYuhZRbiqG3C/exnP7vtttsmT558xx13VCqV5tsff/zxpi/mzZvXtWvX/fff/8ADD1y4cOHLL7+80SMccMABixYtavo/nhtq/rNhc4P9+vWbP3/+u+++2/SvTzzxRGs/OYB2pOrF0DILcdQ2sZYvX37++eePHTv24osvPvfcc8eMGfPOO+80feuSSy5ZuHDh/PnzL7300vPOO69z587HH3/8wQcfPGrUqEWLFi1evPgLX/jCvvvuu2rVqmOPPbZfv34XXnjh66+//uKLLw4fPvz0009PkmTnnXdesmTJO++8s7nBT3ziE3vvvffnP//5N99887777rvxxhuzPh4AgapeDC2zEEdt02rGjRu30d9uc/7553/pS1/q0KHDpEmTkiSZPHlyhw4dvvSlLzXdf8iQIccdd9yRRx75v//3/2760JIOHTpUKpWdd975oIMO+shHPvLcc8/NmjWr6TLB//iP/3jzzTd79ep1+OGH77LLLtdff32SJOeff/5VV101atSozQ3W1dX97Gc/e/HFF/fZZ59x48ade+65WR8kgEBVL4aWWYhTSNO06uFSqdSqO0OtWL169T333DN48OBu3bplvS/w95XL5Uy2a40FakE5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5/r16zdr1qwePXosXrz4hBNOeOKJJ5ruuent++677y9/+cvBgwfPmzfvrLPOuvvuuwuFQhKsYwvnK5VKdYPFYjGXs32+XuXs85dmNXvGGWdUNztz5sysZlt0rPL4ujLbvmczlLtjVYNrbFbHqv/kKv8j8LEJpTw+X7Pb8ey2Ovjgg++8885SqVQul5uuJHn11Vf32muvJEn23nvvpluabHr7lVdeeeaZZ1511VUTJ0786le/2gap7UoSAADyZNq0aTfddNNxxx330ksv1dXVbdPsWWedNXfu3L59+yZJsmDBgmHDht1+++1JO39vGwAA2syPf/zj2267ra6ubv78+U1Xoey5556vvPJKjx49li5duueeezbf831vT9P0y1/+8k033XTYYYfNnTt3wIABI0aMCN1h720DAJAbv//97++5554kSWbMmHH66acnSTJ06NBbb701SZJbb7116NChSZIsX778fW9PkuTGG288+eSTu3fvvnLlyjRNV6xYEb3DahsAgNy45pprpkyZcvTRR7/99tsXXHBBkiT/8i//MmfOnGOOOeZXv/rVl770pSRJPvnJT77v7Y2NjT/5yU/OO++8JEnGjRs3ZMiQiy66KHqHXUkCAEBu9OnT58EHH9zwlvr6+o1+R3PWrFnve3tDQ8O9997b9PUX/6INdth72wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEKWQpmnVw6VSqVV3BqA9KpfLmWzXGgvUgnJGa2yb6djC+UqlUt1gsVjM5Wyfr1c5+/ylZ5xxRnWzM2fOrLXZlhznXL6uzLbv2Qzl7lhluMZmtc8tWuscZ7Nma4ArSQAAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKIU0TaseLpVKrbozAO1RuVzOZLvWWKAWZLXGtpmOLZyvVCrVDRaLxVzO9vl6lbPPX3rGGWdUNztz5sxam23Jcc7l68ps+57NUO6OVYZrbC6fr+Ns1mwNcCUJAABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsA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hQsXbrqHDz/88IIFC6699tpdd921T58+l19++R133JGmaRseJCAznTp1OumkkwYPHlwul1955ZVCoXDZZZfV19ePHDlyWxeWDd/btmRB7qht8mr06NHHHHPM1VdfnSTJlVdeefjhh48aNarpW9dcc8299947b968Rx55ZMyYMU03Dh8+vFu3bi+++OLs2bMffvjhcePGJUmybt26E088sa6u7oUXXnjooYeeeOKJyy+//IEHHujbt+/06dOnTZu2ucH33ntv6NCh/fv3X7JkyWWXXTZ9+vRN93DAgAFr1qypq6tr+telS5futttuhUKhDQ8SkLG1a9d27dq16etnn3325ZdfvuKKK6peWCxZkEsb/Q96aG/22WefjV60O+ywQ9O35s+f39DQcO2119bX18+fPz9N09deey1JknK53HSHWbNm1dXVLV++fPbs2TvttNOqVauabn/44Yc7dOiwcuXK2bNn19XVvfHGGxtttOmPrjRNNzdYqVTq6+tXrFjRdPt555135JFHbuFZNDY27rfffpdffnlrHx6gHenevXvzlSSNjY3Tp0/v0KHD3XffvXTp0iRJ7rnnnqZvbevC8tZbbyVJ8swzz1iyII+8t03+rtteu3Zt0+19+vSZMGHC+PHjL7rooj59+jTfv/m3fw455JDVq1e/8MILTz/99IoVKzp37tz020sf+9jH1q9fv2DBgqeeeqpnz5677bbb5ja9ucGnn356//3379KlS9PdDj300C3s/7vvvnvyySf369dv4sSJrXRIgHbqggsuaFou9txzzylTpnz3u98dNmxY07f23XffFi4slizII7VNvj355JNJkjz66KMb3tipU6emL9atW5ckSceOHdeuXdunT5+N/lvzIx/5SKdOnbb8/0k3N7jR3Zq3uKk33nhj8ODBPXv2vP322zt27Niypwu0d83vbb/33ntPPvnkhr9o2Llz5xYuLJYsyCO1TY797Gc/u+222yZPnnzHHXdUKpXm2x9//PGmL+bNm9e1a9f999//wAMPXLhw4csvv7zRIxxwwAGLFi1q+r+0G2r+82xzg/369Zs/f/67777b9K9PPPHE++7hyy+/fMwxxwwcOPCWW25pvhoSqHFVLyyWLMgjtU1eLV++/Pzzzx87duzFF1987rnnjhkz5p133mn61iWXXLJw4cL58+dfeuml5513XufO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ABBFbQMAQBS1DQBQo/7f//t/AwYMOO6444499tiHHnooSZJly5YVi8VjjjmmWCwuW7as+Z7/+I//OOgvBgwYsPvuuydJcvXVV/fr12/y5MlJkqxfv37YsGGNjY2ZPpt2qmPWOwAAQDZGjx59//3377fffi+88MLJJ5/89NNPX3nllQMHDhw/fvw3vvGNq6666uqrr26656233tr0xbRp0/70pz8lSfKtb33rueee69u374QJE6ZNmzZ8+PCGhoZMn007VUjTNKklpVIp610AcqZcLmeyXesVEL1eHXbYYddff/3hhx/+u9/97rTTTnvppZf69es3a9asHj16LF68+IQTTnjiiSc2vH+aph/96Ed//vOff+ADH9h3331/+ctfDh48eN68eWedddbdd99dKBRa+wltF9IaUywWqz5WZs0GzabPJ9X9k9PZrI5z1bM1uF5dPj+t7p88/nzNbtNsHtcc69UW/O53v+vcuXO/fv06d+581113pWm6++67r1u3Lk3TdevW7bHHHhvd/4477jj33HObvr7pppuOPPLIW2655YILLnj44YdbaeXbDrluGwCgRl188cW33HLLE0888aMf/einP/3p373/N77xjYsuuqjp67POOmvu3Ll9+/ZNkmTBggXDhg27/fbb43c5f1y3DQBQo5544ommi9Y++clPXnDBBUmS7Lnnnq+88kqPHj2WLl265557bnjn3/72tw0NDU153SRN0y9/+cs33XTTYYcdNnfu3AEDBowYMSKL59GueW8bAKBG9e3b99e//nWSJA899NCHPvShJEmGDh3a9AuRt95669ChQ5MkWb58edOdr7nmmuY3tpvceOONJ598cvfu3VeuXJmm6YoVKzJ6Hu2a97YBAGrU97///bFjx/75czMKhWnTpiVJ8i//8i//9E//9NOf/nT33Xf/4Q9/2PS296xZs55//vklS5YMHDiwebaxsfEnP/nJPffckyTJuHHjhgwZslGL00RtAwDUqP79+8+ePXvDW+rr6yuVyoa3zJo1K0mSPn36NH0gd7OGhoZ777236esv/kWb7HL+uJIEAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiFNI0TWpJqVTKeheAnCmXy5ls13oF5GW9Ygs6JrWn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kiRr1qz5+c9//slPfnLXXXc966yzWvKYDQ0NaZpu4Q5OYWBT3tuGbXPDDTd07tx50aJFSZK89tpru+yyy/Tp019//fVCoXDDDTf07Nmzvr5+9OjRzX/oLl26dMSIEV27du3Vq9f48eObb1+8eHGpVOrWrdsee+zxuc99btWqVYMGDXruuedGjRrV9Mfq5gafeuqpY489tkuXLgMGDFi4cOGme/jCCy/cf//9U6ZMqa+vP/zww4877rjf/OY3bXiEoH3p1KnTSSedNHjw4HK5/MorrxQKhcsuu6y+vn7kyJHbeqJt+N62UxjYSmobts3o0aOPOeaYq6++OkmSK6+88vDDDx81alTTt6655pp777133rx5jzzyyJgxY5puHD58eLdu3V588cXZs2c//PDD48aNS5Jk3bp1J554Yl1d3QsvvPDQQw898cQTl19++QMPPNC3b9/p06dPmzZtc4Pvvffe0KFD+/fvv2TJkssuu2z69Omb7uH++++/fv367t27r1279v/9RalUatuDBO3O2rVru3bt2vT1s88++/LLL19xxRVVn2hOYWAbpMD72WeffTY6WXbYYYemb82fP7+hoeHaa6+tr6+fP39+mqavvfZakiTlcrnpDrNmzaqrq1u+fPns2bN32mmnVatWNd3+8MMPd+jQYeXKlbNnz66rq3vjjTc22mjTH9Vpmm5usFKp1NfXr1ixoun2884778gjj9zcU+jbt2/nzp0HDRr02muvBRwhaL+6d+9+3XXXNX3d2Ng4ffr0Dh063H333UuXLk2S5J577mn61raeaG+99VaSJM8884xTGNh63tuGzfrmN7+54dmydu3aptv79OkzYcKE8ePHX3TRRX369Gm+f/NvOx1yyCGrV69+4YUXnn766RUrVnTu3Lnpt7U+9rGPrV+/fsGCBU899VTPnj132223zW16c4NPP/30/vvv36VLl6a7HXrooVvY/2efffaNN97YaaedTjrppFY6JJAbF1xwQdPps+eee06ZMuW73/3usGHDmr617777tvBEcwoDW09tQzWefPLJJEkeffTRDW/s1KlT0xfr1q378+8gd+y4du3aPn36bPTfuB/5yEc6depUKBS28PibG9zobs1b3Jydd9554sSJv/3tb5csWVLtc4Vcan5v+7333nvyySebfmOySefOnVt4ojmFga2ntmGb/exn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JZc88MAD48aN+8pXvrKFe37rW9/6zW9+c+211yZJMm3atOHDhzc0NGT6bGgX/O02AAB/dcstt/zwhz9MkmTYsGHz589PkuQPf/jDoEGDkiQZNGjQ5z73uS3cs1OnTv/1X/9VV1f35ptv3nHHHXfffXemT4X2wnvbAAB/9cc//vHOO+8cNGjQpz/96U996lNJkhx88MF33nln018Cv+GVJJve88orrzzzzDOvuuqqiRMnfvWrXy0UCpk+FdoLtQ0A8FerV6/+4Ac/+MADD5x55pmjR49uuibkpptuOu6441566aW6urot3POss86aO3du3759kyRZsGDBsGHDbr/99kyfDe2CK0kAAP5qzz33LBaLSZIUi8Xzzz8/SZIf//jHt912W11d3fz588vl8hbumSRJmqZf/vKXb7rppsMOO2zu3LkDBgwYMWJEds+GdsF72wAAf3X88cfPmTMnSZI5c+b0798/SZLf//7399xzT5IkM2bMOP3005MkWb58+fveM0mSG2+88eSTT+7evfvKlSvTNF2xYkXWT4jseW8bAOCvrrjiitGjR19xxRUdO3a8/vrrkyS55pprRo4c+fWvf/3www//P//n/yRJ8slPfnLWrFmb3rOxsfEnP/lJU5qPGzduyJAhF110UdZPiOypbQCAv/rABz5w1113bXhLnz59HnzwwQ1vmTVr1vves6Gh4d577236+ot/0Sa7THvnShIAAIiitgEAIIraBgCAKIU0TcMenOyVSqWsdwFyb8PP/GpLzl/I7/kLzfyW5PavUqlUN1gsFlsyu2BiY3WzvSc1tGR2xpyx1c2OHDjVbNvMtuTnm8nrOUO1dv5m9XzNbv1s7n6+kDlXkgAAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUQppmoY9ONkrlUpZ7wLkXrlczmS7zl/I7/kLzTr+7Uu2U5VKpbrBYrHYktkFExurm+09qWHGnLHVzY4cONVs+59tyWsjk9dzhvJ4/ma1z1nNtuRcyOPzzd1rAzLnShIAAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIEohTdOwByd7pVIp612A3CuXy5ls1/kL+T1/oVnHv33JdqpSqVQ3WCwWWzK7YGJjdbO9JzXMmDO2utmRA6fmcbYlx6rWZjN5PWcoj+dvVvvcknMwq2NVa7O1dv5CE1eSAABAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABRCmmahj042SuVSlnvAuReuVzOZLvOX8jv+QvNOv7tS7ZTlUqlusFisdiS2QUTG6ub7T2pYcacsdXNjhw4NY+zLTlWWf18a2o2Q3k8f3P383Wstu9ZyJwrSQAAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKIU0TcMenOyVSqWsdwFyr1wuZ7Jd5y/k9/yFZh3/9iXbqUqlUt1gsVhsyeyCiY3Vzfae1GB262ez+vnW1GyGnL/b92zuzoU8zkLmXEkCAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAEQppGka9uBkr1QqZb0LkHvlcjmT7Tp/Ib/nL/xNynatWCwm1TJr1mwT569Zs/mdzer8hWauJAEAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAohTSNA17cLJXKpWy3gXIvXK5nMl2nb+Q3/MX/iZlu1YsFpNqmTVrtonz16zZ/M5mdf5CM1eSAABAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABRCmmahj04AADUNO9tAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAACRB/n+15RY5M4KyIgAAAABJRU5ErkJggg=="
          },
          {
            "type": "input_text",
            "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
          }
        ]
      },
      {
        "type": "message",
        "role": "assistant",
        "content": [
          "The pattern across all training examples is to detect each outline shape, find its enclosed interior region, then fill that interior with a uniform color. This fill color is the most frequent non-outline, nonzero color found inside that shape. If no such color exists, the fallback is the outline color itself.\n\nThe current best approach uses connected-component extraction for outlines, flood-fills from outside bounding box edges to identify exteriors, and treats any unreachable pixel inside the bounding box (excluding outlines) as interior. Then, it selects the fill color from those interior pixels and writes over the interiors while preserving outlines and external background.\n\nTo improve further and capture more training details:\n\n- Filter out small hole regions (interior disconnected from main interior) that might not be part of the main interior.\n- When multiple disjoint interior regions are inside the same outline, fill each with the detected fill color.\n- To robustly detect interiors, the flood fill of exteriors should consider 8-connectivity (not just 4) to better handle diagonals and avoid holes.\n- When choosing fill color, if the candidate interior pixels have more than one dominant color, prioritize the one closest to outline color or the smallest color number (heuristic).\n- Ensure the entire 21x21 grid output size is enforced.\n  \nBelow is a refined implementation applying these:\n\n```python\ndef transform(grid):\n    import numpy as np\n    from collections import deque, Counter\n\n    grid = np.array(grid)\n    h, w = grid.shape\n    output = grid.copy()\n\n    # 8-directional neighbors for better flood fill accuracy\n    def neighbors8(r, c):\n        for dr in [-1,0,1]:\n            for dc in [-1,0,1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r+dr, c+dc\n                if 0 <= nr < h and 0 <= nc < w:\n                    yield nr, nc\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    # Extract connected outline components (using 4-connectivity)\n    def neighbors4(r, c):\n        for nr, nc in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\n            if 0 <= nr < h and 0 <= nc < w:\n                yield nr, nc\n\n    def bfs_component(sr, sc):\n        q = deque([(sr, sc)])\n        comp_pixels = []\n        visited[sr, sc] = True\n        while q:\n            r, c = q.popleft()\n            comp_pixels.append((r, c))\n            for nr, nc in neighbors4(r, c):\n                if not visited[nr, nc] and grid[nr, nc] != 0:\n                    visited[nr, nc] = True\n                    q.append((nr, nc))\n        return comp_pixels\n\n    def find_outline_pixels(component):\n        comp_set = set(component)\n        outline = set()\n        for (r, c) in component:\n            for nr, nc in neighbors8(r, c):\n                if (nr, nc) not in comp_set:\n                    outline.add((r, c))\n                    break\n        return outline\n\n    components = []\n    for r in range(h):\n        for c in range(w):\n            if grid[r, c] != 0 and not visited[r, c]:\n                comp = bfs_component(r, c)\n                components.append(comp)\n\n    for comp in components:\n        comp_set = set(comp)\n        outline_set = find_outline_pixels(comp)\n\n        # Majority outline color\n        colors_in_comp = [grid[r, c] for r, c in comp]\n        outline_color = Counter(colors_in_comp).most_common(1)[0][0]\n\n        rows = [r for r, c in comp]\n        cols = [c for r, c in comp]\n        rmin, rmax = max(min(rows), 0), min(max(rows), h - 1)\n        cmin, cmax = max(min(cols), 0), min(max(cols), w - 1)\n\n        box_h = rmax - rmin + 1\n        box_w = cmax - cmin + 1\n\n        mask = np.zeros((box_h, box_w), dtype=np.int8)\n\n        for (r, c) in comp_set:\n            rr, cc = r - rmin, c - cmin\n            if (r, c) in outline_set:\n                mask[rr, cc] = 1  # outline\n            else:\n                mask[rr, cc] = 2  # candidate interior\n\n        # Flood fill exterior on mask==0 from bounding box edges - 8 connectivity for exterior flood fill\n        visited_box = np.zeros_like(mask, dtype=bool)\n        q = deque()\n        for rr in range(box_h):\n            for cc in [0, box_w - 1]:\n                if mask[rr, cc] == 0 and not visited_box[rr, cc]:\n                    q.append((rr, cc))\n                    visited_box[rr, cc] = True\n        for cc in range(box_w):\n            for rr in [0, box_h - 1]:\n                if mask[rr, cc] == 0 and not visited_box[rr, cc]:\n                    q.append((rr, cc))\n                    visited_box[rr, cc] = True\n\n        while q:\n            rr, cc = q.popleft()\n            for dr in [-1,0,1]:\n                for dc in [-1,0,1]:\n                    nr, nc = rr+dr, cc+dc\n                    if (dr == 0 and dc == 0) or nr < 0 or nr >= box_h or nc < 0 or nc >= box_w:\n                        continue\n                    if not visited_box[nr, nc] and mask[nr, nc] == 0:\n                        visited_box[nr, nc] = True\n                        q.append((nr, nc))\n\n        # Find all interior pixels: mask==2 & not reachable from outside\n        all_interior_pixels = []\n        for rr in range(box_h):\n            for cc in range(box_w):\n                if mask[rr, cc] == 2 and not visited_box[rr, cc]:\n                    all_interior_pixels.append((rr + rmin, cc + cmin))\n\n        if not all_interior_pixels:\n            continue  # no interior pixels, skip\n\n        # To handle multiple interior blobs, find connected interior components (4-connectivity)\n        interior_visited = set()\n        interior_groups = []\n\n        pixel_set = set(all_interior_pixels)\n\n        def bfs_interior(sr, sc):\n            q = deque([(sr, sc)])\n            group = []\n            interior_visited.add((sr, sc))\n            while q:\n                r, c = q.popleft()\n                group.append((r, c))\n                for nr, nc in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\n                    if (nr, nc) in pixel_set and (nr, nc) not in interior_visited:\n                        interior_visited.add((nr, nc))\n                        q.append((nr, nc))\n            return group\n\n        for p in all_interior_pixels:\n            if p not in interior_visited:\n                grp = bfs_interior(*p)\n                interior_groups.append(grp)\n\n        # For each interior group, pick fill color and fill\n        for group in interior_groups:\n            colors_in_group = [grid[r, c] for r, c in group if grid[r, c] != 0 and grid[r, c] != outline_color]\n            if colors_in_group:\n                fill_color = Counter(colors_in_group).most_common(1)[0][0]\n            else:\n                alt_colors = [grid[r, c] for r, c in group if grid[r, c] != 0]\n                if alt_colors:\n                    fill_color = Counter(alt_colors).most_common(1)[0][0]\n                else:\n                    fill_color = outline_color\n\n            for r, c in group:\n                output[r, c] = fill_color\n\n    return output.tolist()\n```\n\n---\n\n**This improves:**\n- Using 8-connectivity for the exterior flood fill to avoid leaks.\n- Identifying disconnected interior blobs inside the same outline and filling each consistently.\n- More robust fill color choice with sensible fallback.\n- Preserves outline pixels and background perfectly.\n\nThis should increase pixel-wise accuracy and better match all training outputs, generalizing well to the test input.\n\n---\n\nPlease try this improved solution and share feedback or pixel-level accuracy reports."
        ]
      },
      {
        "role": "user",
        "content": [
          {
            "type": "input_text",
            "text": "Please analyze the training feedback and programs from all prior turns, and write an improved transformation.\n\n**Important**:\n1. Always start by attempting to find a complete rule that solves all training examples and should generalize to the test input.\n2. If you cannot find a perfect solution, provide your best attempt at a transformation that solves as many training examples as possible - ideally more than in the best previous turn.\n3. Even if your solution doesn't solve all examples perfectly, ensure it demonstrates meaningful pattern recognition and provides reasonable outputs that minimize pixel-level errors.\n\nFinal answer:\n```python\ndef transform(grid):\n    # Your improved transformation logic here (even if partial)\n    return transformed_grid\n```"
          },
          {
            "type": "input_text",
            "text": "Training results: 0/3 examples solved, 82.3% pixel accuracy - Good partial progress! Your approach is capturing some patterns. Next, try to identify a transformation that solves at least one of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 8, 8, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 1, 1, 1, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 5, 5, 5, 5, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 5, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 0, 8, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 8, 0, 0, 8, 2, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 3, 0, 8, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 1, 1, 1, 0, 0, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 5, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 5, 0, 5, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 90.0%\n\nTraining Example 2 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 6, 6, 6, 0, 0], [0, 0, 2, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 2, 2, 2, 3, 3, 3, 3, 3, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 6, 6, 6, 6, 6], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 8, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 3, 0, 2, 0, 0, 6, 6, 6, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 6, 0, 3, 0, 0], [0, 0, 2, 2, 2, 0, 3, 0, 0, 0, 2, 0, 0, 6, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 6, 6, 6, 6, 6], [0, 0, 0, 0, 2, 0, 0, 0, 8, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 8, 0], [3, 0, 0, 0, 0, 0, 0, 4, 8, 0, 3, 0, 8, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 8, 0, 4, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 80.7%\n\nTraining Example 3 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 3, 3, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0], [0, 3, 3, 3, 6, 6, 6, 6, 6, 6, 3, 3, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 3, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 6, 6, 6, 6, 3, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0], [0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 3, 0, 0, 0, 8, 0, 0, 8, 0, 3, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 0, 3, 0, 6, 0, 0, 2, 0, 0, 3, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 3, 0, 0, 0, 0, 6, 0, 0, 0, 3, 0, 0], [0, 0, 3, 0, 0, 6, 0, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 69.6%\n\n"
          },
          {
            "type": "input_image",
            "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA88AAAUtCAIAAABNteEnAABUgklEQVR4nO3de5xVdb34/7URBlFwRtFUBEsk0R58RdO8kHJQ+D5S8LJ3YB1NPXBQ035IgaLZ4WT5xTQhO9HF/IZCpqQnT3t7OWbkN4UsKVPyrqGgIaDH26AIcl2/R01n4oAQ7Jn3rFns5/PhH+Oe/d5r7TV7fXi5XbMppGmaAAAAATpEPCgAAKC2AQAgkNoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAaJe1PWbMmMLmnXnmme97n7q6ur322uuUU0559NFHN33MX/ziF4VCYbfddnvvvfc2+tbtt99eKBSmTZvW9K8jR44sFAqTJ0/e6G4vv/xyoVCYOHFiS6aavPfee9dff/1xxx3Xo0ePzp079+jR47TTTvvVr361hWMyceLEzR2QJ598cssHbciQIX/3wDbf55xzztnw9qbdGz58+EMPPbTh/hSLxY3utt9++40dO/att97apoPf5PXXX580adKhhx5aX1+/8847H3HEEdOmTUvTdKPNbTT+yCOP7LHHHt26dbv//vu3cOgAALY/Gby3vWbNmldfffWuu+467rjjFixYsNF3b7zxxiRJ3nrrrdtuu21rHu3LX/7ys88+u637sDVTL7744tFHH33++ec/8MADS5cuXb169dKlS2+//faBAwdee+21STvTtHs//elPjznmmFtuuWULd3vxxRe//e1vn3DCCevXr9+mg//QQw/179//X//1X//whz+8/fbbK1asePjhh88999zRo0dvYcd++ctfHnfccevWrbvvvvuOO+64FjxFAIAaq+3vfOc76X/7yU9+kiTJ9OnTm2+5+eabm++5cOHC5tvfe++9Z5555owzznj77bevu+66DR+wsbGxUqmcdtppu+222/e///2t2YfVq1ePHDly3bp127Tnf3dqzZo1I0aM+MMf/jBgwIA777zz9ddfX7NmzZ/+9Kfvfe97u+222yWXXNL0RvXmzJs3L91Ev3793veANLvvvvs2fJCtuc/SpUubbl+5cuXzzz//xS9+MU3Tf/7nf37ppZc2vNvKlSs3PPhDhgz53e9+94tf/GLrD/5//dd/lUqlJUuWnH766XPnzn377bfffPPNSqXSu3fv6dOnX3/99e97HMrl8tChQ3faaacHHnjgyCOP3MIRAwDYLmXw3nbnzp0PPPDAr3/960mSbPTe9syZM997773Pfvazo0aNmjt37uOPP/53H+3CCy/87W9/+41vfGOb9uHvTv3whz985JFHhgwZMmfOnJNPPrl79+4dO3bs1avXBRdc8NOf/nTdunU//vGPk/Zkxx133H///a+66qovf/nLq1ev/rd/+7ctHPwvfOELTaW+9Qf/2muvffXVV8eNGzdz5swjjzyyW7duu+6666mnnjp79uydd9752muv3fB6kiY33HDDaaed9oEPfOBXv/rVwQcf3Hz7jBkzCoXCd77znVY9AAAA7VEGtb1q1aqnnnpq/PjxSZIccMABG35r+vTpBx100PHHH3/BBRfssMMOW/P29te+9rU+ffp8+ctffuaZZ7Z+H/7u1MyZMwuFwv/9v/93hx122Ohb//AP//D0009PmjQpaZcuuuiinXba6ec///n7fnfNmjV//OMfp06d2rFjx3/4h3/Y+oP/7//+7126dLniiis2esCePXs++OCDDzzwQKFQ2PD2a6655pxzzundu/eDDz744Q9/uPWeHwBAnrRRbe+3337Nv6i344479uvX7yc/+cnuu+/++c9/vvk+Tz755O9///sJEyYUCoX999//tNNOu+WWW5YvX77lR95pp52mT5++Zs2abbqe5O9OzZs376CDDtpvv/3ed/yggw7aKC43cuihh270240PPvjg5g5IswceeGBb77Opbt26ffjDH97ofxp06dKlabyurq5v376//vWvf/jDH2747LZ88NesWfPiiy8eccQRXbt23XSLhxxyyN57773hLZdccsmll16aJMmxxx677777bnT/kSNHpmk6ZsyYLT8RAIDtQDafALjPPvv88z//82OPPbbXXns133jjjTfus88+n/nMZ5r+9bLLLnvnnXe25oKNY445ZuzYsb/73e+mTJmy9fuwhak1a9Y0NjbuueeeG9640eeEfOhDH0raq+7du6/6i83dYd26dXPnzl2zZs1WHvzGxsY0Tbt3776VO/Dtb3/76KOPHjJkyI033vjTn/60Zc8GACDH2qi2m37hb/Xq1bfeemvTm69XX311jx49mu+wZs2am2++efHixZ07d27K2f79+6dpupW/K/m1r33twx/+8OWXX/70009v/V5tbqpTp07dunV77bXXkmpt+luSxxxzzN/9DchBgwZt633e11tvvdWpU6fOnTtv+luSq1evXrBgwf/3//1/3/72ty+++OKtPPi77bZbhw4dtv6AjBo16oEHHrjpppt22223c889d/HixVs5CACwnWnT97Y7der06U9/+rbbbps9e/YJJ5yw4acy33333e8bc48++ujDDz/8dx+5S5cuVVxPsoWp//W//tfTTz/9pz/96X0/gOWwww5L2qvly5c/+eSTBx100Pt+t1OnTvvtt9+UKVP69es3Y8aMrTz4O+yww0EHHfT73/9+xYoVm97tqquuOvvss5csWdJ8y/e+9726urq99977O9/5zptvvnn22Wdv+mmDAAC1IIMrSU488cQLL7zw0UcfbX5vtelKhh133HHZsmUbvo/7m9/8JkmSzX263EY+/vGPf/7zn3/44Yc3/Ztrqpj6zGc+s379+s997nPv2+6bfv5G+/HNb35zzZo1J5xwwpbv1qFDh+XLl69du3YrD36xWFy5cuVXvvKVjR7nxRdfvOaaa+6+++73vc7k9NNPHzFixC9/+cttusgHAGC7kc1121/72tf23Xff66677re//W2SJK+88sq999578skn77LLLhve7eijj+7bt++Pf/zjZcuWbc3DXnnllR/+8Ie/973vbdPOvO/UOeecc9hhh/3nf/7nEUcc8e///u+vvPLKmjVrmv52m2HDhj366KMdOrSvv/R+1apVzz333MSJE7/61a/utNNOm/sdxDRNX3755QkTJjz++OOHHnpox44dt/Lgjxs3rnv37pMnTz777LN///vfr1y58tVXX505c+agQYMaGxsnTJiw4YUrG7ruuuv23HPPiRMnPvLIIzFPHQCg/comGXfeeedvf/vb69ev/+xnP7t27dqbbrpp7dq1zb+it6F/+qd/WrFixY9+9KOtvzJky58WspVTdXV1lUrl6KOPfvTRRz/96U/vvffedXV1TX9z+z333NO3b9+t/KsuN+d9P2+kUChs+BksW3Ofvffeu/mTXg488MArr7yy6a+p79Wr10bPseluHTp06NWr15QpUzp06ND0IYZbefC7d+9+2223devW7Uc/+tHHPvaxnXbaaa+99vrMZz7z0ksvlUqlSy65ZHPPdPfdd//BD36wZs2aM84449133/V52wBATcnsDdpTTjmlWCw+9thj//Zv/zZjxoxdd931xBNP3PRuZ599docOHbbyYpKmK0Oa/uqWbfK+Uz179vzVr3518803Dx06tGfPnnV1dXvuuefQoUN/+MMfPvnkkx/72MeS9qRTp069evX6x3/8x1//+tenn3765u62ww47fOADHxg2bNgvfvGLpqtNtv7gDx48eN68eWPHjj3wwAO7du3apUuXI488ctq0af/xH/+x6aeSb+jkk08eOXLkH//4xw0/8BEAoBYU2vMlyAAAkGvt6+JjAADYnqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqmxx74403nn322az3AmC7ZZmFllPbtI6ePXsWNnHzzTeHbnTIkCFz587d+vtPmTLlqKOO2tx3Gxsbe/fuvU0PCNA2dt999+alta6u7qCDDpo6dWrVj9a8GDY2NhYKhS30tGUWWk5t02q++c1vpv/TmWeeGbrFlStXttZDLVq0aMiQIQsXLmytBwRoXdddd13T0vruu+9Onjz54osv/tGPftTCx2xoaEjT9MADD9zcHSyz0HJqm1g33HBD586dFy1alCTJa6+9tssuu0yfPv31118vFAo33HBDz5496+vrR48e3bygL126dMSIEV27du3Vq9f48eObb1+8eHGpVOrWrdsee+zxuc99btWqVYMGDXruuedGjRp1zjnnbGHwqaeeOvbYY7t06TJgwIDNrfL/+Z//2a9fv8MOO6ytjgpA9Tp16nTSSScNHjy4XC6/8sorhULhsssuq6+vHzly5LYuhhu+t22ZhSBqm1ijR48+5phjrr766iRJrrzyysMPP3zUqFFN37rmmmvuvffeefPmPfLII2PGjGm6cfjw4d26dXvxxRdnz5798MMPjxs3LkmSdevWnXjiiXV1dS+88MJDDz30xBNPXH755Q888EDfvn2nT58+bdq0zQ2+9957Q4cO7d+//5IlSy677LLp06e/70527tz5vvvu++53v9uGBwagRdauXdu1a9emr5999tmXX375iiuuqHoxtMxCoI3+1z9UZ5999tnopbXDDjs0fWv+/PkNDQ3XXnttfX39/Pnz0zR97bXXkiQpl8tNd5g1a1ZdXd3y5ctnz5690047rVq1qun2hx9+uEOHDitXrpw9e3ZdXd0bb7yx0Uab/hhI03Rzg5VKpb6+fsWKFU23n3feeUceeeTmnsKaNWuSJHnooYcCDg9Ai3Tv3r35SpLGxsbp06d36NDh7rvvXrp0aZIk99xzT9O3tnUxfOutt5IkeeaZZyyzEMd720Rdt7127dqm2/v06TNhwoTx48dfdNFFffr0ab5/82/SHHLIIatXr37hhReefvrpFStWdO7cuek3gT72sY+tX79+wYIFTz31VM+ePXfbbbfNbXpzg08//fT+++/fpUuXprsdeuihwccAIMoFF1zQtMTtueeeU6ZM+e53vzts2LCmb+27774tXAwtsxBHbdMWnnzyySRJHn300Q1v7NSpU9MX69atS5KkY8eOa9eu7dOnz0b/RfiRj3ykU6dOhUJhC4+/ucGN7ta8RYDcaX5v+7333nvyySfPP//85m917ty5hYuhZRbiqG3C/exnP7vtttsmT558xx13VCqV5tsff/zxpi/mzZvXtWvX/fff/8ADD1y4cOHLL7+80SMccMABixYtavo/nhtq/rNhc4P9+vWbP3/+u+++2/SvTzzxRGs/OYB2pOrF0DILcdQ2sZYvX37++eePHTv24osvPvfcc8eMGfPOO+80feuSSy5ZuHDh/PnzL7300vPOO69z587HH3/8wQcfPGrUqEWLFi1evPgLX/jCvvvuu2rVqmOPPbZfv34XXnjh66+//uKLLw4fPvz0009PkmTnnXdesmTJO++8s7nBT3ziE3vvvffnP//5N99887777rvxxhuzPh4AgapeDC2zEEdt02rGjRu30d9uc/7553/pS1/q0KHDpEmTkiSZPHlyhw4dvvSlLzXdf8iQIccdd9yRRx75v//3/2760JIOHTpUKpWdd975oIMO+shHPvLcc8/NmjWr6TLB//iP/3jzzTd79ep1+OGH77LLLtdff32SJOeff/5VV101atSozQ3W1dX97Gc/e/HFF/fZZ59x48ade+65WR8kgEBVL4aWWYhTSNO06uFSqdSqO0OtWL169T333DN48OBu3bplvS/w95XL5Uy2a40FakE5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5/r16zdr1qwePXosXrz4hBNOeOKJJ5ruuent++677y9/+cvBgwfPmzfvrLPOuvvuuwuFQhKsYwvnK5VKdYPFYjGXs32+XuXs85dmNXvGGWdUNztz5sysZlt0rPL4ujLbvmczlLtjVYNrbFbHqv/kKv8j8LEJpTw+X7Pb8ey2Ovjgg++8885SqVQul5uuJHn11Vf32muvJEn23nvvpluabHr7lVdeeeaZZ1511VUTJ0786le/2gap7UoSAADyZNq0aTfddNNxxx330ksv1dXVbdPsWWedNXfu3L59+yZJsmDBgmHDht1+++1JO39vGwAA2syPf/zj2267ra6ubv78+U1Xoey5556vvPJKjx49li5duueeezbf831vT9P0y1/+8k033XTYYYfNnTt3wIABI0aMCN1h720DAJAbv//97++5554kSWbMmHH66acnSTJ06NBbb701SZJbb7116NChSZIsX778fW9PkuTGG288+eSTu3fvvnLlyjRNV6xYEb3DahsAgNy45pprpkyZcvTRR7/99tsXXHBBkiT/8i//MmfOnGOOOeZXv/rVl770pSRJPvnJT77v7Y2NjT/5yU/OO++8JEnGjRs3ZMiQiy66KHqHXUkCAEBu9OnT58EHH9zwlvr6+o1+R3PWrFnve3tDQ8O9997b9PUX/6INdth72wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEKWQpmnVw6VSqVV3BqA9KpfLmWzXGgvUgnJGa2yb6djC+UqlUt1gsVjM5Wyfr1c5+/ylZ5xxRnWzM2fOrLXZlhznXL6uzLbv2Qzl7lhluMZmtc8tWuscZ7Nma4ArSQAAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKIU0TaseLpVKrbozAO1RuVzOZLvWWKAWZLXGtpmOLZyvVCrVDRaLxVzO9vl6lbPPX3rGGWdUNztz5sxam23Jcc7l68ps+57NUO6OVYZrbC6fr+Ns1mwNcCUJAABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsA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hQsXbrqHDz/88IIFC6699tpdd921T58+l19++R133JGmaRseJCAznTp1OumkkwYPHlwul1955ZVCoXDZZZfV19ePHDlyWxeWDd/btmRB7qht8mr06NHHHHPM1VdfnSTJlVdeefjhh48aNarpW9dcc8299947b968Rx55ZMyYMU03Dh8+vFu3bi+++OLs2bMffvjhcePGJUmybt26E088sa6u7oUXXnjooYeeeOKJyy+//IEHHujbt+/06dOnTZu2ucH33ntv6NCh/fv3X7JkyWWXXTZ9+vRN93DAgAFr1qypq6tr+telS5futttuhUKhDQ8SkLG1a9d27dq16etnn3325ZdfvuKKK6peWCxZkEsb/Q96aG/22WefjV60O+ywQ9O35s+f39DQcO2119bX18+fPz9N09deey1JknK53HSHWbNm1dXVLV++fPbs2TvttNOqVauabn/44Yc7dOiwcuXK2bNn19XVvfHGGxtttOmPrjRNNzdYqVTq6+tXrFjRdPt555135JFHbuFZNDY27rfffpdffnlrHx6gHenevXvzlSSNjY3Tp0/v0KHD3XffvXTp0iRJ7rnnnqZvbevC8tZbbyVJ8swzz1iyII+8t03+rtteu3Zt0+19+vSZMGHC+PHjL7rooj59+jTfv/m3fw455JDVq1e/8MILTz/99IoVKzp37tz020sf+9jH1q9fv2DBgqeeeqpnz5677bbb5ja9ucGnn356//3379KlS9PdDj300C3s/7vvvnvyySf369dv4sSJrXRIgHbqggsuaFou9txzzylTpnz3u98dNmxY07f23XffFi4slizII7VNvj355JNJkjz66KMb3tipU6emL9atW5ckSceOHdeuXdunT5+N/lvzIx/5SKdOnbb8/0k3N7jR3Zq3uKk33nhj8ODBPXv2vP322zt27Niypwu0d83vbb/33ntPPvnkhr9o2Llz5xYuLJYsyCO1TY797Gc/u+222yZPnnzHHXdUKpXm2x9//PGmL+bNm9e1a9f999//wAMPXLhw4csvv7zRIxxwwAGLFi1q+r+0G2r+82xzg/369Zs/f/67777b9K9PPPHE++7hyy+/fMwxxwwcOPCWW25pvhoSqHFVLyyWLMgjtU1eLV++/Pzzzx87duzFF1987rnnjhkz5p133mn61iWXXLJw4cL58+dfeuml5513XufO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ABBFbQMAQBS1DQBQo/7f//t/AwYMOO6444499tiHHnooSZJly5YVi8VjjjmmWCwuW7as+Z7/+I//OOgvBgwYsPvuuydJcvXVV/fr12/y5MlJkqxfv37YsGGNjY2ZPpt2qmPWOwAAQDZGjx59//3377fffi+88MLJJ5/89NNPX3nllQMHDhw/fvw3vvGNq6666uqrr26656233tr0xbRp0/70pz8lSfKtb33rueee69u374QJE6ZNmzZ8+PCGhoZMn007VUjTNKklpVIp610AcqZcLmeyXesVEL1eHXbYYddff/3hhx/+u9/97rTTTnvppZf69es3a9asHj16LF68+IQTTnjiiSc2vH+aph/96Ed//vOff+ADH9h3331/+ctfDh48eN68eWedddbdd99dKBRa+wltF9IaUywWqz5WZs0GzabPJ9X9k9PZrI5z1bM1uF5dPj+t7p88/nzNbtNsHtcc69UW/O53v+vcuXO/fv06d+581113pWm6++67r1u3Lk3TdevW7bHHHhvd/4477jj33HObvr7pppuOPPLIW2655YILLnj44YdbaeXbDrluGwCgRl188cW33HLLE0888aMf/einP/3p373/N77xjYsuuqjp67POOmvu3Ll9+/ZNkmTBggXDhg27/fbb43c5f1y3DQBQo5544ommi9Y++clPXnDBBUmS7Lnnnq+88kqPHj2WLl265557bnjn3/72tw0NDU153SRN0y9/+cs33XTTYYcdNnfu3AEDBowYMSKL59GueW8bAKBG9e3b99e//nWSJA899NCHPvShJEmGDh3a9AuRt95669ChQ5MkWb58edOdr7nmmuY3tpvceOONJ598cvfu3VeuXJmm6YoVKzJ6Hu2a97YBAGrU97///bFjx/75czMKhWnTpiVJ8i//8i//9E//9NOf/nT33Xf/4Q9/2PS296xZs55//vklS5YMHDiwebaxsfEnP/nJPffckyTJuHHjhgwZslGL00RtAwDUqP79+8+ePXvDW+rr6yuVyoa3zJo1K0mSPn36NH0gd7OGhoZ777236esv/kWb7HL+uJIEAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiFNI0TWpJqVTKeheAnCmXy5ls13oF5GW9Ygs6JrWnUqlUN1gsFs22zWx5SpWzpYtrbrb/5CoX1scmlFoy25J9zt1rMkO5O1Y1OJvHdSOr2Tz+jHL3mqQdciUJAABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABClkKZpUktKpVLWuwDkTLlczmS71isgL+sVW9AxqT2VSqW6wWKxaLZtZstTqpwtXVzsP7nKheaxCSWzWz/bkp9R7l6TGcrdsarB2Zo6F3I6m9XPqCVrbB7XKzbHlSQAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQJRCmqZJLSmVSlnvApAz5XI5k+1ar4C8rFdsQcek9lQqleoGi8Wi2baZLU+pcrZ0cbH/5CoXmscmlMxu/WxLfka5e01maMHExuoGe09qyN1xzulsVutVS/Y5q9dVVs/XekW2XEkCAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAEQppGma1JJSqZT1LgA5Uy6XM9mu9QrIy3rFFnRMak+lUqlusFgsmm2b2fKUKmdLFxf7T65yoXlsQsns1s+25GeUu9dkhnJ3rGpwtqbOhZzO1tTPiHbIlSQAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQJRCmqZJLSmVSlnvApAz5XI5k+1ar4C8rFdsQcek9lQqleoGi8Wi2baZLU+pcrZ0cbH/5CoXmscmlMxu/WxLfka5e01mKHfHqgZna+pcaOFsS9YcPyPyy5UkAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAECUQpqmSS0plUpZ7wKQM+VyOZPtWq+AvKxXbEHHpPZUKpXqBovFotm2mS1PqXK2dHHNzfafXOXC+tiEUktmW7LPuXtNZih3x6pYLC6Y2FjdbO9JDXl8vnlcN7KazePPKHevSdohV5IAAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFEKaZomtaRUKmW9C0DOlMvlTLZrvQLysl6xJWmNKRaLSbXMmg2aTZ9Pqvsnp7NZHeeqZ61XZs02z+ZxzbFekS1XkgAAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUQppmia1pFQqZb0LQM6Uy+VMtmu9AvKyXrElaY0pFotJtcyaNVubs9Yrs2bN5mU2q/WKLXAlCQAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQpZCmadiDAwBATfPeNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ3tyBtvvPHss89mvRdAlZzCwKbUNry/nj17FjZx8803h250yJAhc+fO3fr7T5ky5aijjtr09ldffXXEiBG77LJLr169Jk2a1Kr7CDmw++67N5+2dXV1Bx100NSpU6t+tOYTrbGxsVAobKGnncLApjq+z23AX3zzm9/8whe+0JZbXLlyZas8zhlnnLHvvvsuWrRo/vz5J5544l577XXOOee0yiNDXlx33XXnn39+kiRr1qz5+c9//slPfnLXXXc966yzWvKYDQ0NaZpu4Q5OYWBT3tuGbXPDDTd07tx50aJFSZK89tpru+yyy/Tp019//fVCoXDDDTf07Nmzvr5+9OjRzX/oLl26dMSIEV27du3Vq9f48eObb1+8eHGpVOrWrdsee+zxuc99btWqVYMGDXruuedGjRrV9Mfq5gafeuqpY489tkuXLgMGDFi4cOGme/jCCy/cf//9U6ZMqa+vP/zww4877rjf/OY3bXiEoH3p1KnTSSedNHjw4HK5/MorrxQKhcsuu6y+vn7kyJHbeqJt+N62UxjYSmobts3o0aOPOeaYq6++OkmSK6+88vDDDx81alTTt6655pp777133rx5jzzyyJgxY5puHD58eLdu3V588cXZs2c//PDD48aNS5Jk3bp1J554Yl1d3QsvvPDQQw898cQTl19++QMPPNC3b9/p06dPmzZtc4Pvvffe0KFD+/fvv2TJkssuu2z69Omb7uH++++/fv367t27r1279v/9RalUatuDBO3O2rVru3bt2vT1s88++/LLL19xxRVVn2hOYWAbpMD72WeffTY6WXbYYYemb82fP7+hoeHaa6+tr6+fP39+mqavvfZakiTlcrnpDrNmzaqrq1u+fPns2bN32mmnVatWNd3+8MMPd+jQYeXKlbNnz66rq3vjjTc22mjTH9Vpmm5usFKp1NfXr1ixoun2884778gjj9zcU+jbt2/nzp0HDRr02muvBRwhaL+6d+9+3XXXNX3d2Ng4ffr0Dh063H333UuXLk2S5J577mn61raeaG+99VaSJM8884xTGNh63tuGzfrmN7+54dmydu3aptv79OkzYcKE8ePHX3TRRX369Gm+f/NvOx1yyCGrV69+4YUXnn766RUrVnTu3Lnpt7U+9rGPrV+/fsGCBU899VTPnj132223zW16c4NPP/30/vvv36VLl6a7HXrooVvY/2efffaNN97YaaedTjrppFY6JJAbF1xwQdPps+eee06ZMuW73/3usGHDmr617777tvBEcwoDW09tQzWefPLJJEkeffTRDW/s1KlT0xfr1q378+8gd+y4du3aPn36bPTfuB/5yEc6depUKBS28PibG9zobs1b3Jydd9554sSJv/3tb5csWVLtc4Vcan5v+7333nvyySebfmOySefOnVt4ojmFga2ntmGb/exn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JZc88MAD48aN+8pXvrKFe37rW9/6zW9+c+211yZJMm3atOHDhzc0NGT6bGgX/O02AAB/dcstt/zwhz9MkmTYsGHz589PkuQPf/jDoEGDkiQZNGjQ5z73uS3cs1OnTv/1X/9VV1f35ptv3nHHHXfffXemT4X2wnvbAAB/9cc//vHOO+8cNGjQpz/96U996lNJkhx88MF33nln018Cv+GVJJve88orrzzzzDOvuuqqiRMnfvWrXy0UCpk+FdoLtQ0A8FerV6/+4Ac/+MADD5x55pmjR49uuibkpptuOu6441566aW6urot3POss86aO3du3759kyRZsGDBsGHDbr/99kyfDe2CK0kAAP5qzz33LBaLSZIUi8Xzzz8/SZIf//jHt912W11d3fz588vl8hbumSRJmqZf/vKXb7rppsMOO2zu3LkDBgwYMWJEds+GdsF72wAAf3X88cfPmTMnSZI5c+b0798/SZLf//7399xzT5IkM2bMOP3005MkWb58+fveM0mSG2+88eSTT+7evfvKlSvTNF2xYkXWT4jseW8bAOCvrrjiitGjR19xxRUdO3a8/vrrkyS55pprRo4c+fWvf/3www//P//n/yRJ8slPfnLWrFmb3rOxsfEnP/lJU5qPGzduyJAhF110UdZPiOypbQCAv/rABz5w1113bXhLnz59HnzwwQ1vmTVr1vves6Gh4d577236+ot/0Sa7THvnShIAAIiitgEAIIraBgCAKIU0TcMenOyVSqWsdwFyb8PP/GpLzl/I7/kLzfyW5PavUqlUN1gsFlsyu2BiY3WzvSc1tGR2xpyx1c2OHDjVbNvMtuTnm8nrOUO1dv5m9XzNbv1s7n6+kDlXkgAAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUQppmoY9ONkrlUpZ7wLkXrlczmS7zl/I7/kLzTr+7Uu2U5VKpbrBYrHYktkFExurm+09qWHGnLHVzY4cONVs+59tyWsjk9dzhvJ4/ma1z1nNtuRcyOPzzd1rAzLnShIAAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIEohTdOwByd7pVIp612A3CuXy5ls1/kL+T1/oVnHv33JdqpSqVQ3WCwWWzK7YGJjdbO9JzXMmDO2utmRA6fmcbYlx6rWZjN5PWcoj+dvVvvcknMwq2NVa7O1dv5CE1eSAABAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABRCmmahj042SuVSlnvAuReuVzOZLvOX8jv+QvNOv7tS7ZTlUqlusFisdiS2QUTG6ub7T2pYcacsdXNjhw4NY+zLTlWWf18a2o2Q3k8f3P383Wstu9ZyJwrSQAAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKIU0TcMenOyVSqWsdwFyr1wuZ7Jd5y/k9/yFZh3/9iXbqUqlUt1gsVhsyeyCiY3Vzfae1GB262ez+vnW1GyGnL/b92zuzoU8zkLmXEkCAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAEQppGka9uBkr1QqZb0LkHvlcjmT7Tp/Ib/nL/xNynatWCwm1TJr1mwT569Zs/mdzer8hWauJAEAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAohTSNA17cLJXKpWy3gXIvXK5nMl2nb+Q3/MX/iZlu1YsFpNqmTVrtonz16zZ/M5mdf5CM1eSAABAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABRCmmahj04AADUNO9tAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAACRB/n+15RY5M4KyIgAAAABJRU5ErkJggg=="
          },
          {
            "type": "input_text",
            "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
          }
        ]
      },
      {
        "type": "message",
        "role": "assistant",
        "content": [
          "Based on all previous analyses and feedback, here is a refined solution that tries to fully fill each closed colored outline with a uniform interior fill color. This color is chosen as the most frequent non-outline, nonzero color inside the polygon, using robust connectivity and exterior flood-fill via 8-neighbors to separate interior vs exterior pixels. The algorithm handles multiple disconnected interior regions and preserves outlines and background perfectly.\n\n```python\ndef transform(grid):\n    import numpy as np\n    from collections import deque, Counter\n\n    grid = np.array(grid)\n    h, w = grid.shape\n    output = grid.copy()\n\n    def neighbors4(r, c):\n        for nr, nc in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\n            if 0 <= nr < h and 0 <= nc < w:\n                yield nr, nc\n\n    def neighbors8(r, c):\n        for dr in [-1,0,1]:\n            for dc in [-1,0,1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r+dr, c+dc\n                if 0 <= nr < h and 0 <= nc < w:\n                    yield nr, nc\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    # Find connected outline components using 4-connectivity\n    def bfs_component(sr, sc):\n        q = deque([(sr, sc)])\n        comp = []\n        visited[sr, sc] = True\n        while q:\n            r, c = q.popleft()\n            comp.append((r, c))\n            for nr, nc in neighbors4(r, c):\n                if not visited[nr, nc] and grid[nr, nc] != 0:\n                    visited[nr, nc] = True\n                    q.append((nr, nc))\n        return comp\n\n    # Identify outline pixels of the component\n    def find_outline_pixels(component):\n        comp_set = set(component)\n        outline = set()\n        for r, c in component:\n            for nr, nc in neighbors8(r, c):\n                if (nr, nc) not in comp_set:\n                    outline.add((r, c))\n                    break\n        return outline\n\n    components = []\n    for r in range(h):\n        for c in range(w):\n            if grid[r, c] != 0 and not visited[r, c]:\n                comp = bfs_component(r, c)\n                components.append(comp)\n\n    for comp in components:\n        comp_set = set(comp)\n        outline_set = find_outline_pixels(comp)\n\n        # Majority outline color\n        outline_colors = [grid[r, c] for r, c in comp]\n        outline_color = Counter(outline_colors).most_common(1)[0][0]\n\n        rows = [r for r, _ in comp]\n        cols = [c for _, c in comp]\n        rmin, rmax = max(min(rows), 0), min(max(rows), h - 1)\n        cmin, cmax = max(min(cols), 0), min(max(cols), w - 1)\n\n        box_h = rmax - rmin + 1\n        box_w = cmax - cmin + 1\n\n        mask = np.zeros((box_h, box_w), dtype=np.int8)\n\n        for r, c in comp_set:\n            rr, cc = r - rmin, c - cmin\n            if (r, c) in outline_set:\n                mask[rr, cc] = 1  # outline\n            else:\n                mask[rr, cc] = 2  # candidate interior\n\n        # Flood fill exterior (mask==0) from box edges using 8-connectivity\n        visited_box = np.zeros_like(mask, dtype=bool)\n        q = deque()\n        for rr in range(box_h):\n            for cc in [0, box_w - 1]:\n                if mask[rr, cc] == 0 and not visited_box[rr, cc]:\n                    q.append((rr, cc))\n                    visited_box[rr, cc] = True\n        for cc in range(box_w):\n            for rr in [0, box_h - 1]:\n                if mask[rr, cc] == 0 and not visited_box[rr, cc]:\n                    q.append((rr, cc))\n                    visited_box[rr, cc] = True\n\n        while q:\n            rr, cc = q.popleft()\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    nr, nc = rr + dr, cc + dc\n                    if dr == 0 and dc == 0:\n                        continue\n                    if 0 <= nr < box_h and 0 <= nc < box_w:\n                        if not visited_box[nr, nc] and mask[nr, nc] == 0:\n                            visited_box[nr, nc] = True\n                            q.append((nr, nc))\n\n        # Interior pixels: mask==2 and not reachable from outside\n        interior_pixels = []\n        for rr in range(box_h):\n            for cc in range(box_w):\n                if mask[rr, cc] == 2 and not visited_box[rr, cc]:\n                    interior_pixels.append((rr + rmin, cc + cmin))\n\n        if not interior_pixels:\n            continue\n\n        # Find connected interior regions (4-connectivity) and fill each\n        interior_pixel_set = set(interior_pixels)\n        interior_visited = set()\n        def bfs_interior(sr, sc):\n            q = deque([(sr, sc)])\n            group = []\n            interior_visited.add((sr, sc))\n            while q:\n                r, c = q.popleft()\n                group.append((r, c))\n                for nr, nc in neighbors4(r, c):\n                    if (nr, nc) in interior_pixel_set and (nr, nc) not in interior_visited:\n                        interior_visited.add((nr, nc))\n                        q.append((nr, nc))\n            return group\n\n        groups = []\n        for pix in interior_pixels:\n            if pix not in interior_visited:\n                groups.append(bfs_interior(*pix))\n\n        # For each group, determine fill color and fill\n        for group in groups:\n            non_outline_colors = [grid[r, c] for r, c in group if grid[r, c] != 0 and grid[r, c] != outline_color]\n            if non_outline_colors:\n                fill_color = Counter(non_outline_colors).most_common(1)[0][0]\n            else:\n                alt_colors = [grid[r, c] for r, c in group if grid[r, c] != 0]\n                if alt_colors:\n                    fill_color = Counter(alt_colors).most_common(1)[0][0]\n                else:\n                    fill_color = outline_color\n            for r, c in group:\n                output[r, c] = fill_color\n\n    return output.tolist()\n```\n\n---\n\nThis approach should solve the training examples better by:\n\n- Accurately separating interior and exterior via 8-connected flood fill.\n- Handling multiple disconnected interior regions.\n- Choosing fill colors prioritizing non-outline interior colors.\n- Maintaining all outlines and background untouched.\n\nIt generalizes across examples and should work on the test input as well.\n\nFeel free to test and further iterate!"
        ]
      }
    ],
    "all_responses": [
      {
        "id": "resp_686fb4fcb664819e8e261fd5f50adb950954bbe2e6f93c24",
        "model": "gpt-4.1-mini-2025-04-14",
        "usage": {
          "input_tokens": 8230,
          "output_tokens": 839,
          "total_tokens": 9069
        },
        "output": [
          {
            "type": "message",
            "content": [
              "Analysis:\n- Each training example shows grids with colored outlines that contain smaller colored shapes or points inside.\n- The transformation fills the area inside the outlined shape with a single uniform color (filling the interior pixels).\n- The fill color corresponds to one of the colors that appeared inside the shape's outline in the input.\n- The outline color remains unchanged.\n- Interior pixels colored differently or zero in the input become the fill color in output.\n- Colors outside the outlined shapes remain unchanged or zero.\n- The output grid size matches the input grid size (all 21\u00d721).\n- The fills do not overflow outside the outline but fully fill the enclosed region.\n- No other shapes or colors outside the outlines change.\n\nHypothesis for transformation:\n- For each connected outline shape in the input:\n  - Detect the outline pixels.\n  - Find the enclosed region inside this outline.\n  - Determine the fill color by majority or a prominent interior color inside the outline.\n  - Fill the enclosed region (interior, not outline) with this color.\n- Keep all other pixels outside outlines unchanged or zero.\n- Maintain original outline color unchanged.\n\nTo implement this, steps:\n- Use flood fill / connected component analysis.\n- Extract connected components corresponding to outlines.\n- For each outline component, find enclosed pixels by flood fill from inside.\n- Determine fill color by analyzing interior pixels.\n- Update interior to fill color while preserving the outline color.\n\n---\n\nBelow is a Python implementation applying the above logic using numpy and scipy.ndimage for connected components and flood fill.\n\nFinal answer:\n```python\nimport numpy as np\nfrom scipy.ndimage import label, binary_fill_holes\n\ndef transform(grid):\n    grid = np.array(grid)\n    h, w = grid.shape\n\n    # Output grid starts as copy of input\n    output = grid.copy()\n\n    # Get all nonzero pixels (potential outlines)\n    nonzero_mask = grid != 0\n\n    # Label connected components of nonzero pixels\n    labeled, num_features = label(nonzero_mask)\n\n    for comp_id in range(1, num_features + 1):\n        comp_mask = (labeled == comp_id)\n\n        # Determine the outline pixels for this component:\n        # Outline pixels are component pixels that have at least one neighbor outside component\n        # Use binary erosion to find inner pixels, outline = comp_mask - eroded\n        from scipy.ndimage import binary_erosion\n\n        eroded = binary_erosion(comp_mask, structure=np.ones((3,3)))\n        outline_mask = comp_mask & (~eroded)\n\n        # Identify enclosed region by filling holes inside the component mask\n        # Using binary_fill_holes\n        filled_mask = binary_fill_holes(comp_mask)\n\n        # Interior pixels = filled_mask but not outline nor component itself? \n        # Actually, outline within component, so interior = filled_mask & ~outline_mask\n\n        # Pixels strictly inside the outline are those in filled_mask but not on the outline\n        interior_mask = filled_mask & (~outline_mask)\n\n        # The shape interior includes the component pixels (outline + interior inside)\n        # But only fill interior pixels (inside area)\n\n        # Determine fill color: pick the most frequent nonzero color in the interior area inside the component\n        # Usually the interior in input has scattered points - pick dominant color inside interior_mask\n\n        # Get colors in interior\n        interior_colors = grid[interior_mask]\n        # Ignore zero colors\n        interior_colors = interior_colors[interior_colors != 0]\n\n        if len(interior_colors) == 0:\n            # No interior colors inside, maybe fill with 0 (leave unchanged)\n            fill_color = 0\n        else:\n            # Use mode (most frequent color) as fill color\n            vals, counts = np.unique(interior_colors, return_counts=True)\n            fill_color = vals[np.argmax(counts)]\n\n        # Apply fill color to interior pixels in output\n        output[interior_mask] = fill_color\n\n        # Outline pixels remains original color (already preserved)\n\n    # Return result as list of lists\n    return output.tolist()\n```"
            ]
          }
        ]
      },
      {
        "id": "resp_686fb5126d84819ebc7e36c9cad970350954bbe2e6f93c24",
        "model": "gpt-4.1-mini-2025-04-14",
        "usage": {
          "input_tokens": 13793,
          "output_tokens": 1424,
          "total_tokens": 15217
        },
        "output": [
          {
            "type": "message",
            "content": [
              "The previous solution relied on scipy.ndimage functions (labeling and flood fill) which are not available in the execution environment. Without those, we must create an alternative approach using only standard Python and numpy.\n\n---\n\n**Refined understanding of the task:**\n\n1. The input contains polygonal outlines (connected lines) drawn in a unique color.\n2. Inside these outlines are some scattered colored pixels.\n3. The output reflects the same outlines but the interior is completely filled with a single color.\n4. The fill color chosen corresponds to a prominent interior color found inside that outline.\n5. Outlines must remain unchanged.\n6. The rest of the grid remains 0 (background).\n7. The output grid is the same size as input.\n\n---\n\n**Approach without scipy.ndimage:**\n\n- Use numpy for arrays and standard BFS/DFS for connectivity and flood-fill operations.\n- Identify outlines by finding connected components of nonzero pixels.\n- For each outline:\n  - Extract bounding box.\n  - Fill inside by polygon fill or flood fill, starting from some point inside the outline (e.g. center of bounding box).\n  - Determine fill color by the mode (most common) color of the interior pixels inside bounding box (excluding outline color and zero).\n- Construct final output replacing interior pixels with fill color while keeping outline color intact.\n\n---\n\n**Key Steps:**\n\n- Connected components extraction with BFS from all nonzero pixels.\n- For each component:\n  - Get pixels of component.\n  - Get bounding box.\n  - Find a seed position inside bounding box for flood fill that is not outline.\n  - Perform flood fill bounded by outline pixels.\n  - Determine fill color from input pixels inside flood fill.\n  - Fill flood fill area with fill color in output.\n- Maintain outline pixels as is.\n\nThis approach should generalize well.\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n    from collections import deque, Counter\n\n    grid = np.array(grid)\n    h, w = grid.shape\n    output = np.array(grid)  # start from input copy\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def neighbors(r, c):\n        for nr, nc in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\n            if 0 <= nr < h and 0 <= nc < w:\n                yield nr, nc\n\n    def bfs_component(sr, sc):\n        \"\"\"Get all connected pixels (4-dir) of nonzero pixels starting at (sr, sc).\"\"\"\n        q = deque()\n        q.append((sr, sc))\n        comp_pixels = []\n        visited[sr, sc] = True\n        while q:\n            r, c = q.popleft()\n            comp_pixels.append((r,c))\n            for nr, nc in neighbors(r,c):\n                if not visited[nr, nc] and grid[nr, nc] != 0:\n                    visited[nr, nc] = True\n                    q.append((nr, nc))\n        return comp_pixels\n\n    def flood_fill_inside(outline_set, start, outline_color):\n        \"\"\"Flood fill from start pixel inside the outline boundary.\n        outline_set: set of outline pixels (r,c)\n        fill inside only within bounding box limits.\n        Return set of filled pixels.\"\"\"\n        q = deque()\n        q.append(start)\n        filled = set()\n        filled.add(start)\n        while q:\n            r,c = q.popleft()\n            for nr,nc in neighbors(r,c):\n                if (nr,nc) in outline_set:\n                    continue\n                if (nr,nc) in filled:\n                    continue\n                # Must be inside bounding box and not on outline\n                # Also only fill pixels that are zero or inside area (not outside)\n                # We trust outline forms closed polygon so flood_fill won't leak outside\n                filled.add((nr,nc))\n                q.append((nr,nc))\n        return filled\n\n    # Find all connected components of nonzero pixels (likely outlines)\n    components = []\n    for r in range(h):\n        for c in range(w):\n            if grid[r,c] != 0 and not visited[r,c]:\n                comp = bfs_component(r,c)\n                components.append(comp)\n\n    # Process each component\n    for comp_pixels in components:\n        # Colors in component\n        comp_points = comp_pixels\n        comp_vals = [grid[r,c] for r,c in comp_points]\n        # Outline color: majority (likely uniform)\n        cnt = Counter(comp_vals)\n        outline_color, _ = cnt.most_common(1)[0]\n\n        # Make set of outline pixels for fast lookup\n        outline_set = set(comp_points)\n\n        # Get bounding box\n        rows = [p[0] for p in comp_points]\n        cols = [p[1] for p in comp_points]\n        rmin, rmax = min(rows), max(rows)\n        cmin, cmax = min(cols), max(cols)\n\n        # Find a seed point inside to flood fill from\n        # Try center point of bounding box\n        sr = (rmin + rmax) // 2\n        sc = (cmin + cmax) // 2\n\n        # If center is on outline, try to move inside (up to 10 steps)\n        found_seed = False\n        for dr in range(-5,6):\n            for dc in range(-5,6):\n                rr, cc = sr+dr, sc+dc\n                if rmin <= rr <= rmax and cmin <= cc <= cmax:\n                    if (rr, cc) not in outline_set:\n                        found_seed = True\n                        sr, sc = rr, cc\n                        break\n            if found_seed:\n                break\n        if not found_seed:\n            # Cannot find inside seed, skip filling this component\n            continue\n\n        # Get fill area by flood fill inside outline\n        fill_area = flood_fill_inside(outline_set, (sr, sc), outline_color)\n\n        # Determine fill color: most common nonzero color inside fill_area in input that is not outline_color\n        interior_colors = []\n        for (rr, cc) in fill_area:\n            v = grid[rr, cc]\n            # exclude outline color and zero\n            if v != 0 and v != outline_color:\n                interior_colors.append(v)\n        if interior_colors:\n            fill_color = Counter(interior_colors).most_common(1)[0][0]\n        else:\n            # If no other colors, as fallback try colors inside bounding box excluding outline pixels\n            # Just pick zero or outline_color otherwise\n            fill_color = 0\n\n        # Fill interior in output (keep outline pixels unchanged)\n        for (rr, cc) in fill_area:\n            output[rr, cc] = fill_color\n\n        # outline pixels remain unchanged, so nothing to do\n\n    return output.tolist()\n```"
            ]
          }
        ]
      },
      {
        "id": "resp_686fb52e89ac819ea248dc07f233dce70954bbe2e6f93c24",
        "model": "gpt-4.1-mini-2025-04-14",
        "usage": {
          "input_tokens": 23661,
          "output_tokens": 1388,
          "total_tokens": 25049
        },
        "output": [
          {
            "type": "message",
            "content": [
              "The key insight from the training feedback is that the solution needs to clearly differentiate outlines from interiors, and fill the interiors with a single filled color corresponding to an interior color, without filling outside the outlines or over the outlines themselves. The last attempt did not do any filling and mostly returned input unchanged or incorrectly filled everything.\n\nTo improve this, I\u2019ll:\n- More robustly identify outline pixels per connected component.\n- Identify interior pixels as those enclosed by the outline (using a flood fill approach starting outside the outline to identify background, and define interior as non-outline pixels not reachable from outside).\n- Then fill only the interior pixels with the most frequent nonzero interior color.\n- Leave the outline and exterior pixels unchanged.\n\nThis approach matches the assumption the input polygons are closed loops, so inside vs outside can be separated by a flood fill from the outside.\n\nThis should produce correct hollow-to-filled polygon transformation matching training output examples.\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n    from collections import deque, Counter\n\n    grid = np.array(grid)\n    h, w = grid.shape\n    output = grid.copy()\n\n    # Step 1: Identify all nonzero connected components (these are candidate outlines)\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def neighbors(r, c):\n        for nr, nc in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\n            if 0 <= nr < h and 0 <= nc < w:\n                yield nr, nc\n\n    def bfs_component(sr, sc):\n        q = deque([(sr, sc)])\n        comp_pixels = []\n        visited[sr, sc] = True\n        while q:\n            r, c = q.popleft()\n            comp_pixels.append((r, c))\n            for nr, nc in neighbors(r, c):\n                if not visited[nr, nc] and grid[nr, nc] != 0:\n                    visited[nr, nc] = True\n                    q.append((nr, nc))\n        return comp_pixels\n\n    components = []\n    for r in range(h):\n        for c in range(w):\n            if grid[r, c] != 0 and not visited[r, c]:\n                comp = bfs_component(r, c)\n                components.append(comp)\n\n    # Helper: For a component, find outline pixels by checking neighbors outside component\n    def find_outline_pixels(component):\n        comp_set = set(component)\n        outline = set()\n        for (r, c) in component:\n            for nr, nc in neighbors(r, c):\n                if (nr, nc) not in comp_set:\n                    outline.add((r, c))\n                    break\n        return outline\n\n    # Step 2: For each component:\n    # - find outline pixels (on edges)\n    # - find bounding box\n    # - flood-fill from outside the bounding box to mark outside pixels (external background)\n    # - pixels inside bounding box that are not outline and not outside are interior\n    # - fill interior pixels with most common interior color (from input)\n    for comp in components:\n        comp_set = set(comp)\n        outline_set = find_outline_pixels(comp)\n\n        # Determine outline color as majority color in component pixels\n        colors_in_comp = [grid[r, c] for r, c in comp]\n        outline_color = Counter(colors_in_comp).most_common(1)[0][0]\n\n        rows = [r for r, c in comp]\n        cols = [c for r, c in comp]\n        rmin, rmax = max(min(rows), 0), min(max(rows), h - 1)\n        cmin, cmax = max(min(cols), 0), min(max(cols), w - 1)\n\n        # Create mask for bounding box: 0 = unknown, 1 = outline, 2 = component interior candidate\n        box_h = rmax - rmin + 1\n        box_w = cmax - cmin + 1\n        mask = np.zeros((box_h, box_w), dtype=np.int8)\n\n        for (r, c) in comp_set:\n            rr, cc = r - rmin, c - cmin\n            if (r, c) in outline_set:\n                mask[rr, cc] = 1  # outline\n            else:\n                mask[rr, cc] = 2  # possible interior\n\n        # Flood fill from outside bounding box on mask == 0 pixels to mark external background\n        visited_box = np.zeros_like(mask, dtype=bool)\n        q = deque()\n        # Initialize queue with bounding box edges that are 0 in mask (outside)\n        for rr in range(box_h):\n            for cc in [0, box_w - 1]:\n                if mask[rr, cc] == 0:\n                    q.append((rr, cc))\n                    visited_box[rr, cc] = True\n        for cc in range(box_w):\n            for rr in [0, box_h - 1]:\n                if mask[rr, cc] == 0:\n                    q.append((rr, cc))\n                    visited_box[rr, cc] = True\n\n        while q:\n            rr, cc = q.popleft()\n            for nr, nc in ((rr-1, cc), (rr+1, cc), (rr, cc-1), (rr, cc+1)):\n                if 0 <= nr < box_h and 0 <= nc < box_w:\n                    if not visited_box[nr, nc] and mask[nr, nc] == 0:\n                        visited_box[nr, nc] = True\n                        q.append((nr, nc))\n\n        # Interior pixels in bounding box: those with mask == 2 and not reachable from outside\n        interior_pixels = []\n        for rr in range(box_h):\n            for cc in range(box_w):\n                if mask[rr, cc] == 2 and not visited_box[rr, cc]:\n                    interior_pixels.append((rr + rmin, cc + cmin))\n\n        # Find fill color: majority nonzero color inside interior pixels in input\n        interior_colors = [grid[r, c] for r, c in interior_pixels if grid[r, c] != 0]\n\n        if interior_colors:\n            fill_color = Counter(interior_colors).most_common(1)[0][0]\n        else:\n            # Fallback: fill with outline color if no interior color found\n            fill_color = outline_color\n\n        # Fill interior pixels in output with fill color\n        for r, c in interior_pixels:\n            output[r, c] = fill_color\n\n        # Outline pixels remain unchanged, already in output\n\n    return output.tolist()\n```"
            ]
          }
        ]
      },
      {
        "id": "resp_686fb54e636c819eb86b913ab9a07ca50954bbe2e6f93c24",
        "model": "gpt-4.1-mini-2025-04-14",
        "usage": {
          "input_tokens": 33493,
          "output_tokens": 1689,
          "total_tokens": 35182
        },
        "output": [
          {
            "type": "message",
            "content": [
              "The solution is approaching correctness but seems to fail in some cases at identifying the correct interior fill color or properly filling all interior pixels. It also struggles when there are no interior colors distinct from the outline color.\n\nFrom the feedback:\n\n- The outlines must not be covered or changed.\n- The interior fill uses a color that is always present in the interior pixels of the input, but not equal to the outline color.\n- Sometimes there are no interior pixels with colors distinct from the outline, in which case the fill is likely uniform zero or the outline color's \"fill equivalent\".\n- The overall shape edges must be preserved exactly.\n- The fill must stay strictly inside the outline (no spill outside).\n- The interior fill is uniform and occupies the full inside region.\n- Some shapes are irregular polygons, so bounding box flood fill must be careful.\n\n---\n\n**Improvements to be made:**\n\n1. **Fill color determination:**\n   - When no interior color other than the outline exists, check if there are pixels of a secondary \"special\" color inside the shape (e.g. a known fill color like 8 in first example).\n   - If no such pixels exist, fallback to just filling interior with the outline color itself (seems to happen in example 1 with blue outline and gray fill).\n   \n2. **Flood fill for exterior:**\n   - Flood fill is done from outside bounding box edges to reliably find exterior.\n   - Interior defined as inside bounding box pixels that are not outline and not exterior.\n   - This remains good but verify robustness.\n   \n3. **Better preservation of pixels outside outlines:**\n   - All pixels outside outlines remain unchanged at 0.\n   - Filling only strictly interior pixels.\n   \n4. **Fill interior fully:**\n   - Previous attempts may have missed filling some interior pixels.\n   - Ensure full interior fill by properly marking exterior pixels without missing any holes.\n\n---\n\nI will improve the fill color detection by adding logic to:\n\n- Detect most frequent interior color different from outline and zero.\n- If none found, check for most frequent interior color including outline color, but not zero.\n- Fill with that color to mimic the expected filled areas (especially example 1\u2019s blue outline with gray inside).\n\n---\n\nFinal improved code:\n\n```python\ndef transform(grid):\n    import numpy as np\n    from collections import deque, Counter\n\n    grid = np.array(grid)\n    h, w = grid.shape\n    output = grid.copy()\n\n    def neighbors(r, c):\n        for nr, nc in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\n            if 0 <= nr < h and 0 <= nc < w:\n                yield nr, nc\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def bfs_component(sr, sc):\n        q = deque([(sr, sc)])\n        comp_pixels = []\n        visited[sr, sc] = True\n        while q:\n            r, c = q.popleft()\n            comp_pixels.append((r, c))\n            for nr, nc in neighbors(r, c):\n                if not visited[nr, nc] and grid[nr, nc] != 0:\n                    visited[nr, nc] = True\n                    q.append((nr, nc))\n        return comp_pixels\n\n    def find_outline_pixels(component):\n        comp_set = set(component)\n        outline = set()\n        for (r, c) in component:\n            for nr, nc in neighbors(r, c):\n                if (nr, nc) not in comp_set:\n                    outline.add((r, c))\n                    break\n        return outline\n\n    # Find connected components of outlines\n    components = []\n    for r in range(h):\n        for c in range(w):\n            if grid[r, c] != 0 and not visited[r, c]:\n                comp = bfs_component(r, c)\n                components.append(comp)\n\n    for comp in components:\n        comp_set = set(comp)\n        outline_set = find_outline_pixels(comp)\n\n        # Determine outline color (majority color in component)\n        colors_in_comp = [grid[r, c] for r, c in comp]\n        outline_color = Counter(colors_in_comp).most_common(1)[0][0]\n\n        rows = [r for r, c in comp]\n        cols = [c for r, c in comp]\n        rmin, rmax = max(min(rows), 0), min(max(rows), h - 1)\n        cmin, cmax = max(min(cols), 0), min(max(cols), w - 1)\n\n        box_h = rmax - rmin + 1\n        box_w = cmax - cmin + 1\n\n        mask = np.zeros((box_h, box_w), dtype=np.int8)\n\n        for (r, c) in comp_set:\n            rr, cc = r - rmin, c - cmin\n            if (r, c) in outline_set:\n                mask[rr, cc] = 1  # outline\n            else:\n                mask[rr, cc] = 2  # possible interior\n\n        # Flood fill mask from outside bounding box edges where mask == 0 (exterior)\n        visited_box = np.zeros_like(mask, dtype=bool)\n        q = deque()\n        for rr in range(box_h):\n            for cc in [0, box_w - 1]:\n                if mask[rr, cc] == 0 and not visited_box[rr, cc]:\n                    q.append((rr, cc))\n                    visited_box[rr, cc] = True\n        for cc in range(box_w):\n            for rr in [0, box_h - 1]:\n                if mask[rr, cc] == 0 and not visited_box[rr, cc]:\n                    q.append((rr, cc))\n                    visited_box[rr, cc] = True\n\n        while q:\n            rr, cc = q.popleft()\n            for nr, nc in ((rr-1, cc), (rr+1, cc), (rr, cc-1), (rr, cc+1)):\n                if 0 <= nr < box_h and 0 <= nc < box_w:\n                    if not visited_box[nr, nc] and mask[nr, nc] == 0:\n                        visited_box[nr, nc] = True\n                        q.append((nr, nc))\n\n        # Interior pixels are mask==2 and not visited (not reachable from outside)\n        interior_pixels = []\n        for rr in range(box_h):\n            for cc in range(box_w):\n                if mask[rr, cc] == 2 and not visited_box[rr, cc]:\n                    interior_pixels.append((rr + rmin, cc + cmin))\n\n        # Build counts of colors in interior pixels excluding outline_color and zero\n        interior_colors = [grid[r, c] for r, c in interior_pixels if grid[r, c] != 0 and grid[r, c] != outline_color]\n\n        if interior_colors:\n            fill_color = Counter(interior_colors).most_common(1)[0][0]\n        else:\n            # If none found, try including outline color to fill interior (covers gray in ex1)\n            interior_colors_alt = [grid[r, c] for r, c in interior_pixels if grid[r, c] != 0]\n            if interior_colors_alt:\n                fill_color = Counter(interior_colors_alt).most_common(1)[0][0]\n            else:\n                # Fallback to outline color if no interior pixels or colors found\n                fill_color = outline_color\n\n        # Fill interior pixels in output with fill_color (do not overwrite outline pixels)\n        for r, c in interior_pixels:\n            output[r, c] = fill_color\n\n    return output.tolist()\n```\nThis version explicitly tries a fallback to fill interior with outline color when no other interior color is detected, which is crucial for the first training example where the output fills blue outline with gray.\n\nIt uses careful exterior flood-fills to identify interior pixels, avoiding any modification to outline or exterior pixels.\n\nThis should improve accuracy, potentially solving training example 1 fully and increasing overall performance.\n\n---\n\nFeel free to test this and feedback for further refinements."
            ]
          }
        ]
      },
      {
        "id": "resp_686fb5713ac0819e980341c334a183320954bbe2e6f93c24",
        "model": "gpt-4.1-mini-2025-04-14",
        "usage": {
          "input_tokens": 43626,
          "output_tokens": 1411,
          "total_tokens": 45037
        },
        "output": [
          {
            "type": "message",
            "content": [
              "The current best approach identifies outlines and fills interior regions with the most frequent interior color distinct from the outline color, falling back to outline color if needed. It uses a bounding-box flood fill starting from outside to separate exterior, outline, and interior regions.\n\nTo improve further:\n- In Example 2, some interior fill colors are missed (due to scattered interior pixels), so we should consider all inside pixels, including outline color pixels, when computing the fill color, and prioritize non-outline, non-zero colors but fallback sensibly.\n- In Example 3, the interior is fully filled with a single fill color that might not appear clearly as isolated interior pixels but is represented by the most common interior color.\n- Ensure that scattered inside color pixels are included in determining fill color, but exclude exterior background pixels, the outline pixels remain unchanged.\n- To minimize error, fill all interior pixels with the chosen fill color, ensuring solid fill, preserving outlines exactly as they are.\n  \nBelow is an improved version combining all insights:\n\n```python\ndef transform(grid):\n    import numpy as np\n    from collections import deque, Counter\n\n    grid = np.array(grid)\n    h, w = grid.shape\n    output = grid.copy()\n\n    def neighbors(r, c):\n        for nr, nc in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\n            if 0 <= nr < h and 0 <= nc < w:\n                yield nr, nc\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def bfs_component(sr, sc):\n        q = deque([(sr, sc)])\n        comp_pixels = []\n        visited[sr, sc] = True\n        while q:\n            r, c = q.popleft()\n            comp_pixels.append((r, c))\n            for nr, nc in neighbors(r, c):\n                if not visited[nr, nc] and grid[nr, nc] != 0:\n                    visited[nr, nc] = True\n                    q.append((nr, nc))\n        return comp_pixels\n\n    def find_outline_pixels(component):\n        comp_set = set(component)\n        outline = set()\n        for (r, c) in component:\n            for nr, nc in neighbors(r, c):\n                if (nr, nc) not in comp_set:\n                    outline.add((r, c))\n                    break\n        return outline\n\n    # Find connected components of outlines\n    components = []\n    for r in range(h):\n        for c in range(w):\n            if grid[r, c] != 0 and not visited[r, c]:\n                comp = bfs_component(r, c)\n                components.append(comp)\n\n    for comp in components:\n        comp_set = set(comp)\n        outline_set = find_outline_pixels(comp)\n\n        # Determine outline color (majority color in component)\n        colors_in_comp = [grid[r, c] for r, c in comp]\n        outline_color = Counter(colors_in_comp).most_common(1)[0][0]\n\n        rows = [r for r, c in comp]\n        cols = [c for r, c in comp]\n        rmin, rmax = max(min(rows), 0), min(max(rows), h - 1)\n        cmin, cmax = max(min(cols), 0), min(max(cols), w - 1)\n\n        box_h = rmax - rmin + 1\n        box_w = cmax - cmin + 1\n\n        mask = np.zeros((box_h, box_w), dtype=np.int8)\n\n        for (r, c) in comp_set:\n            rr, cc = r - rmin, c - cmin\n            if (r, c) in outline_set:\n                mask[rr, cc] = 1  # outline\n            else:\n                mask[rr, cc] = 2  # possible interior\n\n        # Flood fill mask from bounding box edges where mask == 0\n        visited_box = np.zeros_like(mask, dtype=bool)\n        q = deque()\n        for rr in range(box_h):\n            for cc in [0, box_w - 1]:\n                if mask[rr, cc] == 0 and not visited_box[rr, cc]:\n                    q.append((rr, cc))\n                    visited_box[rr, cc] = True\n        for cc in range(box_w):\n            for rr in [0, box_h - 1]:\n                if mask[rr, cc] == 0 and not visited_box[rr, cc]:\n                    q.append((rr, cc))\n                    visited_box[rr, cc] = True\n\n        while q:\n            rr, cc = q.popleft()\n            for nr, nc in ((rr-1, cc), (rr+1, cc), (rr, cc-1), (rr, cc+1)):\n                if 0 <= nr < box_h and 0 <= nc < box_w:\n                    if not visited_box[nr, nc] and mask[nr, nc] == 0:\n                        visited_box[nr, nc] = True\n                        q.append((nr, nc))\n\n        # Interior pixels: mask==2 and not reachable from outside (visited_box==False)\n        interior_pixels = []\n        for rr in range(box_h):\n            for cc in range(box_w):\n                if mask[rr, cc] == 2 and not visited_box[rr, cc]:\n                    interior_pixels.append((rr + rmin, cc + cmin))\n\n        # Determine fill color:\n        # 1. Most common nonzero color inside interior pixels excluding outline color\n        # 2. If none found, most common nonzero color including outline\n        # 3. Else fallback to outline color\n        interior_colors = [grid[r, c] for r, c in interior_pixels if grid[r, c] != 0 and grid[r, c] != outline_color]\n\n        if interior_colors:\n            fill_color = Counter(interior_colors).most_common(1)[0][0]\n        else:\n            interior_colors_alt = [grid[r, c] for r, c in interior_pixels if grid[r, c] != 0]\n            if interior_colors_alt:\n                fill_color = Counter(interior_colors_alt).most_common(1)[0][0]\n            else:\n                fill_color = outline_color\n\n        # Fill all interior pixels in output\n        for r, c in interior_pixels:\n            output[r, c] = fill_color\n\n    return output.tolist()\n```\n\nThis should better handle all three training examples, and generalize well to the test input by clearly filling polygon interiors with dominant interior colors, preserving outlines exactly and leaving outside areas unchanged.\n\n---\n\nIf needed, further refinements could include special casing for interior detected color being multiple, or small isolated pixels, but this general approach captures the main transformation rule observed."
            ]
          }
        ]
      },
      {
        "id": "resp_686fb58ede98819e9601aa025cf1b7070954bbe2e6f93c24",
        "model": "gpt-4.1-mini-2025-04-14",
        "usage": {
          "input_tokens": 53481,
          "output_tokens": 1493,
          "total_tokens": 54974
        },
        "output": [
          {
            "type": "message",
            "content": [
              "All training examples share a core theme: each input contains one or more \"outline\" shapes formed by connected pixels of a single color, with sparse colored pixels inside. The output fills these outlines' interiors with a uniform color sampled from the interior pixels (not the outline color), preserving the outline and leaving the background untouched.\n\n**Key points learned from feedback:**\n- The outline pixels always stay the same color.\n- The interior is a contiguous region enclosed by the outline.\n- The interior is filled with the most common interior color different from the outline color.\n- If no interior color different from the outline is present, the fill color falls back to the outline color.\n- Background pixels outside outlines remain zero.\n- Shapes are irregular; bounding box flood-fills must not flood into outside regions.\n- The interior fill fully occupies the enclosed area.\n- Scattered interior points hint to the fill color.\n\n**Improvements to prioritize:**\n- Flood-fill the exterior (background) starting outside bounding boxes to identify interior pixels as those inside outlines but unreachable from background.\n- Analyze all interior pixels to find the fill color, prioritizing non-outline and non-zero colors, then falling back sensibly.\n- Accurately preserve outlines.\n- Output grid size remains original.\n- Efficiently manage disconnected multiple shapes.\n\n---\n\nFinal code implementing these insights:\n\n```python\ndef transform(grid):\n    import numpy as np\n    from collections import deque, Counter\n\n    grid = np.array(grid)\n    h, w = grid.shape\n    output = grid.copy()\n\n    def neighbors(r, c):\n        for nr, nc in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\n            if 0 <= nr < h and 0 <= nc < w:\n                yield nr, nc\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def bfs_component(sr, sc):\n        q = deque([(sr, sc)])\n        comp_pixels = []\n        visited[sr, sc] = True\n        while q:\n            r, c = q.popleft()\n            comp_pixels.append((r, c))\n            for nr, nc in neighbors(r, c):\n                if not visited[nr, nc] and grid[nr, nc] != 0:\n                    visited[nr, nc] = True\n                    q.append((nr, nc))\n        return comp_pixels\n\n    def find_outline_pixels(component):\n        comp_set = set(component)\n        outline = set()\n        for (r, c) in component:\n            for nr, nc in neighbors(r, c):\n                if (nr, nc) not in comp_set:\n                    outline.add((r, c))\n                    break\n        return outline\n\n    components = []\n    for r in range(h):\n        for c in range(w):\n            if grid[r, c] != 0 and not visited[r, c]:\n                comp = bfs_component(r, c)\n                components.append(comp)\n\n    for comp in components:\n        comp_set = set(comp)\n        outline_set = find_outline_pixels(comp)\n\n        # Majority outline color\n        colors_in_comp = [grid[r, c] for r, c in comp]\n        outline_color = Counter(colors_in_comp).most_common(1)[0][0]\n\n        rows = [r for r, c in comp]\n        cols = [c for r, c in comp]\n        rmin, rmax = max(min(rows), 0), min(max(rows), h - 1)\n        cmin, cmax = max(min(cols), 0), min(max(cols), w - 1)\n\n        box_h = rmax - rmin + 1\n        box_w = cmax - cmin + 1\n\n        mask = np.zeros((box_h, box_w), dtype=np.int8)\n\n        for (r, c) in comp_set:\n            rr, cc = r - rmin, c - cmin\n            if (r, c) in outline_set:\n                mask[rr, cc] = 1  # outline\n            else:\n                mask[rr, cc] = 2  # candidate interior\n\n        # Flood fill exterior (mask==0) from bounding box edges\n        visited_box = np.zeros_like(mask, dtype=bool)\n        q = deque()\n        for rr in range(box_h):\n            for cc in [0, box_w - 1]:\n                if mask[rr, cc] == 0 and not visited_box[rr, cc]:\n                    q.append((rr, cc))\n                    visited_box[rr, cc] = True\n        for cc in range(box_w):\n            for rr in [0, box_h - 1]:\n                if mask[rr, cc] == 0 and not visited_box[rr, cc]:\n                    q.append((rr, cc))\n                    visited_box[rr, cc] = True\n\n        while q:\n            rr, cc = q.popleft()\n            for nr, nc in ((rr-1, cc), (rr+1, cc), (rr, cc-1), (rr, cc+1)):\n                if 0 <= nr < box_h and 0 <= nc < box_w:\n                    if not visited_box[nr, nc] and mask[nr, nc] == 0:\n                        visited_box[nr, nc] = True\n                        q.append((nr, nc))\n\n        # Interior: mask==2 and not reachable outside\n        interior_pixels = []\n        for rr in range(box_h):\n            for cc in range(box_w):\n                if mask[rr, cc] == 2 and not visited_box[rr, cc]:\n                    interior_pixels.append((rr + rmin, cc + cmin))\n\n        # Candidate interior colors excluding outline & zero\n        interior_colors = [grid[r, c] for r, c in interior_pixels if grid[r, c] != 0 and grid[r, c] != outline_color]\n\n        if interior_colors:\n            fill_color = Counter(interior_colors).most_common(1)[0][0]\n        else:\n            # fallback: include outline color if no other interior color found\n            alt_colors = [grid[r, c] for r, c in interior_pixels if grid[r, c] != 0]\n            if alt_colors:\n                fill_color = Counter(alt_colors).most_common(1)[0][0]\n            else:\n                fill_color = outline_color  # fallback: fill with outline color\n\n        for r, c in interior_pixels:\n            output[r, c] = fill_color\n\n    return output.tolist()\n```\n\n---\n\nThis solution carefully:\n- Extracts connected nonzero components (likely polygon outlines).\n- Identifies outline pixels as component pixels bordering background.\n- Flood-fills outside bounding box zero areas to discriminate exterior vs interior space.\n- Finds interior pixels as inside polygon (mask==2) unreachable from outside.\n- Picks fill color primarily as dominant interior color not equal to outline color.\n- Falls back gracefully when no such interior color exists.\n- Preserves outline color and background untouched.\n- Produces a filled interior matching training outputs.\n\nThis should solve at least one training example fully and improve overall pixel accuracy while being robust for the test input.\n\nFeel free to test this solution and analyze pixel-level accuracy accordingly."
            ]
          }
        ]
      },
      {
        "id": "resp_686fb5b4c43c819eb23e0a5f826d759c0954bbe2e6f93c24",
        "model": "gpt-4.1-mini-2025-04-14",
        "usage": {
          "input_tokens": 63418,
          "output_tokens": 1792,
          "total_tokens": 65210
        },
        "output": [
          {
            "type": "message",
            "content": [
              "The pattern across all training examples is to detect each outline shape, find its enclosed interior region, then fill that interior with a uniform color. This fill color is the most frequent non-outline, nonzero color found inside that shape. If no such color exists, the fallback is the outline color itself.\n\nThe current best approach uses connected-component extraction for outlines, flood-fills from outside bounding box edges to identify exteriors, and treats any unreachable pixel inside the bounding box (excluding outlines) as interior. Then, it selects the fill color from those interior pixels and writes over the interiors while preserving outlines and external background.\n\nTo improve further and capture more training details:\n\n- Filter out small hole regions (interior disconnected from main interior) that might not be part of the main interior.\n- When multiple disjoint interior regions are inside the same outline, fill each with the detected fill color.\n- To robustly detect interiors, the flood fill of exteriors should consider 8-connectivity (not just 4) to better handle diagonals and avoid holes.\n- When choosing fill color, if the candidate interior pixels have more than one dominant color, prioritize the one closest to outline color or the smallest color number (heuristic).\n- Ensure the entire 21x21 grid output size is enforced.\n  \nBelow is a refined implementation applying these:\n\n```python\ndef transform(grid):\n    import numpy as np\n    from collections import deque, Counter\n\n    grid = np.array(grid)\n    h, w = grid.shape\n    output = grid.copy()\n\n    # 8-directional neighbors for better flood fill accuracy\n    def neighbors8(r, c):\n        for dr in [-1,0,1]:\n            for dc in [-1,0,1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r+dr, c+dc\n                if 0 <= nr < h and 0 <= nc < w:\n                    yield nr, nc\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    # Extract connected outline components (using 4-connectivity)\n    def neighbors4(r, c):\n        for nr, nc in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\n            if 0 <= nr < h and 0 <= nc < w:\n                yield nr, nc\n\n    def bfs_component(sr, sc):\n        q = deque([(sr, sc)])\n        comp_pixels = []\n        visited[sr, sc] = True\n        while q:\n            r, c = q.popleft()\n            comp_pixels.append((r, c))\n            for nr, nc in neighbors4(r, c):\n                if not visited[nr, nc] and grid[nr, nc] != 0:\n                    visited[nr, nc] = True\n                    q.append((nr, nc))\n        return comp_pixels\n\n    def find_outline_pixels(component):\n        comp_set = set(component)\n        outline = set()\n        for (r, c) in component:\n            for nr, nc in neighbors8(r, c):\n                if (nr, nc) not in comp_set:\n                    outline.add((r, c))\n                    break\n        return outline\n\n    components = []\n    for r in range(h):\n        for c in range(w):\n            if grid[r, c] != 0 and not visited[r, c]:\n                comp = bfs_component(r, c)\n                components.append(comp)\n\n    for comp in components:\n        comp_set = set(comp)\n        outline_set = find_outline_pixels(comp)\n\n        # Majority outline color\n        colors_in_comp = [grid[r, c] for r, c in comp]\n        outline_color = Counter(colors_in_comp).most_common(1)[0][0]\n\n        rows = [r for r, c in comp]\n        cols = [c for r, c in comp]\n        rmin, rmax = max(min(rows), 0), min(max(rows), h - 1)\n        cmin, cmax = max(min(cols), 0), min(max(cols), w - 1)\n\n        box_h = rmax - rmin + 1\n        box_w = cmax - cmin + 1\n\n        mask = np.zeros((box_h, box_w), dtype=np.int8)\n\n        for (r, c) in comp_set:\n            rr, cc = r - rmin, c - cmin\n            if (r, c) in outline_set:\n                mask[rr, cc] = 1  # outline\n            else:\n                mask[rr, cc] = 2  # candidate interior\n\n        # Flood fill exterior on mask==0 from bounding box edges - 8 connectivity for exterior flood fill\n        visited_box = np.zeros_like(mask, dtype=bool)\n        q = deque()\n        for rr in range(box_h):\n            for cc in [0, box_w - 1]:\n                if mask[rr, cc] == 0 and not visited_box[rr, cc]:\n                    q.append((rr, cc))\n                    visited_box[rr, cc] = True\n        for cc in range(box_w):\n            for rr in [0, box_h - 1]:\n                if mask[rr, cc] == 0 and not visited_box[rr, cc]:\n                    q.append((rr, cc))\n                    visited_box[rr, cc] = True\n\n        while q:\n            rr, cc = q.popleft()\n            for dr in [-1,0,1]:\n                for dc in [-1,0,1]:\n                    nr, nc = rr+dr, cc+dc\n                    if (dr == 0 and dc == 0) or nr < 0 or nr >= box_h or nc < 0 or nc >= box_w:\n                        continue\n                    if not visited_box[nr, nc] and mask[nr, nc] == 0:\n                        visited_box[nr, nc] = True\n                        q.append((nr, nc))\n\n        # Find all interior pixels: mask==2 & not reachable from outside\n        all_interior_pixels = []\n        for rr in range(box_h):\n            for cc in range(box_w):\n                if mask[rr, cc] == 2 and not visited_box[rr, cc]:\n                    all_interior_pixels.append((rr + rmin, cc + cmin))\n\n        if not all_interior_pixels:\n            continue  # no interior pixels, skip\n\n        # To handle multiple interior blobs, find connected interior components (4-connectivity)\n        interior_visited = set()\n        interior_groups = []\n\n        pixel_set = set(all_interior_pixels)\n\n        def bfs_interior(sr, sc):\n            q = deque([(sr, sc)])\n            group = []\n            interior_visited.add((sr, sc))\n            while q:\n                r, c = q.popleft()\n                group.append((r, c))\n                for nr, nc in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\n                    if (nr, nc) in pixel_set and (nr, nc) not in interior_visited:\n                        interior_visited.add((nr, nc))\n                        q.append((nr, nc))\n            return group\n\n        for p in all_interior_pixels:\n            if p not in interior_visited:\n                grp = bfs_interior(*p)\n                interior_groups.append(grp)\n\n        # For each interior group, pick fill color and fill\n        for group in interior_groups:\n            colors_in_group = [grid[r, c] for r, c in group if grid[r, c] != 0 and grid[r, c] != outline_color]\n            if colors_in_group:\n                fill_color = Counter(colors_in_group).most_common(1)[0][0]\n            else:\n                alt_colors = [grid[r, c] for r, c in group if grid[r, c] != 0]\n                if alt_colors:\n                    fill_color = Counter(alt_colors).most_common(1)[0][0]\n                else:\n                    fill_color = outline_color\n\n            for r, c in group:\n                output[r, c] = fill_color\n\n    return output.tolist()\n```\n\n---\n\n**This improves:**\n- Using 8-connectivity for the exterior flood fill to avoid leaks.\n- Identifying disconnected interior blobs inside the same outline and filling each consistently.\n- More robust fill color choice with sensible fallback.\n- Preserves outline pixels and background perfectly.\n\nThis should increase pixel-wise accuracy and better match all training outputs, generalizing well to the test input.\n\n---\n\nPlease try this improved solution and share feedback or pixel-level accuracy reports."
            ]
          }
        ]
      },
      {
        "id": "resp_686fb5e34674819e8cf4cdf26abfa7090954bbe2e6f93c24",
        "model": "gpt-4.1-mini-2025-04-14",
        "usage": {
          "input_tokens": 73654,
          "output_tokens": 1529,
          "total_tokens": 75183
        },
        "output": [
          {
            "type": "message",
            "content": [
              "Based on all previous analyses and feedback, here is a refined solution that tries to fully fill each closed colored outline with a uniform interior fill color. This color is chosen as the most frequent non-outline, nonzero color inside the polygon, using robust connectivity and exterior flood-fill via 8-neighbors to separate interior vs exterior pixels. The algorithm handles multiple disconnected interior regions and preserves outlines and background perfectly.\n\n```python\ndef transform(grid):\n    import numpy as np\n    from collections import deque, Counter\n\n    grid = np.array(grid)\n    h, w = grid.shape\n    output = grid.copy()\n\n    def neighbors4(r, c):\n        for nr, nc in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\n            if 0 <= nr < h and 0 <= nc < w:\n                yield nr, nc\n\n    def neighbors8(r, c):\n        for dr in [-1,0,1]:\n            for dc in [-1,0,1]:\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r+dr, c+dc\n                if 0 <= nr < h and 0 <= nc < w:\n                    yield nr, nc\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    # Find connected outline components using 4-connectivity\n    def bfs_component(sr, sc):\n        q = deque([(sr, sc)])\n        comp = []\n        visited[sr, sc] = True\n        while q:\n            r, c = q.popleft()\n            comp.append((r, c))\n            for nr, nc in neighbors4(r, c):\n                if not visited[nr, nc] and grid[nr, nc] != 0:\n                    visited[nr, nc] = True\n                    q.append((nr, nc))\n        return comp\n\n    # Identify outline pixels of the component\n    def find_outline_pixels(component):\n        comp_set = set(component)\n        outline = set()\n        for r, c in component:\n            for nr, nc in neighbors8(r, c):\n                if (nr, nc) not in comp_set:\n                    outline.add((r, c))\n                    break\n        return outline\n\n    components = []\n    for r in range(h):\n        for c in range(w):\n            if grid[r, c] != 0 and not visited[r, c]:\n                comp = bfs_component(r, c)\n                components.append(comp)\n\n    for comp in components:\n        comp_set = set(comp)\n        outline_set = find_outline_pixels(comp)\n\n        # Majority outline color\n        outline_colors = [grid[r, c] for r, c in comp]\n        outline_color = Counter(outline_colors).most_common(1)[0][0]\n\n        rows = [r for r, _ in comp]\n        cols = [c for _, c in comp]\n        rmin, rmax = max(min(rows), 0), min(max(rows), h - 1)\n        cmin, cmax = max(min(cols), 0), min(max(cols), w - 1)\n\n        box_h = rmax - rmin + 1\n        box_w = cmax - cmin + 1\n\n        mask = np.zeros((box_h, box_w), dtype=np.int8)\n\n        for r, c in comp_set:\n            rr, cc = r - rmin, c - cmin\n            if (r, c) in outline_set:\n                mask[rr, cc] = 1  # outline\n            else:\n                mask[rr, cc] = 2  # candidate interior\n\n        # Flood fill exterior (mask==0) from box edges using 8-connectivity\n        visited_box = np.zeros_like(mask, dtype=bool)\n        q = deque()\n        for rr in range(box_h):\n            for cc in [0, box_w - 1]:\n                if mask[rr, cc] == 0 and not visited_box[rr, cc]:\n                    q.append((rr, cc))\n                    visited_box[rr, cc] = True\n        for cc in range(box_w):\n            for rr in [0, box_h - 1]:\n                if mask[rr, cc] == 0 and not visited_box[rr, cc]:\n                    q.append((rr, cc))\n                    visited_box[rr, cc] = True\n\n        while q:\n            rr, cc = q.popleft()\n            for dr in [-1, 0, 1]:\n                for dc in [-1, 0, 1]:\n                    nr, nc = rr + dr, cc + dc\n                    if dr == 0 and dc == 0:\n                        continue\n                    if 0 <= nr < box_h and 0 <= nc < box_w:\n                        if not visited_box[nr, nc] and mask[nr, nc] == 0:\n                            visited_box[nr, nc] = True\n                            q.append((nr, nc))\n\n        # Interior pixels: mask==2 and not reachable from outside\n        interior_pixels = []\n        for rr in range(box_h):\n            for cc in range(box_w):\n                if mask[rr, cc] == 2 and not visited_box[rr, cc]:\n                    interior_pixels.append((rr + rmin, cc + cmin))\n\n        if not interior_pixels:\n            continue\n\n        # Find connected interior regions (4-connectivity) and fill each\n        interior_pixel_set = set(interior_pixels)\n        interior_visited = set()\n        def bfs_interior(sr, sc):\n            q = deque([(sr, sc)])\n            group = []\n            interior_visited.add((sr, sc))\n            while q:\n                r, c = q.popleft()\n                group.append((r, c))\n                for nr, nc in neighbors4(r, c):\n                    if (nr, nc) in interior_pixel_set and (nr, nc) not in interior_visited:\n                        interior_visited.add((nr, nc))\n                        q.append((nr, nc))\n            return group\n\n        groups = []\n        for pix in interior_pixels:\n            if pix not in interior_visited:\n                groups.append(bfs_interior(*pix))\n\n        # For each group, determine fill color and fill\n        for group in groups:\n            non_outline_colors = [grid[r, c] for r, c in group if grid[r, c] != 0 and grid[r, c] != outline_color]\n            if non_outline_colors:\n                fill_color = Counter(non_outline_colors).most_common(1)[0][0]\n            else:\n                alt_colors = [grid[r, c] for r, c in group if grid[r, c] != 0]\n                if alt_colors:\n                    fill_color = Counter(alt_colors).most_common(1)[0][0]\n                else:\n                    fill_color = outline_color\n            for r, c in group:\n                output[r, c] = fill_color\n\n    return output.tolist()\n```\n\n---\n\nThis approach should solve the training examples better by:\n\n- Accurately separating interior and exterior via 8-connected flood fill.\n- Handling multiple disconnected interior regions.\n- Choosing fill colors prioritizing non-outline interior colors.\n- Maintaining all outlines and background untouched.\n\nIt generalizes across examples and should work on the test input as well.\n\nFeel free to test and further iterate!"
            ]
          }
        ]
      }
    ]
  }
}