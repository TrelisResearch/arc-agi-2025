{
  "task_id": "963f59bc",
  "model": "gpt-4.1",
  "reasoning_effort": "N/A",
  "api_type": "responses_api_multiturn",
  "program": "import numpy as np\nfrom scipy.ndimage import label\n\ndef transform(grid):\n    grid = np.array(grid)\n    nrows, ncols = grid.shape\n\n    # Always output a grid of shape 11x11\n    out = np.zeros((11, 11), dtype=int)\n    # Place a portion of input grid if the grid is larger\n    grid = grid[:11, :11]\n    out[:grid.shape[0], :grid.shape[1]] = grid\n\n    used_labels = []\n    color_to_label = {}\n    label_to_expand = {}\n\n    # Copy for processing input\n    process_grid = grid.copy()\n\n    # For each non-black color, find connected components\n    for color in np.unique(process_grid):\n        if color == 0:\n            continue\n        # Find all blobs of this color\n        mask = (process_grid == color)\n        structure = np.ones((3,3), dtype=int)\n        labeled, ncomponents = label(mask, structure=structure)\n        for k in range(1, ncomponents+1):\n            blob = (labeled == k)\n            # If the blob is only a single pixel, it is expandable\n            if np.sum(blob) == 1:\n                idx = np.argwhere(blob)[0]\n                label_to_expand[(color, idx[0], idx[1])] = True\n\n    # For each \"expandable\" singleton pixel, perform the expansion\n    # The expansion is: fill a 3x3 block centered at the singleton pixel, excluding original nonzero pixels\n    for key in label_to_expand:\n        color, r, c = key\n        # Find a 3x3 region, clip to boundary\n        r0 = max(r-1, 0)\n        r1 = min(r+2, 11)\n        c0 = max(c-1, 0)\n        c1 = min(c+2, 11)\n        # For each cell in 3x3 region, fill with color unless original input had a nonzero pixel there\n        for rr in range(r0, r1):\n            for cc in range(c0, c1):\n                # Don't overwrite colored shapes that already exist in input\n                if out[rr, cc] == 0:\n                    out[rr, cc] = color\n\n    return out.tolist()",
  "execution_error": "Max turns reached",
  "timed_out": false,
  "tokens_used": 5259,
  "request_cost": 0.013488,
  "turns_used": 1,
  "raw_response": {
    "id": "resp_687002b5805c81a1a1d48dfab85019390d5a1ef5a990d8c0",
    "model": "gpt-4.1-2025-04-14",
    "usage": {
      "input_tokens": 4764,
      "output_tokens": 495,
      "total_tokens": 5259
    },
    "output": [
      {
        "type": "message",
        "content": [
          "Final answer:\n```python\nimport numpy as np\nfrom scipy.ndimage import label\n\ndef transform(grid):\n    grid = np.array(grid)\n    nrows, ncols = grid.shape\n\n    # Always output a grid of shape 11x11\n    out = np.zeros((11, 11), dtype=int)\n    # Place a portion of input grid if the grid is larger\n    grid = grid[:11, :11]\n    out[:grid.shape[0], :grid.shape[1]] = grid\n\n    used_labels = []\n    color_to_label = {}\n    label_to_expand = {}\n\n    # Copy for processing input\n    process_grid = grid.copy()\n\n    # For each non-black color, find connected components\n    for color in np.unique(process_grid):\n        if color == 0:\n            continue\n        # Find all blobs of this color\n        mask = (process_grid == color)\n        structure = np.ones((3,3), dtype=int)\n        labeled, ncomponents = label(mask, structure=structure)\n        for k in range(1, ncomponents+1):\n            blob = (labeled == k)\n            # If the blob is only a single pixel, it is expandable\n            if np.sum(blob) == 1:\n                idx = np.argwhere(blob)[0]\n                label_to_expand[(color, idx[0], idx[1])] = True\n\n    # For each \"expandable\" singleton pixel, perform the expansion\n    # The expansion is: fill a 3x3 block centered at the singleton pixel, excluding original nonzero pixels\n    for key in label_to_expand:\n        color, r, c = key\n        # Find a 3x3 region, clip to boundary\n        r0 = max(r-1, 0)\n        r1 = min(r+2, 11)\n        c0 = max(c-1, 0)\n        c1 = min(c+2, 11)\n        # For each cell in 3x3 region, fill with color unless original input had a nonzero pixel there\n        for rr in range(r0, r1):\n            for cc in range(c0, c1):\n                # Don't overwrite colored shapes that already exist in input\n                if out[rr, cc] == 0:\n                    out[rr, cc] = color\n\n    return out.tolist()\n```"
        ]
      }
    ]
  },
  "score": {
    "correct": false,
    "pixel_accuracy": 0.0,
    "total_pixels": 224,
    "correct_pixels": 0,
    "error": "Max turns reached"
  },
  "actual_output": [
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      3,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      3,
      3,
      0,
      0,
      0
    ],
    [
      1,
      1,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      3,
      0,
      3,
      3,
      0
    ],
    [
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      3,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      6,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      6,
      6,
      0,
      6,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      6,
      6,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      6,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]
  ],
  "api_success": true,
  "multiturn_data": {
    "turn_details": [
      {
        "turn_number": 1,
        "timestamp": "2025-07-10T19:13:09.392835",
        "input_tokens": 4764,
        "output_tokens": 495,
        "turn_cost": 0.013488,
        "program_extracted": true,
        "program": "import numpy as np\nfrom scipy.ndimage import label\n\ndef transform(grid):\n    grid = np.array(grid)\n    nrows, ncols = grid.shape\n\n    # Always output a grid of shape 11x11\n    out = np.zeros((11, 11), dtype=int)\n    # Place a portion of input grid if the grid is larger\n    grid = grid[:11, :11]\n    out[:grid.shape[0], :grid.shape[1]] = grid\n\n    used_labels = []\n    color_to_label = {}\n    label_to_expand = {}\n\n    # Copy for processing input\n    process_grid = grid.copy()\n\n    # For each non-black color, find connected components\n    for color in np.unique(process_grid):\n        if color == 0:\n            continue\n        # Find all blobs of this color\n        mask = (process_grid == color)\n        structure = np.ones((3,3), dtype=int)\n        labeled, ncomponents = label(mask, structure=structure)\n        for k in range(1, ncomponents+1):\n            blob = (labeled == k)\n            # If the blob is only a single pixel, it is expandable\n            if np.sum(blob) == 1:\n                idx = np.argwhere(blob)[0]\n                label_to_expand[(color, idx[0], idx[1])] = True\n\n    # For each \"expandable\" singleton pixel, perform the expansion\n    # The expansion is: fill a 3x3 block centered at the singleton pixel, excluding original nonzero pixels\n    for key in label_to_expand:\n        color, r, c = key\n        # Find a 3x3 region, clip to boundary\n        r0 = max(r-1, 0)\n        r1 = min(r+2, 11)\n        c0 = max(c-1, 0)\n        c1 = min(c+2, 11)\n        # For each cell in 3x3 region, fill with color unless original input had a nonzero pixel there\n        for rr in range(r0, r1):\n            for cc in range(c0, c1):\n                # Don't overwrite colored shapes that already exist in input\n                if out[rr, cc] == 0:\n                    out[rr, cc] = color\n\n    return out.tolist()",
        "training_feedback": {
          "feedback_messages": [
            {
              "type": "input_text",
              "text": "Training results: 0/4 examples solved, 0.0% pixel accuracy - Keep experimenting! Try a different approach to the transformation.\n\nTraining Example 1 \u2717:\nExpected: [[1, 1, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 1, 1, 1, 0, 3, 3, 3, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 1, 1, 1, 0, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nError: Traceback (most recent call last):\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmpyyivt_30.py\", line 30, in <module>\n    from scipy.ndimage import label\nModuleNotFoundError: No module named 'scipy'\n\n\nTraining Example 2 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 1, 0, 0, 0, 0, 0, 0, 6, 0], [0, 1, 1, 1, 1, 0, 0, 6, 6, 6, 6], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nError: Traceback (most recent call last):\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmp_i7un9ve.py\", line 30, in <module>\n    from scipy.ndimage import label\nModuleNotFoundError: No module named 'scipy'\n\n\nTraining Example 3 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nError: Traceback (most recent call last):\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmpnzgjstas.py\", line 30, in <module>\n    from scipy.ndimage import label\nModuleNotFoundError: No module named 'scipy'\n\n\nTraining Example 4 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nError: Traceback (most recent call last):\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmp0avhwopd.py\", line 30, in <module>\n    from scipy.ndimage import label\nModuleNotFoundError: No module named 'scipy'\n\n\n"
            },
            {
              "type": "input_image",
              "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZ8AAATYCAIAAABP5V2wAABAW0lEQVR4nO3de1hU9b748e+ogCgISm4vXColsB68IKloaF54noOYOii6Lc0NalqmqbhNK7PTeSTdG4/uLk+eTt5yk1t3ngAr9aAn87KLsnTn3QiokJQQBSRwuK3fU9OeH3FrgBlm5jPv19MftFjfmcWs4e1as4b56jRNUwAgTjtbbwAAWAV1AyATdQMgE3UDIBN1AyATdQMgE3UDIBN1AyATdQMgE3UDIBN1AyATdQMgE3UDIFOr6rZo0SJd42bNmtXgOq6urj179pw0adKpU6fq3+ahQ4d0Ol23bt1u375d51t79+7V6XRbtmwx/m9cXJxOp0tKSqqz2pUrV3Q63erVq1szyuj27dtvvPHGmDFjevfu7ebm1rt372nTph0/fryJx2T16tWNPSDnzp1r+kGLjIz8zQfWtM68efNqLzdu3tSpUz/55JPa26PX6+usdvfddz/11FM3b95s1oNvdP369bVr14aGhnp5eXXu3Hno0KFbtmyp/TEzxrurM/yLL77o3r27p6fnkSNHmnjoAIc/dqusrMzPz3/vvffGjBmTnZ1d57vbtm1TSt28eXPPnj3m3NqaNWsuXbrU3G0wZ9Q333wzfPjwxx9//KOPPrp69WpFRcXVq1f37t07atSojRs3Kjtj3Lx33303IiLi7bffbmK1b7755tVXX42KiqqpqWnWg//JJ58MHDjw+eef/+c//1lSUlJWVnby5MnHHnts7ty5TWzYhx9+OGbMmOrq6sOHD48ZM6YVPyLQhnV77bXXtH955513lFLbt283LUlOTjatmZOTY1p++/btixcvPvLIIyUlJZs3b659g0VFRampqdOmTevWrdt//dd/mbMNFRUVcXFx1dXVzdry3xxVWVkZGxv7z3/+c8SIEfv27bt+/XplZeV33333+uuvd+vW7emnnzYeiDXm9OnTWj0hISENPiAmhw8frn0j5qxz9epV4/Ly8vKvv/561apVmqbNmTPn22+/rb1aeXl57Qc/MjLys88+O3TokPkP/g8//BATE/P9998//PDDGRkZJSUlN27cSE1N7dOnz/bt2994440GH4eUlJTo6OhOnTp99NFHw4YNa+IRAyQcu7m5ufXr1+9Pf/qTUqrOsduuXbtu3769YMGC+Pj4jIyMM2fO/OatLV68+NNPP/3P//zPZm3Db4566623vvjii8jIyGPHjk2cONHHx6dDhw7+/v5PPPHEu+++W11d/be//U3Zk44dO/bt23fdunVr1qypqKj4y1/+0sSDv3TpUmMZzX/wN27cmJ+fv2zZsl27dg0bNszT07Nr166TJ08+evRo586dN27cWP9jULdu3Tpt2rTf/e53x48fHzBggGn5jh07dDrda6+9ZtEHALCDuhkMhvPnzyckJCilgoKCan9r+/bt995779ixY5944on27dubc/j20ksvBQYGrlmz5uLFi+Zvw2+O2rVrl06n++///u/27dvX+daDDz544cKFtWvXKru0fPnyTp06/e///m+D362srPzqq69eeeWVDh06PPjgg+Y/+H//+9/d3d3/4z/+o84N+vn5nThx4qOPPtLpdLWX//nPf543b16fPn1OnDhxzz33WO7nA+ysbnfffbfphe2OHTuGhIS88847d9xxx5IlS0zrnDt37vPPP1+xYoVOp+vbt++0adPefvvt0tLSpm+5U6dO27dvr6ysbNb56W+OOn369L333nv33Xc3OPzee++t88tcR2hoaJ2rASdOnGjsATH56KOPmrtOfZ6envfcc0+dg2J3d3fjcFdX1+Dg4H/84x9vvfVW7Z+u6Qe/srLym2++GTp0qIeHR/17HDRoUK9evWovefrpp1euXKmUGjlyZEBAQJ314+LiNE1btGhR0z8I4JDvCPH19Z0zZ86XX37Zs2dP08Jt27b5+vrOnDnT+L/PPPPMrVu3zDkBjIiIeOqppz777LMNGzaYvw1NjKqsrCwqKurRo0fthXWuY951113KXvn4+Bh+1tgK1dXVGRkZlZWVZj74RUVFmqb5+PiYuQGvvvrq8OHDIyMjt23b9u6777bupwHsu27GF8grKip2795tPLhYv3597969TStUVlYmJyfn5eW5ubkZ8zFw4EBN08y8tvDSSy/dc889L7zwwoULF8zfqsZGubi4eHp6FhQUqJaqf1UhIiLiN68YjB49urnrNOjmzZsuLi5ubm71rypUVFRkZ2c/+eSTr7766h//+EczH/xu3bq1a9fO/AckPj7+o48+2rlzZ7du3R577LG8vDwzBwKOeuzm4uLy+9//fs+ePUePHo2Kiqr9rqj333+/wV+eU6dOnTx58jdv2d3dvQXnp02M6t+//4UL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EwPPnz8/cuRId3f3ESNG5OTk1N/CkydPZmdnb9y4sWvXroGBgS+88EJaWpqmaW34IDmX2jui9rGbObvY1ttu3+ocXMBSfH196x+7GY0dO3bhwoWapi1ZsmTMmDGaphUUFCilgoKCzp49m5WVNXDgwDlz5hhXHj58eFxcXEFBQVZWVkRExIIFCzRNq6qq6t+///Tp0/Pz8zMzMyMiIlauXKlpWnBw8Pbt25sYWF5eHhAQ8OSTT964cWPfvn3u7u7Dhg1r+gd54403/Pz8LP3w4P+rvSNu3ryplLp48aKZu9jW227XqJu1+Pr61vmHpH379sZvZWZment7b9y40cvLKzMz01S3lJQU4wrp6emurq6lpaVHjx7t1KmTwWAwLj958mS7du3Ky8uPHj3q6upaWFhY505NT/3GBqampnp5eZWVlRmXz58/v+m6FRUV3X333S+88IKlHx78imlHmOpm5i620fY6Bs5MrajOsVtVVZVxeWBg4IoVKxISEpYvXx4YGGha3/QC/6BBgyoqKrKysi5cuFBWVubm5ma8KDFkyJCamprs7Ozz58/7+fl169atsbtubOCFCxf69u3r7u5uXC00NLSJ7f/xxx8nTpwYEhKyevVqCz0kaFj9HWHmLrb+pjkw6mYb586dU0qdOnWq9kIXFxfjF9XV1UqpDh06VFVVBQYG1vkX6b777nNxcdHpdE3cfmMD66xmusf6CgsLx40b5+fnt3fv3g4dOrTux8VvqL8jzNzFVt4ux0bdbODAgQN79uxJSkpKS0tLTU01LT9z5ozxi9OnT3t4ePTt27dfv345OTlXrlypcwtBQUG5ubnGs5jaTL8PjQ0MCQnJzMz88ccfjf979uzZBrfwypUrERERo0aNevvtt11dXVv34+K31d8RZu7ittpAx2T9k18n1dhVhVu3bgUEBCxdutT4aouvr29JSYnxdbf7778/Ozv7q6++6t+/f0JCgqZp1dXVoaGhkZGR33333ZUrV5YsWeLv73/79u2amprBgwfPnDmzoKAgJydnypQpM2bM0DQtLCwsMTGxpKSksYEGgyEoKGju3LmFhYWHDh3y9PSs/7rbzZs377nnnqeffrqtHipnV3tHmF53M3MX23rb7Rp1a7urCkqpBQsWLF68+K677iotLdU0rbi42N/ff9GiRca6rVq16s477+zatWtCQkJFRYXx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"
            },
            {
              "type": "input_text",
              "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
            }
          ],
          "solved_count": 0,
          "total_training_examples": 4,
          "pixel_accuracy": 0.0
        },
        "test_result": {
          "execution_error": "Traceback (most recent call last):\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmp63xd1sya.py\", line 30, in <module>\n    from scipy.ndimage import label\nModuleNotFoundError: No module named 'scipy'\n",
          "timed_out": false,
          "predicted_output": null
        },
        "status": "failed_test"
      }
    ],
    "total_turns": 1,
    "conversation_history": [
      {
        "role": "system",
        "content": "You are an expert at solving abstract reasoning puzzles. Write clean, efficient Python code."
      },
      {
        "role": "user",
        "content": [
          {
            "type": "input_text",
            "text": "You are solving an ARC (Abstraction and Reasoning Corpus) task. \nI will show you training examples with input and output grids, plus a test input grid. Your task is to:\n\n1. **Analyze the training examples** to discover patterns that map input grids to output grids\n2. **Write a Python program** that implements your best understanding of the transformation  \n3. **DO NOT predict or generate the test output** - your job is only to write the transformation program\n4. **Attempt a solution** - even if the pattern isn't completely clear, provide your best hypothesis\n5. **Do not repeat the same transformation** - if you have already tried a transformation, do not repeat it.\n\n**IMPORTANT: Your transformation must always produce a 11\u00d711 output grid.**\n\nThe test input is shown for context so you understand what type of grid your program will eventually process. Focus on learning patterns from training examples and writing code that captures your understanding.\n\nTraining Examples:\n\nExample 1:\nInput:\n1 1 0 0 0 0 0 0 0 0 0\n0 1 1 1 0 0 0 0 0 0 0\n0 1 0 0 0 0 0 3 0 0 0\n0 1 1 1 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n8 0 0 0 0 0 0 0 0 0 0\nOutput:\n1 1 0 0 0 0 0 3 3 0 0\n0 1 1 1 0 3 3 3 0 0 0\n0 1 0 0 0 0 0 3 0 0 0\n0 1 1 1 0 3 3 3 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 8 8 8 0 0 0 0 0 0 0\n0 8 0 0 0 0 0 0 0 0 0\n0 8 8 8 0 0 0 0 0 0 0\n8 8 0 0 0 0 0 0 0 0 0\n\nExample 2:\nInput:\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 1 1 0 0 0 0 0 0 0 0\n0 0 1 0 0 0 0 0 0 6 0\n0 1 1 1 1 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\nOutput:\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 1 1 0 0 0 0 0 0 6 6\n0 0 1 0 0 0 0 0 0 6 0\n0 1 1 1 1 0 0 6 6 6 6\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0\n\nExample 3:\nInput:\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 1 0 0 0 0 0 0 0\n0 0 1 0 1 0 0 0 0 0 0 0\n0 0 1 1 1 1 1 0 0 0 0 0\n0 0 0 1 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 2 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\nOutput:\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 1 0 0 0 0 0 0 0\n0 0 1 0 1 0 0 0 0 0 0 0\n0 0 1 1 1 1 1 0 0 0 0 0\n0 0 0 1 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 2 0 0 0 0 0 0 0 0\n0 0 2 2 2 2 2 0 0 0 0 0\n0 0 2 0 2 0 0 0 0 0 0 0\n0 0 0 0 2 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n\nExample 4:\nInput:\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 1 1 0 0 0 0 0 0 0 0\n0 0 1 0 0 0 0 0 0 0 0 2 0\n0 0 0 1 1 0 0 0 0 0 0 0 0\n0 0 0 0 1 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 8 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\nOutput:\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 1 1 0 0 0 0 2 2 0 0\n0 0 1 0 0 0 0 0 0 0 0 2 0\n0 0 0 1 1 0 0 0 0 2 2 0 0\n0 0 0 0 1 0 0 0 0 2 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 8 0 0 0 0 0 0 0 0\n0 0 0 8 8 0 0 0 0 0 0 0 0\n0 0 8 0 0 0 0 0 0 0 0 0 0\n0 0 0 8 8 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n\nTest Input:\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 1 0 0 0 0 0 0 0 3 0 0 0 0\n0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0\n1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\nAnalyze the patterns in the training examples and write a Python function that performs this transformation.\n\n**Approach Guidelines:**\n- Look for patterns in shapes, colors, positions, sizes, rotations, reflections, etc.\n- Even if you can't solve all training examples perfectly, implement what patterns you do observe\n- A partial solution that captures some aspects is better than returning the input unchanged\n- If the pattern is unclear, make your best educated guess based on what you can see\n\nRequirements:\n- The function takes a 2D list (grid) where grid[row][col] gives the value at that position\n- Values are integers from 0-9\n- Return a new grid (2D list) with the transformation applied\n- You can use numpy if needed - just add 'import numpy as np' at the start of your function\n- Aim to handle the training examples as well as possible, even if not perfectly\n- Your function should attempt some meaningful transformation based on the patterns you observe\n\nYou MUST end your response with the following exact format:\n\nFinal answer:\n```python\ndef transform(grid):\n    # Your transformation logic here (implement your best understanding)\n    return transformed_grid\n```\n"
          },
          {
            "type": "input_image",
            "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAmwAAAYxCAIAAACLqFdIAABG/klEQVR4nO3de5hU9Zng8VPaXOQiSJzxgpGmIYskJGiI1xgvAeOMiXpqgjFRd20ULzMSw3qBJI+aXRMvgDPZxNtgUDTBmKjrqWec8LgTzEM0u2NClGgEW8CggpAoCN6xGzj7zPRsL4KS5q1uqk/z+Tz+0Zyut86vqv311zpdjaU8zxMAYMftFpgBAEQUAOJEFACCRBQAgkQUAIJEFACCRBQAgkQUAIJEFACCRBQAgkQUAIJEFACCRBQAahHRSZMmlT7YWWed9b636dmz57777nvKKac88cQT297nz3/+81KpNGjQoA0bNmz1qfvvv79UKs2aNav1j42NjaVSacaMGVvdbOXKlaVS6YorrqhmqtWGDRtmzpx5/PHH77///r169dp///1PO+20Rx99NPacjBs3LkmStWvX7r///nvttdfKlSu3mv2bv/mbnj17/va3v23nE/LlL3+5VCrV1dW98sor265k1KhRpVKpsbGx9Y8TJ07ccjG77777nnvuefjhh99+++1tI2malkqlbU/UzofWas2aNVOmTDnooIP22GOPgQMHHnXUUbfeeuumTZu286QBFFQNXom2tLT86U9/evDBB48//vg//OEPW332jjvuSJJk3bp1P/3pT9tzb1dddVVTU9OOrqE9U88///yRRx554YUXzp8/f/Xq1c3NzatXr77//vuPOeaYf/iHf0iiPvShD91xxx3r16+fMGHClv8fuptvvjnLsmuvvfZTn/rUDj0hmzZteuCBB7Y6+Pvf/37RokXbWcbmzZvfeOON3/zmNxMnTpw+fXrSQV555ZVDDz10xowZzz777IYNG1577bV//dd//bu/+7vTTjvN/3QP6H6qiuhNN92U/z/33XdfkiSzZ89uOzJnzpy2Wy5fvrzt+IYNG5555pkzzjjj9ddfv/XWW7e8w/Xr11cqldNOO23QoEH/+I//2J41NDc3NzY27ugLnT871dLSMn78+N/97ndHHXXUP/3TP61Zs6alpeXFF1+85ZZbBg0aNGXKlKeffno797/l420zb9681s/+1V/91UUXXTRv3rybbrqp9ciTTz556aWXfu5zn7v00kt36AnZfffdR4wYce+99251/Cc/+cnHPvaxbW+/evXq1sVs3rz5zTff/PGPf9y7d+9rrrnm3Xff3e4T1t6H9v3vf//5558fP378k08++dZbb61fv/4Xv/jFIYcckmXZgw8+2M5TABRFDV6J9urV66CDDpo2bVqSJFu9Ev3xj3+8YcOGCy64YMKECY899thTTz31Z+/tq1/96q9//eu///u/36E1/Nmpu+666/HHHx83btwjjzxy8sknf+hDH6qrq/vwhz/8t3/7tw888MCmTZvuueeepAozZsw46KCDpk6d+uyzz7755ptf+tKXBgwY8MMf/rBUKu3oE/KlL33pl7/85csvv7zlwZ/+9Kenn376dhZQKpX69u37la985ctf/vLrr7++ZMmSpCM0NTXV1dXNmTPnE5/4RJ8+fQYMGHD88ce3vlB+6KGHWm9z5513lkqltv+AACiuGkT03XffXbRo0SWXXJIkyX/6T/9py0/Nnj175MiRn/3sZ//2b/929913b8+L0WuvvXb48OFXXXXVM8880/41/NmpH//4x6VS6bbbbtt99923+tSxxx67ePHi73znO0kV9thjj7vvvnvjxo1nnXXWhRdeuHTp0h/+8If77LPPVjdrzxPypS99aasrur/5zW+ee+65L33pS+1ZSetr0G0fZszo0aM3btyYZdmWB+vr6/M8v+WWWzrkFAC7XESHDh3a9iaU3r17jxo16r777tt7772/9rWvtd3m6aef/u1vf3v55ZeXSqVhw4addtppd99995tvvrn9e+7Tp8/s2bNbWlp26KLun51auHDhyJEjhw4d+r7jI0eO3Ool43Yeb5v58+dveZtPfvKT/+2//bff/va3d9999yWXXHLiiSdudSftfEJGjRr10Y9+tPVyequf/OQnn/rUp4YNG7adFW7atGnVqlXf+9737r333r/8y78cMWLEdm7c/oc2efLko48++itf+UpDQ8PEiRNvu+22bX8029jYmOf5pEmT2nlGgC6rNr/iMnjw4HPOOefJJ5/cd9992w7ecccdgwcPPvPMM1v/+I1vfOONN95oz1XTo48++uKLL/7Nb35zww03tH8N25lqaWlZv379Vq8Lt3pvan19fVK1U089tTXGRx999Lafbf8TsuUV3TzP77333g+6lrvffvu1rr+urm7w4MGTJ0/etGnTtdde21GvRPv16zd//vw5c+aMHj26UqlccMEFo0aNGjp06F133dUh9w+wK0a09d0ozc3NP/nJT/r37/+Rj3zk+uuv33///dtu0NLSMmfOnJdeeqlXr16t3+VHjx6d53k731507bXXfuQjH/nWt761ePHi9q/qg6Z69OjRv3//9/29kWrefXPcccdteZsNGzacccYZAwYM6N+//wUXXLDVDzV36Ak5/fTT267oPvLII6tWrfqz13J32223QYMGjR07tlKpnHvuuR340Hbfffczzzwzy7I1a9YsXbp09uzZ++yzT2Nj43e/+932nwWgEHbqK9EePXqcfvrpP/3pT3/5y1/+1V/91Za/j/jP//zP7xutJ554YsGCBX/2nvfYY4/ARd3tTH384x9fvHjxiy+++L5vRR4zZkxStcmTJz/11FPf/3cvv/zyOeecs+Vnd+gJOeiggz7+8Y+3vkf3pz/96RFHHHHggQe+70nb3p27adOmtWvXzps379RTT006zfDhwxsbG3/1q18dcsghVf4UGaALqsHl3L/+67/+6le/+sQTT1x22WVtB++4447evXu/9tprW76++T//5/8kSTJz5sz23O2nP/3pr33tawsWLNj2L1IITJ155pmbN2/+u7/7u/dNcvW/8njffffNnDnzjDPO+M//+T83NjZ+8Ytf/NnPfrblL/zs6BNy+umnP/LII62/ybr99+V2npdeeqlUKk2cOHGr43V1dR//+MfXr1/f3Nxck4UBdKufiV577bUHHnjgrbfe+utf/zpJkj/+8Y8PPfTQySefvOeee255syOPPHLEiBH33HPPa6+91p67veaaaz7ykY/s6LtA33dq4sSJY8aM+dnPfnbYYYfde++9f/zjH1taWloT9fnPf/6JJ57Ybbf4U7d8+fLzzjtv6NChbdWcOXPmfvvtd+mll7b+FRCBJ6T1iu7kyZPXrFlz2mmnJbUwePDgT37yk3fcccekSZP+9V//9U9/+tOGDRuee+65W2655b777jvssMN69uxZk4UBdKuI9u3b98Ybb9y8efMFF1ywcePGH/7whxs3bmx7B82Wzj777LfffvtHP/pR+y/Pbv99s+2c6tmzZ6VSOfLII5944onTTz99v/3269mzZ+tf+zd37twRI0Zs/y9Uet+3sJZKpTfffLOlpeX0009/66237r777rZGfuhDH7rzzjs3bNhw5plntrS0BJ6Q4cOHH3LIIffee+9nPvOZLX/YHLDHHntstew777yzPQ+t9QX0wIEDb7755qOOOmrffffdY489hg8fftFFF9XV1bX9YqjfEwW6jZr9BfSnnHJKmqZPPvnk//gf/+POO+/ca6+9/vqv/3rbm/2X//Jfdtttt3Ze0W29PDt58uQdXcz7Th1wwAGPPvronDlzTjrppAMOOKBnz5777LPPSSeddNdddz399NOHHnpoEvL1r399wYIF3/rWt4488sgtj3/uc5+bNGnSE088ccUVV8SekNaruO389dBOMnr06EWLFl166aWjRo3ac889e/bsWV9ff/755//+97/vkB8kA3QpJX+jKQDE+F+hAUCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIsrW1a9c2NTXVehXQrbaGbdVdiWixpWna2NjYsfc5bty4xx577IM+u379+oaGhu3cALq+FStWnHfeeYMHD+7du3dDQ8Nll1326quvVrk1qpm1rYpLRNnaO++880GfWrFixbhx45YvX75zVwQdacmSJWPGjFm3bt3cuXNfffXVBx544JlnnhkzZszq1avDW+PPsq26KxHtJtasWVMqlW6++eb6+vrevXufeOKJL730Utvx22+//YADDhgwYMC5557buplXrlxZKpWef/751vEbbrjhiCOOSJLkuOOOe/bZZydMmDBx4sStTvGzn/1s1KhRY8aMqcXjgw4zceLEY4899v777x89enSfPn0OPvjgBx98cN9997344ovbuTVsK9qIaLdy1113Pfzww01NTatWrbr66qvbjk+fPv2hhx5auHDh448/PmnSpO3cw/z580eMGDF79uxZs2Zt9alevXrNmzfv5ptv7rTlQ6d74YUXHn300a12wW677TZ58uRKpbJu3br2bw3bChHtbq688sphw4bV19c3NjYuWLCg7fi0adNGjRrV0NAwY8aMOXPmvPXWW4E7Hzdu3KGHHtqh64WdbfHixUmSjBw5cqvjo0eP3rhx47Jly9p/V7YVItrd1NfXt37Qt2/flpaWtuOt15SSJDn44IObm5ufe+65Gi0QaqxUKiVJsmnTpq2Ov/vuuzt6V7YV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3/Z46/eOurq6rS4Zbfs95X2tXbt27NixBxxwwP33319XV9dxC4edpPU1aOvr0S01NTXV1dUNHz68/VvDtkJEdxVPPfVU6wcLFy7s16/fsGHDWn8M03YB6sUXX2y78Qf9SGblypVHH330Mcccc/fdd7f9FAeKZciQIWPHjr3++uu3PLh58+bp06efcsope+21V/u3hm2FiO4qpkyZsnz58qVLl06dOvX888/v1avX3nvvPXTo0JkzZ7799tvz5s2755572m7ct2/fVatWvfHGG1vew/r16z/72c+ecsop06dP98YHCu22225btGjRWWedtWTJkpaWlsWLF48fP/7ll1++8cYbkyRp/9awrfg3//+NuhT/V1yeeeaZ1uO33nrrxz72sbbjX//614cMGbLXXntdcsklzc3Nrbd5+OGHR44c2atXr2OOOabtvfh5nv/gBz/o16/fF7/4xS1PdN111237L88bb7yx0x8xdIDVq1dfdNFFBx54YK9everr6ydPnrxmzZq2z/7ZrWFb0aa05U/OiqJcLtd6CYXR3Nw8d+7csWPH9u/fv9Zr6c6yLEuKxj4Ks606SVbAfVTIV6JpmoYf7642e9JJJ9XkvLvabF5ARXyezXbv2byA/EwUAIJEtJvzfj+AziOiABAkogAQJKIAECSiABAkogAQJKIAECSiABAkogAQJKIAECSiABAkogAQJKIAECSiABAkogAQJKIAECSiABBUyvM8KZpyuVzrJcB7ZFmWFI19RFeTFXAfJXkBpWkafrxmzXbGbF5ARXyezXbv2byAXM4FgCARBYAgEQWAIBEFgCARBYAgEQWAIBEFgCARBYAgEQWAIBEFgCARBYAgEQWAIBEFgCARBYAgEQWAIBEFgCARBYAgEQWAoFKe50nRlMvlWi8B3iPLsqRo7CO6mqyA+yjJCyhN0/DjNWu2M2bzAiri82y2e8/mBeRyLgAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASV8jxPiqZcLtd6CfAeWZYlRWMf0dVkBdxHSV5AaZqGH69Zs50xmxdQEZ9ns917Ni8gl3MBIEhEASBIRAEgSEQBIEhEASBIRAEgSEQBIEhEASBIRAEgSEQBIEhEASBIRAEgSEQBIEhEASBI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0Rs3bly2bFn778qW3EWIaMHU19e3ftC3b9+Wlpa240cccUTrBwcffHBzc/Nzzz0XPkVTU9PatWv79OnzhS98oer1QpGUSqUkSTZt2rTV8XfffXdH78qW3EWIaMH06NGj7eM8z7c93rr/6+rqWr8dtNn2+8J29O3b94orrvj1r3+9atWqjlg1FEPra9DW16NbampqqqurGz58ePu3lS25ixDRbuKpp55q/WDhwoX9+vUbNmxYz549kyRpu4j04osvtt14q83c6qGHHhowYEDbf3G/+uqru++++8CBA3fK8qFLGDJkyNixY6+//votD27evHn69OmnnHLKXnvt1f5tZUvuIkS0m5gyZcry5cuXLl06derU888/v1evXnvvvffQoUNnzpz59ttvz5s375577mm7cd++fVetWvXGG29seQ/HHXfcvvvue8kll7z22mtPPfXU5ZdfPmHChD59+tTi0UDN3HbbbYsWLTrrrLOWLFnS0tKyePHi8ePHv/zyyzfeeGOSJO3fVrbkrqLWbw9mx37F5Zlnnmk9fuutt37sYx9rO/71r399yJAhe+211yWXXNLc3Nx6m4cffnjkyJG9evU65phj2t5Pn+f5D37wg379+n3xi1/c6lzLli076aST9txzzwMPPPAb3/jGO++8s3MfK3QJq1evvuiiiw488MBevXrV19dPnjy57fdM2rOtbMldSmnLn6vtTN6r3VGam5vnzp07duzY/v3713otu64sy5KisQc7iS25a+3BWtU7TdPwms2a7WqzeQEV8Xk2a/aD1Gof+ZkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABJXyPE9qoVwu1+S80BmyLEuKxh6kO8lqtAfrktqpVCqxwTRNCzk7fFpwdtnUQj7eXWm2oAr3PNuDZrsal3MBIEhEASBIRAEgSEQBIEhEASBIRAEgSEQBIEhEASBIRAEgSEQBIEhEASBIRAEgSEQBIEhEASBIRAEgSEQBIEhEASBIRAEgqJTneVIL5XK5JueFzpBlWVI09iDdSVajPViX1E6lUokNpmla1ezwacHZZVMLeV6znT9bUPbgTjqv2e67B13OBYAgEQWAIBEFgCARBYAgEQWAIBEFgCARBYAgEQWAIBEFgCAR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0hVXXNH6x4kTJ255z7vvvvuee+55+OGH33777Vs96ueff36ru2pqaiqVSpdddllswQAUTl3SBbzyyiuHHXZYW5Y2bNjwr//u5z//+f/8n/+zVCp11Imuuuqqk08++aCDDmrn7Tdv3vzGG2/85t+tXbt2ypQpHbUSAHb1V6I33XRT/v/cd999SZLMnj277cicOXPabrl8+fJ8G/PmzWv97Pe///3nn39+/PjxTz755FtvvbV+/fpf/OIXhxxySJZlDz744A6daPuam5sbGxvbXuB+kNWrV7fe8+bNm998880f//jHvXv3vuaaa959990Of2YAKK4u8TPRpqamurq6OXPmfOITn+jTp8+AAQOOP/74Bx54IEmShx56qANP9NWvfvXXv/713//937fz9qVSqW/fvl/5yle+/OUvv/7660uWLOnAxdx5552lUummm27qwPsEYJeL6OjRozdu3Jhl2ZYH6+vr8zy/5ZZbOvBE11577fDhw6+66qpnnnlmhwZbX4PuvvvuHbgYAIpuJ0V06NCh276/Zv78+a2fnTx58tFHH/2Vr3yloaFh4sSJt91226JFizpjGX369Jk9e3ZLS0t7LuomSbJp06ZVq1Z973vfu/fee//yL/9yxIgRHbiYxsbGPM8nTZrUgfcJwC73SrRfv37z58+fM2fO6NGjK5XKBRdcMGrUqKFDh951110dfq6jjz764osv/s1vfnPDDTd80G3222+/1szX1dUNHjx48uTJmzZtuvbaa70SBaAGEX3fNxYdd9xxbTfYfffdzzzzzCzL1qxZs3Tp0tmzZ++zzz6NjY3f/e53O3wx11577Uc+8pFvfetbixcv3v4td9ttt0GDBo0dO7ZSqZx77rmtB+vq/u0tzS0tLVvduPVI62cB2BV0iVeiWxk+fHhjY+OvfvWrQw455Dvf+U6H3/8ee+yx/Yu6be/O3bRp09q1a+fNm3fqqae2fXbAgAFJkrz88stbTf3xj39s+ywAu4LaR/Sll14qlUoTJ07c6nhdXd3HP/7x9evXNzc3d/hJP/3pT3/ta19bsGDBtn/9wp81dOjQ933bcOuRhoaGjlsmAF1a7a89Dh48+JOf/OQdd9zRu3fvM888s6GhYcCAAS+99NL/+l//67777jvssMN69uzZGee95ppr/vmf/znw7t8TTjihR48e06dPHzBgwJlnnvkXf/EXf/rTn37yk5/ceOONffr0+exnP9sZqwWgC6rlu3NLpdKbb76ZJMkdd9wxcODAm2+++aijjtp333332GOP4cOHX3TRRXV1dZ33a5StF3UDfx3S4MGD//t//+/Nzc2XX375/vvv36NHjwMOOOCyyy7buHHjP/zDP/zFX/xFO+/H74kCFF1X+T3RRYsWXXrppaNGjdpzzz179uxZX19//vnn//73vx8zZkznnffTn/705MmTA4Pf+MY3KpXKiSeeuM8++/To0WO//fY7+eST582bd8EFF3TCMgHookp5ntd6DQBQSF3ilSgAFJGIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIhCV7F27dqmpqbudy7oxkQUqjJ+/PjS+5k3b96O3tW4ceMee+yxbY+nadrY2NhB6/0z5wJ2iIhCVe6///78382ePbtv376tH+d5Pm7cuB29q3feeadz1ljjc0E3JqLQiVavXj1+/Ph+/fp9+MMfvuSSS9rS9Y//+I8NDQ39+/c/9NBDH3jggSRJjjvuuGeffXbChAkTJ078oHtbs2ZNqVS6+eab6+vre/fufeKJJ7700kttx2+//fYDDjhgwIAB5557buuJVq5cWSqVnn/++dbxG2644YgjjmjnuYD2EFHoRF/84hf79+///PPP//KXv1ywYMF//a//NUmSp556asqUKffff/+aNWu+9rWvnXHGGevWrZs/f/6IESNmz549a9as7d/nXXfd9fDDDzc1Na1aterqq69uOz59+vSHHnpo4cKFjz/++KRJk7ZzD+0/F7B9Igqd5ZFHHnnyySdnzpy59957NzQ0fPe73/3BD36wYcOGF154IUmSvn379urV66yzztqwYcNee+3V/ru98sorhw0bVl9f39jYuGDBgrbj06ZNGzVqVENDw4wZM+bMmfPWW291zsMC/j8Rhc6yePHit99+u1evXq1vNTr00EM3b978hz/84YQTTjjssMNGjhx52GGHffvb3165cuUO3W19fX3rB3379m1paWk73nqpNkmSgw8+uLm5+bnn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"
          },
          {
            "type": "input_text",
            "text": "Above is a visual representation of all the training examples and the test input. Each grid cell is colored according to its value (0-9), with clear labels and arrows showing input\u2192output transformations. Use both the textual and visual information to understand the pattern."
          }
        ]
      },
      {
        "type": "message",
        "role": "assistant",
        "content": [
          "Final answer:\n```python\nimport numpy as np\nfrom scipy.ndimage import label\n\ndef transform(grid):\n    grid = np.array(grid)\n    nrows, ncols = grid.shape\n\n    # Always output a grid of shape 11x11\n    out = np.zeros((11, 11), dtype=int)\n    # Place a portion of input grid if the grid is larger\n    grid = grid[:11, :11]\n    out[:grid.shape[0], :grid.shape[1]] = grid\n\n    used_labels = []\n    color_to_label = {}\n    label_to_expand = {}\n\n    # Copy for processing input\n    process_grid = grid.copy()\n\n    # For each non-black color, find connected components\n    for color in np.unique(process_grid):\n        if color == 0:\n            continue\n        # Find all blobs of this color\n        mask = (process_grid == color)\n        structure = np.ones((3,3), dtype=int)\n        labeled, ncomponents = label(mask, structure=structure)\n        for k in range(1, ncomponents+1):\n            blob = (labeled == k)\n            # If the blob is only a single pixel, it is expandable\n            if np.sum(blob) == 1:\n                idx = np.argwhere(blob)[0]\n                label_to_expand[(color, idx[0], idx[1])] = True\n\n    # For each \"expandable\" singleton pixel, perform the expansion\n    # The expansion is: fill a 3x3 block centered at the singleton pixel, excluding original nonzero pixels\n    for key in label_to_expand:\n        color, r, c = key\n        # Find a 3x3 region, clip to boundary\n        r0 = max(r-1, 0)\n        r1 = min(r+2, 11)\n        c0 = max(c-1, 0)\n        c1 = min(c+2, 11)\n        # For each cell in 3x3 region, fill with color unless original input had a nonzero pixel there\n        for rr in range(r0, r1):\n            for cc in range(c0, c1):\n                # Don't overwrite colored shapes that already exist in input\n                if out[rr, cc] == 0:\n                    out[rr, cc] = color\n\n    return out.tolist()\n```"
        ]
      }
    ],
    "all_responses": [
      {
        "id": "resp_687002b5805c81a1a1d48dfab85019390d5a1ef5a990d8c0",
        "model": "gpt-4.1-2025-04-14",
        "usage": {
          "input_tokens": 4764,
          "output_tokens": 495,
          "total_tokens": 5259
        },
        "output": [
          {
            "type": "message",
            "content": [
              "Final answer:\n```python\nimport numpy as np\nfrom scipy.ndimage import label\n\ndef transform(grid):\n    grid = np.array(grid)\n    nrows, ncols = grid.shape\n\n    # Always output a grid of shape 11x11\n    out = np.zeros((11, 11), dtype=int)\n    # Place a portion of input grid if the grid is larger\n    grid = grid[:11, :11]\n    out[:grid.shape[0], :grid.shape[1]] = grid\n\n    used_labels = []\n    color_to_label = {}\n    label_to_expand = {}\n\n    # Copy for processing input\n    process_grid = grid.copy()\n\n    # For each non-black color, find connected components\n    for color in np.unique(process_grid):\n        if color == 0:\n            continue\n        # Find all blobs of this color\n        mask = (process_grid == color)\n        structure = np.ones((3,3), dtype=int)\n        labeled, ncomponents = label(mask, structure=structure)\n        for k in range(1, ncomponents+1):\n            blob = (labeled == k)\n            # If the blob is only a single pixel, it is expandable\n            if np.sum(blob) == 1:\n                idx = np.argwhere(blob)[0]\n                label_to_expand[(color, idx[0], idx[1])] = True\n\n    # For each \"expandable\" singleton pixel, perform the expansion\n    # The expansion is: fill a 3x3 block centered at the singleton pixel, excluding original nonzero pixels\n    for key in label_to_expand:\n        color, r, c = key\n        # Find a 3x3 region, clip to boundary\n        r0 = max(r-1, 0)\n        r1 = min(r+2, 11)\n        c0 = max(c-1, 0)\n        c1 = min(c+2, 11)\n        # For each cell in 3x3 region, fill with color unless original input had a nonzero pixel there\n        for rr in range(r0, r1):\n            for cc in range(c0, c1):\n                # Don't overwrite colored shapes that already exist in input\n                if out[rr, cc] == 0:\n                    out[rr, cc] = color\n\n    return out.tolist()\n```"
            ]
          }
        ]
      }
    ]
  }
}