{
  "task_id": "a57f2f04",
  "model": "gpt-4.1",
  "reasoning_effort": "N/A",
  "api_type": "responses_api_multiturn",
  "program": "import numpy as np\nfrom collections import deque\n\ndef transform(grid):\n    grid = np.array(grid)\n    H, W = grid.shape\n    output = np.array(grid)  # Start with a copy\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    background = 6  # blue\n\n    # Directions: 4-connected\n    dirs = [(-1,0),(1,0),(0,-1),(0,1)]\n    \n    def in_bounds(r, c):\n        return 0 <= r < H and 0 <= c < W\n\n    # Floodfill for connected component\n    def floodfill(sr, sc):\n        q = deque()\n        q.append((sr, sc))\n        component = []\n        visited[sr, sc] = True\n        while q:\n            r, c = q.popleft()\n            component.append((r, c))\n            for dr, dc in dirs:\n                nr, nc = r+dr, c+dc\n                if in_bounds(nr, nc) and not visited[nr, nc]:\n                    # Only travel through non-background (non-blue) cells\n                    if grid[nr, nc] != background:\n                        visited[nr, nc] = True\n                        q.append((nr, nc))\n        return component\n\n    # Process all non-background cells\n    for r in range(H):\n        for c in range(W):\n            if not visited[r, c] and grid[r, c] != background:\n                comp = floodfill(r, c)\n                # bounding box\n                rs = [p[0] for p in comp]\n                cs = [p[1] for p in comp]\n                rmin, rmax = min(rs), max(rs)\n                cmin, cmax = min(cs), max(cs)\n                # Find the dominant color (ignoring black 0)\n                colors = [grid[p] for p in comp if grid[p] != 0]\n                if colors:\n                    # There might be more than one, but observation is only 1 significant color per region\n                    signal_color = max(colors, key=colors.count)\n                else:\n                    signal_color = 0  # fallback, shouldn't happen\n                # Fill bounding box with checker of color+black\n                for rr in range(rmin, rmax+1):\n                    for cc in range(cmin, cmax+1):\n                        if (rr+cc)%2==0:\n                            output[rr,cc] = signal_color\n                        else:\n                            output[rr,cc] = 0  # black\n    return output.tolist()",
  "execution_error": "Max turns reached",
  "timed_out": false,
  "tokens_used": 8950,
  "request_cost": 0.024272,
  "turns_used": 1,
  "raw_response": {
    "id": "resp_687002c86a74819f8f02a2bc61538aed0067888449fa580f",
    "model": "gpt-4.1-2025-04-14",
    "usage": {
      "input_tokens": 7888,
      "output_tokens": 1062,
      "total_tokens": 8950
    },
    "output": [
      {
        "type": "message",
        "content": [
          "Let's analyze the provided training examples:\n\n### Observations from Input\u2192Output:\n\n1. **Color region swap & checkerboard:**\n    - In each input, there are color regions bordered/filled with black (0) cells and a distinct color (red, blue, green, yellow).\n    - In the output, the same regions become: the non-black region is uniformly filled with that color, and within, a \"checkerboard\" of black (0) is overlaid.\n    - The region is NOT always the same as the color region in input (sometimes the entire area, sometimes just the colored area).\n    - The overlaid checkerboard is always such that the colored region has black on every alternate cell, starting at the top-left of the color region.\n    - Black regions (not overlaid checkerboard) remain black.\n\n2. **Shape consistency:**\n    - In output, the original colored area expands to cover the region previously bounded by black, then gets the checkerboard.\n\n3. **Multiple sub-regions:**\n    - Grids can have multiple colored regions \u2014 each gets the checkerboard with its color & black.\n    - Bounding rectangles are axis-aligned.\n\n4. **Background is blue (number 6) in outputs, so keep that background unchanged. All transformations happen only within non-blue regions.**\n\n5. **Grid size:** Stays the same as input, and always is 19x13 (for this problem, always must output that size).\n\n### Hypothesis:\n\n- For each contiguous non-blue (non-6) region:\n  - Find the bounding rectangle containing the region.\n  - Take the dominant non-zero/non-black color (\"the signal color\" of that region).\n  - Fill the entire bounding rectangle with the signal color.\n  - Overlay a checkerboard pattern: set cells with (row+col)%2==0 to signal color, and (row+col)%2==1 to black (0).\n- Leave blue (6) background untouched.\n- Black regions not belonging to a colored region (background black) remain black (confirm: in every example, black only comes as part of the checkerboard or used as a fill in the input).\n\n### Implementation Plan:\n\n- For each connected component of non-blue, non-background:\n    - Use flood fill (BFS/DFS) to find regions.\n    - For each, get its bounding box.\n    - Find the main color (non-black) in it.\n    - Within that box, apply the checkerboard using the main color and black.\n\nFinal answer:\n```python\nimport numpy as np\nfrom collections import deque\n\ndef transform(grid):\n    grid = np.array(grid)\n    H, W = grid.shape\n    output = np.array(grid)  # Start with a copy\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    background = 6  # blue\n\n    # Directions: 4-connected\n    dirs = [(-1,0),(1,0),(0,-1),(0,1)]\n    \n    def in_bounds(r, c):\n        return 0 <= r < H and 0 <= c < W\n\n    # Floodfill for connected component\n    def floodfill(sr, sc):\n        q = deque()\n        q.append((sr, sc))\n        component = []\n        visited[sr, sc] = True\n        while q:\n            r, c = q.popleft()\n            component.append((r, c))\n            for dr, dc in dirs:\n                nr, nc = r+dr, c+dc\n                if in_bounds(nr, nc) and not visited[nr, nc]:\n                    # Only travel through non-background (non-blue) cells\n                    if grid[nr, nc] != background:\n                        visited[nr, nc] = True\n                        q.append((nr, nc))\n        return component\n\n    # Process all non-background cells\n    for r in range(H):\n        for c in range(W):\n            if not visited[r, c] and grid[r, c] != background:\n                comp = floodfill(r, c)\n                # bounding box\n                rs = [p[0] for p in comp]\n                cs = [p[1] for p in comp]\n                rmin, rmax = min(rs), max(rs)\n                cmin, cmax = min(cs), max(cs)\n                # Find the dominant color (ignoring black 0)\n                colors = [grid[p] for p in comp if grid[p] != 0]\n                if colors:\n                    # There might be more than one, but observation is only 1 significant color per region\n                    signal_color = max(colors, key=colors.count)\n                else:\n                    signal_color = 0  # fallback, shouldn't happen\n                # Fill bounding box with checker of color+black\n                for rr in range(rmin, rmax+1):\n                    for cc in range(cmin, cmax+1):\n                        if (rr+cc)%2==0:\n                            output[rr,cc] = signal_color\n                        else:\n                            output[rr,cc] = 0  # black\n    return output.tolist()\n```\n"
        ]
      }
    ]
  },
  "score": {
    "correct": false,
    "pixel_accuracy": 0.0,
    "total_pixels": 572,
    "correct_pixels": 0,
    "error": "Max turns reached"
  },
  "actual_output": [
    [
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8
    ],
    [
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8
    ],
    [
      8,
      8,
      8,
      0,
      1,
      0,
      0,
      1,
      0,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8
    ],
    [
      8,
      8,
      8,
      1,
      0,
      1,
      1,
      0,
      1,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8
    ],
    [
      8,
      8,
      8,
      1,
      1,
      0,
      1,
      1,
      0,
      8,
      8,
      8,
      8,
      4,
      0,
      4,
      0,
      4,
      0,
      8,
      8,
      8
    ],
    [
      8,
      8,
      8,
      0,
      1,
      0,
      0,
      1,
      0,
      8,
      8,
      8,
      8,
      4,
      4,
      4,
      4,
      4,
      4,
      8,
      8,
      8
    ],
    [
      8,
      8,
      8,
      1,
      0,
      1,
      1,
      0,
      1,
      8,
      8,
      8,
      8,
      4,
      0,
      4,
      0,
      4,
      0,
      8,
      8,
      8
    ],
    [
      8,
      8,
      8,
      1,
      1,
      0,
      1,
      1,
      0,
      8,
      8,
      8,
      8,
      4,
      4,
      4,
      4,
      4,
      4,
      8,
      8,
      8
    ],
    [
      8,
      8,
      8,
      0,
      1,
      0,
      0,
      1,
      0,
      8,
      8,
      8,
      8,
      4,
      0,
      4,
      0,
      4,
      0,
      8,
      8,
      8
    ],
    [
      8,
      8,
      8,
      1,
      0,
      1,
      1,
      0,
      1,
      8,
      8,
      8,
      8,
      4,
      4,
      4,
      4,
      4,
      4,
      8,
      8,
      8
    ],
    [
      8,
      8,
      8,
      1,
      1,
      0,
      1,
      1,
      0,
      8,
      8,
      8,
      8,
      4,
      0,
      4,
      0,
      4,
      0,
      8,
      8,
      8
    ],
    [
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      4,
      4,
      4,
      4,
      4,
      4,
      8,
      8,
      8
    ],
    [
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8
    ],
    [
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8
    ],
    [
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8
    ],
    [
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8
    ],
    [
      8,
      8,
      8,
      3,
      0,
      3,
      3,
      3,
      0,
      3,
      3,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8
    ],
    [
      8,
      8,
      8,
      0,
      3,
      0,
      3,
      0,
      3,
      0,
      3,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8
    ],
    [
      8,
      8,
      8,
      3,
      3,
      0,
      3,
      3,
      3,
      0,
      3,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8
    ],
    [
      8,
      8,
      8,
      3,
      0,
      3,
      3,
      3,
      0,
      3,
      3,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8
    ],
    [
      8,
      8,
      8,
      0,
      3,
      0,
      3,
      0,
      3,
      0,
      3,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8
    ],
    [
      8,
      8,
      8,
      3,
      3,
      0,
      3,
      3,
      3,
      0,
      3,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8
    ],
    [
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8
    ],
    [
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8
    ],
    [
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8
    ],
    [
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8
    ]
  ],
  "api_success": true,
  "multiturn_data": {
    "turn_details": [
      {
        "turn_number": 1,
        "timestamp": "2025-07-10T19:13:28.089277",
        "input_tokens": 7888,
        "output_tokens": 1062,
        "turn_cost": 0.024272,
        "program_extracted": true,
        "program": "import numpy as np\nfrom collections import deque\n\ndef transform(grid):\n    grid = np.array(grid)\n    H, W = grid.shape\n    output = np.array(grid)  # Start with a copy\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    background = 6  # blue\n\n    # Directions: 4-connected\n    dirs = [(-1,0),(1,0),(0,-1),(0,1)]\n    \n    def in_bounds(r, c):\n        return 0 <= r < H and 0 <= c < W\n\n    # Floodfill for connected component\n    def floodfill(sr, sc):\n        q = deque()\n        q.append((sr, sc))\n        component = []\n        visited[sr, sc] = True\n        while q:\n            r, c = q.popleft()\n            component.append((r, c))\n            for dr, dc in dirs:\n                nr, nc = r+dr, c+dc\n                if in_bounds(nr, nc) and not visited[nr, nc]:\n                    # Only travel through non-background (non-blue) cells\n                    if grid[nr, nc] != background:\n                        visited[nr, nc] = True\n                        q.append((nr, nc))\n        return component\n\n    # Process all non-background cells\n    for r in range(H):\n        for c in range(W):\n            if not visited[r, c] and grid[r, c] != background:\n                comp = floodfill(r, c)\n                # bounding box\n                rs = [p[0] for p in comp]\n                cs = [p[1] for p in comp]\n                rmin, rmax = min(rs), max(rs)\n                cmin, cmax = min(cs), max(cs)\n                # Find the dominant color (ignoring black 0)\n                colors = [grid[p] for p in comp if grid[p] != 0]\n                if colors:\n                    # There might be more than one, but observation is only 1 significant color per region\n                    signal_color = max(colors, key=colors.count)\n                else:\n                    signal_color = 0  # fallback, shouldn't happen\n                # Fill bounding box with checker of color+black\n                for rr in range(rmin, rmax+1):\n                    for cc in range(cmin, cmax+1):\n                        if (rr+cc)%2==0:\n                            output[rr,cc] = signal_color\n                        else:\n                            output[rr,cc] = 0  # black\n    return output.tolist()",
        "training_feedback": {
          "feedback_messages": [
            {
              "type": "input_text",
              "text": "Training results: 0/3 examples solved, 39.4% pixel accuracy - Good partial progress! Your approach is capturing some patterns. Next, try to identify a transformation that solves at least one of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 2, 2, 2, 2, 2, 2, 8, 8, 8, 8, 8], [8, 8, 0, 2, 2, 0, 2, 2, 8, 8, 8, 8, 8], [8, 8, 2, 0, 2, 2, 0, 2, 8, 8, 8, 8, 8], [8, 8, 2, 2, 2, 2, 2, 2, 8, 8, 8, 8, 8], [8, 8, 0, 2, 2, 0, 2, 2, 8, 8, 8, 8, 8], [8, 8, 2, 0, 2, 2, 0, 2, 8, 8, 8, 8, 8], [8, 8, 2, 2, 2, 2, 2, 2, 8, 8, 8, 8, 8], [8, 8, 0, 2, 2, 0, 2, 2, 8, 8, 8, 8, 8], [8, 8, 2, 0, 2, 2, 0, 2, 8, 8, 8, 8, 8], [8, 8, 2, 2, 2, 2, 2, 2, 8, 8, 8, 8, 8], [8, 8, 0, 2, 2, 0, 2, 2, 8, 8, 8, 8, 8], [8, 8, 2, 0, 2, 2, 0, 2, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8]]\nYour output: [[8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8], [0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0], [8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8], [0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0], [8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8], [0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0], [8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8], [0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0], [8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8], [0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0], [8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8], [0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0], [8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8], [0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0], [8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8], [0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0], [8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8], [0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0], [8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8]]\nPixel accuracy: 38.9%\n\nTraining Example 2 \u2717:\nExpected: [[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 1, 1, 1, 1, 1, 1, 1, 1, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 1, 0, 1, 0, 1, 0, 1, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 1, 1, 1, 1, 1, 1, 1, 1, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 1, 0, 1, 0, 1, 0, 1, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 1, 1, 1, 1, 1, 1, 1, 1, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 1, 0, 1, 0, 1, 0, 1, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 0, 3, 0, 0, 3, 0, 0, 3, 0, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 3, 0, 3, 3, 0, 3, 3, 0, 3, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 0, 3, 0, 0, 3, 0, 0, 3, 0, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 3, 0, 3, 3, 0, 3, 3, 0, 3, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8]]\nYour output: [[8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8], [0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0], [8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8], [0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0], [8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8], [0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0], [8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8], [0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0], [8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8], [0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0], [8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8], [0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0], [8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8], [0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0], [8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8], [0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0], [8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8], [0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0], [8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8], [0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0], [8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8], [0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0], [8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8]]\nPixel accuracy: 40.5%\n\nTraining Example 3 \u2717:\nExpected: [[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 0, 2, 0, 2, 0, 0, 2, 0, 2, 0, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 2, 2, 0, 2, 2, 2, 2, 0, 2, 2, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 0, 2, 2, 2, 0, 0, 2, 2, 2, 0, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 0, 2, 0, 2, 0, 0, 2, 0, 2, 0, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 2, 2, 0, 2, 2, 2, 2, 0, 2, 2, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 0, 2, 2, 2, 0, 0, 2, 2, 2, 0, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 0, 2, 0, 2, 0, 0, 2, 0, 2, 0, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 2, 2, 0, 2, 2, 2, 2, 0, 2, 2, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 0, 2, 2, 2, 0, 0, 2, 2, 2, 0, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 8, 8, 8], [8, 8, 8, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 8, 8, 8], [8, 8, 8, 4, 0, 4, 4, 0, 4, 4, 0, 4, 4, 0, 4, 4, 0, 4, 8, 8, 8], [8, 8, 8, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 8, 8, 8], [8, 8, 8, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 8, 8, 8], [8, 8, 8, 4, 0, 4, 4, 0, 4, 4, 0, 4, 4, 0, 4, 4, 0, 4, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8]]\nYour output: [[8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8], [0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0], [8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8], [0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0], [8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8], [0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0], [8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8], [0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0], [8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8], [0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0], [8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8], [0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0], [8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8], [0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0], [8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8], [0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0], [8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8], [0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0], [8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8], [0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0], [8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8], [0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0], [8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8], [0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0]]\nPixel accuracy: 38.7%\n\n"
            },
            {
              "type": "input_image",
              "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA88AAAX1CAIAAACz2H9lAABau0lEQVR4nO3de7hUBb3w8TW42YiCoGgqAscLivZw3Jp3U9PgfVLwMiu0jqUm4bXQAt2a5+XkqTDNzdGTl6w3BO/pyZzRjIw8IWVeMuXg3YOKhoAeRUER5CLrfWo/Lw8vCsHM/u21Z/bn8/QHbuY3vzXDzOLbuPa2kGVZAgAABOgScacAAIDaBgCAQGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAoEPW9ujRowvrdtJJJ33sbRobG7fbbrtjjz32iSee+Oh9/va3vy0UCltttdUHH3yw1m/deeedhUJh4sSJrf946qmnFgqFlpaWtW722muvFQqFcePGVTPV6oMPPvjJT35yxBFH9O3bt1u3bn379j3hhBP+8Ic/rOc5GTdu3LqekKeffnr9T9rQoUP/7hO7+jannXbaml9vPbwRI0Y8/PDDax5PsVhc62Y77bTTueee+84772zUk9/qrbfeGj9+/N57792rV6/NN998//33nzhxYpZla61ba/zxxx/fZpttevbsOW3atPU8dQAA9SeHz7ZXrFjxxhtv/PKXvzziiCNefvnltX530qRJSZK88847d9xxx4bc27e//e3nn39+Y49hQ6ZeeeWVgw466KyzznrggQfmz5+/fPny+fPn33nnnYcddtgVV1yRdDCth3fXXXcdcsght95663pu9sorr1x99dVHHnnkqlWrNurJf/jhh5uamv7lX/7lv/7rv959990lS5Y89thjp59++qhRo9ZzYL/73e+OOOKIDz/88P777z/iiCOqeIgAAJ2stq+55prs//n5z3+eJMnkyZNXf+WWW25ZfcvZs2ev/voHH3zw3HPPfelLX3r33Xevu+66Ne9w4cKF5XL5hBNO2GqrrX784x9vyDEsX7781FNP/fDDDzfqyP/u1IoVK44//vj/+q//Ovjgg++555633nprxYoVf/nLX370ox9ttdVWF1xwQesH1esyY8aM7CMGDx78sU/Iavfff/+ad7Iht5k/f37r15cuXfriiy9+61vfyrLsq1/96quvvrrmzZYuXbrmkz906NA//elPv/3tbzf8yf+f//mfNE3nzZt34oknPvLII+++++7bb79dLpd33nnnyZMn/+QnP/nY56FUKg0bNmyzzTZ74IEHDjjggPU8YwAAdSmHz7a7deu2++67/+AHP0iSZK3Ptm+77bYPPvjgzDPPHDly5COPPPLkk0/+3Xs755xzHn300X/7t3/bqGP4u1M33njj448/PnTo0N///vfHHHNMnz59Ghoa+vfvf/bZZ991110ffvjhz372s6Qj2XTTTXfZZZdLL73029/+9vLly//93/99PU/+N7/5zdZS3/An/4orrnjjjTfGjBlz2223HXDAAT179txyyy2PO+646dOnb7755ldcccWa15O0uv7660844YRPfOITf/jDH/bcc8/VX7/hhhsKhcI111zTpk8AAEBHlENtL1u27Jlnnhk7dmySJLvtttuavzV58uQ99tjjs5/97Nlnn73JJptsyMfb3//+9wcOHPjtb3/7ueee2/Bj+LtTt912W6FQ+D//5/9ssskma/3WZz7zmWeffXb8+PFJh3Teeedtttlmv/nNbz72d1esWPHf//3fV111VUNDw2c+85kNf/L/4z/+o3v37t/97nfXusN+/fo9+OCDDzzwQKFQWPPrl19++Wmnnbbzzjs/+OCDu+66a9s9PgCAWtJOtb3TTjut/ka9TTfddPDgwT//+c+33nrrb3zjG6tv8/TTT//5z39ubm4uFAq77LLLCSeccOutty5evHj997zZZptNnjx5xYoVG3U9yd+dmjFjxh577LHTTjt97Pgee+yxVlyuZe+9917ruxsffPDBdT0hqz3wwAMbe5uP6tmz56677rrWvzTo3r1763hjY+OgQYP++Mc/3njjjWs+uvU/+StWrHjllVf233//Hj16fHTjXnvttf3226/5lQsuuODCCy9MkuTQQw8dMGDAWrc/9dRTsywbPXr0+h8IAEAdyOcnAO6www5f/epXZ86cud12263+4qRJk3bYYYcvf/nLrf940UUXvffeextywcYhhxxy7rnn/ulPf5owYcKGH8N6plasWLFw4cJtt912zS+u9XNCdtxxx6Sj6tOnz7K/WdcNPvzww0ceeWTFihUb+OQvXLgwy7I+ffps4AFcffXVBx100NChQydNmnTXXXdV92gAAGpYO9V26zf8LV++/Pbbb2/98PWyyy7r27fv6husWLHilltumTt3brdu3VpztqmpKcuyDfxeye9///u77rrrxRdf/Oyzz274Ua1rqmvXrj179nzzzTeTSn30uyQPOeSQv/sdkIcffvjG3uZjvfPOO127du3WrdtHv0ty+fLlL7/88te//vWrr776/PPP38Anf6utturSpcuGPyEjR4584IEHbrrppq222ur000+fO3fuBg4CANSZdv1su2vXrl/84hfvuOOO6dOnH3nkkWv+VOZ77733Y2PuiSeeeOyxx/7uPXfv3r2C60nWM/WP//iPzz777F/+8peP/QEs++yzT9JRLV68+Omnn95jjz0+9ne7du260047TZgwYfDgwTfccMMGPvmbbLLJHnvs8ec//3nJkiUfvdmll156yimnzJs3b/VXfvSjHzU2Nm6//fbXXHPN22+/fcopp3z0pw0CAHQGOVxJctRRR51zzjlPPPHE6s9WW69k2HTTTRctWrTm57gPPfRQkiTr+ulya/n0pz/9jW9847HHHvvof7mmgqkvf/nLq1at+trXvvax7f7Rn7/RcVx55ZUrVqw48sgj13+zLl26LF68eOXKlRv45BeLxaVLl/7rv/7rWvfzyiuvXH755ffee+/HXmdy4oknHn/88b/73e826iIfAIC6kc9129///vcHDBhw3XXXPfroo0mSvP766/fdd98xxxyzxRZbrHmzgw46aNCgQT/72c8WLVq0IXd7ySWX7Lrrrj/60Y826mA+duq0007bZ599fvWrX+2///7/8R//8frrr69YsaL1v24zfPjwJ554okuXjvUfvV+2bNkLL7wwbty473znO5ttttm6vgcxy7LXXnutubn5ySef3HvvvRsaGjbwyR8zZkyfPn1aWlpOOeWUP//5z0uXLn3jjTduu+22ww8/fOHChc3NzWteuLKm6667bttttx03btzjjz8e89ABADqufJJx8803v/rqq1etWnXmmWeuXLnypptuWrly5epv0VvTV77ylSVLltx8880bfmXI+n9ayAZONTY2lsvlgw466IknnvjiF7+4/fbbNzY2tv6X26dMmTJo0KAN/E9drsvH/ryRQqGw5s9g2ZDbbL/99qt/0svuu+9+ySWXtP5n6vv377/WY2y9WZcuXfr37z9hwoQuXbq0/hDDDXzy+/Tpc8cdd/Ts2fPmm2/eb7/9Nttss+222+7LX/7yq6++mqbpBRdcsK5HuvXWW//0pz9dsWLFl770pffff9/P2wYAOpXcPqA99thji8XizJkz//3f//2GG27YcsstjzrqqI/e7JRTTunSpcsGXkzSemVI63+6ZaN87FS/fv3+8Ic/3HLLLcOGDevXr19jY+O22247bNiwG2+88emnn95vv/2SjqRr1679+/f/p3/6pz/+8Y8nnnjium62ySabfOITnxg+fPhvf/vb1qtNNvzJHzJkyIwZM84999zdd9+9R48e3bt3P+CAAyZOnPiLX/zioz+VfE3HHHPMqaee+t///d9r/sBHAIDOoNCRL0EGAICa1rEuPgYAgHqitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG2oGQsWLHj++efzPgro1LwNgY2ltqES/fr1K3zELbfcErp06NChjzzyyIbffsKECQceeOC6fnfhwoU777zzRt0hdBxbb7316rdeY2PjHnvscdVVV1V8b6vfLAsXLiwUCuvpaW9DYGOpbajQlVdemf3/TjrppNCNS5cubau7mjNnztChQ2fPnt1Wdwjt77rrrmt9673//vstLS3nn3/+zTffXOV99u7dO8uy3XfffV038DYENpbahrZ0/fXXd+vWbc6cOUmSvPnmm1tsscXkyZPfeuutQqFw/fXX9+vXr1evXqNGjVr9F/b8+fOPP/74Hj169O/ff+zYsau/Pnfu3DRNe/bsuc0223zta19btmzZ4Ycf/sILL4wcOfK0005bz+Azzzxz6KGHdu/e/eCDD17X3+K/+tWvBg8evM8++7TXswKxunbtevTRRw8ZMqRUKr3++uuFQuGiiy7q1avXqaeeurFvljU/2/Y2BNqE2oa2NGrUqEMOOeSyyy5LkuSSSy7Zd999R44c2fpbl19++X333TdjxozHH3989OjRrV8cMWJEz549X3nllenTpz/22GNjxoxJkuTDDz886qijGhsbX3rppYcffvipp566+OKLH3jggUGDBk2ePHnixInrGvzggw+GDRvW1NQ0b968iy66aPLkyR97kN26dbv//vuvvfbadnxiINzKlSt79OjR+uvnn3/+tdde++53v1vxm8XbEGgza/2rcGBD7LDDDmu9lTbZZJPW35o1a1bv3r2vuOKKXr16zZo1K8uyN998M0mSUqnUeoOpU6c2NjYuXrx4+vTpm2222bJly1q//thjj3Xp0mXp0qXTp09vbGxcsGDBWktb/5rPsmxdg+VyuVevXkuWLGn9+hlnnHHAAQes6yGsWLEiSZKHH3444OmBcH369Fl9JcnChQsnT57cpUuXe++9d/78+UmSTJkypfW3NvbN8s477yRJ8txzz3kbAm3FZ9vQNtdtr1y5svXrAwcObG5uHjt27HnnnTdw4MDVt1/9nVJ77bXX8uXLX3rppWeffXbJkiXdunVr/U6v/fbbb9WqVS+//PIzzzzTr1+/rbbaal2r1zX47LPP7rLLLt27d2+92d577x38HECezj777Na3wLbbbjthwoRrr712+PDhrb81YMCAKt8s3oZAW1Hb0PaefvrpJEmeeOKJNb/YtWvX1l98+OGHSZI0NDSsXLly4MCBa/0/4E9+8pNdu3YtFArruf91Da51s9UboS6t/mz7gw8+ePrpp88666zVv9WtW7cq3yzehkBbUdvQxn7961/fcccdLS0td999d7lcXv31J598svUXM2bM6NGjxy677LL77rvPnj37tddeW+sedttttzlz5rT+G+01rf67f12DgwcPnjVr1vvvv9/6j0899VRbPzioMRW/WbwNgbaitqEtLV68+Kyzzjr33HPPP//8008/ffTo0e+9917rb11wwQWzZ8+eNWvWhRdeeMYZZ3Tr1u2zn/3snnvuOXLkyDlz5sydO/eb3/zmgAEDli1bduihhw4ePPicc8556623XnnllREjRpx44olJkmy++ebz5s1777331jX4uc99bvvtt//GN77x9ttv33///ZMmTcr7+YCcVfxm8TYE2orahgqNGTNmrf+6zVlnnfXP//zPXbp0GT9+fJIkLS0tXbp0+ed//ufW2w8dOvSII4444IAD/tf/+l+tP7SkS5cu5XJ5880332OPPT75yU++8MILU6dObb0M9Be/+MXbb7/dv3//fffdd4sttvjJT36SJMlZZ5116aWXjhw5cl2DjY2Nv/71r1955ZUddthhzJgxp59+et5PEuSs4jeLtyHQVgpZlrXZnVFf0jTN+xDqxPLly6dMmTJk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G0ltA7Slvfbaa+7cuUmSLFu2bLfddrvqqqv23nvvT33qU1OnTs370KATiE5hqc3GU9sAben444+/5557kiSZNm3akUceOX78+N///ve33XbbLbfckvehQecQF8RSm4qobYC2dMIJJ9x9991Jkvzyl7/8whe+MGzYsFNOOWXOnDk33XRT3ocGnUZEFkttKqW2AdrSoEGDFixY8O67786YMePTn/70DTfcMGbMmOuuu27kyJF5Hxp0Jm0bx1KbKjRUMwzARx133HGXXXbZ/vvv/+677x577LH333//Pvvss/POO+d9XNDJZFlSKLTN/UAVCpnXEOuQpmnehwAdQqlU2qjbv/DCC3vuuee0adMOPvjglpaW22+/fdWqVaNGjRo9evRG3Y/3IFT2Hlxbxc2tkWgLapt1StO0qaXCE9zM5qpmS4vmVTab9uprdsNn8/rzrbnZfx2Y5CJN03K5XNlssVis5rmy194OtbdtWmWjmlsd0XZcSQIAdAKrA3o92S2yCaC2AYDORFLTvvxMEgAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAOrKkiVLvvjFLx5++OH77LPPr371qyRJ/vM///Pggw8+4ogjDj300Icffnj1LWfPnv25z33u8MMPP/roo994440kSS677LLBgwe3tLQkSbJq1arhw4cvXLgw10dDzVPbAEBdueaaa/bbb78HHnjg3nvv/frXv54kyahRo2699dZp06bdcMMNo0aNWn3LM84444ILLnjggQfGjBnzr//6r0mS/PCHP3zooYeuuOKKJEkmTpw4YsSI3r175/poqHmFLMvyPgY6qDRN8z4E6BBKpVIue70HobL34DvvvLP55ps3Njbef//9Z5999qxZs/bZZ5+f/OQn++6775/+9KcTTjjh1Vdfbb3lNtts8/rrr2+yySYffvjhJz/5yRdeeGHAgAG/+93vhgwZMmPGjJNPPvnee+8tFAoxD4vOoiHvA6BDa2qpMDJmNqfVzJbL5cpmi8ViadG8ymbTXn2rma3FY87rz7fmZnOU1/vIXns71N6NteWWWyZJcvLJJ99111333HNPkiQ//vGPDznkkF133XXWrFl33nnn6lvuueee99xzT5qmpVKp9UqSSy65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qG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKIUsy8LuHAAAOjWfbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdt0UgsWLHj++efzPgqAcE53kC+1Tf769etX+IhbbrkldOnQoUMfeeSRDb/9hAkTDjzwwI9+fdasWUcffXTv3r233377M8888913323TwwTqx9Zbb736FNfY2LjHHntcddVVFd/b6pPSwoULC4XCenra6Q7ypbbpEK688srs/3fSSSeFbly6dGn1d7JixYqjjz56xx13nD179h/+8IfHH3/8rLPOaoujA+rTdddd13qKe//991taWs4///ybb765yvvs3bt3lmW77777um7gdAf5Utt0XNdff323bt3mzJmTJMmbb765xRZbTJ48+a233ioUCtdff32/fv169eo1atSo1X+RzJ8///jjj+/Ro0f//v3Hjh27+utz585N07Rnz57bbLPN1772tWXLlh1++OEvvPDCyJEjTzvttPUMPvPMM4ceemj37t0PPvjg2bNnf/QIH3vssZdffvmKK67YcsstBw4cePHFF999991ZlrXjkwTUpK5dux599NFDhgwplUqvv/56oVC46KKLevXqdeqpp27sSWnNz7ad7qADUtt0XKNGjTrkkEMuu+yyJEkuueSSfffdd+TIka2/dfnll993330zZsx4/PHHR48e3frFESNG9OzZ85VXXpk+ffpjjz02ZsyYJEk+/PDDo446qrGx8aWXXnr44Yefeuqpiy+++IEHHhg0aNDkyZMnTpy4rsEPPvhg2LBhTU1N8+bNu+iiiyZPnvzRIzz44INXrFjR2NjY+o/z58/faqutCoVCOz5JQA1buXJljx49Wn/9/PPPv/baa9/97ncrPik53UEHtda/vof2t8MOO6z1stxkk01af2vWrFm9e/e+4oorevXqNWvWrCzL3nzzzSRJSqVS6w2mTp3a2Ni4ePHi6dOnb7bZZsuWLWv9+mOPPdalS5elS5dOnz69sbFxwYIFay1t/esny7J1DZbL5V69ei1ZsqT162ecccYBBxywnkexcOHCnXba6eKLL27rpweoE3369Fl9JcnChQsnT57cpUuXe++9d/78+UmSTJkypfW3Nvak9M477yRJ8txzzzndQcfks2064nXbK1eubP36wIEDm5ubx44de9555w0cOHD17Vd/B89ee+21fPnyl1566dlnn12yZEm3bt1avwNpv/32W7Vq1csvv/zMM8/069dvq622WtfqdQ0+++yzu+yyS/fu3Vtvtvfee6/n+N9///1jjjlm8ODB48aNa6OnBKhDZ599duupZtttt50wYcK11147fPjw1t8aMGBAlSclpzvomNQ2Hd3TTz+dJMkTTzyx5he7du3a+osPP/wwSZKGhoaVK1cOHDhwrf83+clPfrJr167r/3ed6xpc62arN37UggULhgwZ0q9fvzvvvLOhoaG6hwvUs9WfbX/wwQdPP/30mt9o2K1btypPSk530DGpbTq0X//613fccUdLS8vdd99dLpdXf/3JJ59s/cWMGTN69Oixyy677L777rNnz37ttdfWuofddtttzpw5rf+mdU2r/05a1+DgwYNnzZr1/vvvt/7jU0899bFH+Nprrx1yyCGHHXbYrbfeuvqKRoCKVXxScrqDjklt03EtXrz4rLPOOvfcc88///zTTz999OjR7733XutvXXDBBbNnz541a9aFF154xhlndOvW7bOf/eyee+45cuTIOXPmzJ0795vf/OaAAQOWLVt26KGHDh48+JxzznnrrbdeeeWVESNGnHjiiUmSbL755vPmzXvvvffWNfi5z31u++23/8Y3vvH222/ff//9kyZN+ugRLly48LOf/eyxxx57+eWX+24hoE1UfFJyuoMOqo2u/4a2/C7JJEnOPPPMc845Z8cdd1y8eHGWZYsWLerfv//o0aNbv0vyW9/61j/8wz9sueWWY8eOXb58eev9vPrqq8cdd9zmm2++xRZbHHnkkc8991zr12fPnn3UUUdtuummffr0OfXUUxctWpRl2U9/+tMePXqMGDFiPYMvvfTSkCFDNt1008GDB48d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Dx566KGXXnrp6tu8/vrrF1xwwQN/M378+CRJfvjDHz700ENXXHFFkiQTJ04cMWJE7969kzpVyLIsqTVpmuZ9CEAnUiqVctnrXAd0/HPd17/+9c985jNnnHHGwoULBw8ePHXq1L59+86dO/fII4986qmnWm9z+eWXDxo06Ljjjls9NWDAgN/97ndDhgyZMWPGySeffO+99xYKhaRONSS1qamlwr/8ZjanZs2aNVsrqnm85XK5stlisWivvfZ2wr0VePDBB+fNm/eFL3zhjDPOSJLkjTfe2G677ZIk2X777d94443VN5s/f/6LL77Y0tKy1VZbXXnllbvssssll1xy0kknXXrppePGjfvOd75Tx6ntShIAACqxbNmy888//9prr/27tywUCk1NTQ8++OCpp556+umnJ0ly8sknP/LII4MGDUqS5OWXXx4+fPidd96Z1Kla/WwbAIAc/eIXv3jvvfe+9KUvJUmyePHiU045Zdttt3399df79u07f/78bbfddvUtzz333P79+ydJctxxx5155pmtX8yy7Nvf/vZNN920zz77PPLIIwcffPDxxx+f1COfbQMAsNG+9KUvPfPMM63f+9ijR4+bbrpp2LBht99+e5Ikt99++7Bhw1orPEmSb33rW/fee2+SJI8++ug//uM/to5PmjTpmGOO6dOnz9KlS7MsW7JkSVKnfLYNAEAb+N//+39/5Stfueuuu7beeusbb7wxSZLPf/7zU6dO/d73vjdy5Mgrr7xy0003/elPf5okycKFC3/+859PmTIlSZIxY8YMHTr0vPPOS+qU2gYAoCqtPy27V69ea31/59SpU5Mk2XXXXR988ME1v967d+/77ruv9dff+pukfrmSBAAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAohSyLEtqTZqmeR8C0ImUSqVc9jrXAZ3hXFf3GpLa1NRS4QtiZnNqtn1my+VyZbPFYvHlcQsrm915fO9q9jrm9jnmmns95yiv59lee+3thHsJ4koSAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACBKIcuypNakaZr3IQCdSKlUymWvcx3QGc51da8hqU1NLRW+IGY2p2bbZ/blcQsrm915fO9yuVzZbLFYrGavY26fY66513OOqnm81fz52muvvZ1wL0FcSQIAAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARClkWZbUmjRN8z4EoBMplUq57HWuAzrDua7uNSS1qamlwhfEzObUbPvMvjxuYWWzO4/vbba+Z2vu9Zyjcrlc2WCxWKzmubLXXns74V6CuJIEAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIhSyLIsqTVpmuZ9CEAnUiqVctnrXAd0hnNd3WtIalNTS4UviJnNqdn2mS2Xy5XNFovFl8ctrGx25/G9q9nrmNvnmGvu9ZyjvN6D9tprbyfcSxBXkgAAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUQpZliW1Jk3TvA8B6ERKpVIue53rgM5wrqt7DXkfQIWaWip8QcxsTs22z+zL4xZWNrvz+N7lcrmy2WKxWM1ex9w+x1xzr+ccVfNnVM1zZa+99nbCvQRxJQkAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEKWQZVlSa9I0zfsQgE6kVCrlste5DugM57q615DUpqaWCl8QM5tTs+0z+/K4hZXN7jy+t9n6nq2513OOqnm85XK5stlisWivvfZ2wr0EcSUJAABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABClkGVZUmvSNM37EIBOpFQq5bLXuQ7oDOe6uteQ1KamlgpfEDObU7NmzZqtFeVyubLBYrFYzXNlr732dsK9BHElCQAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQpZBlWVJr0jTN+xCATqRUKuWy17kO6AznurrXkNSmppYKXxAzm1OzZs2arRXVPN5yuVzZbLFYtNdeezvhXoK4kgQAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiKK2AQAgitoGAIAoahsAAKKobQAAiFLIsiypNWma5n0IQCdSKpVy2etcB3SGc13da0hqU1NLhS+Imc2pWbNmzdaKcrlc2WCxWKzmubLXXns74V6CuJIEAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIhSyLIsqTVpmuZ9CEAnUiqVctnrXAd0hnNd3WtIalNTS4UviJnNqVmzZs3Wimoeb7lcrmy2WCzaa6+9nXAvQVxJAgAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEUdsAABBFbQMAQBS1DQAAUdQ2AABEKWRZFnbnAADQqflsGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2qaGLViw4Pnnn8/7KADqltMsVE9t0zb69etX+IhbbrkldOnQoUMfeeSRDb/9hAkTDjzwwI9+/Y033jj++OO32GKL/v37jx8/vk2PEaANbL311qtPrY2NjXvsscdVV11V8b2tPhkuXLiwUCisp6edZqF6DW1wH/A3V1555Te/+c323Lh06dI2uZ8vfelLAwYMmDNnzqxZs4466qjtttvutNNOa5N7Bmgr11133VlnnZUkyYoVK37zm998/vOf33LLLU8++eRq7rN3795Zlq3nBk6zUD2fbRPr+uuv79at25w5c5IkefPNN7fYYovJkye/9dZbhULh+uuv79evX69evUaNGrX6hD5//vzjjz++R48e/fv3Hzt27Oqvz507N03Tnj17brPNNl/72teWLVt2+OGHv/DCCyNHjmw9Za9r8Jlnnjn00EO7d+9+8MEHz549+6NH+NJLL02bNm3ChAm9evXad999jzjiiIceeqgdnyGAjdO1a9ejjz56yJAhpVLp9ddfLxQKF110Ua9evU499dSNPRmu+dm20ywEUdvEGjVq1CGHHHLZZZclSXLJJZfsu+++I0eObP2tyy+//L777psxY8bjjz8+evTo1i+OGDGiZ8+er7zyyvTp0x977LExY8YkSfLhhx8eddRRjY2NL7300sMPP/zUU09dfPHFDzzwwKBBgyZPnjxx4sR1DX7wwQfDhg1ramqaN2/eRRddNHny5I8e4S677LJq1ao+ffqsXLnyP/8mTdP2fZIANtrKlSt79OjR+uvnn3/+tdde++53v1vxydBpFgJl0BZ22GGHtV5am2yySetvzZo1q3fv3ldccUWvXr1mzZqVZdmbb76ZJEmpVGq9wdSpUxsbGxcvXjx9+vTNNtts2bJlrV9/7LHHunTpsnTp0unTpzc2Ni5YsGCtpa1/DWRZtq7Bcrncq1evJUuWtH79jDPOOOCAA9b1EAYNGtStW7fDDz/8zTffDHiGACrXp0+f6667rvXXCxcunDx5cpcuXe6999758+cnSTJlypTW39rYk+E777yTJMlzzz3nNAtxfLZNm7nyyivXfG2tXLmy9esDBw5sbm4eO3bseeedN3DgwNW3X/2dNHvttdfy5ctfeumlZ599dsmSJd26dWv9TqD99ttv1apVL7/88jPPPNOvX7+tttpqXavXNfjss8/usssu3bt3b73Z3nvvvZ7jf/755xcsWLDZZpsdffTRbfSUALSZs88+u/UUt+22206YMOHaa68dPnx4628NGDCgypOh0yzEUdu0h6effjpJkieeeGLNL3bt2rX1Fx9++OFfv2O3oWHlypUDBw5c6/8RfvKTn+zatWuhUFjP/a9rcK2brd64Lptvvvm4ceMeffTRefPmVfpYAUKs/mz7gw8+ePrpp1u/Y7JVt27dqjwZOs1CHLVNuF//+td33HFHS0vL3XffXS6XV3/9ySefbP3FjBkzevToscsuu+y+++6zZ89+7bXX1rqH3Xbbbc6cOa3/xnNNq/9uWNfg4MGDZ82a9f7777f+41NPPfXRw7vvvvt69eq1bNmy1n98++23N9lkk969e1f3oAFyUPHJ0GkW4qhtYi1evPiss84699xzzz///NNPP3306NHvvfde629dcMEFs2fPnjVr1oUXXnjGGWd069bts5/97J577jly5Mg5c+bMnTv3m9/85oABA5YtW3booYcOHjz4nHPOeeutt1555ZURI0aceOKJrZ+RzJs377333lvX4Oc+97ntt9/+G9/4xttvv33//fdPmjTpo0d4+OGHb7fddmPHjl20aNGTTz7Z3Nw8cuTIzTbbrN2fKoBqVXwydJqFQG10/Ted3Ue/SzJJkjPPPPOcc87ZcccdFy9enGXZokWL+vfvP3r06NbvkvzWt771D//wD1tuueXYsWOXL1/eej+vvvrqcccdt/nmm2+xxRZHHnnkc8891/r12bNnH3XUUZtuummfPn1OPfXURYsWZVn205/+tEePHiNGjFjP4EsvvTRkyJBNN9108ODBY8eO/dhv33nxxReHDRu2xRZbDBgw4KKLLlq6dGk7PnMAG/ddkmtq/S7J1m9Ab7VRJ8PV3yXpNAtxCuv/sfbr5yf4UJnly5dPmTJlyJAhPXv2zPtY4O8rlUq57HWOBTqDUk7n2Jr5b0k2tVT4BM1sTs122tkl77w1Zco2u19wzdY7796ee82aTWpNNY93zW+T2CjFYtFee+21t9321j3XbQMAQEf9bBsqsNmWW188q/JLmAAAaoXPtgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIhSyLKs4uE0Tdv0YAA6olKplMte51igMyjldI5tNw1Vzje1VPgEzWxOzZo1a7YmZnNULpcrGywWi9U8V/baa6+97ba37rmSBAAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIUsiyrOLhNE3b9GAAOqJSqZTLXudYoDMo5XSObTcNVc43tVT4BM1sTs2aNWu2JmZzVM3jLZfLlc0Wi0V77bXX3nbbW/dcSQIAAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARFHbAAAQRW0DAEAUtQ0AAFHUNgAARClkWVbxcJqmbXowAB1RqVTKZa9zLNAZlHI6x7abhirnm1oqfIJmNqdmN3y2XC5XNlssFkuL5lU2m/bqW4t7a/GY89pbi++FXGZzlNefr7322mtvu+2te64kAQCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiFLIsq3g4TdM2PRiAjqhUKuWy1zkW6AxKOZ1j201DlfNNLRU+QTObU7MbPltaNK+y2bRX32pmy+VyZbPFYjGvY/ZcbfhsLb4XcpnNUTWPt5rXpL322mtvu+2te64kAQCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiFLIsq3g4TdM2PRiAjqhUKuWy1zkW6AxKOZ1j201DlfNNLRU+QTObU7MbPlsulyubLRaLpUXzKptNe/XNa7aax+u52kDFYrEW3wu5zOYorz9fe+21195221v3XEkCAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAERR2wAAEEVtAwBAFLUNAABR1DYAAEQpZFlW8XCapm16MAAdUalUymWvcyzQGZRyOse2m4Yq55taKnyCZjanZjd8tlwuVzZbLBZLi+ZVNpv26luLe2vxmPPaW4vvhVxmc5TXecNee+21t9321j1XkgAAQBS1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Bg0a1NzcPHHixBEjRvTu3Tv6gNU2AAA14/TTT998882TJHnmmWe6du2aJEmfPn0WLFiw0047LViw4P3331/r9lmWXXvttb/5zW+SJOnatev//M//NDY2vv3223ffffe9997bDgestgEAqBlbbrllkiQnn3zyXXfddc899yRJ8uMf//iQQw7ZddddZ82adeedd651+1/+8pf77bffJz7xiSRJLrnkkpNOOunSSy8dN27cd77znUKh0A4H7LptAABqzM0333zbbbfdeOONSZKcf/75t95661NPPXXzzTffdddda93y3/7t384777zWX5988smPPPLIoEGDkiR5+eWXhw8f/tE6b3NqGwCAmnHOOeesXLkySZKjjz669bskn3rqqTRNkyT5/Oc/3/pp92qPPvpo7969W/O6VZZl3/72t7/3ve9dcMEF119//QUXXBB9wGobAICasWjRonK5nCTJQw891JrRgwYN+uMf/5gkycMPP7zjjjsmSbJ48eLWG19++eWrP9huNWnSpGOOOaZPnz5Lly7NsmzJkiXRB+y6bQAAasb48eO/8pWvXH311Y2NjZMmTWq9bvvcc89NkqRQKEycOLH1Q+6pU6e++OKL8+bNO+yww1bPLly48Oc///mUKVOSJBkzZszQoUPXavEIahsAgJoxYMCAadOmrfmVpqam6dOnr/mVqVOnJkkycODANX/8dpIkvXv3vu+++1p//a2/aYcDdiUJAABEUdsAABBFbQMAQJRClmUVD7f+sBWA+lYqlXLZ6xwLdAalnM6x7aba75JsaqnwCZrZnJo1a9ZsTczmqPWnXFWgWCxW81zZa6+99rbb3rrnShIAAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIIraBgCAKGobAACiqG0AAIiitgEAIEohy7KKh9M0bdODAeiISqVSLnudY4HOoJTTObbdNFQ539RS4RM0sznNa7Y0oVzZbHp+0axZs9XP1tx5I0fVPN5yucI/o2Kxqj8je+21117W5EoSAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYBACCK2gYAgChqGwAAoqhtAACIorYB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"
            },
            {
              "type": "input_text",
              "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
            }
          ],
          "solved_count": 0,
          "total_training_examples": 3,
          "pixel_accuracy": 0.3939393939393939
        },
        "test_result": {
          "correct": false,
          "pixel_accuracy": 0.40384615384615385,
          "total_pixels": 572,
          "correct_pixels": 231,
          "error": null
        },
        "status": "failed_test"
      }
    ],
    "total_turns": 1,
    "conversation_history": [
      {
        "role": "system",
        "content": "You are an expert at solving abstract reasoning puzzles. Write clean, efficient Python code."
      },
      {
        "role": "user",
        "content": [
          {
            "type": "input_text",
            "text": "You are solving an ARC (Abstraction and Reasoning Corpus) task. \nI will show you training examples with input and output grids, plus a test input grid. Your task is to:\n\n1. **Analyze the training examples** to discover patterns that map input grids to output grids\n2. **Write a Python program** that implements your best understanding of the transformation  \n3. **DO NOT predict or generate the test output** - your job is only to write the transformation program\n4. **Attempt a solution** - even if the pattern isn't completely clear, provide your best hypothesis\n5. **Do not repeat the same transformation** - if you have already tried a transformation, do not repeat it.\n\n**IMPORTANT: Your transformation must always produce a 19\u00d713 output grid.**\n\nThe test input is shown for context so you understand what type of grid your program will eventually process. Focus on learning patterns from training examples and writing code that captures your understanding.\n\nTraining Examples:\n\nExample 1:\nInput:\n8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 2 2 2 0 0 0 8 8 8 8 8\n8 8 0 2 2 0 0 0 8 8 8 8 8\n8 8 2 0 2 0 0 0 8 8 8 8 8\n8 8 0 0 0 0 0 0 8 8 8 8 8\n8 8 0 0 0 0 0 0 8 8 8 8 8\n8 8 0 0 0 0 0 0 8 8 8 8 8\n8 8 0 0 0 0 0 0 8 8 8 8 8\n8 8 0 0 0 0 0 0 8 8 8 8 8\n8 8 0 0 0 0 0 0 8 8 8 8 8\n8 8 0 0 0 0 0 0 8 8 8 8 8\n8 8 0 0 0 0 0 0 8 8 8 8 8\n8 8 0 0 0 0 0 0 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8\nOutput:\n8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 2 2 2 2 2 2 8 8 8 8 8\n8 8 0 2 2 0 2 2 8 8 8 8 8\n8 8 2 0 2 2 0 2 8 8 8 8 8\n8 8 2 2 2 2 2 2 8 8 8 8 8\n8 8 0 2 2 0 2 2 8 8 8 8 8\n8 8 2 0 2 2 0 2 8 8 8 8 8\n8 8 2 2 2 2 2 2 8 8 8 8 8\n8 8 0 2 2 0 2 2 8 8 8 8 8\n8 8 2 0 2 2 0 2 8 8 8 8 8\n8 8 2 2 2 2 2 2 8 8 8 8 8\n8 8 0 2 2 0 2 2 8 8 8 8 8\n8 8 2 0 2 2 0 2 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8\n\nExample 2:\nInput:\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 1 1 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8\n8 8 1 0 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8\n8 8 0 0 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8\n8 8 0 0 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8\n8 8 0 0 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8\n8 8 0 0 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 8 8 8\n8 8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 8 8 8\n8 8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 8 8 8\n8 8 8 8 8 8 8 0 0 0 0 0 0 0 3 0 8 8 8\n8 8 8 8 8 8 8 0 0 0 0 0 0 3 0 3 8 8 8\n8 8 8 8 8 8 8 0 0 0 0 0 0 3 3 3 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\nOutput:\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 1 1 1 1 1 1 1 1 8 8 8 8 8 8 8 8 8\n8 8 1 0 1 0 1 0 1 0 8 8 8 8 8 8 8 8 8\n8 8 1 1 1 1 1 1 1 1 8 8 8 8 8 8 8 8 8\n8 8 1 0 1 0 1 0 1 0 8 8 8 8 8 8 8 8 8\n8 8 1 1 1 1 1 1 1 1 8 8 8 8 8 8 8 8 8\n8 8 1 0 1 0 1 0 1 0 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 0 3 0 0 3 0 0 3 0 8 8 8\n8 8 8 8 8 8 8 3 0 3 3 0 3 3 0 3 8 8 8\n8 8 8 8 8 8 8 3 3 3 3 3 3 3 3 3 8 8 8\n8 8 8 8 8 8 8 0 3 0 0 3 0 0 3 0 8 8 8\n8 8 8 8 8 8 8 3 0 3 3 0 3 3 0 3 8 8 8\n8 8 8 8 8 8 8 3 3 3 3 3 3 3 3 3 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n\nExample 3:\nInput:\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 0 0 0 0 0 0 2 0 2 0 8 8 8 8 8\n8 8 8 8 8 8 0 0 0 0 0 2 2 0 2 2 8 8 8 8 8\n8 8 8 8 8 8 0 0 0 0 0 0 2 2 2 0 8 8 8 8 8\n8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0 8 8 8 8 8\n8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0 8 8 8 8 8\n8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0 8 8 8 8 8\n8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0 8 8 8 8 8\n8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0 8 8 8 8 8\n8 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8\n8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8\n8 8 8 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8\n8 8 8 4 4 4 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8\n8 8 8 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8\n8 8 8 4 0 4 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\nOutput:\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 0 2 0 2 0 0 2 0 2 0 8 8 8 8 8\n8 8 8 8 8 8 2 2 0 2 2 2 2 0 2 2 8 8 8 8 8\n8 8 8 8 8 8 0 2 2 2 0 0 2 2 2 0 8 8 8 8 8\n8 8 8 8 8 8 0 2 0 2 0 0 2 0 2 0 8 8 8 8 8\n8 8 8 8 8 8 2 2 0 2 2 2 2 0 2 2 8 8 8 8 8\n8 8 8 8 8 8 0 2 2 2 0 0 2 2 2 0 8 8 8 8 8\n8 8 8 8 8 8 0 2 0 2 0 0 2 0 2 0 8 8 8 8 8\n8 8 8 8 8 8 2 2 0 2 2 2 2 0 2 2 8 8 8 8 8\n8 8 8 8 8 8 0 2 2 2 0 0 2 2 2 0 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 8 8 8\n8 8 8 0 4 0 0 4 0 0 4 0 0 4 0 0 4 0 8 8 8\n8 8 8 4 0 4 4 0 4 4 0 4 4 0 4 4 0 4 8 8 8\n8 8 8 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 8 8 8\n8 8 8 0 4 0 0 4 0 0 4 0 0 4 0 0 4 0 8 8 8\n8 8 8 4 0 4 4 0 4 4 0 4 4 0 4 4 0 4 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n\nTest Input:\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 0 0 0 0 1 0 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 0 0 0 1 0 1 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 0 0 0 1 1 0 8 8 8 8 0 0 0 0 0 0 8 8 8\n8 8 8 0 0 0 0 0 0 8 8 8 8 0 0 0 0 0 0 8 8 8\n8 8 8 0 0 0 0 0 0 8 8 8 8 0 0 0 0 0 0 8 8 8\n8 8 8 0 0 0 0 0 0 8 8 8 8 0 0 0 0 0 0 8 8 8\n8 8 8 0 0 0 0 0 0 8 8 8 8 0 0 0 0 0 0 8 8 8\n8 8 8 0 0 0 0 0 0 8 8 8 8 0 0 0 0 0 0 8 8 8\n8 8 8 0 0 0 0 0 0 8 8 8 8 4 0 0 0 0 0 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 4 4 0 0 0 0 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 0 0 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 0 0 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 0 0 0 0 0 0 0 0 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 0 0 0 0 3 0 3 3 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 0 0 0 0 0 3 0 3 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 0 0 0 0 3 3 0 3 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n\nAnalyze the patterns in the training examples and write a Python function that performs this transformation.\n\n**Approach Guidelines:**\n- Look for patterns in shapes, colors, positions, sizes, rotations, reflections, etc.\n- Even if you can't solve all training examples perfectly, implement what patterns you do observe\n- A partial solution that captures some aspects is better than returning the input unchanged\n- If the pattern is unclear, make your best educated guess based on what you can see\n\nRequirements:\n- The function takes a 2D list (grid) where grid[row][col] gives the value at that position\n- Values are integers from 0-9\n- Return a new grid (2D list) with the transformation applied\n- You can use numpy if needed - just add 'import numpy as np' at the start of your function\n- Aim to handle the training examples as well as possible, even if not perfectly\n- Your function should attempt some meaningful transformation based on the patterns you observe\n\nYou MUST end your response with the following exact format:\n\nFinal answer:\n```python\ndef transform(grid):\n    # Your transformation logic here (implement your best understanding)\n    return transformed_grid\n```\n"
          },
          {
            "type": "input_image",
            "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA6wAAAg+CAIAAACT8E+hAABex0lEQVR4nO3dfZRcdZ3g/yookpAQEhBHSFCSTlzAjRaI8iQzggk6I4J1d1BU2DWRCMyImlU67HhQdxURaGZcR1BhIxGNosBy64xjDjvGWRR3RkXARgmBgEEegmKARB4Mebq/s9Nn++QXHmxuderWtz+v11+h0p/+fnNT98vb4ibWi6KoAQBAJLtUvQEAAOg2EQwAQDgiGACAcEQwAADhiGAAAMIRwQAAhCOCAQAIRwQDABCOCAYAIBwRDABAOCIYAIBwRDAAAOGIYAAAwukogs8+++z68zvttNOe82vGjRu37777nnTSSbfeeuuzv+f3vve9er2+9957b9y4cYefuu666+r1+pIlS4b+cf78+fV6fWBgYIcve/DBB+v1+nnnndfJ1JCNGzdefvnlxx133LRp08aPHz9t2rR3vOMdN910U7lrMm/evFqt9uijj06bNm2vvfZ68MEHd5j9D//hP4wbN+5nP/vZCC/Iu971rnq93mg0fve73z17J3PmzKnX6/Pnzx/6x4ULF26/mV133XXPPfc84ogjvvKVrwyPtFqter3+7IVG+Esbsm7dusWLFx900EG777771KlTjz766C996Utbt259gYsGADD2PwnevHnzb3/72+985zvHHXfcr371qx1+9sorr6zVao8//vi3v/3tkXy3T3ziE6tWrXqxexjJ1H333XfUUUedddZZN95448MPP7xp06aHH374uuuu+7M/+7O/+7u/q5X1kpe85Morr1y/fv2CBQuKohh+/bLLLsvz/IILLnjd6173oi7I1q1br7/++h1e/MUvfnHHHXe8wDa2bdv2xBNP/PSnP124cOHFF19cGyW/+93vXv/61w8MDNx1110bN27csGHDv/7rv/71X//1O97xju1/sQAACUfwpZdeWvw/1157ba1WW7p06fAry5YtG/7KNWvWDL++cePGO++88z3vec/vf//7L33pS9t/w/Xr17fb7Xe84x177733l7/85ZHsYdOmTfPnz3+xHzT+0anNmzeffPLJP//5z48++uh/+Id/WLdu3ebNm++///4vfvGLe++99+LFi3/5y1++wPff/tc7bMWKFUM/++d//ucf+MAHVqxYcemllw69Mjg4+NGPfvTNb37zRz/60Rd1QXbdddcDDzzwmmuu2eH1b33rW//+3//7Z3/9ww8/PLSZbdu2Pfnkk9/85jcnTJjwmc985plnnnnBCzbSX9rf//3f33fffSeffPLg4OBTTz21fv36f/7nfz700EPzPP/Od74zwiUAAMbgJ8Hjx48/6KCDLrroolqttsMnwd/85jc3btx45plnLliw4Mc//vHtt9/+R7/bBz/4wZ/85Cd/+7d/+6L28EenrrrqqltuuWXevHk//OEPTzzxxJe85CWNRuPlL3/5X/3VX11//fVbt269+uqrax0YGBg46KCDzj333LvuuuvJJ5985zvfOWXKlK997Wv1ev3FXpB3vvOdP/jBDx555JHtX/z2t799yimnvMAG6vX6pEmT3v3ud7/rXe/6/e9/f/fdd9dGw6pVqxqNxrJly17zmtdMnDhxypQpxx133NAH1TfccMPQ13z1q1+t1+vD/wMAACBEBD/zzDN33HHHRz7ykVqt9u/+3b/b/qeWLl168MEHv+lNb/qrv/qrXXfddSQfBl9wwQWzZ8/+xCc+ceedd458D3906pvf/Ga9Xr/iiit23XXXHX7qjW9848qVK88///xaB3bfffdvfOMbW7ZsOe20084666zVq1d/7Wtfe9nLXrbDl43kgrzzne/c4YmIn/70p/fee+873/nOkexk6DPgZ/8yy2k2m1u2bMnzfPsXZ8yYURTFF7/4xVFZAgAgmQieOXPm8B+imjBhwpw5c6699tp99tnnwx/+8PDX/PKXv/zZz37W399fr9dnzZr1jne84xvf+MaTTz75wt954sSJS5cu3bx584t6KOKPTt12220HH3zwzJkzn3P84IMP3uEj2xf49Q678cYbt/+a1772tf/1v/7Xn/3sZ9/4xjc+8pGPvOUtb9nhm4zwgsyZM+dVr3rV0OMoQ771rW+97nWvmzVr1gvscOvWrWvXrv385z9/zTXX/Mmf/MmBBx74Al888l/aokWLjjnmmHe/+919fX0LFy684oornv1o8vz584uiOPvss0e4IgDAGPkr0qZPn/6+971vcHBw3333HX7xyiuvnD59+qmnnjr0j3/zN3/zxBNPjOSpg2OOOeZDH/rQT3/600suuWTke3iBqc2bN69fv36Hz2V3+LsRZsyYUevY29/+9qGYPuaYY579syO/INs/EVEUxTXXXPN8z0Lst99+Q/tvNBrTp09ftGjR1q1bL7jggtH6JHiPPfa48cYbly1b1mw22+32mWeeOWfOnJkzZ1511VWj8v0BAFKK4KE/TbVp06ZvfetbkydPfuUrX3nhhRdOmzZt+As2b968bNmyhx56aPz48UOV1mw2i6IY4R+Pu+CCC175yld+8pOfXLly5ch39XxTu+222+TJk5/z7x3r5E+PHXvssdt/zcaNG9/znvdMmTJl8uTJZ5555g4P9b6oC3LKKacMPxHxwx/+cO3atX/0WYhddtll7733njt3brvdPv3000fxl7brrrueeuqpeZ6vW7du9erVS5cufdnLXjZ//vzPfe5zI18FAGDsfBK82267nXLKKd/+9rd/8IMf/Pmf//n2fx/tP/7jPz5ndN56660333zzH/3Ou+++e4mHIl5g6tWvfvXKlSvvv//+5/yrMA477LBaxxYtWnT77bf//b955JFH3ve+923/sy/qghx00EGvfvWrh/6OiG9/+9tHHnnkK17xiudcdPhvh9i6deujjz66YsWKt7/97bWdZvbs2fPnz//Rj3506KGHdvgUNQBA2o9D/MVf/MUHP/jBW2+99Zxzzhl+8corr5wwYcKGDRu2/3zxX/7lX2q12uWXXz6Sb/uGN7zhwx/+8M033/zs/yOMElOnnnrqtm3b/vqv//o5k7rzv/L22muvvfzyy9/znvf8x//4H+fPn/+Xf/mX3/3ud7f/C+Ne7AU55ZRTfvjDHw79TcYv/PdC7DwPPfRQvV5fuHDhDq83Go1Xv/rV69ev37RpUyUbAwDoiWeCL7jggle84hVf+tKXfvKTn9Rqtd/85jc33HDDiSeeuOeee27/ZUcdddSBBx549dVXb9iwYSTf9jOf+cwrX/nKF/u3EDzn1MKFCw877LDvfve7hx9++DXXXPOb3/xm8+bNQ4l5wgkn3HrrrbvsUv7SrVmz5v3vf//MmTOHq/fyyy/fb7/9PvrRjw79X3iUuCBDT0QsWrRo3bp173jHO2pVmD59+mtf+9orr7zy7LPP/td//dff/va3GzduvPfee7/4xS9ee+21hx9++Lhx4yrZGABAT0TwpEmTvvCFL2zbtu3MM8/csmXL1772tS1btgz/CbDtvfe973366ae//vWvj/zxhhf+extGODVu3Lh2u33UUUfdeuutp5xyyn777Tdu3Lih/9vk5cuXH3jggS/8f2j3nH+FQr1ef/LJJzdv3nzKKac89dRT3/jGN4Yb9yUveclXv/rVjRs3nnrqqZs3by5xQWbPnn3ooYdec801f/qnf7r9w9Yl7L777jts+6tf/epIfmlDH2BPnTr1sssuO/roo/fdd9/dd9999uzZH/jABxqNxvBfDOzvCQYAgkZwrVY76aSTWq3W4ODgf//v//2rX/3qXnvt9Rd/8RfP/rL/9J/+0y677DLCJyKGHm9YtGjRi93Mc07tv//+N91007Jly9761rfuv//+48aNe9nLXvbWt771qquu+uUvf/n617++Vsp/+S//5eabb/7kJz951FFHbf/6m9/85rPPPvvWW28977zzyl2QoacgRvjXA+8kzWbzjjvu+OhHPzpnzpw999xz3LhxM2bMOOOMM37xi1+MyoPUAACjot75460AAJCWyj4JBgCAqohgAADCEcEAAIQjggEACEcEAwAQjggGACAcEQwAQDgiGACAcEQwAADhiGAAAMIRwQAAhCOCAQAIRwQDABCOCAYAIBwRDABAOCIYAIBwRDAAAOGIYAAAwhHBAACEI4IBAAhHBAMAEI4IBgAgHBEMAEA4IhgAgHBEMAAA4YhgAADCEcEAAIQjggEACEcEAwAQjggGACAcEQwAQDgiGACAcEQwAADhiGAAAMIRwQAAhCOCAQAIRwRDeh599NFVq1ZVvQtgFG5JtzNURQTDztVqtebPnz+633PevHk//vGPn+9n169f39fX9wJfADyfBx544P3vf//06dMnTJjQ19d3zjnnPPbYYx3ekp3Mup1h5xHBkJ4//OEPz/dTDzzwwLx589asWdPdHcFYcPfddx922GGPP/748uXLH3vsseuvv/7OO+887LDDHn744dK35B/ldoaqiGDoknXr1tXr9csuu2zGjBkTJkx4y1ve8tBDDw2//pWvfGX//fefMmXK6aefPvQvxQcffLBer993331D45dccsmRRx5Zq9WOPfbYu+66a8GCBQsXLtxhie9+97tz5sw57LDDqvj1QfIWLlz4xje+8brrrms2mxMnTjzkkEO+853v7Lvvvh/60IdGeEu6nSEhIhi66qqrrvr+97+/atWqtWvXfupTnxp+/eKLL77hhhtuu+22W2655eyzz36B73DjjTceeOCBS5cuXbJkyQ4/NX78+BUrVlx22WU7bfswZv3617++6aabdrj7dtlll0WL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AIBwRDAAAOGIYAAAwhHBAACEUy+Kouo90KOyLKt6C9AT8jyvpcb9C+nev3RHo0vrkKbmQMmzY7A/M2t2zMwmKrnrbNbszpiF5+NxCAAAwhHBAACEI4IBAAhHBAMAEI4IBgAgHBEMAEA4IhgAgHBEMAAA4YhgAADCEcEAAIQjggEACEcEAwAQjggGACAcEQwAQDgiGACAcEQwAADhiGAAAMIRwQAAhFMviqLqPQAAQFf5JBgAgHBEMAAA4YhgAADCEcEAAIQjggEACEcEAwAQjggGACAcEQwAQDgiGACAcEQwAADhiGAAAMIRwQAAhCOCAQAIRwQDABCOCAYAIBwRDABAOCIYAIBwRDAAAOGIYAAAwhHBAACEI4IBAAhHBAMAEI4IBgAgHBEMAEA4IhgAgHBEMAAA4YhgAADCEcEAAIQjggEACEcEAwAQjggGACAcEQwAQDgiGACAcEQwAADhiGAAAMIRwQAAhCOCAQAIRwQDABCOCAYAIBwRDABAOCIYAIBwRDAAAOGIYAAAwhHBRPfoo4+uWrWq6l0AJHP0OTYZG0QwKWm1WvPnzx/d7zlv3rwf//jHz3599erVb3vb26ZOnbrffvudeeaZv//970d3XYBR8cADD7z//e+fPn36hAkT+vr6zjnnnMcee6z00TcSjk3GBhFMdH/4wx+e/eLmzZvf9ra3zZgxY82aNTfddNMtt9xy1llnVbE7gBdy9913H3bYYY8//vjy5csfe+yx66+//s477zzssMMefvjhEkffCDk2GSMKSMfb3/729773vUVR/O53v6vVapdeeukBBxwwfvz4N7/5zQ8++ODw60uWLJk+ffqee+75vve97+mnny6K4oEHHqjVamvWrBn6PgMDA0cccURRFG984xuHboTTTz99+4X+z//5P41G45lnnhn6x3/4h3+YOHHitm3bqvhFAzyvP/3TPz355JO3f2Xr1q1HHnnk0IsjOfocm4Tlk2ASdtVVV33/+99ftWrV2rVrP/WpTw2/fvHFF99www233XbbLbfccvbZZ7/Ad7jxxhsPPPDApUuXLlmyZPvXjz766M2bN48bN27oHx9++OG99967Xq/vtF8KwIv261//+qabbtrhlNtll10WLVrUbrcff/zxkR99jk0CEsEk7OMf//isWbNmzJgxf/78m2++efj1iy66aM6cOX19fQMDA8uW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BAMAEI4IBgAgHBEMAEA4IhgAgHBEMAAA4YhgAADCEcEAAIQjggEACEcEAwAQjggGACAcEQwAQDgiGACAcEQwAADhiGAAAMIRwYwFjz766KpVq6reBUAInRy5jmt6hwim21qt1vz580f3e86bN+/HP/7xs1//7W9/e/LJJ++5554vf/nLzz///NFdFCB1DzzwwPvf//7p06dPmDChr6/vnHPOeeyxx0ofuSPhuKZ3iGDGgj/84Q/P+fp73vOeyZMnP/DAA3mef/7zn1+yZEnXtwbQo+6+++7DDjvs8ccfX758+WOPPXb99dffeeedhx122MMPP1zuyB0JxzW9QwRTmXXr1tXr9csuu2zGjBkTJkx4y1ve8tBDDw2//pWvfGX//fefMmXK6aefPnRoPvjgg/V6/b777hsav+SSS4488sharXbsscfeddddCxYsWLhw4fbf/9577/3f//t/X3LJJVOmTHnd61533HHH/cu//EtFv1aAnrNw4cI3vvGN1113XbPZnDhx4iGHHPKd73xn3333/dCHPjTCI9dxTdJEMBW76qqrvv/9769atWrt2rWf+tSnhl+/+OKLb7jhhttuu+2WW245++yzX+A73HjjjQceeODSpUt3+ORg1qxZ27Zte8lLXrJly5bv/5ssy3bmLwUgGb/+9a9vuummHU7XXXbZZdGiRe12+/HHHx/5keu4JlEimIp9/OMfnzVr1owZM+bPn3/zzTcPv37RRRfNmTOnr69vYGBg2bJlTz31VOkl5syZc8IJJ7zmNa856qijRmnXAGlbuXJlrVY7+OCDd3i92Wxu2bLlnnvuGfm3clyTKBFMxWbMmDH0g0mTJm3evHn49aH/dlar1Q455JBNmzbde++9pZdYtWrVo48+OnHixLe97W0d7xdgLKjX67VabevWrTu8/swzz7zYb+W4JlEimIrttttuwz8uiuLZrw+d0Y1GY+jIHvbss/sFTJo06bzzzvvJT36ydu3a0dg1QNqGPgMe+jx4e6tWrWo0GrNnzx75keu4JlEimB51++23D/3gtttu22OPPWbNmjVu3LharTb8H9ruv//+4S/e4cAdcsMNN0yZMmX4U43HHnts1113nTp1ale2D9DTDjjggLlz51544YXbv7ht27aLL774pJNO2muvvUZ+5DquSZQIpkctXrx4zZo1q1evPvfcc88444zx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AQAIRwQDABCOCAYAIBwRDABAOCIYAIBwRDAAAOGIYAAAwhHBAACE01EEn3322fXnd9ppp73w18ybN2/4W61bt27x4sUHHXTQ7rvvPnXq1KOPPvpLX/rS1q1bR77QDq677rp6vb5kyZKhf5w/f369Xh8YGNjhyx588MF6vX7eeecN/ePChQu3/8677rrrnnvuecQRR3zlK1/Z4Vd933337fCtVq1aVa/XzznnnHIbBgCgaxq1HvC73/3u8MMPH87KjRs3/uu/+d73vvc//+f/rNfro7XQJz7xiRNPPPGggw4a4ddv27btiSee+Om/efTRRxcvXjxaOwEAINVPgi+99NLi/7n22mtrtdrSpUuHX1m2bNnwV65Zs6Z4lhUrVgz97N///d/fd999J5988uDg4FNPPbV+/fp//ud/PvTQQ/M8/853vvOiFnphmzZtmj9//vAHzM/n4YcfHvrO27Zte/LJJ7/5zW9OmDDhM5/5zDPPPDPqVwYAgKDPBK9atarRaCxbtuw1r3nNxIkTp0yZctxxx11//fW1Wu2GG24YxYU++MEP/uQnP/nbv/3bEX59vV6fNGnSu9/97ne9612///3v77777lHczFe/+tV6vX7ppZeO4vcEACCZCG42m1u2bMnzfPsXZ8yYURTFF7/4xVFc6IILLpg9e/YnPvGJO++880UNDn0GvOuuu47iZgAAGOMRPHPmzGf/+bAbb7xx6GcXLVp0zDHHvPvd7+7r61u4cOEVV1xxxx137IxtTJw4cenSpZs3bx7JQxG1Wm3r1q1r1679/Oc/f8011/zJn/zJgQceOIqbmT9/flEUZ5999ih+TwAAkvkkeI899rjxxhuXLVvWbDbb7faZZ545Z86cmTNnXnXVVaO+1jHHHPOhD33opz/96SWXXPJ8X7PffvsNZXqj0Zg+ffqiRYu2bt16wQUX+CQYAGBs6FIEP+cfjDv22GOHv2DXXXc99dRT8zxft27d6tWrly5d+rKXvWz+/Pmf+9znRn0zF1xwwStf+cpPfvKTK1eufOGv3GWXXfbee++5c+e22+3TTz996MVG4//+lRqbN2/e4YuHXhn6WQAAellPfBK8g9mzZ8+fP/9HP/rRoYceev7554/69999991f+KGI4b8dYuvWrY8++uiKFSve/va3D//slClTarXaI488ssPUb37zm+GfBQCgl1UfwQ899FC9Xl+4cOEOrzcajVe/+tXr16/ftGnTqC/6hje84cMf/vDNN9/87P/7jD9q5syZz/nXVgy90tfXN3rbBABgp6j+v91Pnz79ta997ZVXXjlhwoRTTz21r69vypQpDz300P/6X//r2muvPfzww8eNG7cz1v3MZz7zj//4jyX+9onjjz9+t912u/jii6dMmXLqqae+9KUv/e1vf/utb33rC1/4wsSJE9/0pjftjN0CADBG/naIer3+5JNP1mq1K6+8curUqZdddtnRRx+977777r777rNnz/7ABz7QaDR23l+jO/RQRIn/O7rp06f/t//23zZt2tTf3z9t2rTddttt//33P+ecc7Zs2fJ3f/d3L33pS0f4ffw9wQAA0f+e4DvuuOOjH/3onDlz9txzz3Hjxs2YMeOMM874xS9+cdhhh+28dd/whjcsWrSoxODf/M3ftNvtt7zlLS972ct22223/fbb78QTT1yxYsWZZ565E7YJAMAoqxdFMdrfEwAAelpPfBIMAADdJIIBAAhHBAMAEI4IBgAgHBEMAEA4IhgAgHBEMAAA4YhgAADCEcEAAIQjggEACEcEAwAQjggGACAcEQwAQDgiGACAcEQwAADhiGAAAMIRwQAAhCOCAQAIRwQDABCOCAYAIBwRDABAOCIYAIBwRDAAAOGIYAAAwhHBAACEI4IBAAhHBAMAEI4IBgAgHBEMAEA4IhgAgHBEMAAA4YhgAADCEcEAAIQjggEACEcEAwAQjggGACAcEQzQDY8++uiqVavG3loAiRLBAM/r5JNPrj+XFStWvNhvNW/evB//+MfPfr3Vas2fP3+U9vtH1gJgmAgGeF7XXXdd8W+WLl06adKkoR8XRTFv3rwX+63+8Ic/7Jw9VrwWQKJEMEBJDz/88Mknn7zHHnu8/OUv/8hHPjKcnl/+8pf7+vomT578+te//vrrr6/Vascee+xdd921YMGChQsXPt93W7duXb1ev+yyy2bMmDFhwoS3vOUtDz300PDrX/nKV/bff/8pU6acfvrpQws9+OCD9Xr9vvvuGxq/5JJLjjzyyBGuBYAIBijpL//yLydPnnzffff94Ac/uPnmm//zf/7PtVrt9ttvX7x48XXXXbdu3boPf/jD73nPex5//PEbb7zxwAMPXLp06ZIlS174e1511VXf//73V61atXbt2k996lPDr1988cU33HDDbbfddsstt5x99tkv8B1GvhZAZCIYoIwf/vCHg4ODl19++T777NPX1/e5z33uf/yP/7Fx48Zf//rXtVpt0qRJ48ePP+200zZu3LjXXnuN/Nt+/OMfnzVr1owZM+bPn3/zzTcPv37RRRfNmTOnr69vYGBg2bJlTz311M75ZQFEIYIByli5cuXTTz89fvz4oT8q9/rXv37btm2/+tWvjj/++MMPP/zggw8+/PDDP/3pTz/44IMv6tvOmDFj6AeTJk3avHnz8OtDjzrUarVDDjlk06ZN995776j+agDCEcEAZWzZsmX27NnF/9+rXvWqCRMmfO973/vRj340d+7cr3/964ceeujq1atH/m1322234R8XRfHs17du3Vqr1RqNRr1e335w6HUARkgEA5Rx0EEHrVmz5jk/6K3X60cfffRnP/vZlStXTpw48Z/+6Z+GXuxkudtvv33oB7fddtsee+wxa9ascePG1Wq14eci7r///u030MlaABGIYIAy3vSmN73mNa9ZsGDBAw888NBDDy1atOgVr3jFM8888/Wvf33GjBm//OUvN23adNNNNz3yyCOvfe1rhx5vWLt27RNPPFFuucWLF69Zs2b16tXnnnvuGWecMX78+H322WfmzJmXX375008/vWLFiquvvnr4iztcCyACEQxQxi677NJutydNmnTwwQe/6lWvuuuuu/7pn/5p6A/Dvfe9733rW986efLkM84444tf/OJRRx1Vq9XOOuusz372swsWLCi33Lx584477rgjjjji+OOPv/DCC4c+7l2yZMmKFSv23nvvT3/60x/72MeGv7jDtQAiqG//zBmMbVmWVb0FeNE2bdq0fPnyuXPnTp48ueq9MPbleV71FqBLGt1aCHpCc6Dk+T7Yn5k1W8ns04+vW778pQctvnSfvoO6ua7ZmLMQh8chAAAIxyfBAD1t4l77fHK159YARplPggEACEcEAwAQjggGACAcEQwAQDgiGACAcEQwAADhiGAAAMIRwQAAhCOCAQAIRwQDABCOCAYAIBwRDABAOCIYAIBwRDAAAOGIYAAAwhHBAACEUy+Kouo9QJdkWVb1FgB6Wp7nVW8BuqTRrYWgJzQHSp7vg/2ZWbNmzY75WYjD4xAAAIQjggEACEcEAwAQjggGACAcEQwAQDgiGACAcEQwAADhiGAAAMIRwQAAhCOC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"
          },
          {
            "type": "input_text",
            "text": "Above is a visual representation of all the training examples and the test input. Each grid cell is colored according to its value (0-9), with clear labels and arrows showing input\u2192output transformations. Use both the textual and visual information to understand the pattern."
          }
        ]
      },
      {
        "type": "message",
        "role": "assistant",
        "content": [
          "Let's analyze the provided training examples:\n\n### Observations from Input\u2192Output:\n\n1. **Color region swap & checkerboard:**\n    - In each input, there are color regions bordered/filled with black (0) cells and a distinct color (red, blue, green, yellow).\n    - In the output, the same regions become: the non-black region is uniformly filled with that color, and within, a \"checkerboard\" of black (0) is overlaid.\n    - The region is NOT always the same as the color region in input (sometimes the entire area, sometimes just the colored area).\n    - The overlaid checkerboard is always such that the colored region has black on every alternate cell, starting at the top-left of the color region.\n    - Black regions (not overlaid checkerboard) remain black.\n\n2. **Shape consistency:**\n    - In output, the original colored area expands to cover the region previously bounded by black, then gets the checkerboard.\n\n3. **Multiple sub-regions:**\n    - Grids can have multiple colored regions \u2014 each gets the checkerboard with its color & black.\n    - Bounding rectangles are axis-aligned.\n\n4. **Background is blue (number 6) in outputs, so keep that background unchanged. All transformations happen only within non-blue regions.**\n\n5. **Grid size:** Stays the same as input, and always is 19x13 (for this problem, always must output that size).\n\n### Hypothesis:\n\n- For each contiguous non-blue (non-6) region:\n  - Find the bounding rectangle containing the region.\n  - Take the dominant non-zero/non-black color (\"the signal color\" of that region).\n  - Fill the entire bounding rectangle with the signal color.\n  - Overlay a checkerboard pattern: set cells with (row+col)%2==0 to signal color, and (row+col)%2==1 to black (0).\n- Leave blue (6) background untouched.\n- Black regions not belonging to a colored region (background black) remain black (confirm: in every example, black only comes as part of the checkerboard or used as a fill in the input).\n\n### Implementation Plan:\n\n- For each connected component of non-blue, non-background:\n    - Use flood fill (BFS/DFS) to find regions.\n    - For each, get its bounding box.\n    - Find the main color (non-black) in it.\n    - Within that box, apply the checkerboard using the main color and black.\n\nFinal answer:\n```python\nimport numpy as np\nfrom collections import deque\n\ndef transform(grid):\n    grid = np.array(grid)\n    H, W = grid.shape\n    output = np.array(grid)  # Start with a copy\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    background = 6  # blue\n\n    # Directions: 4-connected\n    dirs = [(-1,0),(1,0),(0,-1),(0,1)]\n    \n    def in_bounds(r, c):\n        return 0 <= r < H and 0 <= c < W\n\n    # Floodfill for connected component\n    def floodfill(sr, sc):\n        q = deque()\n        q.append((sr, sc))\n        component = []\n        visited[sr, sc] = True\n        while q:\n            r, c = q.popleft()\n            component.append((r, c))\n            for dr, dc in dirs:\n                nr, nc = r+dr, c+dc\n                if in_bounds(nr, nc) and not visited[nr, nc]:\n                    # Only travel through non-background (non-blue) cells\n                    if grid[nr, nc] != background:\n                        visited[nr, nc] = True\n                        q.append((nr, nc))\n        return component\n\n    # Process all non-background cells\n    for r in range(H):\n        for c in range(W):\n            if not visited[r, c] and grid[r, c] != background:\n                comp = floodfill(r, c)\n                # bounding box\n                rs = [p[0] for p in comp]\n                cs = [p[1] for p in comp]\n                rmin, rmax = min(rs), max(rs)\n                cmin, cmax = min(cs), max(cs)\n                # Find the dominant color (ignoring black 0)\n                colors = [grid[p] for p in comp if grid[p] != 0]\n                if colors:\n                    # There might be more than one, but observation is only 1 significant color per region\n                    signal_color = max(colors, key=colors.count)\n                else:\n                    signal_color = 0  # fallback, shouldn't happen\n                # Fill bounding box with checker of color+black\n                for rr in range(rmin, rmax+1):\n                    for cc in range(cmin, cmax+1):\n                        if (rr+cc)%2==0:\n                            output[rr,cc] = signal_color\n                        else:\n                            output[rr,cc] = 0  # black\n    return output.tolist()\n```\n"
        ]
      }
    ],
    "all_responses": [
      {
        "id": "resp_687002c86a74819f8f02a2bc61538aed0067888449fa580f",
        "model": "gpt-4.1-2025-04-14",
        "usage": {
          "input_tokens": 7888,
          "output_tokens": 1062,
          "total_tokens": 8950
        },
        "output": [
          {
            "type": "message",
            "content": [
              "Let's analyze the provided training examples:\n\n### Observations from Input\u2192Output:\n\n1. **Color region swap & checkerboard:**\n    - In each input, there are color regions bordered/filled with black (0) cells and a distinct color (red, blue, green, yellow).\n    - In the output, the same regions become: the non-black region is uniformly filled with that color, and within, a \"checkerboard\" of black (0) is overlaid.\n    - The region is NOT always the same as the color region in input (sometimes the entire area, sometimes just the colored area).\n    - The overlaid checkerboard is always such that the colored region has black on every alternate cell, starting at the top-left of the color region.\n    - Black regions (not overlaid checkerboard) remain black.\n\n2. **Shape consistency:**\n    - In output, the original colored area expands to cover the region previously bounded by black, then gets the checkerboard.\n\n3. **Multiple sub-regions:**\n    - Grids can have multiple colored regions \u2014 each gets the checkerboard with its color & black.\n    - Bounding rectangles are axis-aligned.\n\n4. **Background is blue (number 6) in outputs, so keep that background unchanged. All transformations happen only within non-blue regions.**\n\n5. **Grid size:** Stays the same as input, and always is 19x13 (for this problem, always must output that size).\n\n### Hypothesis:\n\n- For each contiguous non-blue (non-6) region:\n  - Find the bounding rectangle containing the region.\n  - Take the dominant non-zero/non-black color (\"the signal color\" of that region).\n  - Fill the entire bounding rectangle with the signal color.\n  - Overlay a checkerboard pattern: set cells with (row+col)%2==0 to signal color, and (row+col)%2==1 to black (0).\n- Leave blue (6) background untouched.\n- Black regions not belonging to a colored region (background black) remain black (confirm: in every example, black only comes as part of the checkerboard or used as a fill in the input).\n\n### Implementation Plan:\n\n- For each connected component of non-blue, non-background:\n    - Use flood fill (BFS/DFS) to find regions.\n    - For each, get its bounding box.\n    - Find the main color (non-black) in it.\n    - Within that box, apply the checkerboard using the main color and black.\n\nFinal answer:\n```python\nimport numpy as np\nfrom collections import deque\n\ndef transform(grid):\n    grid = np.array(grid)\n    H, W = grid.shape\n    output = np.array(grid)  # Start with a copy\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    background = 6  # blue\n\n    # Directions: 4-connected\n    dirs = [(-1,0),(1,0),(0,-1),(0,1)]\n    \n    def in_bounds(r, c):\n        return 0 <= r < H and 0 <= c < W\n\n    # Floodfill for connected component\n    def floodfill(sr, sc):\n        q = deque()\n        q.append((sr, sc))\n        component = []\n        visited[sr, sc] = True\n        while q:\n            r, c = q.popleft()\n            component.append((r, c))\n            for dr, dc in dirs:\n                nr, nc = r+dr, c+dc\n                if in_bounds(nr, nc) and not visited[nr, nc]:\n                    # Only travel through non-background (non-blue) cells\n                    if grid[nr, nc] != background:\n                        visited[nr, nc] = True\n                        q.append((nr, nc))\n        return component\n\n    # Process all non-background cells\n    for r in range(H):\n        for c in range(W):\n            if not visited[r, c] and grid[r, c] != background:\n                comp = floodfill(r, c)\n                # bounding box\n                rs = [p[0] for p in comp]\n                cs = [p[1] for p in comp]\n                rmin, rmax = min(rs), max(rs)\n                cmin, cmax = min(cs), max(cs)\n                # Find the dominant color (ignoring black 0)\n                colors = [grid[p] for p in comp if grid[p] != 0]\n                if colors:\n                    # There might be more than one, but observation is only 1 significant color per region\n                    signal_color = max(colors, key=colors.count)\n                else:\n                    signal_color = 0  # fallback, shouldn't happen\n                # Fill bounding box with checker of color+black\n                for rr in range(rmin, rmax+1):\n                    for cc in range(cmin, cmax+1):\n                        if (rr+cc)%2==0:\n                            output[rr,cc] = signal_color\n                        else:\n                            output[rr,cc] = 0  # black\n    return output.tolist()\n```\n"
            ]
          }
        ]
      }
    ]
  }
}