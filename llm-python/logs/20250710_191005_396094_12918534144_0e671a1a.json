{
  "task_id": "0e671a1a",
  "model": "gpt-4.1",
  "reasoning_effort": "N/A",
  "api_type": "responses_api_multiturn",
  "program": "def transform(grid):\n    import numpy as np\n\n    grid = np.array(grid)\n    n = 13  # always 13x13\n\n    # Step 1: Get the positions of color blocks\n    # Color code: red=2, green=3, yellow=4\n    pos = {}\n    for val in [2, 3, 4]:\n        locs = np.argwhere(grid == val)\n        if len(locs):\n            pos[val] = tuple(locs[0])\n    # There may be three colored blocks per grid, but not necessarily in any fixed order.\n    # Let's get their positions mapped as color->(y,x)\n    # There is always a red (2), yellow (4), green (3)\n\n    # Step 2: Determine which block is topmost, leftmost etc.\n    # For the path:\n    # - Find the two blocks that are closer vertically and horizontally\n    # Let's always draw a 'corner' connecting all 3, in the pattern observed in outputs\n\n    # Form a set of three points\n    pts = [(v, pos[v]) for v in pos]\n    # Sort by row, col, but let's just brute force all 3 prefixes\n\n    # Try all (start, corner, end) assignments\n    best = None\n    best_steps = None\n    for perm in [(2,4,3), (2,3,4), (3,4,2), (3,2,4), (4,2,3), (4,3,2)]:\n        p0 = pos[perm[0]]\n        p1 = pos[perm[1]]\n        p2 = pos[perm[2]]\n        # Compute \"total step length\" for path: p0 -> (p1[0],p0[1]) -> p1 -> (p1[0],p2[1]) -> p2\n        # As in output, the path always corner-turns at one block.\n        steps = (abs(p0[0]-p1[0]) + abs(p1[1]-p0[1])) + (abs(p1[0]-p2[0]) + abs(p2[1]-p1[1]))\n        if best is None or steps < best_steps:\n            best = perm\n            best_steps = steps\n\n    # Use the assignment with shortest \"route\" passing through the middle point\n    start, corner, end = best\n    p0 = pos[start]\n    p1 = pos[corner]\n    p2 = pos[end]\n\n    # Build output grid\n    out = np.zeros((n,n), dtype=int)\n\n    # Place blocks\n    out[p0] = start\n    out[p1] = corner\n    out[p2] = end\n\n    # Draw path from start to corner (horizontal then vertical)\n    x1, y1 = p0[1], p0[0]\n    x2, y2 = p1[1], p1[0]\n    for col in range(min(x1,x2)+1,max(x1,x2)):\n        out[y1, col] = 5\n    for row in range(min(y1,y2)+1,max(y1,y2)):\n        out[row, x2] = 5\n\n    # Draw path from corner to end (vertical then horizontal)\n    x1, y1 = p1[1], p1[0]\n    x2, y2 = p2[1], p2[0]\n    for row in range(min(y1,y2)+1,max(y1,y2)):\n        out[row, x1] = 5\n    for col in range(min(x1,x2)+1,max(x1,x2)):\n        out[y2, col] = 5\n\n    return out.tolist()",
  "execution_error": "Max turns reached",
  "timed_out": false,
  "tokens_used": 5849,
  "request_cost": 0.01654,
  "turns_used": 1,
  "raw_response": {
    "id": "resp_687001eb324c8192be8c51c726c4a7d800937712ff4e7607",
    "model": "gpt-4.1-2025-04-14",
    "usage": {
      "input_tokens": 5042,
      "output_tokens": 807,
      "total_tokens": 5849
    },
    "output": [
      {
        "type": "message",
        "content": [
          "Final answer:\n```python\ndef transform(grid):\n    import numpy as np\n\n    grid = np.array(grid)\n    n = 13  # always 13x13\n\n    # Step 1: Get the positions of color blocks\n    # Color code: red=2, green=3, yellow=4\n    pos = {}\n    for val in [2, 3, 4]:\n        locs = np.argwhere(grid == val)\n        if len(locs):\n            pos[val] = tuple(locs[0])\n    # There may be three colored blocks per grid, but not necessarily in any fixed order.\n    # Let's get their positions mapped as color->(y,x)\n    # There is always a red (2), yellow (4), green (3)\n\n    # Step 2: Determine which block is topmost, leftmost etc.\n    # For the path:\n    # - Find the two blocks that are closer vertically and horizontally\n    # Let's always draw a 'corner' connecting all 3, in the pattern observed in outputs\n\n    # Form a set of three points\n    pts = [(v, pos[v]) for v in pos]\n    # Sort by row, col, but let's just brute force all 3 prefixes\n\n    # Try all (start, corner, end) assignments\n    best = None\n    best_steps = None\n    for perm in [(2,4,3), (2,3,4), (3,4,2), (3,2,4), (4,2,3), (4,3,2)]:\n        p0 = pos[perm[0]]\n        p1 = pos[perm[1]]\n        p2 = pos[perm[2]]\n        # Compute \"total step length\" for path: p0 -> (p1[0],p0[1]) -> p1 -> (p1[0],p2[1]) -> p2\n        # As in output, the path always corner-turns at one block.\n        steps = (abs(p0[0]-p1[0]) + abs(p1[1]-p0[1])) + (abs(p1[0]-p2[0]) + abs(p2[1]-p1[1]))\n        if best is None or steps < best_steps:\n            best = perm\n            best_steps = steps\n\n    # Use the assignment with shortest \"route\" passing through the middle point\n    start, corner, end = best\n    p0 = pos[start]\n    p1 = pos[corner]\n    p2 = pos[end]\n\n    # Build output grid\n    out = np.zeros((n,n), dtype=int)\n\n    # Place blocks\n    out[p0] = start\n    out[p1] = corner\n    out[p2] = end\n\n    # Draw path from start to corner (horizontal then vertical)\n    x1, y1 = p0[1], p0[0]\n    x2, y2 = p1[1], p1[0]\n    for col in range(min(x1,x2)+1,max(x1,x2)):\n        out[y1, col] = 5\n    for row in range(min(y1,y2)+1,max(y1,y2)):\n        out[row, x2] = 5\n\n    # Draw path from corner to end (vertical then horizontal)\n    x1, y1 = p1[1], p1[0]\n    x2, y2 = p2[1], p2[0]\n    for row in range(min(y1,y2)+1,max(y1,y2)):\n        out[row, x1] = 5\n    for col in range(min(x1,x2)+1,max(x1,x2)):\n        out[y2, col] = 5\n\n    return out.tolist()\n```"
        ]
      }
    ]
  },
  "score": {
    "correct": false,
    "pixel_accuracy": 0.0,
    "total_pixels": 169,
    "correct_pixels": 0,
    "error": "Max turns reached"
  },
  "actual_output": [
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      5,
      5,
      5,
      4,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      5,
      0,
      0,
      5,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      5,
      0,
      0,
      5,
      0,
      0
    ],
    [
      0,
      2,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      5,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      5,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      5,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      5,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      5,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      3,
      0,
      0,
      0,
      0,
      0
    ],
    [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]
  ],
  "api_success": true,
  "multiturn_data": {
    "turn_details": [
      {
        "turn_number": 1,
        "timestamp": "2025-07-10T19:09:41.068747",
        "input_tokens": 5042,
        "output_tokens": 807,
        "turn_cost": 0.01654,
        "program_extracted": true,
        "program": "def transform(grid):\n    import numpy as np\n\n    grid = np.array(grid)\n    n = 13  # always 13x13\n\n    # Step 1: Get the positions of color blocks\n    # Color code: red=2, green=3, yellow=4\n    pos = {}\n    for val in [2, 3, 4]:\n        locs = np.argwhere(grid == val)\n        if len(locs):\n            pos[val] = tuple(locs[0])\n    # There may be three colored blocks per grid, but not necessarily in any fixed order.\n    # Let's get their positions mapped as color->(y,x)\n    # There is always a red (2), yellow (4), green (3)\n\n    # Step 2: Determine which block is topmost, leftmost etc.\n    # For the path:\n    # - Find the two blocks that are closer vertically and horizontally\n    # Let's always draw a 'corner' connecting all 3, in the pattern observed in outputs\n\n    # Form a set of three points\n    pts = [(v, pos[v]) for v in pos]\n    # Sort by row, col, but let's just brute force all 3 prefixes\n\n    # Try all (start, corner, end) assignments\n    best = None\n    best_steps = None\n    for perm in [(2,4,3), (2,3,4), (3,4,2), (3,2,4), (4,2,3), (4,3,2)]:\n        p0 = pos[perm[0]]\n        p1 = pos[perm[1]]\n        p2 = pos[perm[2]]\n        # Compute \"total step length\" for path: p0 -> (p1[0],p0[1]) -> p1 -> (p1[0],p2[1]) -> p2\n        # As in output, the path always corner-turns at one block.\n        steps = (abs(p0[0]-p1[0]) + abs(p1[1]-p0[1])) + (abs(p1[0]-p2[0]) + abs(p2[1]-p1[1]))\n        if best is None or steps < best_steps:\n            best = perm\n            best_steps = steps\n\n    # Use the assignment with shortest \"route\" passing through the middle point\n    start, corner, end = best\n    p0 = pos[start]\n    p1 = pos[corner]\n    p2 = pos[end]\n\n    # Build output grid\n    out = np.zeros((n,n), dtype=int)\n\n    # Place blocks\n    out[p0] = start\n    out[p1] = corner\n    out[p2] = end\n\n    # Draw path from start to corner (horizontal then vertical)\n    x1, y1 = p0[1], p0[0]\n    x2, y2 = p1[1], p1[0]\n    for col in range(min(x1,x2)+1,max(x1,x2)):\n        out[y1, col] = 5\n    for row in range(min(y1,y2)+1,max(y1,y2)):\n        out[row, x2] = 5\n\n    # Draw path from corner to end (vertical then horizontal)\n    x1, y1 = p1[1], p1[0]\n    x2, y2 = p2[1], p2[0]\n    for row in range(min(y1,y2)+1,max(y1,y2)):\n        out[row, x1] = 5\n    for col in range(min(x1,x2)+1,max(x1,x2)):\n        out[y2, col] = 5\n\n    return out.tolist()",
        "training_feedback": {
          "feedback_messages": [
            {
              "type": "input_text",
              "text": "Training results: 0/4 examples solved, 89.8% pixel accuracy - Good partial progress! Your approach is capturing some patterns. Next, try to identify a transformation that solves at least one of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 4, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 4, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 91.7%\n\nTraining Example 2 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 2, 0], [0, 0, 5, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 5, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 2, 0], [0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 89.3%\n\nTraining Example 3 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0], [0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0], [0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0], [0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 2, 5, 5, 5, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 86.4%\n\nTraining Example 4 \u2717:\nExpected: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0], [0, 0, 2, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nYour output: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 2, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\nPixel accuracy: 91.7%\n\n"
            },
            {
              "type": "input_image",
              "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAo8AAAUUCAIAAAAx9G8iAABTZUlEQVR4nO3deZRU5b3o710MjSgIimMY4oCgXqIiOOEQDNwVBdEqQaPtEEgbHIIDOBw5y6uJVyJHiCYmBr1BIIgVPRqrHEIIGgFjAgaVE0EUCaCCgBeJLSIz7N9K6nd7ccBGqO6ueqv7eZZ/tNX7W3vXtl8+1K5qKxHHcQQABKxRsQ8AAPgKag0AoVNrAAidWgNA6NQaAEKn1gAQOrUGgNCpNQCETq0BIHRqDQChU2sACJ1aA0Do1BoA6nWthwwZkqje5Zdf/qXblJWVHXLIIeeff/6bb765832++OKLiURi//3337Bhww7fevrppxOJxNixY3P/OnDgwEQiMWrUqB02W7ZsWSKRuOOOO2oylbNhw4ZHHnnk7LPP/trXvtasWbOvfe1rF1100Z/+9KddnJM77rijuhMyb968XZ+03r17f+WJrdrmqquu2v723OH1799/5syZ2x9PMpncYbPDDz/8hhtu+PTTT/fo5Od88skn99xzT9euXVu1arXPPvucfPLJY8eO3f5j3HK722H8jTfeOPDAA1u2bDlt2rRdnDoAAnpuvXnz5o8//vj5558/++yzFy9evMN3x40bF0XRp59++uSTT+7Ovd15553vvvvunh7D7ky9//77p5122jXXXDN9+vQVK1Zs2rRpxYoVTz/99FlnnXX//fdHgckd3jPPPHPGGWc8/vjju9js/fff//nPf37OOeds27Ztj07+zJkzjz/++P/1v/7Xf/3Xf61Zs2bdunWzZ8/+/ve/X1FRsYsDe/nll88+++ytW7e+9NJLZ599dg0eIkDDVaNa/+IXv4j/n6eeeiqKovHjx1fdMmnSpKotlyxZUnX7hg0b3nnnnfLy8jVr1owZM2b7O6ysrMxmsxdddNH+++//8MMP784xbNq0aeDAgVu3bt2jI//Kqc2bNw8YMOC//uu/evTo8dxzz33yySebN2/+8MMPf/nLX+6///633XZb7olydebMmRPvpEuXLl96Qqq89NJL29/J7myzYsWK3O3r16//+9//fvvtt8dx/L3vfe+DDz7YfrP169dvf/J79+7917/+9cUXX9z9k/9//+//TaVSy5cvv/TSS2fNmrVmzZp//OMf2Wz2iCOOGD9+/COPPPKl5yGTyfTp02fvvfeePn36KaecsoszBkBYz62bNWt29NFH/8d//EcURTs8t06n0xs2bLj66qsHDRo0a9ast9566yvv7frrr3/ttdd+8pOf7NExfOXUr3/96zfeeKN3796vvPJKv3792rRp06RJk/bt21977bXPPPPM1q1bf/Ob30Qh2WuvvY488sh77733zjvv3LRp009/+tNdnPybbropV/rdP/n333//xx9/PHTo0HQ6fcopp7Rs2XK//fa74IILZsyYsc8++9x///3bXw/PefTRRy+66KKDDjroT3/603HHHVd1+4QJExKJxC9+8YtaPQEA9VkRar1x48a333572LBhURR16tRp+2+NHz/+mGOO+da3vnXttdc2btx4d55e//jHP+7YseOdd975zjvv7P4xfOVUOp1OJBL/5//8n8aNG+/wrW9+85vz58+/5557oiDdfPPNe++99x/+8Icv/e7mzZvfe++9Bx98sEmTJt/85jd3/+T/53/+Z/Pmze++++4d7rBdu3avvvrq9OnTE4nE9rffd999V1111RFHHPHqq68eddRRtff4ABqiAtX68MMPr3qj01577dWlS5ennnrqgAMOuPHGG6u2mTdv3uuvv37rrbcmEokjjzzyoosuevzxx9euXbvre957773Hjx+/efPmPboe/pVTc+bMOeaYYw4//PAvHT/mmGN2iNMOunbtusO7w1599dXqTkiV6dOn7+k2O2vZsuVRRx21w0WL5s2b58bLyso6d+785z//+de//vX2j27XJ3/z5s3vv//+ySef3KJFi533eMIJJxx66KHb33Lbbbf927/9WxRFZ555ZocOHXbYfuDAgXEcDxkyZNcPBIAi/wZX27Ztv/e97/3tb3875JBDqm4cN25c27ZtL7vssty/Dh8+/PPPP9+dC85nnHHGDTfc8Ne//nX06NG7fwy7mNq8eXNlZeXBBx+8/Y07vE/7sMMOi0LVpk2bjf9S3QZbt26dNWvW5s2bd/PkV1ZWxnHcpk2b3TyAn//856eddlrv3r3HjRv3zDPP1OzRAFCoWufeMLVp06Ynnngi9+Rv5MiRX/va16o22Lx586RJkz766KNmzZrlcnj88cfHcbyb7zX78Y9/fNRRR911113z58/f/aOqbqpp06YtW7ZctWpVlK+d32V2xhlnfOU7yHr27Lmn23ypTz/9tGnTps2aNdv5XWabNm1avHjxD37wg5///Oe33HLLbp78/fffv1GjRrt/QgYNGjR9+vSJEyfuv//+3//+9z/66KPdHASg+M+tmzZt+p3vfOfJJ5+cMWPGOeecs/1v5b7wwgtfGoM333xz9uzZX3nPzZs3z+N6+C6mvvGNb8yfP//DDz/80jfAd+vWLQrV2rVr582bd8wxx3zpd5s2bXr44YePHj26S5cuEyZM2M2T37hx42OOOeb1119ft27dzpvde++9V1555fLly6tu+eUvf1lWVnbooYf+4he/+Mc//nHllVfu/NtiAAR9Jfzcc8+9/vrr33zzzarndrkrsXvttddnn322/fPIv/zlL1EUVffbQTs4/fTTb7zxxtmzZ+/8fz7JY+qyyy7btm3bdddd96Xt3/n9z+F44IEHNm/efM455+x6s0aNGq1du3bLli27efKTyeT69et/+MMf7nA/77///n333ffCCy986XXySy+9dMCAAS+//PIevUgBQBCvW//4xz/u0KHDmDFjXnvttSiKVq5cOWXKlH79+u27777bb3baaad17tz5N7/5zWeffbY7dztixIijjjrql7/85R4dzJdOXXXVVd26dfvd73538skn/+d//ufKlSs3b96c+7+j9O3b980332zUKKz/aevGjRsXLFhwxx13/OhHP9p7772rew9XHMfLli279dZb33rrra5duzZp0mQ3T/7QoUPbtGkzatSoK6+88vXXX1+/fv3HH3+cTqd79uxZWVl56623bn/hfXtjxow5+OCD77jjjjfeeKNuHjpA/Vec5Oyzzz4///nPt23bdvXVV2/ZsmXixIlbtmypeovT9r773e+uW7fuscce2/0r27t+t/ZuTpWVlWWz2dNOO+3NN9/8zne+c+ihh5aVleX+z6OTJ0/u3Lnzbv6v1qrzpe/3TiQS278Hfne2OfTQQ6veaX/00UePGDEi979Zbd++/Q6PMbdZo0aN2rdvP3r06EaNGuV+CW03T36bNm2efPLJli1bPvbYYyeddNLee+99yCGHXHbZZR988EEqlbrtttuqe6QHHHDAr371q82bN5eXl3/xxRd+3xogD0V7gnj++ecnk8m//e1vP/3pTydMmLDffvude+65O2925ZVXNmrUaDcvhueubOf+1x975Eun2rVr96c//WnSpEl9+vRp165dWVnZwQcf3KdPn1//+tfz5s076aSTopA0bdq0ffv2l1xyyZ///OdLL720us0aN2580EEH9e3b98UXX8xdLd/9k9+rV685c+bccMMNRx99dIsWLZo3b37KKaeMHTv2t7/97c6/lb69fv36DRw48L333tv+F/YA2H2JkF+CBQB8YiYAlAC1BoDQqTUAhE6tASB0ag0AoVNrAAidWgNA6NQaAEKn1gAQOrUGgNCpNQCETq0BIHRqDQChU2sACJ1aA0Do1BoAQqfWABA6tQaA0Kk1AIROrQEgdGoNAKFTawAInVoDQOjUGgBCp9YAEDq1BoDQqTUAhE6tASB0ag0AoVNrAAidWgNA6NQaAEKn1gAQOrUGgNCpNQCETq0BIHRqXa+sXr363XffLfZRQINmGVIX1LqutGvXLrGTSZMm1elOe/fuPWvWrN3ffvTo0aeeemp1362srDziiCP26A4hHAcccEDV0isrKzvmmGMefPDBvO+tarFUVlYmEold9NgypC6odR164IEH4v/u8ssvr9M9rl+/vrbuaunSpb17916yZElt3SEU3pgxY3JL74svvhg1atQtt9zy2GOP1fA+W7duHcfx0UcfXd0GliF1Qa0L7dFHH23WrNnSpUujKFq1atW+++47fvz4Tz75JJFIPProo+3atWvVqlVFRUXVgl+xYsWAAQNatGjRvn37YcOGVd3+0UcfpVKpli1bHnjggdddd93GjRt79uy5YMGCQYMGXXXVVbsYfPvtt88888zmzZv36NGjuj8Ffve733Xp0qVbt26FOitQt5o2bXreeef16tUrk8msXLkykUgMHz68VatWAwcO3NPFsv1za8uQglHrQquoqDjjjDNGjhwZRdGIESO6d+8+aNCg3Lfuu+++KVOmzJkz54033hgyZEjuxv79+7ds2fL999+fMWPG7Nmzhw4dGkXR1q1bzz333LKyskWLFs2cOXPu3Ll33XXX9OnTO3fuPH78+LFjx1Y3uGHDhj59+hx//PHLly8fPnz4+PHjv/QgmzVr9tJLLz300EMFPDFQ57Zs2dKiRYvc1+++++6yZcvuvvvuvBeLZUhB7XCpltrStm3bHU5148aNc99auHBh69at77///latWi1cuDCO41WrVkVRlMlkchtMnTq1rKxs7dq1M2bM2HvvvTdu3Ji7ffbs2Y0aNVq/fv2MGTPKyspWr169w05zf0zEcVzdYDabbdWq1bp163K3Dx48+JRTTqnuIWzevDmKopkzZ9bB6YE616ZNm6or4ZWVlePHj2/UqNELL7ywYsWKKIomT56c+9aeLpZPP/00iqJ33nnHMqSQPLcu3OvWW7Zsyd3esWPHW2+9ddiwYTfffHPHjh2rtq96p8kJJ5ywadOmRYsWzZ8/f926dc2aNcu9U+akk07atm3b4sWL33777Xbt2u2///7V7bq6wfnz5x955JHNmzfPbda1a9c6PgdQTNdee21uCRx88MGjR49+6KGH+vbtm/tWhw4darhYLEMKSa2LY968eVEUvfnmm9vf2LRp09wXW7dujaKoSZMmW7Zs6dix4w5/wzr22GObNm2aSCR2cf/VDe6wWdUeoV6qem69YcOGefPmXXPNNVXfatasWQ0Xi2VIIal1Efz+979/8sknR40a9eyzz2az2arb33rrrdwXc+bMadGixZFHHnn00UcvWbJk2bJlO9xDp06dli5dmrsit72qPzuqG+zSpcvChQu/+OKL3L/OnTu3th8clJi8F4tlSCGpdaGtXbv2mmuuueGGG2655Zbvf//7Q4YM+fzzz3Pfuu2225YsWbJw4cJ/+7d/Gzx4cLNmzb71rW8dd9xxgwYNWrp06UcffXTTTTd16NBh48aNZ555ZpcuXa6//vpPPvnk/fff79+//6WXXhpF0T777LN8+fLPP/+8usFvf/vbhx566I033viPf/zjpZdeGjduXLHPBxRZ3ovFMqSgaun1b776XWZRFF199dXXX3/9YYcdtnbt2jiOP/vss/bt2w8ZMiT3LrPbb7/961//+n777Tds2LBNmzbl7ueDDz644IIL9tlnn3333fecc8555513crcvWbLk3HPP3Wuvvdq0aTNw4MDPPvssjuNf/epXLVq06N+//y4GFy1a1KtXr7322qtLly7Dhg3z9hYawrvMtpd7l1nuDZ45e7RYqt5lZhlSSIk4jvMufSqVqtlfFfj/bdq0afLkyb169WrZsmWxj4V8ZDKZouzXGoTirsHCqUnqk8lk3vs1a7Y+zdbeX6CtQbNmS2kNFozXrQEgdGoNAKFTawAInVoDQOjUGgBCp9YAEDq1BoDQqTUAhE6tASB0ag0AoVNrAAidWgNA6NQaAEKn1gAQOrUGgNCpNQCETq0BIHRqDQChS8RxnPdwKpWq1YOBUpXJZIqyX2sQirsGCyeugWQymfd+zZqtT7M1WUfWoFmzpbsGC8aVcAAInVoDQOjUGgBCp9YAEDq1BoDQqTUAhE6tASB0ag0AoVNrAAidWgNA6NQaAEKn1gAQOrUGgNCpNQCETq0BIHRqDQChU2sACJ1aA0DoEnEc5z2cSqVq9WCgVGUymaLs1xqE4q7BgmlSw/lsNpvfYDKZzHy2PL/ZVKuvlZeX5zebTqfN1u/ZmvxM5j1bRKW4Bovy38hs/Z6t91wJB4DQqTUAhE6tASB0ag0AoVNrAAidWgNA6NQaAEKn1gAQOrUGgNCpNQCETq0BIHRqDQChU2sACJ1aA0Do1BoAQqfWABA6tQaA0Kk1AIQuEcdx3sOpVKpWDwZKVSaTKcp+rUEo7hosmCY1nM9ms/kNJpNJs2army0vL89vNp1OF+WYi8h/393fr9l6PFvvuRIOAKFTawAInVoDQOjUGgBCp9YAEDq1BoDQqTUAhE6tASB0ag0AoVNrAAidWgNA6NQaAEKn1gAQOrUGgNCpNQCETq0BIHRqDQChU2sACF0ijuO8h1OpVK0eDJSqTCZTlP1ag1DcNVgwTWo4n81m8xtMJpNmzVY3W15ent9sOp0uyjEXkf++u79fs/V4tt6raa0BoL5JJKr9Vg0uSNeEWgPAV0V6520Km221BqDBSyTyHClUs9UagAYskaiF8bpvtt/gAqChSiTCup/qqTUADVKiVhNbx8FWawAankQdxLUug63WADQwiUTJ3bNaA9CQJBKleP9qDUCDkUiU6F7UGgBCp9YANAyJROnuS60BIHRqDUADkEiU9B7VGgBCp9YAEDq1BqC+SyRKfb8+gwsAdhLH0bPPRlu2RE2bRuefX7Te/z+JuAaf85VKpWr1YKBUZTKZouzXGoTdWoN5tPa116Jx46JHHokqKqKrropOOy3KTy19mGZNn1tns9n8BpPJpFmz1c2Wl5fnN5tOp4tyzEXkv+/u79dsPZ6tfUuXRhs3RqeeGn300T//KTavWwPAl5k0KRo+PJoyJQqAWgPAlxk0KJowIerXLwqAWgPATtq3j5o3jzKZf37Rtm1UbN4TDgA7OfnkaOXK6Kyz/vme8FNPjYpNrQFgJ8X+la0duBIOQH0Xx6W+X7UGgNCpNQCETq0BaADiuKT3qNYAEDq1BqBhiOPS3ZdaA0Do1BqABiOOS3Qvag2FdsIJJ3z0r4/02bhxY6dOnR588MGuXbueeOKJU6dOLfahQQMQx6V4/2oNhTZgwIDnnnsuiqJp06adc84599xzzyuvvJJOpydNmlTsQ4OGIY5L7p7VGgrtoosuevbZZ6Moev755y+++OI+ffpceeWVS5cunThxYrEPDRqMOC6tZ+1qDYXWuXPn1atXr1mzZs6cOaeffvqECROGDh06ZsyYQYMGFfvQoCGJ4xK6wO5TPaAILrjggpEjR5588slr1qw5//zzX3rppW7duh1xxBHFPi5oYOK4dj69o+7fvJaIa7CPVCpVqwcDpSqTyezR9gsWLDjuuOOmTZvWo0ePUaNGPfHEE9u2bauoqBgyZMge3Y81CPmtwR3l3exC/Q53TWudzWbzm00mk8WaLS8vz282nU6bLcxsZnSe/31TtxTn56om66gmrEGzdTTbQNdgYk+aXdhV70o4APz3AO8i20X6q7laA0AYn4ddPe8JB4DQqTUAhE6tASB0ag0AoVNrAAidWgNA6NQaAEKn1gAQOrUGgNCpNQCETq0BIHRqDQChU2sACJ1aA0Do1BqABmfJkiXf/va3e/bsed5553388ce5GysrKwcOHNiqVavtt7zkkkt6/kuPHj0OOOCAKIpGjhzZpUuXUaNGRVG0bdu2vn37VlZW1vUB+3xrABqcwYMH33777b169frjH//4wx/+cMyYMVEU9evX7+KLL85ms9tv+cQTT+S+GDt27IcffhhF0c9+9rMFCxZ07tz51ltvHTt2bP/+/Vu3bl3XB5yIa/CZ26lUqlYPBkpVJpMpyn6tQchvDR544IErV65s3Ljx1q1bjz322AULFkRRtHLlykMOOaR169Y7P1eO4/jEE0/8wx/+cNBBB3Xo0OHll1/u1avXnDlzrrjiihdeeCGRSESBP7fe4e8guy+ZTBZrtry8PL/ZdDpdio/XbAFmi6jkzpU1aLYuZvfUcccd99xzz6VSqUwmU3Ul/JBDDqlu++eff/6kk0466KCDoigaMWLE5Zdffu+9995xxx0/+tGPCpBqr1sD0BCNHTt24sSJZ5999gcffFBWVvaV2//kJz+5+eabc19fccUVs2bN6ty5cxRFixcv7tu379NPP13XB+x1awAanN/85jdPPvlkWVnZwoULv/Iq+muvvda6detcnnPiOL7zzjsnTpzYrVu3WbNm9ejRY8CAAXV6wJ5bA9DgvP7665MnT46iaMKECZdeeumXbrN27drcF/fdd1/VE+uccePG9evXr02bNuvXr4/jeN26dXV9wGoNQINz3333jR49+rTTTluzZs211177pdtceOGFURT9/e9/X758+VlnnVV1e2Vl5VNPPTV48OAoioYOHdq7d+8dWl4XXAkHoMHp2LHjq6+++qXfqnpD+NSpU3Nbzpw5c/sNWrduPWXKlNzXt/9L3R+v59YAEDy1BoDQqTUAhE6tASB0ag0AoVNrAAidWgNA6NQaAEKn1gAQOrUGgNCpNQCETq0BIHRqDQChS8RxnPdwKpWq1YOBUvWVn2ZfR6xBKO4aLJiafmJmNpvNbzCZTBZrtry8PL/ZdDpdio/XbAFmi6jkzpU1aLYuZus9V8IBIHRqDQChU2sACJ1aA0Do1BoAQqfWABA6tQaA0Kk1AIROrQEgdGoNAKFTawAInVoDQOjUGgBCp9YAEDq1BoDQqTUAhE6tASB0ag0AoUvEcZz3cCqVqtWDgVKVyWSKsl9rEIq7BgumSQ3ns9lsfoPJZLJYs+Xl5fnNptPpUny8ZgswW0Qld66sQbN1MVvvuRIOAKFTawAInVoDQOjUGgBCp9YAEDq1BoDQqTUAhE6tASB0ag0AoVNrAAidWgNA6NQaAEKn1gAQOrUGgNCpNQCETq0BIHRqDQChU2sACF0ijuO8h1OpVK0eDJSqTCZTlP1ag1DcNVgwTWo4n81m8xtMJpPFmi0vL89vNp1Ol+LjNVuA2SIquXNlDZqti9l6z5VwAAidWgNA6NQaAEKn1gAQOrUGgNCpNQCETq0BIHRqDQChU2sACJ1aA0Do1BoAQqfWABA6tQaA0Kk1AIROrQEgdGoNAKFTawAInVoDQOgScRznPZxKpWr1YKBUZTKZouzXGoTirsGCaVLD+Ww2m99gMpks1uziOyrzmz3intal+HjNFmC2iEruXFmDZutitt5zJRwAQqfWABA6tQaA0Kk1AIROrQEgdGoNAKFTawAInVoDQOjUGgBCp9YAEDq1BoDQqTUAhE6tASB0ag0AoVNrAAidWgNA6NQaAEKn1gAQukQcx3kPp1KpWj0YKFWZTKYo+7UGobhrsHDiGkgmk3nv16zZ+jRbk3VkDZo1W7prsGBcCQeA0Kk1AIROrQEgdGoNAKFTawAInVoDQOjUGgBCp9YAEDq1BoDQqTUAhE6tASB0ag0AoVNrAAidWgNA6NQaAEKn1gAQOrUGgNCpNQCELhHHcbGPAQDYFc+tASB0ag0AoVNrAAidWgNA6NQaAEKn1gAQOrUGgNCpNQCETq0BIHRqDQChU2sACJ1aA0Do1BoAQqfWABA6tQaA0Kk1AIROrQEgdGoNAKFTawAInVoDQOjUGgBCp9YAEDq1BoDQqTUAhE6tASB0ag0AoVNrAAidWgNA6NQaAEKn1gAQOrUGgNCpNQCETq0BIHRqDQChU2sACJ1aA0Do1BoAQqfWABA6tQaA0Kk1AIROrQEgdGoNAKFTawAInVrXK6tXr3733XeLfRTQoFmG1AW1rivt2rVL7GTSpEl1utPevXvPmjVr97cfPXr0qaeeuvPtCxcuPO+881q3bn3ooYdeffXVa9asqdXDhEI44IADqpZeWVnZMccc8+CDD+Z9b1WLpbKyMpFI7KLHliF1Qa3r0AMPPBD/d5dffnmd7nH9+vU1v5PNmzefd955hx122JIlS/70pz+98cYb11xzTW0cHRTamDFjckvviy++GDVq1C233PLYY4/V8D5bt24dx/HRRx9d3QaWIXVBrQvt0Ucfbdas2dKlS6MoWrVq1b777jt+/PhPPvkkkUg8+uij7dq1a9WqVUVFRdWCX7FixYABA1q0aNG+ffthw4ZV3f7RRx+lUqmWLVseeOCB11133caNG3v27LlgwYJBgwZdddVVuxh8++23zzzzzObNm/fo0WPJkiU7H+Hs2bMXL158//3377fffh07drzrrrueffbZOI4LeJKgljVt2vS8887r1atXJpNZuXJlIpEYPnx4q1atBg4cuKeLZfvn1pYhBaPWhVZRUXHGGWeMHDkyiqIRI0Z079590KBBuW/dd999U6ZMmTNnzhtvvDFkyJDcjf3792/ZsuX7778/Y8aM2bNnDx06NIqirVu3nnvuuWVlZYsWLZo5c+bcuXPvuuuu6dOnd+7cefz48WPHjq1ucMOGDX369Dn++OOXL18+fPjw8ePH73yEPXr02Lx5c1lZWe5fV6xYsf/++ycSiQKeJKgTW7ZsadGiRe7rd999d9myZXfffXfei8UypKB2uFRLbWnbtu0Op7px48a5by1cuLB169b3339/q1atFi5cGMfxqlWroijKZDK5DaZOnVpWVrZ27doZM2bsvffeGzduzN0+e/bsRo0arV+/fsaMGWVlZatXr95hp7k/JuI4rm4wm822atVq3bp1udsHDx58yimn7OJRVFZWHn744XfddVdtnx6oc23atKm6El5ZWTl+/PhGjRq98MILK1asiKJo8uTJuW/t6WL59NNPoyh65513LEMKyXPrwr1uvWXLltztHTt2vPXWW4cNG3bzzTd37Nixavuqd5qccMIJmzZtWrRo0fz589etW9esWbPcO2VOOumkbdu2LV68+O23327Xrt3+++9f3a6rG5w/f/6RRx7ZvHnz3GZdu3bdxfF/8cUX/fr169Klyx133FFLpwQK6tprr80tgYMPPnj06NEPPfRQ3759c9/q0KFDDReLZUghqXVxzJs3L4qiN998c/sbmzZtmvti69atURQ1adJky5YtHTt23OFvWMcee2zTpk13fU2susEdNqva485Wr17dq1evdu3aPf30002aNKnZw4XiqHpuvWHDhnnz5m3/Rq1mzZrVcLFYhhSSWhfB73//+yeffHLUqFHPPvtsNputuv2tt97KfTFnzpwWLVoceeSRRx999JIlS5YtW7bDPXTq1Gnp0qW5K3Lbq/qzo7rBLl26LFy48Isvvsj969y5c7/0CJctW3bGGWecddZZjz/+eNUrZ1Av5b1YLEMKqpauqLOjtm3b7vwbXHEcf/755x06dLjppptyr1e1bdt2zZo1udetu3fvvnjx4vfee+8b3/jGsGHD4jjeunVr165de/fu/eGHHy5btuzGG29s3779hg0btm3bduKJJ1522WWrVq1asmTJhRdeeMkll8Rx3K1btxEjRqxZs6a6wY0bN3bq1KmiomL16tUvvvhiy5Ytd37B7NNPPz3qqKNuu+22Qp0qqPPXrbeXe90695aRXayy6hZL1evWliGFpNaFe5dZFEVXX3319ddff9hhh61duzaO488++6x9+/ZDhgzJ1fr222//+te/vt9++w0bNmzTpk25+/nggw8uuOCCffbZZ9999z3nnHPeeeed3O1Lliw599xz99prrzZt2gwcOPCzzz6L4/hXv/pVixYt+vfvv4vBRYsW9erVa6+99urSpcuwYcN2/mPi3nvv3fnIP//888KePyhQrfd0sVTV2jKkkBI1+QW+VCqV9yzb27Rp0+TJk3v16tWyZctiHwv5yGQyRdmvNQjFXYOFU5PUJ5PJvPdr1mx9mq29v0Bbg2bNltIaLBjvMgOA0Kk1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/PLL77333jvuuONHP/pRAVLtSjgADdEtt9zy+OOPz50797HHHnvmmWdy17QnTpx49tlnf/DBB2VlZTts/9hjj6XT6V//+te5cs+aNatz585RFC1evLhv37653gf93BoASs7cuXNzLyRdeOGF1157bRRFv/nNb5588smysrKFCxduf139+uuvf+CBB5o0aXLeeed973vfy90Yx/Gdd945ceLEbt26zZo1q0ePHgMGDKjTA/bcGoAGp3Pnzn/+85+jKJo5c+Zhhx0WRdHrr78+efLkKIomTJhw6aWXRlG0du3aKIo+++yz3PX5v/zlL7nn01EUjRs3rl+/fm3atFm/fn0cx+vWravrA/bcGoAG5+GHH77hhhv++V7rRGLs2LFRFN13330DBw78j//4j+7du//v//2/c0+7p06des8993z3u9/9+c9/XlZWNm7cuCiKKisrn3rqqVzahw4d2rt375tvvrmuD1itAWhwjj/++BkzZmx/S8eOHV999dXtb5k6dWoURR06dJg2bdr2t7du3XrKlCm5r2//lwIcsCvhABA6tQaA0Kk1AIROrQEgdGoNAKFTawAInVoDQOjUGgBCp9YAEDq1BoDQqTUAhE6tASB0ag0AoUvEcZz3cO6jvIHtP7u+kKxBKO4aLJiafmJm7jO685BMJmsyW15ent9sOp02W79nM58tz2821epref9MFpE1aDa02Ya2BgvDlXAACJ1aA0Do1BoAQqfWABA6tQaA0Kk1AIROrQEgdGoNAKFTawAInVoDQOjUGgBCp9YAEDq1BoDQqTUAhE6tASB0ag0AoVNrAAidWgNA6BJxHOc9nEqlavVgoFRlMpmi7NcahOKuwYJpUsP5bDab32AymazJbHl5eX6z6XTaMZut9dki8vNs1mxD4Eo4AIROrQEgdGoNAKFTawAInVoDQOjUGgBCp9YAEDq1BoDQqTUAhE6tASB0ag0AoVNrAAidWgNA6NQaAEKn1gAQOrUGgNCpNQCETq0BIHSJOI7zHk6lUrV6MFCqMplMUfZrDUJx12DBNKnhfDabzW8wmUzWZDYzOs/Z1C3J8vLy/GbT6XSxZot1ns2GrxTXYMn99zUb/my950o4AIROrQEgdGoNAKFTawAInVoDQOjUGgBCp9YAEDq1BoDQqTUAhE6tASB0ag0AoVNrAAidWgNA6NQaAEKn1gAQOrUGgNCpNQCETq0BIHSJOI7zHk6lUrV6MFCqMplMUfZrDUJx12DhxDWQTCbz3q9Zs/VptibryBo0a7Z012DBuBIOAKFTawAInVoDQOjUGgBCp9YAEDq1BoDQqTUAhE6tASB0ag0AoVNrAAidWgNA6NQaAEKn1gAQOrUGgNCpNQCETq0BIHRqDQChU2sACF0ijuO8h1OpVK0eDJSqTCZTlP1ag1DcNVg4cQ0kk8m892vWbH2arck6sgbNmi3dNVgwroQDQOjUGgBCp9YAEDq1BoDQqTUAhE6tASB0ag0AoVNrAAidWgNA6NQaAEKn1gAQOrUGgNCpNQCETq0BIHRqDQChU2sACJ1aA0Do1BoAQpeI47jYxwAA7Irn1gAQOrUGgNCpNQCETq0BIHRqDQChU2sACJ1aA0Do1BoAQqfWABA6tQaA0Kk1AIROrQEgdGoNAKFTawAInVoDQOjUGgBCp9YAEDq1BoDQqTUAhE6tASB0ag0AoVNrAAidWgNA6NQaAEKn1gAQOrUGgNCpNQCETq0BIHRqDQChU2sACJ1aA0Do1BoAQqfWABA6tQaA0Kk1AIROrQEgdGoNAKFTawAInVoDQOjUGgBCp9YAEDq1BoDQqTUAhE6t65XVq1e/++67xT4KaNAsQ+qCWteVdu3aJXYyadKkOt1p7969Z82atfvbjx49+tRTT9359o8//njAgAH77rtv+/bt77nnnlo9RiiQAw44oGrplZWVHXPMMQ8++GDe91a1WCorKxOJxC56bBlSF5rUyb3yLw888MBNN91UyD2uX7++Vu6nvLy8Q4cOS5cuXbhw4bnnnnvIIYdcddVVtXLPUEhjxoy55pproijavHnzH/7whwsvvHC//fa74ooranKfrVu3juN4FxtYhtQFz60L7dFHH23WrNnSpUujKFq1atW+++47fvz4Tz75JJFIPProo+3atWvVqlVFRUXVgl+xYsWAAQNatGjRvn37YcOGVd3+0UcfpVKpli1bHnjggdddd93GjRt79uy5YMGCQYMG5ZZ0dYNvv/32mWee2bx58x49eixZsmTnI1y0aNG0adNGjx7dqlWr7t27n3322X/5y18KeIag9jVt2vS8887r1atXJpNZuXJlIpEYPnx4q1atBg4cuKeLZfvn1pYhBaPWhVZRUXHGGWeMHDkyiqIRI0Z079590KBBuW/dd999U6ZMmTNnzhtvvDFkyJDcjf3792/ZsuX7778/Y8aM2bNnDx06NIqirVu3nnvuuWVlZYsWLZo5c+bcuXPvuuuu6dOnd+7cefz48WPHjq1ucMOGDX369Dn++OOXL18+fPjw8ePH73yERx555LZt29q0abNly5Y//ksqlSrsSYI6sWXLlhYtWuS+fvfdd5ctW3b33XfnvVgsQwoqpm60bdt2h1PduHHj3LcWLlzYunXr+++/v1WrVgsXLozjeNWqVVEUZTKZ3AZTp04tKytbu3btjBkz9t57740bN+Zunz17dqNGjdavXz9jxoyysrLVq1fvsNPcHxNxHFc3mM1mW7VqtW7dutztgwcPPuWUU6p7CJ07d27WrFnPnj1XrVpVB2cI6labNm3GjBmT+7qysnL8+PGNGjV64YUXVqxYEUXR5MmTc9/a08Xy6aefRlH0zjvvWIYUkufWdeiBBx7Y/lxv2bIld3vHjh1vvfXWYcOG3XzzzR07dqzavuqdJieccMKmTZsWLVo0f/78devWNWvWLPdOmZNOOmnbtm2LFy9+++2327Vrt//++1e36+oG58+ff+SRRzZv3jy3WdeuXXdx/O++++7q1av33nvv8847r5ZOCRTUtddem1sCBx988OjRox966KG+ffvmvtWhQ4caLhbLkEJS6+KYN29eFEVvvvnm9jc2bdo098XWrVv/+Q7AJk22bNnSsWPHHf6GdeyxxzZt2jSRSOzi/qsb3GGzqj1WZ5999rnjjjtee+215cuX5/tYoWiqnltv2LBh3rx5uXec5TRr1qyGi8UypJDUugh+//vfP/nkk6NGjXr22Wez2WzV7W+99Vbuizlz5rRo0eLII488+uijlyxZsmzZsh3uoVOnTkuXLs1dkdte1Z8d1Q126dJl4cKFX3zxRe5f586du/PhTZkypVWrVhs3bsz96z/+8Y/GjRu3bt26Zg8aApX3YrEMKahauqLOjtq2bbvDlfCczz//vEOHDjfddFPu9aq2bduuWbMm97p19+7dFy9e/N57733jG98YNmxYHMdbt27t2rVr7969P/zww2XLlt14443t27ffsGHDtm3bTjzxxMsuu2zVqlVLliy58MILL7nkkjiOu3XrNmLEiDVr1lQ3uHHjxk6dOlVUVKxevfrFF19s2bLlzi+YrV+/vlOnTtddd11lZeXf/va3Y4455qqrrirU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des4jo8++ujqNrAMqQtqXWiPPvpos2bNli5dGkXRqlWr9t133/Hjx3/yySeJROLRRx9t165dq1atKioqqhb8ihUrBgwY0KJFi/bt2w8bNqzq9o8++iiVSrVs2fLAAw+87rrrNm7c2LNnzwULFgwaNOiqq67axeDbb7995plnNm/evEePHkuWLKnuODds2FBRUdG9e/eCnBWoW02bNj3vvPN69eqVyWRWrlyZSCSGDx/eqlWrgQMH7uli2f65tWVIwah1oVVUVJxxxhkjR46MomjEiBHdu3cfNGhQ7lv33XfflClT5syZ88YbbwwZMiR3Y//+/Vu2bPn+++/PmDFj9uzZQ4cOjaJo69at5557bllZ2aJFi2bOnDl37ty77rpr+vTpnTt3Hj9+/NixY6sb3LBhQ58+fY4//vjly5cPHz58/Pjx1R3nnXfe+T/+x/+48MILC3VioM5t2bKlRYsWua/ffffdZcuW3X333XkvFsuQgtrhUi21pW3btjuc6saNG+e+tXDhwtatW99///2tWrVauHBhHMerVq2KoiiTyeQ2mDp1allZ2dq1a2fMmLH33ntv3Lgxd/vs2bMbNWq0fv36GTNmlJWVrV69eoed5v6YiOO4usFsNtuqVat169blbh88ePApp5yy88H/9a9/PfDAA1esWHHvvfd+85vfrLOTBHWoTZs2VVfCKysrx48f36hRoxdeeGHFihVRFE2ePDn3rT1dLJ9++mkURe+8845lSCF5bl241623bNmSu71jx4633nrrsGHDbr755o4dO1ZtX/VOkxNOOGHTpk2LFi2aP3/+unXrmjVrlnunzEknnbRt27bFixe//fbb7dq123///avbdXWD8+fPP/LII5s3b57brGvXrjvPbt68+Xvf+96oUaMOOeSQ2j4lUFDXXnttbgkcfPDBo0ePfuihh/r27Zv7VocOHWq4WCxDCkmti2PevHlRFL355pvb39i0adPcF1u3bo2iqEmTJlu2bOnYseMOf8M69thjmzZtmkgkdnH/1Q3usFnVHrc3YsSIdu3affe7362NBwrFVPXcesOGDfPmzbvmmmuqvtWsWbMaLhbLkEJS6yL4/e9//+STT44aNerZZ5/NZrNVt7/11lu5L+bMmdOiRYsjjzzy6KOPXrJkybJly3a4h06dOi1dujR3RW57VX92VDfYpUuXhQsXfvHF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bBfpr+ZqDQBhfB529bwnHABCp9YAEDq1BoDQqTUAhE6tASB0ag0AoVNrAAidWgNA6NQaAEKn1gAQOrUGgNCpNQCETq0BIHRqDQChU2sAGpwlS5Z8+9vf7tmz53nnnffxxx/nbqysrBw4cGCrVq223/KSSy7p+S89evQ44IADoigaOXJkly5dRo0aFUXRtm3b+vbtW1lZWdcH7POtAWhwBg8efPvtt/fq1euPf/zjD3/4wzFjxkRR1K9fv4svvjibzW6/5RNPPJH7YuzYsR9++GEURT/72c8WLFjQuXPnW2+9dezYsf3792/dunVdH3AirsFnbqdSqVo9GChVmUymKPu1BiG/NXjggQeuXLmycePGW7duPfbYYxcsWBBF0cqVKw855JDWrVvv/Fw5juMTTzzxD3/4w0EHHdShQ4eXX365V69ec+bMueKKK1544YVEIhEF/tx6h7+D7L5kMmm2fs+Wl5fnN5tOp0vu8RZRyZ0rsyUxW3Lrd08dd9xxzz33XCqVymQyVVfCDznkkOq2f/7550866aSDDjooiqIRI0Zcfvnl99577x133PGjH/2oAKn2ujUADdHYsWMnTpx49tlnf/DBB2VlZV+5/U9+8pObb7459/UVV1wxa9aszp07R1G0ePHivn37Pv3003V9wF63BqDB+c1vfvPkk0+WlZUtXLjwK6+iv/baa61bt87lOSeO4zvvvHPixIndunWbNWtWjx49BgwYUKcH7Lk1AA3O66+/Pnny5CiKJkyYcOmll37pNmvXrs19cd9991U9sc4ZN25cv3792rRps379+jiO161bV9cHrNYANDj33Xff6NGjTzvttDVr1lx77bVfus2FF14YRdHf//735cuXn3XWWVW3V1ZWPvXUU4MHD46iaOjQob17996h5XXBlXAAGpyOHTu++uqrX/qtqjeET506NbflzJkzt9+gdevWU6ZMyX19+7/U/fF6bg0AwVNrAAidWgNA6NQaAEKn1gAQOrUGgNCpNQCETq0BIHRqDQChU2sACJ1aA0Do1BoAQqfWABC6RBzHeQ+nUqlaPRgoVV/5afZ1xBqE4q7BgqnpJ2Zms9n8BpPJpNn6PVteXp7fbDqdLrnHW0Qld67MlsRsya3fes+VcAAInVoDQOjUGgBCp9YAEDq1BoDQqTUAhE6tASB0ag0AoVNrAAidWgNA6NQaAEKn1gAQOrUGgNCpNQCETq0BIHRqDQChU2sACJ1aA0DoEnEc5z2cSqVq9WCgVGUymaLs1xqE4q7BgmlSw/lsNpvfYDKZNFu/Z8vLy/ObTafTJfd4i6jkzpXZkpgtufVb77kSDgChU2sACJ1aA0Do1BoAQqfWABA6tQaA0Kk1AIROrQEgdGoNAKFTawAInVoDQOjUGgBCp9YAEDq1BoDQqTUAhE6tASB0ag0AoVNrAAhdIo7jvIdTqVStHgyUqkwmU5T9WoNQ3DVYME1qOJ/NZvMbTCaTZuv3bHl5eX6z6XS65B5vEZXcuTJbErMlt37rPVfCASB0ag0AoVNrAAidWgNA6NQaAEKn1gAQOrUGgNCpNQCETq0BIHRqDQChU2sACJ1aA0Do1BoAQqfWABA6tQaA0Kk1AIROrQEgdGoNAKFLxHGc93AqlarVg4FSlclkirJfaxCKuwYLpkkN57PZbH6DyWTSbP2eXXxHZX6zR9zTuuQebxGV3LkyW7BZa7A+cSUcAEKn1gAQOrUGgNCpNQCETq0BIHRqDQChU2sACJ1aA0Do1BoAQqfWABA6tQaA0Kk1AIROrQEgdGoNAKFTawAInVoDQOjUGgBCp9YAELpEHMd5D6dSqVo9GChVmUymKPu1BqG4a7Bw4hpIJpN579es2fo0W5N1ZA2aNVu6a7BgXAkHgNCpNQCETq0BIHRqDQChU2sACJ1aA0Do1BoAQqfWABA6tQaA0Kk1AIROrQEgdGoNAKFTawAInVoDQOjUGgBCp9YAEDq1BoDQqTUAhC4Rx3GxjwEA2BXPrQEgdGoNAKFTawAInVoDQOjUGgBCp9YAEDq1BoDQqTUAhE6tASB0ag0AoVNrAAidWgNA6NQaAEKn1gAQOrUGgNCpNQCETq0BIHRqDQChU2sAiAL3/wGBCkd/SLfXfAAAAABJRU5ErkJggg=="
            },
            {
              "type": "input_text",
              "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
            }
          ],
          "solved_count": 0,
          "total_training_examples": 4,
          "pixel_accuracy": 0.8979289940828402
        },
        "test_result": {
          "correct": false,
          "pixel_accuracy": 0.8994082840236687,
          "total_pixels": 169,
          "correct_pixels": 152,
          "error": null
        },
        "status": "failed_test"
      }
    ],
    "total_turns": 1,
    "conversation_history": [
      {
        "role": "system",
        "content": "You are an expert at solving abstract reasoning puzzles. Write clean, efficient Python code."
      },
      {
        "role": "user",
        "content": [
          {
            "type": "input_text",
            "text": "You are solving an ARC (Abstraction and Reasoning Corpus) task. \nI will show you training examples with input and output grids, plus a test input grid. Your task is to:\n\n1. **Analyze the training examples** to discover patterns that map input grids to output grids\n2. **Write a Python program** that implements your best understanding of the transformation  \n3. **DO NOT predict or generate the test output** - your job is only to write the transformation program\n4. **Attempt a solution** - even if the pattern isn't completely clear, provide your best hypothesis\n5. **Do not repeat the same transformation** - if you have already tried a transformation, do not repeat it.\n\n**IMPORTANT: Your transformation must always produce a 13\u00d713 output grid.**\n\nThe test input is shown for context so you understand what type of grid your program will eventually process. Focus on learning patterns from training examples and writing code that captures your understanding.\n\nTraining Examples:\n\nExample 1:\nInput:\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 2 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 4 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 3 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\nOutput:\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 2 5 5 5 5 5 5 5 5 5 0 0\n0 0 0 0 0 0 0 0 0 0 5 0 0\n0 0 0 0 0 0 0 0 0 0 5 0 0\n0 0 0 0 0 0 0 0 0 0 5 0 0\n0 0 0 5 5 5 5 5 5 5 4 0 0\n0 0 0 5 0 0 0 0 0 0 0 0 0\n0 0 0 5 0 0 0 0 0 0 0 0 0\n0 0 0 5 0 0 0 0 0 0 0 0 0\n0 0 0 5 0 0 0 0 0 0 0 0 0\n0 0 0 3 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n\nExample 2:\nInput:\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 3 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 2 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 4 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\nOutput:\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 3 0 0 0 0 0 0 0\n0 0 0 0 0 5 0 0 0 0 0 0 0\n0 0 0 0 0 5 0 0 0 0 0 0 0\n0 0 0 0 0 5 0 0 0 0 0 0 0\n0 0 0 0 0 5 0 0 0 0 0 0 0\n0 0 0 0 0 5 0 0 0 0 0 0 0\n0 0 0 0 0 5 0 0 0 0 0 0 0\n0 0 5 5 5 5 5 5 5 5 5 2 0\n0 0 5 0 0 5 0 0 0 0 0 0 0\n0 0 4 5 5 5 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n\nExample 3:\nInput:\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 4 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 3 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 2 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\nOutput:\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 4 5 5 5 5 5 5 5 5 5 5 0\n0 5 0 0 0 0 0 0 0 0 0 5 0\n0 5 0 0 0 0 0 0 0 0 0 5 0\n0 5 0 0 0 0 0 0 0 0 0 3 0\n0 5 0 0 0 0 0 0 0 0 0 0 0\n0 5 0 0 0 0 0 0 0 0 0 0 0\n0 5 0 0 0 0 0 0 0 0 0 0 0\n0 5 0 0 0 0 0 0 0 0 0 0 0\n0 5 0 0 0 0 0 0 0 0 0 0 0\n0 5 5 5 5 2 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n\nExample 4:\nInput:\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 4 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 2 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 3 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\nOutput:\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 5 4 0 0\n0 0 0 0 0 0 0 0 0 5 5 0 0\n0 0 0 0 0 0 0 0 0 5 5 0 0\n0 0 0 0 0 0 0 0 0 5 5 0 0\n0 0 2 5 5 5 5 5 5 5 5 0 0\n0 0 0 0 0 0 0 0 0 5 0 0 0\n0 0 0 0 0 0 0 0 0 5 0 0 0\n0 0 0 0 0 0 0 0 0 5 0 0 0\n0 0 0 0 0 0 0 0 0 5 0 0 0\n0 0 0 0 0 0 0 0 0 5 0 0 0\n0 0 0 0 0 0 0 0 0 3 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n\nTest Input:\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 4 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 2 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 3 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0\n\nAnalyze the patterns in the training examples and write a Python function that performs this transformation.\n\n**Approach Guidelines:**\n- Look for patterns in shapes, colors, positions, sizes, rotations, reflections, etc.\n- Even if you can't solve all training examples perfectly, implement what patterns you do observe\n- A partial solution that captures some aspects is better than returning the input unchanged\n- If the pattern is unclear, make your best educated guess based on what you can see\n\nRequirements:\n- The function takes a 2D list (grid) where grid[row][col] gives the value at that position\n- Values are integers from 0-9\n- Return a new grid (2D list) with the transformation applied\n- You can use numpy if needed - just add 'import numpy as np' at the start of your function\n- Aim to handle the training examples as well as possible, even if not perfectly\n- Your function should attempt some meaningful transformation based on the patterns you observe\n\nYou MUST end your response with the following exact format:\n\nFinal answer:\n```python\ndef transform(grid):\n    # Your transformation logic here (implement your best understanding)\n    return transformed_grid\n```\n"
          },
          {
            "type": "input_image",
            "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAmwAAAZZCAIAAABvD9p/AABHcklEQVR4nO3de5hUhZng/1PaXOQiaJzxgpGmIYskJGiI15ioAeOMiXpqgjFp3bVRvMxIElYNJnnU7Jp4A2eyibfBoGiCbYKup59xwuNOcB4SszsmRIlGsAUNKgiJguAdu4Hze37Tz/awqKR5q6XqFJ/PM3/g6XrrnCp555s63Ugpz/MEANhxuwVmAAARBYA4EQWAIBEFgCARBYAgEQWAIBEFgCARBYAgEQWAIBEFgCARBYAgEQWAIBEFgGpEdOrUqaX3duaZZ77rY/r27bvffvudcsopjz766Duf8+c//3mpVNp77703bty4zZfuvffeUqk0e/bsrn9saWkplUozZ87c5mGrVq0qlUqXXXZZJVNdNm7cOGvWrOOPP/6AAw7o16/fAQcccNpppz300EOx92TixIlJkqxbt+6AAw7Ya6+9Vq1atc3s3/zN3/Tt2/e3v/1tD9+QL33pS6VSqaGh4aWXXnrnlYwdO7ZUKrW0tHT945QpU7a+mN13333PPfc84ogjbrvttu6RNE1LpdI7T9TDl9Zl7dq106dPP/jgg/fYY4+hQ4ceffTRt9xyy+bNm7fzpgEUVBU+iXZ2dv7pT3+6//77jz/++D/84Q/bfPX2229PkmT9+vU//elPe/JsV1xxRXt7+45eQ0+mnn322aOOOuqCCy5YuHDhmjVrOjo61qxZc++9937605/+h3/4hyTqAx/4wO23375hw4bJkydv/ffQ3XTTTVmWXX311Z/4xCd26A3ZvHnzfffdt83B3//+90uWLNnOZWzZsuW11177zW9+M2XKlBkzZiS95KWXXjrssMNmzpz51FNPbdy48ZVXXvm3f/u3v/u7vzvttNP8pXtA/akoojfeeGP+f91zzz1JksyZM6f7yNy5c7sfuWLFiu7jGzdufPLJJ5ubm1999dVbbrll6yfcsGFDW1vbaaedtvfee//jP/5jT66ho6OjpaVlRz/o/Nmpzs7OSZMm/e53vzv66KP/6Z/+ae3atZ2dnc8///zNN9+89957T58+/YknntjO82/9erstWLCg66t/9Vd/deGFFy5YsODGG2/sOvLYY49dfPHFn/3sZy+++OIdekN233330aNHz5s3b5vjP/nJTz7ykY+88/Fr1qzpupgtW7a8/vrrra2t/fv3v+qqq95+++3tvmE9fWk/+MEPnn322UmTJj322GNvvPHGhg0b/vVf//XQQw/Nsuz+++/v4SkAiqIKn0T79et38MEHX3fddUmSbPNJtLW1dePGjeeff/7kyZMffvjhxx9//M8+21e+8pVf//rXf//3f79D1/Bnp+68885HHnlk4sSJv/zlL08++eQPfOADDQ0NH/zgB//2b//2vvvu27x58913351UYObMmQcffPCll1761FNPvf7661/84heHDBnyox/9qFQq7egb8sUvfvEXv/jFiy++uPXBn/70p6effvp2LqBUKg0cOPDLX/7yl770pVdffXXZsmVJb2hvb29oaJg7d+7HPvaxAQMGDBky5Pjjj+/6oPzAAw90PeaOO+4olUrd/wMCoLiqENG33357yZIlF110UZIk/+k//aetvzRnzpwxY8Z85jOf+du//dvdd9+9Jx9Gr7766lGjRl1xxRVPPvlkz6/hz061traWSqVbb71199133+ZLxx577NKlS7/73e8mFdhjjz3uuuuuTZs2nXnmmRdccMHy5ct/9KMf7bvvvts8rCdvyBe/+MVt7uj+5je/eeaZZ774xS/25Eq6PoO+82XGjBs3btOmTVmWbX2wsbExz/Obb765V04BsMtFdMSIEd0/hNK/f/+xY8fec889++yzz9e+9rXuxzzxxBO//e1vv/71r5dKpZEjR5522ml33XXX66+/vv1nHjBgwJw5czo7O3fopu6fnVq8ePGYMWNGjBjxruNjxozZ5iPjdl5vt4ULF279mI9//OP/7b/9t9/+9rd33XXXRRdddOKJJ27zJD18Q8aOHfvhD3+463Z6l5/85Cef+MQnRo4cuZ0r3Lx58+rVq7///e/PmzfvL//yL0ePHr2dB/f8pU2bNu2YY4758pe/3NTUNGXKlFtvvfWd35ptaWnJ83zq1Kk9PCNAzarOH3EZNmzY2Wef/dhjj+23337dB2+//fZhw4adccYZXf/4zW9+87XXXuvJXdNjjjnmq1/96m9+85vrr7++59ewnanOzs4NGzZs87lwm59NbWxsTCp26qmndsX4mGOOeedXe/6GbH1HN8/zefPmvde93P3337/r+hsaGoYNGzZt2rTNmzdfffXVvfVJdNCgQQsXLpw7d+64cePa2trOP//8sWPHjhgx4s477+yV5wfYFSPa9dMoHR0dP/nJTwYPHvyhD33o2muvPeCAA7of0NnZOXfu3BdeeKFfv35d/19+3LhxeZ738MeLrr766g996EPf/va3ly5d2vOreq+pPn36DB48+F3/3EglP31z3HHHbf2YjRs3Njc3DxkyZPDgweeff/4239TcoTfk9NNP776j+8tf/nL16tV/9l7ubrvttvfee0+YMKGtre2cc87pxZe2++67n3HGGVmWrV27dvny5XPmzNl3331bWlq+973v9fwsAIWwUz+J9unT5/TTT//pT3/6i1/84q/+6q+2/vOI//zP//yu0Xr00UcXLVr0Z595jz32CNzU3c7URz/60aVLlz7//PPv+qPI48ePTyo2bdq0xx9//Af/7sUXXzz77LO3/uoOvSEHH3zwRz/60a6f0f3pT3965JFHHnTQQe960u6fzt28efO6desWLFhw6qmnJu+bUaNGtbS0/OpXvzr00EMr/C4yQA2qwu3cv/7rv/7KV77y6KOPXnLJJd0Hb7/99v79+7/yyitbf775P//n/yRJMmvWrJ487Sc/+cmvfe1rixYteud/SCEwdcYZZ2zZsuXv/u7v3jXJlf+Rx3vuuWfWrFnNzc3/+T//55aWli984Qs/+9nPtv4DPzv6hpx++um//OUvu/4k6/Z/Lvf988ILL5RKpSlTpmxzvKGh4aMf/eiGDRs6OjqqcmEAdfU90auvvvqggw665ZZbfv3rXydJ8sc//vGBBx44+eST99xzz60fdtRRR40ePfruu+9+5ZVXevK0V1111Yc+9KEd/SnQd52aMmXK+PHjf/aznx1++OHz5s374x//2NnZ2ZWoz33uc48++uhuu8XfuhUrVpx77rkjRozoruasWbP233//iy++uOs/ARF4Q7ru6E6bNm3t2rWnnXZaUg3Dhg37+Mc/fvvtt0+dOvXf/u3f/vSnP23cuPGZZ565+eab77nnnsMPP7xv375VuTCAuorowIEDb7jhhi1btpx//vmbNm360Y9+tGnTpu6foNnaWWed9eabb/74xz/u+e3Z7f/cbA+n+vbt29bWdtRRRz366KOnn376/vvv37dv367/7N/8+fNHjx69/f+g0rv+CGupVHr99dc7OztPP/30N95446677upu5Ac+8IE77rhj48aNZ5xxRmdnZ+ANGTVq1KGHHjpv3rxPfepTW3+zOWCPPfbY5rLvuOOOnry0rg/QQ4cOvemmm44++uj99ttvjz32GDVq1IUXXtjQ0ND9B0P9OVGgblTtP0B/yimnpGn62GOP/Y//8T/uuOOOvfba66//+q/f+bD/8l/+y2677dbDO7pdt2enTZu2oxfzrlMHHnjgQw89NHfu3JNOOunAAw/s27fvvvvue9JJJ915551PPPHEYYcdloR84xvfWLRo0be//e2jjjpq6+Of/exnp06d+uijj1522WWxN6TrLm4P/3jo+2TcuHFLliy5+OKLx44du+eee/bt27exsfG88877/e9/3yvfSAaoKSX/RVMAiPFXoQFAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiNandevWtbe3V/sqgF5YSetcy0S0+tI0bWlp6d3nnDhx4sMPP/xeX92wYUNTU9N2HgC8l5UrV5577rnDhg3r379/U1PTJZdc8vLLL1e4kpXMWufqEtH69NZbb73Xl1auXDlx4sQVK1bs3CuCerBs2bLx48evX79+/vz5L7/88n333ffkk0+OHz9+zZo14ZX8s6xzLRPRGrJ27dpSqXTTTTc1Njb279//xBNPfOGFF7qP33bbbQceeOCQIUPOOeecrqVatWpVqVR69tlnu8avv/76I488MkmS44477qmnnpo8efKUKVO2OcXPfvazsWPHjh8/vhqvDwpvypQpxx577L333jtu3LgBAwYccsgh999//3777ffVr361hytpneuMiNacO++888EHH2xvb1+9evWVV17ZfXzGjBkPPPDA4sWLH3nkkalTp27nGRYuXDh69Og5c+bMnj17my/169dvwYIFN9100/t2+VC3nnvuuYceemib7dttt92mTZvW1ta2fv36nq+kda4bIlpzLr/88pEjRzY2Nra0tCxatKj7+HXXXTd27NimpqaZM2fOnTv3jTfeCDz5xIkTDzvssF69XthVLF26NEmSMWPGbHN83LhxmzZtevrpp3v+VNa5bohozWlsbOz6xcCBAzs7O7uPd93bSZLkkEMO6ejoeOaZZ6p0gbCLKpVKSZJs3rx5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KZfL4VmoJ1mWJUVjf6Hy/W1IKtPW1hYbTNO0WrN/uGxDbLbpu0OL+HrN7oTZgirc+2x/zdba/rqdCwBBIgoAQSIKAEEiCgBBIgoAQSIKAEEiCgBBIgoAQSIKAEEiCgBBIgoAQSIKAEEiCgBBIgoAQSIKAEEiCgBBIgoAQSIKAEGlPM+js0m5XA7PQj3JsiwpGvsLvbC/eQXSNA2f16zZeprNC6iI77NZs+/HbCV75HYuAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABJXyPI/OAsAuzSdRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgS0fq0bt269vb2al8F0AsraZ1rmYhWX5qmLS0tvfucEydOfPjhh995fPny5Z///OeHDh26//77n3/++a+++mrvnhfq3sqVK88999xhw4b179+/qanpkksuefnll8Mr2RPWuZaJaH1666233nmws7Pz85//fGNj44oVKx566KFHHnnkggsuqMbVQVEtW7Zs/Pjx69evnz9//ssvv3zfffc9+eST48ePX7NmTWAle8g617Scajv11FPPOuusPM9feumlJEluvPHG4cOH9+vX77Of/eyqVau6j8+ePXvYsGF77rnn2Wef/eabb+Z5vnLlyiRJVqxY0fU8M2fOPOKII/I8P/bYY7v+5Z5zzjlbn+h//+//3dDQ8Pbbb3f94z/90z8NGDBgy5Yt1XjRUEif+tSnJk2atPWRzZs3H3nkkV0He7KS1rnO+CRac+68884HH3ywvb199erVV155ZffxGTNmPPDAA4sXL37kkUemTp26nWdYuHDh6NGj58yZM3v27K2PH3300Z2dnX379u36xzVr1uy9996lUul9eylQV5577rmHHnpom+3bbbfdpk2b1tbWtn79+p6vpHWuGyJacy6//PKRI0c2Nja2tLQsWrSo+/h11103duzY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PD/22GO7/uWec845W5/o6aefLpVKa9eu7frH0047bfLkydV4xVBUn/rUpyZNmrT1kc2bNx955JFdB3uykta5zvgkWnPuvPPOBx98sL29ffXq1VdeeWX38RkzZjzwwAOLFy9+5JFHpk6dup1nWLhw4ejRo+fMmbPN/zIdOXLkli1bPvCBD2zatOnBf1cul9/PlwJ15bnnnnvooYe22b7ddttt2rRpbW1t69ev7/lKWue6IaI15/LLLx85cmRjY2NLS8uiRYu6j1933XVjx45tamqaOXPm3Llz33jjjfApxo4d+7nPfe5jH/vYUUcd1UtXDfVv6dKlSZKMGTNmm+Pjxo3btGnT008/3fOnss51Q0RrTmNjY9cvBg4c2NnZ2X38yCOP7PrFIYcc0tHR8cwzz4RP0d7evm7dugEDBnz+85+v+HphV1EqlZIk2bx58zbH33777R19KutcN0S05vTp06f713mev/N41w43NDR0rXS3d+72dgwcOPCyyy779a9/vXr16t64aqh/XZ9Buz6Pbq29vb2hoWHUqFE9X0nrXDdEtDAef/zxrl8sXrx40KBBI0eO7Nu3b5Ik3TeCnn/++e4Hb7OQXR544IEhQ4Z0/6/ml19+effddx86dOhOuXwovOHDh0+YMOHaa6/d+uCWLVtmzJhxyimn7LXXXj1fSetcN0S0MKZPn75ixYrly5dfeuml5513Xr9+/fbZZ58RI0bMmjXrzTffXLBgwd1339394IEDB65evfq1117b+hmOO+64/fbb76KLLnrllVcef/zxr3/965MnTx4wYEA1Xg0U0q233rpkyZIzzzxz2bJlnZ2dS5cunTRp0osvvnjDDTckSdLzlbTO9aPaPx7Mtn/E5cknn+w6fsstt3zkIx/pPv6Nb3xj+PDhe+2110UXXdTR0dH1mAcffHDMmDH9+vX79Kc/3f0z8Xme//CHPxw0aNAXvvCFbc719NNPn3TSSXvuuedBBx30zW9+86233tq5rxUKb82aNRdeeOFBBx3Ur1+/xsbGadOmdf85k56spHWuM6Wtv+u2o/xE9c7R0dExf/78CRMmDB48uNrXwrvLsiwpGvtbFda53va3kgKnaRo+r9meO+mkk6pyXrM9lxdQEd9ns2ZrbX99TxQAgkS0ALp+bA+AWiOiABAkogAQJKIAECSiABAkogAQJKIAECSiABAk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gkQUAIJEFACCRBQAgkQUAIJEFACCRLQ+rVu3rr29vdpXAfTCSlrnWiai1ZemaUtLS+8+58SJEx9++OHtPGDq1KnHHXdc754UdgUrV64899xzhw0b1r9//6ampksuueTll1+ufCUrmbXOVSSi9emtt97azld/9atf3XzzzTvxcqBOLFu2bPz48evXr58/f/7LL7983333Pfnkk+PHj1+zZk0lK1nJrHWuLhGtIWvXri2VSjfddFNjY2P//v1PPPHEF154ofv4bbfdduCBBw4ZMuScc87pWqpVq1aVSqVnn322a/z6668/8sgjkyQ57rjjnnrqqcmTJ0+ZMuWdZ9m4ceM555zziU98Yqe/Pii8KVOmHHvssffee++4ceMGDBhwyCGH3H///fvtt99Xv/rVHq6kda4zIlpz7rzzzgcffLC9vX316tVXXnll9/EZM2Y88MADixcvfuSRR6ZOnbqdZ1i4cOHo0aPnzJkze/bsd371iiuu+MhHPvI3f/M378/lQ9167rnnHnrooW22b7fddps2bVpbW9v69et7vpLWuW6IaM25/PLLR44c2djY2NLSsmjRou7j11133dixY5uammbOnDl37tw33ngj8OSLFi2644473PyBgKVLlyZJMmbMmG2Ojxs3btOmTU8//XTPn8o61w0RrTmNjY1dvxg4cGBnZ2f38a57O0mSHHLIIR0dHc8888yOPnNnZ+fZZ589c+bM/fbbr/euF3YVpVIpSZLNmzdvc/ztt9/e0aeyznVDRGtOnz59un+d5/k7j3ftcENDQ9dKd3vnbm/jqquuOvDAA88666zevmTYJXR9Bu36PLq19vb2hoaGUaNG9XwlrXPdaKj2BdBTjz/++PHHH58kyeLFiwcNGjRy5MhXX301SZLuG0HPP/9894O3Wcgu995775IlS7b+UqlUWrly5YEHHrhTXgEU2/DhwydMmHDttddOmDCh++CWLVtmzJhxyimn7LXXXps2berhSlrnuuGTaGFMnz59xYoVy5cvv/TSS88777x+/frts88+I0aMmDVr1ptvvrlgwYK77767+8EDBw5cvXr1a6+9tvUzPPHEE/n/dc011xx77LF5nls56Llbb711yZIlZ5555rJlyzo7O5cuXTpp0qQXX3zxhhtuSJKk5ytpneuGiBbGxIkTjz/++COOOOKEE0649tpru/6H5+zZ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KAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAElfI8j84CwC7NJ1EACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQCoRkSnTp1aem9nnnnm9h8zceLE7qdau3bt9OnTDz744D322GPo0KFHH330Lbfcsnnz5p6faBv33ntvqVSaPXt21z+2tLSUSqWZM2du87BVq1aVSqXLLrus6x+nTJmy9TPvvvvue+655xFHHHHbbbdt86qfffbZbZ6qvb29VCpdcsklsQsGoHAakhrw0ksvHX744d1Z2rhx47/9u5///Of/83/+z1Kp1FsnuuKKK04++eSDDz64h4/fsmXLa6+99pt/t27duunTp/fWlQCwq38SvfHGG/P/65577kmSZM6cOd1H5s6d2/3IFStW5O+wYMGCrq/+4Ac/ePbZZydNmvTYY4+98cYbGzZs+Nd//ddDDz00y7L7779/h060fR0dHS0tLd0fcN/LmjVrup55y5Ytr7/+emtra//+/a+66qq33367198ZAIqrJr4n2t7e3tDQMHfu3I997GMDBgwYMmTI8ccff9999yVJ8sADD/Tiib7yla/8+te//vu///sePr5UKg0cOPDLX/7yl770pVdffXXZsmW9eDF33HFHqVS68cYbe/E5AdjlIjpu3LhNmzZlWbb1wcbGxjzPb7755l480dVXXz1q1KgrrrjiySef3KHBrs+gu+++ey9eDABFt5MiOmLEiHf+fM3ChQu7vjpt2rRjjjnmy1/+clNT05QpU2699dYlS5a8H5cxYMCAOXPmdHZ29uSmbpIkmzdvXr169fe///158+b95V/+5ejRo3vxYlpaWvI8nzp1ai8+JwC73CfRQYMGLVy4cO7cuePGjWtrazv//PPHjh07YsSIO++8s9fPdcwxx3z1q1/9zW9+c/3117/XY/bff/+uzDc0NAwbNmzatGmbN2+++uqrfRIFoAoRfdcfLDruuOO6H7D77rufccYZWZatXbt2+fLlc+bM2XfffVtaWr73ve/1+sVcffXVH/rQh7797W8vXbp0+4/cbbfd9t577wkTJrS1tZ1zzjldBxsa/v8fae7s7NzmwV1Hur4KwK6gJj6JbmPUqFEtLS2/+tWvDj300O9+97u9/vx77LHH9m/qdv907ubNm9etW7dgwYJTTz21+6tDhgxJkuTFF1/cZuqPf/xj91cB2BVUP6IvvPBCqVSaMmXKNscbGho++tGPbtiwoaOjo9dP+slPfvJrX/vaokWL3vmfX/izRowY8a4/Ntx1pKmpqfcuE4CaVv17j8OGDfv4xz9+++239+/f/4wzzmhqahoyZMgLL7zwv/7X/7rnnnsOP/zwvn37vh/nveqqq/75n/858NO/J5xwQp8+fWbMmDFkyJAzzjjjL/7iL/70pz/95Cc/ueGGGwYMGPCZz3zm/bhaAGpQNX86t1Qqvf7660mS3H777UOHDr3pppuOPvro/fbbb4899hg1atSFF17Y0NDw/v0xyq6buoH/HNKwYcP++3//7x0dHV//+tcPOOCAPn36HHjggZdccsmmTZv+4R/+4S/+4i96+Dz+nChA0dXKnxNdsmTJxRdfPHbs2D333LNv376NjY3nnXfe73//+/Hjx79/5/3kJz85bdq0wOA3v/nNtra2E088cd999+3Tp8/+++9/8sknL1iw4Pzzz38fLhOAGlXK87za1wAAhVQTn0QBoIhEFACCRBQAgkQUAIJEFACCRBQAgkQUAIJEFACCRBQAgkQUAIJEFACCRBQAgkQUAIJEFACCRBQAgkQUAIJEFACCRBQAgkQUAIJEFACCRBQAgkQUAIJEFACCRBQAgkQUAIJEFACCRBQAgkQUAIJEFACCRBQAgkQUAIJEFACCRBQAgkQUAIJEFACCRBQAgkQUasW6deva29vr71xQx0QUKjJp0qTSu1mwYMGOPtXEiRMffvjhdx5P07SlpaWXrvfPnAvYISIKFbn33nvzfzdnzpyBAwd2/TrP84kTJ+7oU7311lvvzzVW+VxQx0QU3kdr1qyZNGnSoEGDPvjBD1500UXd6frHf/zHpqamwYMHH3bYYffdd1+SJMcdd9xTTz01efLkKVOmvNezrV27tlQq3XTTTY2Njf379z/xxBNfeOGF7uO33XbbgQceOGTIkHPOOafrRKtWrSqVSs8++2zX+PXXX3/kkUf28FxAT4govI++8IUvDB48+Nlnn/3FL36xaNGi//pf/2uSJI8//vj06dPvvffetWvXfu1rX2tubl6/fv3ChQtHjx49Z86c2bNnb/8577zzzgcffLC9vX316tVXXnll9/EZM2Y88MADixcvfuSRR6ZOnbqdZ+j5uYDtE1F4v/zyl7987LHHZs2atc8++zQ1NX3ve9/74Q9/uHHjxueeey5JkoEDB/br1+/MM8/cuHHjXnvt1fOnvfzyy0eOHNnY2NjS0rJo0aLu49ddd93YsWObmppmzpw5d+7cN9544/15WcB/EFF4vyxduvTNN9/s169f148aHXbYYVu2bPnDH/5wwgknHH744WPGjDn88MO/853vrFq1aoeetrGxsesXAwcO7Ozs7D7edas2SZJDDjmko6PjmWee6dVXA7wLEYX3y6ZNm0aNGpX/vz784Q/379//5z//+a9+9asJEyb8+Mc/PvTQQ5cvX97zp+3Tp0/3r/M8f+fxzZs3J0nS0NBQKpW2Huw6DvQiEYX3y8EHH7xixYp3/aBZKpWOPvroa665ZunSpQMGDPiXf/mXroOVnO7xxx/v+sXixYsHDRo0cuTIvn37JknSfV/3+eef3/oCKjkX0EVE4f3ymc985mMf+9jkyZNXrlz5wgsvTJs27aCDDnr77bd//OMfNzY2PvHEEx0dHQ899NCLL7748Y9/vOv27OrVq1977bXY6aZPn75ixYrly5dfeuml5513Xr9+/fbZZ58RI0bMmjXrzTffXLBgwd1339394ArPBXQRUXi/7Lbbbm1tbQMHDhwzZsyHP/zhp5566l/+5V+6fpjorLPOOumkkwYPHnzeeefdfPPNRx11VJIkF1xwwTXXXDN58uTY6SZOnHj88ccfccQRJ5xwwrXXXtv1cXP27NkLFizYe++9v/Od73zrW9/qfnCF5wK6lLb+ngpsrVwuV/sS6JGOjo758+dPmDBh8ODB1b6W+pRlWbUvgVq1zU89QLc0TcO/r8yarafZau8itcvtXAAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgq5XkenaXOlcvlal8C1IQsy6p9CdSqHN5Dmqbh31dmzdbTbLV3kdrldi4ABIkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAElfI8j85S58rlcrUvAWpClmXVvgRqVQ7vIU3T8O8rs2a3M5s/ncT+r1rXXO1dpHa5nQsAQSIKAEEiCgBBIgoAQSIKAEEiCgBBIgoAQSIKAEEiCgBBIgoAQSIKAEEiCgBBIgoAQSIKAEEiCgBBIgoAQSIKAEEiCgBBpTzPo7PUuXK5XO1LgJqQZVm1L4FalcN7SNM0/PvKrNl6mq32LlK73M4FgCARBYAgEQWAIBEFgCARBYAgEQWAIBEFgCARBYAgEQWAIBEFgCARBYAgEQWAIBEFgCARBYAgEQWAIBEFgCARBYAgEQWAoFKe59FZ6ly5XK72JUBNyLKs2pdArcrhPaRpGv59ZdZsPc1WexepXW7nAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQJCIAkCQiAJAkIgCQFApz/PoLHWuXC5X+xKgJmRZVu1LoEY1VPsCqGltbW2xwTRNs1dWx2bLQw6o5Lxmzfb6LLwXt3MBIEhEASBIRAEgSEQBIEhEASBIRAEgSEQBIEhEASBIRAEgSEQBIEhEASBIRAEgSEQBIEhEASBIRAEgSEQBIEhEASBIRAEgqJTneXSWOlcul6t9CVATsiyr9iVQq3J4D2mahn9fmTVbT7PV3kVql9u5ABAkogAQJKIAECSiABAkogAQJKIAECSiABAkogAQJKIAECSiABAkogAQJKIAECSiABAkogAQJKIAECSiABAkogAQJKIAEFTK8zw6S50rl8vVvgSoCVmWVfsSqFU5vIc0TcO/r8yarafZau8itcvtXAAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgq5XkenaXOlcvlal8C1IQsy6p9CdSqHN5Dmqbh31dmzdbTbLV3kdrldi4ABIkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAEiSgABIkoAASJKAAElfI8j85S58rlcrUvAWpClmXVvgRqVQ7vIU3T8O8rs2brabbau0jtcjsXAIJEFACCRBQAgkQUAIJEFACCRBQAgkQUAIJEFACCRBQAgkQUAIJEFACCRBQAgkQUAIJEFACCRBQAgkQUAIJEFACCRBQAgkp5nkdnqXPlcrnalwA1Icuyal8CtSqH95Cmafj3lVmz9TRb7V2kdrmdCwBBIgoAQSIKAEEiCgBBIgoAQSIKAEEiCgBBIgoAQSIKAEEiCgBBIgoAQSIKAEEiCgBBIgoAQSIKAEEiCgBBIgoAQSIKAEGlPM+js9S5crlc7UuAmpBlWbUvgRrVUO0LoKa1tbXFBtM0NbtzZv9w2YbYbNN3hxbx9VZlFt6L27kAECSiABAkogAQJKIAECSiABAkogAQJKIAECSiABAkogAQJKIAECSiABAkogAQJKIAECSiABAkogAQJKIAECSiABAkogAQVMrzPDpLnSuXy9W+BKgJWZZV+xKoVTm8hzRNw7+vzJqtp9lq7yK1y+1cAAgSUQAIElEACBJRAAgSUQAIElEACBJRAAgSUQBIYv4/+PHkwOW6/KkAAAAASUVORK5CYII="
          },
          {
            "type": "input_text",
            "text": "Above is a visual representation of all the training examples and the test input. Each grid cell is colored according to its value (0-9), with clear labels and arrows showing input\u2192output transformations. Use both the textual and visual information to understand the pattern."
          }
        ]
      },
      {
        "type": "message",
        "role": "assistant",
        "content": [
          "Final answer:\n```python\ndef transform(grid):\n    import numpy as np\n\n    grid = np.array(grid)\n    n = 13  # always 13x13\n\n    # Step 1: Get the positions of color blocks\n    # Color code: red=2, green=3, yellow=4\n    pos = {}\n    for val in [2, 3, 4]:\n        locs = np.argwhere(grid == val)\n        if len(locs):\n            pos[val] = tuple(locs[0])\n    # There may be three colored blocks per grid, but not necessarily in any fixed order.\n    # Let's get their positions mapped as color->(y,x)\n    # There is always a red (2), yellow (4), green (3)\n\n    # Step 2: Determine which block is topmost, leftmost etc.\n    # For the path:\n    # - Find the two blocks that are closer vertically and horizontally\n    # Let's always draw a 'corner' connecting all 3, in the pattern observed in outputs\n\n    # Form a set of three points\n    pts = [(v, pos[v]) for v in pos]\n    # Sort by row, col, but let's just brute force all 3 prefixes\n\n    # Try all (start, corner, end) assignments\n    best = None\n    best_steps = None\n    for perm in [(2,4,3), (2,3,4), (3,4,2), (3,2,4), (4,2,3), (4,3,2)]:\n        p0 = pos[perm[0]]\n        p1 = pos[perm[1]]\n        p2 = pos[perm[2]]\n        # Compute \"total step length\" for path: p0 -> (p1[0],p0[1]) -> p1 -> (p1[0],p2[1]) -> p2\n        # As in output, the path always corner-turns at one block.\n        steps = (abs(p0[0]-p1[0]) + abs(p1[1]-p0[1])) + (abs(p1[0]-p2[0]) + abs(p2[1]-p1[1]))\n        if best is None or steps < best_steps:\n            best = perm\n            best_steps = steps\n\n    # Use the assignment with shortest \"route\" passing through the middle point\n    start, corner, end = best\n    p0 = pos[start]\n    p1 = pos[corner]\n    p2 = pos[end]\n\n    # Build output grid\n    out = np.zeros((n,n), dtype=int)\n\n    # Place blocks\n    out[p0] = start\n    out[p1] = corner\n    out[p2] = end\n\n    # Draw path from start to corner (horizontal then vertical)\n    x1, y1 = p0[1], p0[0]\n    x2, y2 = p1[1], p1[0]\n    for col in range(min(x1,x2)+1,max(x1,x2)):\n        out[y1, col] = 5\n    for row in range(min(y1,y2)+1,max(y1,y2)):\n        out[row, x2] = 5\n\n    # Draw path from corner to end (vertical then horizontal)\n    x1, y1 = p1[1], p1[0]\n    x2, y2 = p2[1], p2[0]\n    for row in range(min(y1,y2)+1,max(y1,y2)):\n        out[row, x1] = 5\n    for col in range(min(x1,x2)+1,max(x1,x2)):\n        out[y2, col] = 5\n\n    return out.tolist()\n```"
        ]
      }
    ],
    "all_responses": [
      {
        "id": "resp_687001eb324c8192be8c51c726c4a7d800937712ff4e7607",
        "model": "gpt-4.1-2025-04-14",
        "usage": {
          "input_tokens": 5042,
          "output_tokens": 807,
          "total_tokens": 5849
        },
        "output": [
          {
            "type": "message",
            "content": [
              "Final answer:\n```python\ndef transform(grid):\n    import numpy as np\n\n    grid = np.array(grid)\n    n = 13  # always 13x13\n\n    # Step 1: Get the positions of color blocks\n    # Color code: red=2, green=3, yellow=4\n    pos = {}\n    for val in [2, 3, 4]:\n        locs = np.argwhere(grid == val)\n        if len(locs):\n            pos[val] = tuple(locs[0])\n    # There may be three colored blocks per grid, but not necessarily in any fixed order.\n    # Let's get their positions mapped as color->(y,x)\n    # There is always a red (2), yellow (4), green (3)\n\n    # Step 2: Determine which block is topmost, leftmost etc.\n    # For the path:\n    # - Find the two blocks that are closer vertically and horizontally\n    # Let's always draw a 'corner' connecting all 3, in the pattern observed in outputs\n\n    # Form a set of three points\n    pts = [(v, pos[v]) for v in pos]\n    # Sort by row, col, but let's just brute force all 3 prefixes\n\n    # Try all (start, corner, end) assignments\n    best = None\n    best_steps = None\n    for perm in [(2,4,3), (2,3,4), (3,4,2), (3,2,4), (4,2,3), (4,3,2)]:\n        p0 = pos[perm[0]]\n        p1 = pos[perm[1]]\n        p2 = pos[perm[2]]\n        # Compute \"total step length\" for path: p0 -> (p1[0],p0[1]) -> p1 -> (p1[0],p2[1]) -> p2\n        # As in output, the path always corner-turns at one block.\n        steps = (abs(p0[0]-p1[0]) + abs(p1[1]-p0[1])) + (abs(p1[0]-p2[0]) + abs(p2[1]-p1[1]))\n        if best is None or steps < best_steps:\n            best = perm\n            best_steps = steps\n\n    # Use the assignment with shortest \"route\" passing through the middle point\n    start, corner, end = best\n    p0 = pos[start]\n    p1 = pos[corner]\n    p2 = pos[end]\n\n    # Build output grid\n    out = np.zeros((n,n), dtype=int)\n\n    # Place blocks\n    out[p0] = start\n    out[p1] = corner\n    out[p2] = end\n\n    # Draw path from start to corner (horizontal then vertical)\n    x1, y1 = p0[1], p0[0]\n    x2, y2 = p1[1], p1[0]\n    for col in range(min(x1,x2)+1,max(x1,x2)):\n        out[y1, col] = 5\n    for row in range(min(y1,y2)+1,max(y1,y2)):\n        out[row, x2] = 5\n\n    # Draw path from corner to end (vertical then horizontal)\n    x1, y1 = p1[1], p1[0]\n    x2, y2 = p2[1], p2[0]\n    for row in range(min(y1,y2)+1,max(y1,y2)):\n        out[row, x1] = 5\n    for col in range(min(x1,x2)+1,max(x1,x2)):\n        out[y2, col] = 5\n\n    return out.tolist()\n```"
            ]
          }
        ]
      }
    ]
  }
}