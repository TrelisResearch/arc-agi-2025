{
  "task_id": "358ba94e",
  "model": "gpt-4.1-mini",
  "reasoning_effort": "N/A",
  "api_type": "responses_api_multiturn",
  "program": "def transform(grid):\n    import numpy as np\n    from collections import deque\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def neighbors(r, c):\n        for nr, nc in ((r-1, c), (r+1, c), (r, c-1), (r, c+1)):\n            if 0 <= nr < rows and 0 <= nc < cols:\n                yield nr, nc\n\n    components = []\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                q = deque([(r, c)])\n                visited[r, c] = True\n                cells = []\n                while q:\n                    rr, cc = q.popleft()\n                    cells.append((rr, cc))\n                    for nr, nc in neighbors(rr, cc):\n                        if not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                components.append((len(cells), color, cells))\n\n    if not components:\n        return [[0] * 5 for _ in range(5)]\n\n    components.sort(key=lambda x: x[0], reverse=True)\n    size, color, cells = components[0]\n\n    rmin = min(r for r, c in cells)\n    rmax = max(r for r, c in cells)\n    cmin = min(c for r, c in cells)\n    cmax = max(c for r, c in cells)\n\n    block = grid[rmin:rmax + 1, cmin:cmax + 1]\n    h_in, w_in = block.shape\n\n    # Create mask of component color presence (1) and holes (0)\n    comp_mask = (block == color).astype(int)\n    zero_mask = (block == 0).astype(int)\n\n    # Detect internal holes fully enclosed by component (zero pixels surrounded by color)\n    # We'll use flood fill from border zeros to find external zeros, rest zeros inside are holes\n    external_zeros = np.zeros_like(zero_mask, dtype=bool)\n    from collections import deque\n    queue = deque()\n\n    # Add border zeros positions\n    for i in range(h_in):\n        for j in [0, w_in -1]:\n            if zero_mask[i,j]:\n                queue.append((i,j))\n                external_zeros[i,j] = True\n    for j in range(w_in):\n        for i in [0, h_in -1]:\n            if zero_mask[i,j]:\n                queue.append((i,j))\n                external_zeros[i,j] = True\n\n    # Flood fill external zeros\n    while queue:\n        x, y = queue.popleft()\n        for nx, ny in ((x-1,y), (x+1,y), (x,y-1), (x,y+1)):\n            if 0 <= nx < h_in and 0 <= ny < w_in:\n                if zero_mask[nx, ny] and not external_zeros[nx, ny]:\n                    external_zeros[nx, ny] = True\n                    queue.append((nx, ny))\n\n    # Holes mask are zeros not reachable from outside\n    holes_mask = zero_mask.astype(bool) & (~external_zeros)\n\n    def max_pool_2d(arr, out_h=5, out_w=5):\n        in_h, in_w = arr.shape\n        out_arr = np.zeros((out_h, out_w), dtype=int)\n        for i in range(out_h):\n            r0 = int(i * in_h / out_h)\n            r1 = int((i + 1) * in_h / out_h)\n            if r1 == r0:\n                r1 = min(r0+1, in_h)\n            for j in range(out_w):\n                c0 = int(j * in_w / out_w)\n                c1 = int((j + 1) * in_w / out_w)\n                if c1 == c0:\n                    c1 = min(c0+1, in_w)\n                block_slice = arr[r0:r1, c0:c1]\n                out_arr[i,j] = 1 if np.any(block_slice) else 0\n        return out_arr\n\n    comp_down = max_pool_2d(comp_mask)\n    holes_down = max_pool_2d(holes_mask.astype(int))\n\n    # Compose final output: where holes present \u2192 0, else color if comp_down present\n    output = np.where(holes_down==1, 0, comp_down * color)\n\n    return output.tolist()",
  "execution_error": "Max turns reached",
  "timed_out": false,
  "tokens_used": 115796,
  "request_cost": 0.0560372,
  "turns_used": 8,
  "raw_response": {
    "id": "resp_686fb3da6a4481a0be659969f20021240309873a52022234",
    "model": "gpt-4.1-mini-2025-04-14",
    "usage": {
      "input_tokens": 21273,
      "output_tokens": 1401,
      "total_tokens": 22674
    },
    "output": [
      {
        "type": "message",
        "content": [
          "The main recurring error is the positions of the black pixels (holes) inside the 5x5 output grid\u2014which are often misplaced by the simple nearest neighbor resampling, especially in Training Examples 1, 2, and 3. The hole pattern in outputs is quite specific and symmetrical, not fully captured by nearest neighbor resampling of the input bounding box.\n\n**Hypothesis / Pattern:**\n\n- The output 5x5 grid corresponds exactly to the **shape of the largest colored region** but with holes only in a few very specific fixed cells.\n- The holes correspond to black pixels (zeros) in the input but in fixed relative positions.\n- The position of holes resembles **the largest connected component's mask's contour of disconnected zero cells inside it**.\n- Overall, the output captures a 5x5 shape with:\n  - Border cells all colored (no holes on borders except some specific inside).\n  - Some inner cells are black (holes) following a fixed pattern.\n\n**Improved approach:**\n\n1. Extract the largest colored connected component and its bounding box.\n2. Extract a boolean mask of the largest component inside the bounding box.\n3. Rescale the mask to 5x5 using **max pooling** on 2x2 blocks: \n   - Resulting in a binary 5x5 mask representing where the color is present.\n4. Identify holes: any zero pixels fully enclosed by the component inside bounding box (holes fully surrounded).\n   - Create an internal mask of holes inside the component (zeros surrounded by color).\n   - Rescale holes using **max pooling (or any zero within block means hole)** to 5x5.\n5. The final output 5x5 grid uses:\n   - Color where rescaled mask = 1\n   - Hole (0) where rescaled hole mask = 1\n6. This pooling approach maintains hole shapes and their positions more robustly.\n\nThis will better preserve hole shapes and positions compared to nearest neighbor sampling.\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n    from collections import deque\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def neighbors(r, c):\n        for nr, nc in ((r-1, c), (r+1, c), (r, c-1), (r, c+1)):\n            if 0 <= nr < rows and 0 <= nc < cols:\n                yield nr, nc\n\n    components = []\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                q = deque([(r, c)])\n                visited[r, c] = True\n                cells = []\n                while q:\n                    rr, cc = q.popleft()\n                    cells.append((rr, cc))\n                    for nr, nc in neighbors(rr, cc):\n                        if not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                components.append((len(cells), color, cells))\n\n    if not components:\n        return [[0] * 5 for _ in range(5)]\n\n    components.sort(key=lambda x: x[0], reverse=True)\n    size, color, cells = components[0]\n\n    rmin = min(r for r, c in cells)\n    rmax = max(r for r, c in cells)\n    cmin = min(c for r, c in cells)\n    cmax = max(c for r, c in cells)\n\n    block = grid[rmin:rmax + 1, cmin:cmax + 1]\n    h_in, w_in = block.shape\n\n    # Create mask of component color presence (1) and holes (0)\n    comp_mask = (block == color).astype(int)\n    zero_mask = (block == 0).astype(int)\n\n    # Detect internal holes fully enclosed by component (zero pixels surrounded by color)\n    # We'll use flood fill from border zeros to find external zeros, rest zeros inside are holes\n    external_zeros = np.zeros_like(zero_mask, dtype=bool)\n    from collections import deque\n    queue = deque()\n\n    # Add border zeros positions\n    for i in range(h_in):\n        for j in [0, w_in -1]:\n            if zero_mask[i,j]:\n                queue.append((i,j))\n                external_zeros[i,j] = True\n    for j in range(w_in):\n        for i in [0, h_in -1]:\n            if zero_mask[i,j]:\n                queue.append((i,j))\n                external_zeros[i,j] = True\n\n    # Flood fill external zeros\n    while queue:\n        x, y = queue.popleft()\n        for nx, ny in ((x-1,y), (x+1,y), (x,y-1), (x,y+1)):\n            if 0 <= nx < h_in and 0 <= ny < w_in:\n                if zero_mask[nx, ny] and not external_zeros[nx, ny]:\n                    external_zeros[nx, ny] = True\n                    queue.append((nx, ny))\n\n    # Holes mask are zeros not reachable from outside\n    holes_mask = zero_mask.astype(bool) & (~external_zeros)\n\n    def max_pool_2d(arr, out_h=5, out_w=5):\n        in_h, in_w = arr.shape\n        out_arr = np.zeros((out_h, out_w), dtype=int)\n        for i in range(out_h):\n            r0 = int(i * in_h / out_h)\n            r1 = int((i + 1) * in_h / out_h)\n            if r1 == r0:\n                r1 = min(r0+1, in_h)\n            for j in range(out_w):\n                c0 = int(j * in_w / out_w)\n                c1 = int((j + 1) * in_w / out_w)\n                if c1 == c0:\n                    c1 = min(c0+1, in_w)\n                block_slice = arr[r0:r1, c0:c1]\n                out_arr[i,j] = 1 if np.any(block_slice) else 0\n        return out_arr\n\n    comp_down = max_pool_2d(comp_mask)\n    holes_down = max_pool_2d(holes_mask.astype(int))\n\n    # Compose final output: where holes present \u2192 0, else color if comp_down present\n    output = np.where(holes_down==1, 0, comp_down * color)\n\n    return output.tolist()\n```"
        ]
      }
    ]
  },
  "score": {
    "correct": false,
    "pixel_accuracy": 0.0,
    "total_pixels": 25,
    "correct_pixels": 0,
    "error": "Max turns reached"
  },
  "actual_output": [
    [
      1,
      1,
      1,
      1,
      1
    ],
    [
      1,
      0,
      1,
      0,
      1
    ],
    [
      1,
      1,
      1,
      1,
      1
    ],
    [
      1,
      0,
      1,
      0,
      1
    ],
    [
      1,
      1,
      1,
      1,
      1
    ]
  ],
  "api_success": true,
  "multiturn_data": {
    "turn_details": [
      {
        "turn_number": 1,
        "timestamp": "2025-07-10T13:34:45.982272",
        "input_tokens": 5509,
        "output_tokens": 1071,
        "turn_cost": 0.0039172,
        "program_extracted": true,
        "program": "def transform(grid):\n    import numpy as np\n    from collections import deque\n    \n    grid = np.array(grid)\n    rows, cols = grid.shape\n    \n    # Find all connected components of nonzero colors\n    visited = np.zeros_like(grid, dtype=bool)\n    \n    def neighbors(r,c):\n        for nr,nc in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\n            if 0 <= nr < rows and 0 <= nc < cols:\n                yield nr,nc\n    \n    components = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            if grid[r,c] != 0 and not visited[r,c]:\n                color = grid[r,c]\n                q = deque([(r,c)])\n                visited[r,c] = True\n                cells = []\n                while q:\n                    rr,cc = q.popleft()\n                    cells.append((rr,cc))\n                    for nr,nc in neighbors(rr,cc):\n                        if not visited[nr,nc] and grid[nr,nc] == color:\n                            visited[nr,nc] = True\n                            q.append((nr,nc))\n                components.append((len(cells), color, cells))\n    \n    if not components:\n        # No nonzero colors, output empty 5x5 zero grid\n        return [[0]*5 for _ in range(5)]\n    \n    # Choose largest component by size\n    components.sort(reverse=True, key=lambda x: x[0])\n    size, color, cells = components[0]\n    \n    # Get bounding box of largest component\n    rows_c = [r for r,c in cells]\n    cols_c = [c for r,c in cells]\n    rmin, rmax = min(rows_c), max(rows_c)\n    cmin, cmax = min(cols_c), max(cols_c)\n    \n    # Extract 5x5 subgrid from top-left corner of bounding box, or as fits\n    # The bounding box can be bigger than 5x5, crop accordingly\n    r_end = min(rmin+5, rows)\n    c_end = min(cmin+5, cols)\n    \n    subgrid = grid[rmin:r_end, cmin:c_end]\n    \n    # Create output 5x5 initially zeros\n    out = np.zeros((5,5), dtype=int)\n    \n    # Place the pattern into output\n    # For each cell in subgrid:\n    # If cell == color => place color\n    # else => 0 (black dot inside square)\n    for rr in range(subgrid.shape[0]):\n        for cc in range(subgrid.shape[1]):\n            if subgrid[rr, cc] == color:\n                out[rr, cc] = color\n            else:\n                out[rr, cc] = 0\n                \n    return out.tolist()",
        "training_feedback": {
          "feedback_messages": [
            {
              "type": "input_text",
              "text": "Training results: 1/4 examples solved, 87.0% pixel accuracy - Great progress! You're on the right track. Next, try to identify a transformation that solves more than 1 of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[7, 7, 7, 7, 7], [7, 0, 7, 7, 7], [7, 7, 7, 0, 7], [7, 0, 7, 7, 7], [7, 7, 7, 7, 7]]\nYour output: [[7, 7, 7, 7, 7], [7, 7, 7, 0, 7], [7, 0, 7, 7, 7], [7, 7, 7, 7, 7], [7, 7, 7, 7, 7]]\nPixel accuracy: 80.0%\n\nTraining Example 2 \u2717:\nExpected: [[8, 8, 8, 8, 8], [8, 0, 8, 0, 8], [8, 8, 8, 8, 8], [8, 0, 8, 0, 8], [8, 8, 8, 8, 8]]\nYour output: [[8, 8, 8, 8, 8], [8, 0, 8, 8, 8], [8, 8, 8, 0, 8], [8, 0, 8, 8, 8], [8, 8, 8, 8, 8]]\nPixel accuracy: 88.0%\n\nTraining Example 3 \u2717:\nExpected: [[6, 6, 6, 6, 6], [6, 0, 6, 0, 6], [6, 6, 6, 6, 6], [6, 0, 6, 6, 6], [6, 6, 6, 6, 6]]\nYour output: [[6, 6, 6, 6, 6], [6, 6, 6, 6, 6], [6, 0, 6, 0, 6], [6, 6, 6, 6, 6], [6, 6, 6, 6, 6]]\nPixel accuracy: 80.0%\n\nTraining Example 4 \u2713:\nExpected: [[2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 0, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]]\nYour output: [[2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 0, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]]\n\n"
            },
            {
              "type": "input_image",
              "image_url": "data:image/png;base64,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"
            },
            {
              "type": "input_text",
              "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
            }
          ],
          "solved_count": 1,
          "total_training_examples": 4,
          "pixel_accuracy": 0.87
        },
        "test_result": {
          "correct": false,
          "pixel_accuracy": 0.92,
          "total_pixels": 25,
          "correct_pixels": 23,
          "error": null
        },
        "status": "failed_test",
        "feedback_sent": true
      },
      {
        "turn_number": 2,
        "timestamp": "2025-07-10T13:35:06.839915",
        "input_tokens": 7857,
        "output_tokens": 873,
        "turn_cost": 0.0045395999999999995,
        "program_extracted": true,
        "program": "def transform(grid):\n    import numpy as np\n    from collections import deque\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n\n    # Find largest connected component of a single color (nonzero)\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def neighbors(r,c):\n        for nr,nc in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\n            if 0 <= nr < rows and 0 <= nc < cols:\n                yield nr,nc\n\n    components = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r,c] != 0 and not visited[r,c]:\n                color = grid[r,c]\n                q = deque([(r,c)])\n                visited[r,c] = True\n                cells = []\n                while q:\n                    rr,cc = q.popleft()\n                    cells.append((rr,cc))\n                    for nr,nc in neighbors(rr,cc):\n                        if not visited[nr,nc] and grid[nr,nc] == color:\n                            visited[nr,nc] = True\n                            q.append((nr,nc))\n                components.append((len(cells), color, cells))\n\n    if not components:\n        # no colored component -> 5x5 zeros\n        return [[0]*5 for _ in range(5)]\n\n    # Largest colored component\n    components.sort(reverse=True, key=lambda x: x[0])\n    size, color, cells = components[0]\n\n    rows_c = [r for r,c in cells]\n    cols_c = [c for r,c in cells]\n    rmin, rmax = min(rows_c), max(rows_c)\n    cmin, cmax = min(cols_c), max(cols_c)\n\n    block = grid[rmin:rmax+1, cmin:cmax+1]\n\n    # Resize block to 5x5 using nearest neighbor sampling\n    # Define a function for nearest-neighbor downsampling to 5x5\n    def resize_to_5x5(arr):\n        h, w = arr.shape\n        result = np.zeros((5,5), dtype=int)\n        for i in range(5):\n            for j in range(5):\n                # Map output i,j to input coordinates\n                x = int(round(i * (h-1) / 4))\n                y = int(round(j * (w-1) / 4))\n                result[i,j] = arr[x,y]\n        return result\n\n    resized = resize_to_5x5(block)\n\n    # Map nonzero pixels to color, zeros remain 0\n    output = np.where(resized != 0, color, 0)\n\n    return output.tolist()",
        "training_feedback": {
          "feedback_messages": [
            {
              "type": "input_text",
              "text": "Training results: 1/4 examples solved, 87.0% pixel accuracy - Great progress! You're on the right track. Next, try to identify a transformation that solves more than 1 of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[7, 7, 7, 7, 7], [7, 0, 7, 7, 7], [7, 7, 7, 0, 7], [7, 0, 7, 7, 7], [7, 7, 7, 7, 7]]\nYour output: [[7, 7, 7, 7, 7], [7, 7, 7, 0, 7], [7, 0, 7, 7, 7], [7, 7, 7, 7, 7], [7, 7, 7, 7, 7]]\nPixel accuracy: 80.0%\n\nTraining Example 2 \u2717:\nExpected: [[8, 8, 8, 8, 8], [8, 0, 8, 0, 8], [8, 8, 8, 8, 8], [8, 0, 8, 0, 8], [8, 8, 8, 8, 8]]\nYour output: [[8, 8, 8, 8, 8], [8, 0, 8, 8, 8], [8, 8, 8, 0, 8], [8, 0, 8, 8, 8], [8, 8, 8, 8, 8]]\nPixel accuracy: 88.0%\n\nTraining Example 3 \u2717:\nExpected: [[6, 6, 6, 6, 6], [6, 0, 6, 0, 6], [6, 6, 6, 6, 6], [6, 0, 6, 6, 6], [6, 6, 6, 6, 6]]\nYour output: [[6, 6, 6, 6, 6], [6, 6, 6, 6, 6], [6, 0, 6, 0, 6], [6, 6, 6, 6, 6], [6, 6, 6, 6, 6]]\nPixel accuracy: 80.0%\n\nTraining Example 4 \u2713:\nExpected: [[2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 0, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]]\nYour output: [[2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 0, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]]\n\n"
            },
            {
              "type": "input_image",
              "image_url": "data:image/png;base64,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"
            },
            {
              "type": "input_text",
              "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
            }
          ],
          "solved_count": 1,
          "total_training_examples": 4,
          "pixel_accuracy": 0.87
        },
        "test_result": {
          "correct": false,
          "pixel_accuracy": 0.92,
          "total_pixels": 25,
          "correct_pixels": 23,
          "error": null
        },
        "status": "failed_test",
        "feedback_sent": true
      },
      {
        "turn_number": 3,
        "timestamp": "2025-07-10T13:35:20.759641",
        "input_tokens": 10007,
        "output_tokens": 1095,
        "turn_cost": 0.0057548,
        "program_extracted": true,
        "program": "def transform(grid):\n    import numpy as np\n    from collections import deque\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def neighbors(r, c):\n        for nr, nc in ((r-1,c), (r+1,c), (r,c-1), (r,c+1)):\n            if 0 <= nr < rows and 0 <= nc < cols:\n                yield nr, nc\n\n    components = []\n\n    # Find largest connected component of a single nonzero color\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                q = deque([(r, c)])\n                visited[r, c] = True\n                cells = []\n                while q:\n                    rr, cc = q.popleft()\n                    cells.append((rr, cc))\n                    for nr, nc in neighbors(rr, cc):\n                        if not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                components.append((len(cells), color, cells))\n\n    if not components:\n        # no colored component\n        return [[0]*5 for _ in range(5)]\n\n    # Choose largest component\n    components.sort(key=lambda x: x[0], reverse=True)\n    size, color, cells = components[0]\n\n    rmin = min(r for r, c in cells)\n    rmax = max(r for r, c in cells)\n    cmin = min(c for r, c in cells)\n    cmax = max(c for r, c in cells)\n\n    block = grid[rmin:rmax+1, cmin:cmax+1]\n\n    h_in, w_in = block.shape\n\n    # Create two binary masks for colors and holes\n    color_mask = (block == color).astype(int)\n    hole_mask = (block == 0).astype(int)\n\n    # Downsample masks to 5x5 by block majority\n    def downsample_majority(mask):\n        out = np.zeros((5,5), dtype=int)\n        # Compute block sizes (may not divide evenly)\n        h_block_sizes = []\n        acc = 0\n        for i in range(5):\n            start = int(i * h_in / 5)\n            end = int((i+1) * h_in / 5)\n            h_block_sizes.append((start,end))\n        w_block_sizes = []\n        for j in range(5):\n            start = int(j * w_in / 5)\n            end = int((j+1) * w_in / 5)\n            w_block_sizes.append((start,end))\n        for i in range(5):\n            for j in range(5):\n                rstart, rend = h_block_sizes[i]\n                cstart, cend = w_block_sizes[j]\n                block_slice = mask[rstart:rend, cstart:cend]\n                if block_slice.size == 0:\n                    out[i,j] = 0\n                else:\n                    # majority vote\n                    val = 1 if block_slice.sum() >= (block_slice.size / 2) else 0\n                    out[i,j] = val\n        return out\n\n    color_ds = downsample_majority(color_mask)\n    hole_ds = downsample_majority(hole_mask)\n\n    # The final output: where hole_ds is 1 -> 0, else color\n    output = np.where(hole_ds == 1, 0, color_ds * color)\n\n    return output.tolist()",
        "training_feedback": {
          "feedback_messages": [
            {
              "type": "input_text",
              "text": "Training results: 1/4 examples solved, 87.0% pixel accuracy - Great progress! You're on the right track. Next, try to identify a transformation that solves more than 1 of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[7, 7, 7, 7, 7], [7, 0, 7, 7, 7], [7, 7, 7, 0, 7], [7, 0, 7, 7, 7], [7, 7, 7, 7, 7]]\nYour output: [[7, 7, 7, 7, 7], [7, 7, 7, 0, 7], [7, 0, 7, 7, 7], [7, 7, 7, 7, 7], [7, 7, 7, 7, 7]]\nPixel accuracy: 80.0%\n\nTraining Example 2 \u2717:\nExpected: [[8, 8, 8, 8, 8], [8, 0, 8, 0, 8], [8, 8, 8, 8, 8], [8, 0, 8, 0, 8], [8, 8, 8, 8, 8]]\nYour output: [[8, 8, 8, 8, 8], [8, 0, 8, 8, 8], [8, 8, 8, 0, 8], [8, 0, 8, 8, 8], [8, 8, 8, 8, 8]]\nPixel accuracy: 88.0%\n\nTraining Example 3 \u2717:\nExpected: [[6, 6, 6, 6, 6], [6, 0, 6, 0, 6], [6, 6, 6, 6, 6], [6, 0, 6, 6, 6], [6, 6, 6, 6, 6]]\nYour output: [[6, 6, 6, 6, 6], [6, 6, 6, 6, 6], [6, 0, 6, 0, 6], [6, 6, 6, 6, 6], [6, 6, 6, 6, 6]]\nPixel accuracy: 80.0%\n\nTraining Example 4 \u2713:\nExpected: [[2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 0, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]]\nYour output: [[2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 0, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]]\n\n"
            },
            {
              "type": "input_image",
              "image_url": "data:image/png;base64,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"
            },
            {
              "type": "input_text",
              "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
            }
          ],
          "solved_count": 1,
          "total_training_examples": 4,
          "pixel_accuracy": 0.87
        },
        "test_result": {
          "correct": false,
          "pixel_accuracy": 0.92,
          "total_pixels": 25,
          "correct_pixels": 23,
          "error": null
        },
        "status": "failed_test",
        "feedback_sent": true
      },
      {
        "turn_number": 4,
        "timestamp": "2025-07-10T13:35:38.054497",
        "input_tokens": 12379,
        "output_tokens": 922,
        "turn_cost": 0.006426800000000001,
        "program_extracted": true,
        "program": "def transform(grid):\n    import numpy as np\n    from collections import deque\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def neighbors(r, c):\n        for nr, nc in ((r-1,c), (r+1,c), (r,c-1), (r,c+1)):\n            if 0 <= nr < rows and 0 <= nc < cols:\n                yield nr, nc\n\n    components = []\n\n    # Find largest connected component with a single nonzero color\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                q = deque([(r, c)])\n                visited[r, c] = True\n                cells = []\n                while q:\n                    rr, cc = q.popleft()\n                    cells.append((rr, cc))\n                    for nr, nc in neighbors(rr, cc):\n                        if not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                components.append((len(cells), color, cells))\n\n    if not components:\n        # No colored component found -> return empty 5x5\n        return [[0]*5 for _ in range(5)]\n\n    components.sort(key=lambda x: x[0], reverse=True)\n    size, color, cells = components[0]\n\n    rmin = min(r for r, c in cells)\n    rmax = max(r for r, c in cells)\n    cmin = min(c for r, c in cells)\n    cmax = max(c for r, c in cells)\n\n    block = grid[rmin:rmax+1, cmin:cmax+1]\n    h_in, w_in = block.shape\n\n    output = np.zeros((5, 5), dtype=int)\n\n    # For each cell in output 5x5 grid, map to corresponding block in input\n    for i in range(5):\n        r_start = int(i * h_in / 5)\n        r_end = int((i + 1) * h_in / 5)\n        if r_end == r_start:\n            r_end = min(r_start + 1, h_in)  # Ensure at least one row\n\n        for j in range(5):\n            c_start = int(j * w_in / 5)\n            c_end = int((j + 1) * w_in / 5)\n            if c_end == c_start:\n                c_end = min(c_start + 1, w_in)  # Ensure at least one col\n\n            subblock = block[r_start:r_end, c_start:c_end]\n\n            # If any zero in subblock => hole(0), else color\n            if np.any(subblock == 0):\n                output[i, j] = 0\n            else:\n                # Should be all color pixels or zeros only if holes\n                # If subblock has any color pixels, paint with that color\n                if np.any(subblock == color):\n                    output[i, j] = color\n                else:\n                    output[i, j] = 0  # Default safe fallback\n\n    return output.tolist()",
        "training_feedback": {
          "feedback_messages": [
            {
              "type": "input_text",
              "text": "Training results: 1/4 examples solved, 87.0% pixel accuracy - Great progress! You're on the right track. Next, try to identify a transformation that solves more than 1 of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[7, 7, 7, 7, 7], [7, 0, 7, 7, 7], [7, 7, 7, 0, 7], [7, 0, 7, 7, 7], [7, 7, 7, 7, 7]]\nYour output: [[7, 7, 7, 7, 7], [7, 7, 7, 0, 7], [7, 0, 7, 7, 7], [7, 7, 7, 7, 7], [7, 7, 7, 7, 7]]\nPixel accuracy: 80.0%\n\nTraining Example 2 \u2717:\nExpected: [[8, 8, 8, 8, 8], [8, 0, 8, 0, 8], [8, 8, 8, 8, 8], [8, 0, 8, 0, 8], [8, 8, 8, 8, 8]]\nYour output: [[8, 8, 8, 8, 8], [8, 0, 8, 8, 8], [8, 8, 8, 0, 8], [8, 0, 8, 8, 8], [8, 8, 8, 8, 8]]\nPixel accuracy: 88.0%\n\nTraining Example 3 \u2717:\nExpected: [[6, 6, 6, 6, 6], [6, 0, 6, 0, 6], [6, 6, 6, 6, 6], [6, 0, 6, 6, 6], [6, 6, 6, 6, 6]]\nYour output: [[6, 6, 6, 6, 6], [6, 6, 6, 6, 6], [6, 0, 6, 0, 6], [6, 6, 6, 6, 6], [6, 6, 6, 6, 6]]\nPixel accuracy: 80.0%\n\nTraining Example 4 \u2713:\nExpected: [[2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 0, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]]\nYour output: [[2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 0, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]]\n\n"
            },
            {
              "type": "input_image",
              "image_url": "data:image/png;base64,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"
            },
            {
              "type": "input_text",
              "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
            }
          ],
          "solved_count": 1,
          "total_training_examples": 4,
          "pixel_accuracy": 0.87
        },
        "test_result": {
          "correct": false,
          "pixel_accuracy": 0.92,
          "total_pixels": 25,
          "correct_pixels": 23,
          "error": null
        },
        "status": "failed_test",
        "feedback_sent": true
      },
      {
        "turn_number": 5,
        "timestamp": "2025-07-10T13:35:53.143630",
        "input_tokens": 14578,
        "output_tokens": 1013,
        "turn_cost": 0.007452000000000001,
        "program_extracted": true,
        "program": "def transform(grid):\n    import numpy as np\n    from collections import deque\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def neighbors(r, c):\n        for nr, nc in ((r-1,c), (r+1,c), (r,c-1), (r,c+1)):\n            if 0 <= nr < rows and 0 <= nc < cols:\n                yield nr, nc\n\n    components = []\n\n    # Find largest connected component with single nonzero color\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r,c] != 0 and not visited[r,c]:\n                color = grid[r,c]\n                q = deque([(r,c)])\n                visited[r,c] = True\n                cells = []\n                while q:\n                    rr, cc = q.popleft()\n                    cells.append((rr, cc))\n                    for nr, nc in neighbors(rr, nc):\n                        if not visited[nr,nc] and grid[nr,nc] == color:\n                            visited[nr,nc] = True\n                            q.append((nr,nc))\n                components.append((len(cells), color, cells))\n\n    if not components:\n        return [[0]*5 for _ in range(5)]\n\n    components.sort(key=lambda x: x[0], reverse=True)\n    size, color, cells = components[0]\n\n    rmin = min(r for r,c in cells)\n    rmax = max(r for r,c in cells)\n    cmin = min(c for r,c in cells)\n    cmax = max(c for r,c in cells)\n\n    block = grid[rmin:rmax+1, cmin:cmax+1]\n    h_in, w_in = block.shape\n\n    # Pad to at least 6x6 with color pixels (if smaller)\n    target = 6\n    if h_in < target or w_in < target:\n        padded = np.full((max(h_in,target), max(w_in,target)), fill_value=color, dtype=int)\n        padded[:h_in, :w_in] = block\n        block = padded\n        h_in, w_in = block.shape\n\n    # Now block is at least 6x6; crop if bigger (to 6x6 top-left)\n    block = block[:target, :target]\n    h_in, w_in = block.shape  # now 6,6\n\n    output = np.zeros((5,5), dtype=int)\n\n    # For each output cell, check corresponding 2x2 input cells for holes (0)\n    # If any zero in 2x2 block, output is 0 else color\n    for i in range(5):\n        for j in range(5):\n            # input cells from (i,i+1),(j,j+1)\n            subblock = block[i:i+2, j:j+2]\n            if np.any(subblock == 0):\n                output[i,j] = 0\n            else:\n                output[i,j] = color\n\n    return output.tolist()",
        "training_feedback": {
          "feedback_messages": [
            {
              "type": "input_text",
              "text": "Training results: 0/4 examples solved, 0.0% pixel accuracy - Keep experimenting! Try a different approach to the transformation.\n\nTraining Example 1 \u2717:\nExpected: [[7, 7, 7, 7, 7], [7, 0, 7, 7, 7], [7, 7, 7, 0, 7], [7, 0, 7, 7, 7], [7, 7, 7, 7, 7]]\nError: Traceback (most recent call last):\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmpqsilh1_c.py\", line 107, in <module>\n    output = transform(test_input)\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmpqsilh1_c.py\", line 56, in transform\n    for nr, nc in neighbors(rr, nc):\n                                ^^\nUnboundLocalError: cannot access local variable 'nc' where it is not associated with a value\n\n\nTraining Example 2 \u2717:\nExpected: [[8, 8, 8, 8, 8], [8, 0, 8, 0, 8], [8, 8, 8, 8, 8], [8, 0, 8, 0, 8], [8, 8, 8, 8, 8]]\nError: Traceback (most recent call last):\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmp7twqaxhw.py\", line 107, in <module>\n    output = transform(test_input)\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmp7twqaxhw.py\", line 56, in transform\n    for nr, nc in neighbors(rr, nc):\n                                ^^\nUnboundLocalError: cannot access local variable 'nc' where it is not associated with a value\n\n\nTraining Example 3 \u2717:\nExpected: [[6, 6, 6, 6, 6], [6, 0, 6, 0, 6], [6, 6, 6, 6, 6], [6, 0, 6, 6, 6], [6, 6, 6, 6, 6]]\nError: Traceback (most recent call last):\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmp5unfk6xk.py\", line 107, in <module>\n    output = transform(test_input)\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmp5unfk6xk.py\", line 56, in transform\n    for nr, nc in neighbors(rr, nc):\n                                ^^\nUnboundLocalError: cannot access local variable 'nc' where it is not associated with a value\n\n\nTraining Example 4 \u2717:\nExpected: [[2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 0, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]]\nError: Traceback (most recent call last):\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmpabwbtifk.py\", line 107, in <module>\n    output = transform(test_input)\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmpabwbtifk.py\", line 56, in transform\n    for nr, nc in neighbors(rr, nc):\n                                ^^\nUnboundLocalError: cannot access local variable 'nc' where it is not associated with a value\n\n\n"
            },
            {
              "type": "input_image",
              "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAP8AAAKUCAIAAABExnktAAAxLUlEQVR4nO3de1hTZ4LH8TfcQSAItSi3qiBgn3hBFAWjFeEPhKIg6Nh6GRBHpohF4lq1Zey4jxR3cHFq+9R1VaAMdXB0y0VHXfQRUWtRW5mK4oUBqkCRwWiISLjm3ceep3lYIGnQkNv7+zz+gYdzyTl8z+HkJIfwKKUEgEkmun4AADqD+oFdqB/YhfqBXagf2IX6gV2oH9iF+oFdqB/YhfqBXagf2IX6gV2oH9j1SvUnJyfzlFu1atWQ41hYWIwdO3bx4sU3btwYPM+zZ8/yeDxHR8fOzs4B3zp+/DiPxzt06BD337i4OB6Pl5mZOWC0xsZGHo+Xlpb2KlNxOjs7Dxw4EBwc7OLiYmlp6eLismzZskuXLqnYJmlpaco2yK1bt1RvtNDQ0F/dsIpx1q1b13849/BiYmK+/fbb/o8nKipqwGgTJkx4//33nz59OqyNz3n8+PGuXbv8/Pz4fP6oUaMCAgIOHTrU/23C3OIGTP7999+PGTPGzs6urKyMMH7s7+npaWlpOXHiRHBwcF1d3YDvZmdnE0KePn169OhRdea2Y8eOu3fvDvcxqDPVjz/+GBgY+Pvf//7ChQvNzc3d3d3Nzc3Hjx+fP39+VlYW0TPcw/v666+FQuFXX32lYrQff/zxs88+CwsLk8vlw9r433777bRp0/7whz/84x//kEqlHR0d169f/93vfpeQkKDigZ0/fz44OLivr+/cuXPBwcHEaOr//PPP6S+OHTtGCMnJyVEMyc/PV4xZX1+vGN7Z2Xnnzp13331XKpXu37+//wwlEklRUdGyZcscHR3/67/+S53H0N3dHRcX19fXN6xH/qtT9fT0xMbG/uMf/wgKCiopKXn8+HFPT8/Dhw+/+OILR0fHDz74gDuQK1NZWUkHEQgEQ24QhXPnzvWfiTrjNDc3c8NlMtk///nPbdu2UUrXrl374MGD/qPJZLL+Gz80NPTatWtnz55Vf+P/61//io6O/umnn955552KigqpVPrkyZOioqKJEyfm5OQcOHBgyO1QWFgYHh5uY2Nz4cKF2bNnEz2jg2O/paWlr6/vf/zHfxBCBhz7jxw50tnZmZiYGB8fX1FRcfPmzV+d28aNG69evfqf//mfw3oMvzrVl19++f3334eGhl68eDEyMtLJycnMzMzd3f299977+uuv+/r6/vrXvxJ9YmVl5enpmZGRsWPHju7u7j//+c8qNv6mTZu4PUf9jZ+VldXS0pKamnrkyJHZs2fb2dmNHj16yZIl5eXlo0aNysrKGnyb1OHDh5ctW/b6669funRp6tSpiuG5ubk8Hu/zzz8nDNbf1dV1+/ZtkUhECPH29u7/rZycnMmTJy9cuPC9994zNTVV5/D/ySefeHl57dix486dO+o/hl+d6siRIzwe77//+79NTU0HfOutt96qrq7etWsX0UubN2+2sbH53//93yG/29PTc//+/X379pmZmb311lvqb/y//e1v1tbW//7v/z5ghm5ubpcvX75w4QKPx+s//E9/+tO6desmTpx4+fLlSZMmEb2kpfonTJigeOJlZWUlEAiOHTv22muvpaSkKMa5devWd999t2XLFh6P5+npuWzZsq+++qq9vV31nG1sbHJycnp6eoZ1/vOrU1VWVk6ePHnChAlDTj558uQBP+wB/Pz8BjxbvXz5srINonDhwoXhjjOYnZ3dpEmTBvxStba25ia3sLDw8fH55ptvvvzyy/5rp3rj9/T0/PjjjwEBAba2toOXOH369HHjxvUf8sEHH2zdupUQMm/ePA8PjwHjx8XFUUqTk5MJm1c8XV1d165d+8MPP4wdO1YxMDs729XVdeXKldx/t2/f/uzZM3VOMIRC4fvvv3/t2rU9e/ao/xhUTNXT0yORSJydnfsPHHAdZvz48URfOTk5df1M2Qh9fX0VFRU9PT1qbnyJREIpdXJyUvMBfPbZZ4GBgaGhodnZ2V9//TXRV1qqn3sC193dXVBQwB2cdu/e7eLiohihp6cnPz+/qanJ0tKSy2vatGmUUjWf+37yySeTJk36+OOPq6ur1X9UyqYyNze3s7NrbW0lL2vws16hUPirz2gXLFgw3HGG9PTpU3Nzc0tLy8HPeru7u+vq6jZs2PDZZ5/927/9m5ob39HR0cTERP0NEh8ff+HChby8PEdHx9/97ndNTU1EL2n12G9ubv6b3/zm6NGj5eXlYWFh/a8Knzx5csiNe+PGjevXr//qnK2trV/i/EfFVFOmTKmurn748OGQF7j8/f2Jvmpvb79169bkyZOH/K65ufmECRP27NkjEAhyc3PV3PimpqaTJ0/+7rvvOjo6Bo+WkZGxZs2an376STHkiy++sLCw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"
            },
            {
              "type": "input_text",
              "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
            }
          ],
          "solved_count": 0,
          "total_training_examples": 4,
          "pixel_accuracy": 0.0
        },
        "test_result": {
          "execution_error": "Traceback (most recent call last):\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmph9bb60z9.py\", line 107, in <module>\n    output = transform(test_input)\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmph9bb60z9.py\", line 56, in transform\n    for nr, nc in neighbors(rr, nc):\n                                ^^\nUnboundLocalError: cannot access local variable 'nc' where it is not associated with a value\n",
          "timed_out": false,
          "predicted_output": null
        },
        "status": "failed_test",
        "feedback_sent": true
      },
      {
        "turn_number": 6,
        "timestamp": "2025-07-10T13:36:12.886143",
        "input_tokens": 16985,
        "output_tokens": 837,
        "turn_cost": 0.0081332,
        "program_extracted": true,
        "program": "def transform(grid):\n    import numpy as np\n    from collections import deque\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def neighbors(r, c):\n        for nr, nc in ((r-1,c), (r+1,c), (r,c-1), (r,c+1)):\n            if 0 <= nr < rows and 0 <= nc < cols:\n                yield nr, nc\n\n    components = []\n\n    # Find largest connected component with single nonzero color\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                q = deque([(r, c)])\n                visited[r, c] = True\n                cells = []\n                while q:\n                    rr, cc = q.popleft()\n                    cells.append((rr, cc))\n                    for nr, nc in neighbors(rr, cc):\n                        if not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                components.append((len(cells), color, cells))\n\n    if not components:\n        # No colored component found, output empty 5x5 grid\n        return [[0] * 5 for _ in range(5)]\n\n    # Largest component\n    components.sort(key=lambda x: x[0], reverse=True)\n    size, color, cells = components[0]\n\n    rmin = min(r for r, c in cells)\n    rmax = max(r for r, c in cells)\n    cmin = min(c for r, c in cells)\n    cmax = max(c for r, c in cells)\n\n    block = grid[rmin:rmax + 1, cmin:cmax + 1]\n    h_in, w_in = block.shape\n\n    # Pad to at least 6x6 with color pixels if smaller\n    target = 6\n    if h_in < target or w_in < target:\n        padded = np.full((max(h_in, target), max(w_in, target)), fill_value=color, dtype=int)\n        padded[:h_in, :w_in] = block\n        block = padded\n        h_in, w_in = block.shape\n\n    # Crop to 6x6 top-left\n    block = block[:target, :target]\n    h_in, w_in = block.shape  # now 6x6\n\n    output = np.zeros((5, 5), dtype=int)\n\n    # For each output cell corresponding to 2x2 input cells check holes\n    for i in range(5):\n        for j in range(5):\n            subblock = block[i:i + 2, j:j + 2]\n            if np.any(subblock == 0):\n                output[i, j] = 0\n            else:\n                output[i, j] = color\n\n    return output.tolist()",
        "training_feedback": {
          "feedback_messages": [
            {
              "type": "input_text",
              "text": "Training results: 0/4 examples solved, 71.0% pixel accuracy - Good partial progress! Your approach is capturing some patterns. Next, try to identify a transformation that solves at least one of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[7, 7, 7, 7, 7], [7, 0, 7, 7, 7], [7, 7, 7, 0, 7], [7, 0, 7, 7, 7], [7, 7, 7, 7, 7]]\nYour output: [[7, 7, 0, 0, 7], [0, 0, 0, 0, 7], [0, 0, 7, 7, 7], [7, 7, 7, 7, 7], [7, 7, 7, 7, 7]]\nPixel accuracy: 64.0%\n\nTraining Example 2 \u2717:\nExpected: [[8, 8, 8, 8, 8], [8, 0, 8, 0, 8], [8, 8, 8, 8, 8], [8, 0, 8, 0, 8], [8, 8, 8, 8, 8]]\nYour output: [[0, 0, 8, 8, 8], [0, 0, 0, 0, 8], [0, 0, 0, 0, 8], [0, 0, 8, 8, 8], [8, 8, 8, 8, 8]]\nPixel accuracy: 60.0%\n\nTraining Example 3 \u2717:\nExpected: [[6, 6, 6, 6, 6], [6, 0, 6, 0, 6], [6, 6, 6, 6, 6], [6, 0, 6, 6, 6], [6, 6, 6, 6, 6]]\nYour output: [[6, 6, 6, 6, 6], [0, 0, 0, 0, 6], [0, 0, 0, 0, 6], [6, 6, 6, 6, 6], [6, 6, 6, 6, 6]]\nPixel accuracy: 72.0%\n\nTraining Example 4 \u2717:\nExpected: [[2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 0, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]]\nYour output: [[2, 2, 2, 2, 2], [0, 0, 2, 2, 2], [0, 0, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]]\nPixel accuracy: 88.0%\n\n"
            },
            {
              "type": "input_image",
              "image_url": "data:image/png;base64,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"
            },
            {
              "type": "input_text",
              "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
            }
          ],
          "solved_count": 0,
          "total_training_examples": 4,
          "pixel_accuracy": 0.71
        },
        "test_result": {
          "correct": false,
          "pixel_accuracy": 0.68,
          "total_pixels": 25,
          "correct_pixels": 17,
          "error": null
        },
        "status": "failed_test",
        "feedback_sent": true
      },
      {
        "turn_number": 7,
        "timestamp": "2025-07-10T13:36:26.928475",
        "input_tokens": 19109,
        "output_tokens": 887,
        "turn_cost": 0.009062800000000001,
        "program_extracted": true,
        "program": "def transform(grid):\n    import numpy as np\n    from collections import deque\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def neighbors(r, c):\n        for nr, nc in ((r-1,c), (r+1,c), (r,c-1), (r,c+1)):\n            if 0 <= nr < rows and 0 <= nc < cols:\n                yield nr, nc\n\n    components = []\n    # Identify largest connected component of one color (nonzero)\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                q = deque([(r, c)])\n                visited[r, c] = True\n                cells = []\n                while q:\n                    rr, cc = q.popleft()\n                    cells.append((rr, cc))\n                    for nr, nc in neighbors(rr, cc):\n                        if not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                components.append((len(cells), color, cells))\n\n    if not components:\n        return [[0]*5 for _ in range(5)]\n\n    # Choose largest component\n    components.sort(key=lambda x: x[0], reverse=True)\n    size, color, cells = components[0]\n\n    rmin = min(r for r, c in cells)\n    rmax = max(r for r, c in cells)\n    cmin = min(c for r, c in cells)\n    cmax = max(c for r, c in cells)\n\n    block = grid[rmin:rmax+1, cmin:cmax+1]\n    h_in, w_in = block.shape\n\n    # Nearest neighbor rescale block to 5x5 output\n    output = np.zeros((5, 5), dtype=int)\n    for i in range(5):\n        for j in range(5):\n            ri = int(round(i * (h_in - 1) / 4))\n            cj = int(round(j * (w_in - 1) / 4))\n            val = block[ri, cj]\n            if val == color:\n                output[i, j] = color\n            else:\n                # Zero or any other color (black holes are zeros)\n                output[i, j] = 0\n\n    return output.tolist()",
        "training_feedback": {
          "feedback_messages": [
            {
              "type": "input_text",
              "text": "Training results: 1/4 examples solved, 87.0% pixel accuracy - Great progress! You're on the right track. Next, try to identify a transformation that solves more than 1 of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[7, 7, 7, 7, 7], [7, 0, 7, 7, 7], [7, 7, 7, 0, 7], [7, 0, 7, 7, 7], [7, 7, 7, 7, 7]]\nYour output: [[7, 7, 7, 7, 7], [7, 7, 7, 0, 7], [7, 0, 7, 7, 7], [7, 7, 7, 7, 7], [7, 7, 7, 7, 7]]\nPixel accuracy: 80.0%\n\nTraining Example 2 \u2717:\nExpected: [[8, 8, 8, 8, 8], [8, 0, 8, 0, 8], [8, 8, 8, 8, 8], [8, 0, 8, 0, 8], [8, 8, 8, 8, 8]]\nYour output: [[8, 8, 8, 8, 8], [8, 0, 8, 8, 8], [8, 8, 8, 0, 8], [8, 0, 8, 8, 8], [8, 8, 8, 8, 8]]\nPixel accuracy: 88.0%\n\nTraining Example 3 \u2717:\nExpected: [[6, 6, 6, 6, 6], [6, 0, 6, 0, 6], [6, 6, 6, 6, 6], [6, 0, 6, 6, 6], [6, 6, 6, 6, 6]]\nYour output: [[6, 6, 6, 6, 6], [6, 6, 6, 6, 6], [6, 0, 6, 0, 6], [6, 6, 6, 6, 6], [6, 6, 6, 6, 6]]\nPixel accuracy: 80.0%\n\nTraining Example 4 \u2713:\nExpected: [[2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 0, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]]\nYour output: [[2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 0, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]]\n\n"
            },
            {
              "type": "input_image",
              "image_url": "data:image/png;base64,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"
            },
            {
              "type": "input_text",
              "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
            }
          ],
          "solved_count": 1,
          "total_training_examples": 4,
          "pixel_accuracy": 0.87
        },
        "test_result": {
          "correct": false,
          "pixel_accuracy": 0.92,
          "total_pixels": 25,
          "correct_pixels": 23,
          "error": null
        },
        "status": "failed_test",
        "feedback_sent": true
      },
      {
        "turn_number": 8,
        "timestamp": "2025-07-10T13:36:42.163437",
        "input_tokens": 21273,
        "output_tokens": 1401,
        "turn_cost": 0.0107508,
        "program_extracted": true,
        "program": "def transform(grid):\n    import numpy as np\n    from collections import deque\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def neighbors(r, c):\n        for nr, nc in ((r-1, c), (r+1, c), (r, c-1), (r, c+1)):\n            if 0 <= nr < rows and 0 <= nc < cols:\n                yield nr, nc\n\n    components = []\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                q = deque([(r, c)])\n                visited[r, c] = True\n                cells = []\n                while q:\n                    rr, cc = q.popleft()\n                    cells.append((rr, cc))\n                    for nr, nc in neighbors(rr, cc):\n                        if not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                components.append((len(cells), color, cells))\n\n    if not components:\n        return [[0] * 5 for _ in range(5)]\n\n    components.sort(key=lambda x: x[0], reverse=True)\n    size, color, cells = components[0]\n\n    rmin = min(r for r, c in cells)\n    rmax = max(r for r, c in cells)\n    cmin = min(c for r, c in cells)\n    cmax = max(c for r, c in cells)\n\n    block = grid[rmin:rmax + 1, cmin:cmax + 1]\n    h_in, w_in = block.shape\n\n    # Create mask of component color presence (1) and holes (0)\n    comp_mask = (block == color).astype(int)\n    zero_mask = (block == 0).astype(int)\n\n    # Detect internal holes fully enclosed by component (zero pixels surrounded by color)\n    # We'll use flood fill from border zeros to find external zeros, rest zeros inside are holes\n    external_zeros = np.zeros_like(zero_mask, dtype=bool)\n    from collections import deque\n    queue = deque()\n\n    # Add border zeros positions\n    for i in range(h_in):\n        for j in [0, w_in -1]:\n            if zero_mask[i,j]:\n                queue.append((i,j))\n                external_zeros[i,j] = True\n    for j in range(w_in):\n        for i in [0, h_in -1]:\n            if zero_mask[i,j]:\n                queue.append((i,j))\n                external_zeros[i,j] = True\n\n    # Flood fill external zeros\n    while queue:\n        x, y = queue.popleft()\n        for nx, ny in ((x-1,y), (x+1,y), (x,y-1), (x,y+1)):\n            if 0 <= nx < h_in and 0 <= ny < w_in:\n                if zero_mask[nx, ny] and not external_zeros[nx, ny]:\n                    external_zeros[nx, ny] = True\n                    queue.append((nx, ny))\n\n    # Holes mask are zeros not reachable from outside\n    holes_mask = zero_mask.astype(bool) & (~external_zeros)\n\n    def max_pool_2d(arr, out_h=5, out_w=5):\n        in_h, in_w = arr.shape\n        out_arr = np.zeros((out_h, out_w), dtype=int)\n        for i in range(out_h):\n            r0 = int(i * in_h / out_h)\n            r1 = int((i + 1) * in_h / out_h)\n            if r1 == r0:\n                r1 = min(r0+1, in_h)\n            for j in range(out_w):\n                c0 = int(j * in_w / out_w)\n                c1 = int((j + 1) * in_w / out_w)\n                if c1 == c0:\n                    c1 = min(c0+1, in_w)\n                block_slice = arr[r0:r1, c0:c1]\n                out_arr[i,j] = 1 if np.any(block_slice) else 0\n        return out_arr\n\n    comp_down = max_pool_2d(comp_mask)\n    holes_down = max_pool_2d(holes_mask.astype(int))\n\n    # Compose final output: where holes present \u2192 0, else color if comp_down present\n    output = np.where(holes_down==1, 0, comp_down * color)\n\n    return output.tolist()",
        "training_feedback": {
          "feedback_messages": [
            {
              "type": "input_text",
              "text": "Training results: 1/4 examples solved, 87.0% pixel accuracy - Great progress! You're on the right track. Next, try to identify a transformation that solves more than 1 of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[7, 7, 7, 7, 7], [7, 0, 7, 7, 7], [7, 7, 7, 0, 7], [7, 0, 7, 7, 7], [7, 7, 7, 7, 7]]\nYour output: [[7, 7, 7, 7, 7], [7, 7, 7, 0, 7], [7, 0, 7, 7, 7], [7, 7, 7, 7, 7], [7, 7, 7, 7, 7]]\nPixel accuracy: 80.0%\n\nTraining Example 2 \u2717:\nExpected: [[8, 8, 8, 8, 8], [8, 0, 8, 0, 8], [8, 8, 8, 8, 8], [8, 0, 8, 0, 8], [8, 8, 8, 8, 8]]\nYour output: [[8, 8, 8, 8, 8], [8, 0, 8, 8, 8], [8, 8, 8, 0, 8], [8, 0, 8, 8, 8], [8, 8, 8, 8, 8]]\nPixel accuracy: 88.0%\n\nTraining Example 3 \u2717:\nExpected: [[6, 6, 6, 6, 6], [6, 0, 6, 0, 6], [6, 6, 6, 6, 6], [6, 0, 6, 6, 6], [6, 6, 6, 6, 6]]\nYour output: [[6, 6, 6, 6, 6], [6, 6, 6, 6, 6], [6, 0, 6, 0, 6], [6, 6, 6, 6, 6], [6, 6, 6, 6, 6]]\nPixel accuracy: 80.0%\n\nTraining Example 4 \u2713:\nExpected: [[2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 0, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]]\nYour output: [[2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 0, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]]\n\n"
            },
            {
              "type": "input_image",
              "image_url": "data:image/png;base64,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"
            },
            {
              "type": "input_text",
              "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
            }
          ],
          "solved_count": 1,
          "total_training_examples": 4,
          "pixel_accuracy": 0.87
        },
        "test_result": {
          "correct": false,
          "pixel_accuracy": 0.92,
          "total_pixels": 25,
          "correct_pixels": 23,
          "error": null
        },
        "status": "failed_test"
      }
    ],
    "total_turns": 8,
    "conversation_history": [
      {
        "role": "system",
        "content": "You are an expert at solving abstract reasoning puzzles. Write clean, efficient Python code."
      },
      {
        "role": "user",
        "content": [
          {
            "type": "input_text",
            "text": "You are solving an ARC (Abstraction and Reasoning Corpus) task. \nI will show you training examples with input and output grids, plus a test input grid. Your task is to:\n\n1. **Analyze the training examples** to discover patterns that map input grids to output grids\n2. **Write a Python program** that implements your best understanding of the transformation  \n3. **DO NOT predict or generate the test output** - your job is only to write the transformation program\n4. **Attempt a solution** - even if the pattern isn't completely clear, provide your best hypothesis\n5. **Do not repeat the same transformation** - if you have already tried a transformation, do not repeat it.\n\n**IMPORTANT: Your transformation must always produce a 5\u00d75 output grid.**\n\nThe test input is shown for context so you understand what type of grid your program will eventually process. Focus on learning patterns from training examples and writing code that captures your understanding.\n\nTraining Examples:\n\nExample 1:\nInput:\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 7 7 7 7 7 0 0 0 0 0 0 0 0 0 0 0\n0 0 7 7 7 0 7 0 0 7 7 7 7 7 0 0 0 0\n0 0 7 0 7 7 7 0 0 7 7 7 7 7 0 0 0 0\n0 0 7 7 7 7 7 0 0 7 0 7 7 7 0 0 0 0\n0 0 7 7 7 7 7 0 0 7 7 7 0 7 0 0 0 0\n0 0 0 0 0 0 0 0 0 7 7 7 7 7 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 7 7 7 7 7 0 0 0 0 7 7 7 7 7 0\n0 0 0 7 7 7 0 7 0 0 0 0 7 0 7 7 7 0\n0 0 0 7 0 7 7 7 0 0 0 0 7 7 7 0 7 0\n0 0 0 7 7 7 7 7 0 0 0 0 7 0 7 7 7 0\n0 0 0 7 7 7 7 7 0 0 0 0 7 7 7 7 7 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\nOutput:\n7 7 7 7 7\n7 0 7 7 7\n7 7 7 0 7\n7 0 7 7 7\n7 7 7 7 7\n\nExample 2:\nInput:\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 8 8 8\n0 8 8 8 8 8 0 0 0 0 0 0 0 0 8 0 8 8 8\n0 8 0 8 0 8 0 0 8 8 8 8 8 0 8 8 8 0 8\n0 8 8 8 8 8 0 0 8 0 8 0 8 0 8 0 8 8 8\n0 8 0 8 8 8 0 0 8 8 8 8 8 0 8 8 8 8 8\n0 8 8 8 8 8 0 0 8 8 8 0 8 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 8 8 8 8 8 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 8 8 8 8 8 0 0\n0 0 0 8 8 8 8 8 0 0 0 0 8 8 8 0 8 0 0\n0 0 0 8 0 8 0 8 0 0 0 0 8 0 8 8 8 0 0\n0 0 0 8 8 8 8 8 0 0 0 0 8 8 8 0 8 0 0\n0 0 0 8 0 8 0 8 0 0 0 0 8 8 8 8 8 0 0\n0 0 0 8 8 8 8 8 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\nOutput:\n8 8 8 8 8\n8 0 8 0 8\n8 8 8 8 8\n8 0 8 0 8\n8 8 8 8 8\n\nExample 3:\nInput:\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 6 6 6 6 6 0 0 0 0 0 0 6 6 6 6 6 0 0\n0 6 6 6 6 6 0 0 0 0 0 0 6 0 6 0 6 0 0\n0 6 0 6 0 6 0 0 0 0 0 0 6 6 6 6 6 0 0\n0 6 6 6 6 6 0 0 0 0 0 0 6 0 6 6 6 0 0\n0 6 6 6 6 6 0 0 0 0 0 0 6 6 6 6 6 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 6 6 6 6 6 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 6 0 6 6 6 0 0 0 0 0 0 0\n0 6 6 6 6 6 0 6 6 6 6 6 0 0 0 0 0 0 0\n0 6 6 0 6 6 0 6 6 6 0 6 0 0 0 0 0 0 0\n0 6 6 6 6 6 0 6 6 6 6 6 0 0 6 6 6 6 6\n0 6 0 6 6 6 0 0 0 0 0 0 0 0 6 6 6 6 6\n0 6 6 6 6 6 0 0 0 0 0 0 0 0 6 0 6 6 6\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 6 6 0 6\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 6 6 6 6\nOutput:\n6 6 6 6 6\n6 0 6 0 6\n6 6 6 6 6\n6 0 6 6 6\n6 6 6 6 6\n\nExample 4:\nInput:\n0 0 0 0 0 0 0 0 2 2 2 2 2 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 2 2 2 0 2 0 0 0 0 0 0\n0 2 2 2 2 2 0 0 2 0 2 2 2 0 0 0 0 0 0\n0 2 0 2 0 2 0 0 2 2 2 2 2 0 0 0 0 0 0\n0 2 2 2 2 2 0 0 2 2 2 2 2 0 2 2 2 2 2\n0 2 2 2 2 2 0 0 0 0 0 0 0 0 2 2 2 0 2\n0 2 2 2 2 2 0 0 0 0 0 0 0 0 2 0 2 2 2\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2 2 2 2\n0 0 2 2 2 2 2 0 0 0 0 0 0 0 2 2 2 2 2\n0 0 2 2 0 2 2 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 2 2 2 2 2 0 0 2 2 2 2 2 0 0 0 0 0\n0 0 2 2 2 0 2 0 0 2 2 2 2 2 0 0 0 0 0\n0 0 2 2 2 2 2 0 0 2 0 2 2 2 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 2 2 2 2 2 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 2 2 2 2 2 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\nOutput:\n2 2 2 2 2\n2 2 2 2 2\n2 0 2 2 2\n2 2 2 2 2\n2 2 2 2 2\n\nTest Input:\n0 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 1 1 1 0 1 0 0 0 1 1 1 1 1 0 0 0 0 0\n0 1 1 1 1 1 0 0 0 1 0 1 0 1 0 0 0 0 0\n0 1 0 1 1 1 0 0 0 1 1 1 1 1 0 0 0 0 0\n0 1 1 1 1 1 0 0 0 1 1 1 1 1 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 1 1 1 1 1 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n1 1 1 1 1 0 0 0 0 0 0 0 0 0 1 1 1 1 1\n1 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 1 1 1\n1 1 1 1 1 0 0 1 1 1 1 1 0 0 1 1 1 0 1\n1 0 1 0 1 0 0 1 1 1 0 1 0 0 1 1 1 1 1\n1 1 1 1 1 0 0 1 0 1 1 1 0 0 1 1 1 1 1\n0 0 0 0 0 0 0 1 1 1 1 1 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 1 1 1 1 1 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\nAnalyze the patterns in the training examples and write a Python function that performs this transformation.\n\n**Approach Guidelines:**\n- Look for patterns in shapes, colors, positions, sizes, rotations, reflections, etc.\n- Even if you can't solve all training examples perfectly, implement what patterns you do observe\n- A partial solution that captures some aspects is better than returning the input unchanged\n- If the pattern is unclear, make your best educated guess based on what you can see\n\nRequirements:\n- The function takes a 2D list (grid) where grid[row][col] gives the value at that position\n- Values are integers from 0-9\n- Return a new grid (2D list) with the transformation applied\n- You can use numpy if needed - just add 'import numpy as np' at the start of your function\n- Aim to handle the training examples as well as possible, even if not perfectly\n- Your function should attempt some meaningful transformation based on the patterns you observe\n\nYou MUST end your response with the following exact format:\n\nFinal answer:\n```python\ndef transform(grid):\n    # Your transformation logic here (implement your best understanding)\n    return transformed_grid\n```\n"
          },
          {
            "type": "input_image",
            "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAkQAAAddCAIAAAAOY9D5AABPkklEQVR4nO3df7xVdZ3o/71180MQUbNJwfTwo1GKQiP8lfkjsGasbK0Js9J7OySpM5FxTaF69OPeyh9AM938ORoJFmWp17Ue08TDO8E8TLt3LFLCFFFwMFEoBZH8hecA6/v4zvne8+WinA57n8M677Ofz7+O++z3Wp+911n7xV5nI9WiKCoAENk+ZS8AABolZgCEJ2YAhCdmAIQnZgCEJ2YAhCdmAIQnZgCEJ2YAhCdmAIQnZgCEJ2YAhCdmADR3zGbMmFHdvfPOO+917zNw4MBDDz30rLPOeuCBB167zZ///OfVavXggw/eunXrLt+64447qtXq/PnzO/6ztbW1Wq3Omzdvl7s99dRT1Wr1y1/+ciNTHbZu3XrjjTeefvrpI0aMGDRo0IgRI84+++x77723vudkypQplUpl06ZNI0aMOOigg5566qldZv/mb/5m4MCBv/nNb7r5hHzsYx+rVqu1Wu3ZZ5997UrGjx9frVZbW1s7/nP69Ok7L2bfffc94IADjj/++O9973udI0mSVKvV1+6omw+tw8aNG2fNmnX00Ufvt99+Bx544EknnXTDDTds3769iycNIN47s/b29j/+8Y8//elPTz/99H//93/f5bs333xzpVLZvHnzT37yk+5s7atf/eqqVav2dA3dmXriiSdOPPHEiy666O67796wYUNbW9uGDRvuuOOOU0455R/+4R8q9XrDG95w8803P//889OmTdv539+57rrrsiy74oor3vWud+3RE7J9+/Y777xzlxt/97vfPfzww10sY8eOHS+88MKvf/3r6dOnz507t9JDnn322UmTJs2bN+/RRx/dunXrli1b/u3f/u3v/u7vzj77bP/YENBHY3bttdcW/8ftt99eqVQWLFjQecuiRYs677l27drO27du3frII4984hOf+NOf/nTDDTfsvMHnn38+z/Ozzz774IMP/sd//MfurKGtra21tXVP/+D/Z6fa29unTp3629/+9qSTTvqnf/qnjRs3tre3P/nkk9dff/3BBx88a9ashx56qIvt7/x4Oy1ZsqTju3/1V3/1mc98ZsmSJddee23HLStWrPj85z//vve97/Of//wePSH77rvvUUcdddttt+1y+49//OO3ve1tr73/hg0bOhazY8eOF1988Uc/+tHgwYMvv/zyV199tcsnrLsP7eqrr37iiSemTp26YsWKl1566fnnn//Xf/3XY489Nsuyn/70p93cBUCAd2aDBg06+uij58yZU6lUdnln9qMf/Wjr1q0XXnjhtGnT7rvvvgcffPDPbu2zn/3sr371q7//+7/fozX82albbrnl/vvvnzJlyj333POhD33oDW94Q61We/Ob3/y3f/u3d9555/bt22+99dZKA+bNm3f00UfPnj370UcfffHFFz/60Y8OHz78+9//frVa3dMn5KMf/egvfvGLZ555Zucbf/KTn5xzzjldLKBarQ4dOvTjH//4xz72sT/96U+PPfZYpSesWrWqVqstWrToHe94x5AhQ4YPH3766ad3vHG86667Ou6zcOHCarXaGXKAkDF79dVXH3744UsuuaRSqfzlX/7lzt9asGDBuHHj3vve9/7t3/7tvvvu2503Z1dcccXYsWO/+tWvPvLII91fw5+d+tGPflStVm+66aZ99913l2+deuqpK1eu/OY3v1lpwH777ffDH/5w27Zt55133kUXXbR69ervf//7b3rTm3a5W3eekI9+9KO7XGn89a9//fjjj3/0ox/tzko63pO99mHWZ8KECdu2bcuybOcbW1paiqK4/vrre2QXAKXFbNSoUZ0fFhg8ePD48eNvv/32Qw455HOf+1znfR566KHf/OY3l112WbVaHTNmzNlnn/3DH/7wxRdf7HrLQ4YMWbBgQXt7+x5dbPyzU8uXLx83btyoUaNed3zcuHG7vIXq4vF2uvvuu3e+zzvf+c7/+l//629+85sf/vCHl1xyyfvf//5dNtLNJ2T8+PFvfetbOy7zdvjxj3/8rne9a8yYMV2scPv27evXr//Od75z2223/cVf/MVRRx3VxZ27/9Bmzpx58sknf/zjHx89evT06dNvuumm1/7qrrW1tSiKGTNmdHOPAH30o/kjR4781Kc+tWLFikMPPbTzxptvvnnkyJHnnntux39+8YtffOGFF7pzNe/kk0+++OKLf/3rX3/rW9/q/hq6mGpvb3/++ed3eZ+0y2f5WlpaKg378Ic/3BHFk08++bXf7f4TsvOVxqIobrvttt1dYzzssMM61l+r1UaOHDlz5szt27dfccUVPfXObP/997/77rsXLVo0YcKEPM8vvPDC8ePHjxo16pZbbumR7QOUGbOOTw20tbX9+Mc/HjZs2Fve8parrrpqxIgRnXdob29ftGjR008/PWjQoI5X2wkTJhRF0c2PgVxxxRVvectbvva1r61cubL7q9rd1IABA4YNG/a6n3dv5FMSp5122s732bp16yc+8Ynhw4cPGzbswgsv3OWXXnv0hJxzzjmdVxrvueee9evX/9lrjPvss8/BBx88efLkPM/PP//8Hnxo++6777nnnptl2caNG1evXr1gwYI3velNra2t3/72t7u/F4C++85swIAB55xzzk9+8pNf/OIXf/VXf7Xz32f653/+59eNxwMPPLBs2bI/u+X99tuvjouNXUy9/e1vX7ly5ZNPPvm6H92cOHFipWEzZ8588MEHr/4PzzzzzKc+9amdv7tHT8jRRx/99re/veMzjT/5yU9OOOGEI4444nV32vlpxu3bt2/atGnJkiUf/vCHK71m7Nixra2tv/zlL4899tgGf8sI0LcuM/71X//1Zz/72QceeODSSy/tvPHmm28ePHjwli1bdv7z/v/+3/+7UqnceOON3dnsu9/97s997nPLli177V+IrmPq3HPP3bFjx9/93d+9bhob/ytTt99++4033viJT3ziP/2n/9Ta2vqRj3zkZz/72c5/UWFPn5Bzzjnnnnvu6fibcF1/jrH3PP3009Vqdfr06bvcXqvV3v72tz///PNtbW2lLAzo98r5ndkVV1xxxBFH3HDDDb/61a8qlcof/vCHu+6660Mf+tABBxyw891OPPHEo4466tZbb92yZUt3Nnv55Ze/5S1v2dNPzb3u1PTp0ydOnPizn/3suOOOu+222/7whz+0t7d3pOIDH/jAAw88sM8+9T91a9eu/fSnPz1q1KjOet14442HHXbY5z//+Y6/yl3HE9JxpXHmzJkbN248++yzK2UYOXLkO9/5zptvvnnGjBn/9m//9sc//nHr1q2PP/749ddff/vttx933HEDBw4sZWFAv1dOzIYOHXrNNdfs2LHjwgsv3LZt2/e///1t27Z1ftJhZ5/85CdffvnlH/zgB92/bNj15wy7OTVw4MA8z0888cQHHnjgnHPOOeywwwYOHNjxv7NavHjxUUcd1fX/oOR1P/JXrVZffPHF9vb2c84556WXXvrhD3/Y2ao3vOENCxcu3Lp167nnntve3l7HEzJ27Nhjjz32tttue8973rPzLyPrsN9+++2y7IULF3bnoXW8oTzwwAOvu+66k0466dBDD91vv/3Gjh37mc98plardf7FMn/PDOg//6Phs846K0mSFStW/Pf//t8XLlx40EEH/fVf//Vr7/af//N/3meffbp5pbHjsuHMmTP3dDGvO3X44Yffe++9ixYtOvPMMw8//PCBAwe+6U1vOvPMM2+55ZaHHnpo0qRJlbp84QtfWLZs2de+9rUTTzxx59vf9773zZgx44EHHvjyl79c3xPScXWxm3+9rJdMmDDh4Ycf/vznPz9+/PgDDjhg4MCBLS0tF1xwwe9+97se+UUjwOuq+j/mARCdfwIGgPDEDIDwxAyA8MQMgPDEDIDwxAyA8MQMgPDEDIDwxAyA8MQMgPDEDIDwxAyA8MQMgPDEDIDwxAyA8MQMgPDEDIDwxAyA8MQMgPDEDIDwxAyA8MQMgPDEDIDwxAyA8MQMgPDEDIDwxAyA8MQMgPDEDIDwxAyA8MQMgPDEDIDwxAyA8MQMgPDEDIDwxAyA8MSMvmLTpk2rVq0qexXQRCfOpn500okZ9UiSpLW1tWe3OWXKlPvuu293333++edHjx7dxR0gunXr1n36058eOXLk4MGDR48efemllz733HMNnjjNc9KJGX3FK6+8srtvrVu3bsqUKWvXrt27K4K957HHHps4ceLmzZsXL1783HPP3XnnnY888sjEiRM3bNhQ94nTVCedmNGQjRs3VqvV6667rqWlZfDgwe9///uffvrpztu/973vHX744cOHDz///PM7TpunnnqqWq0+8cQTHePf+ta3TjjhhEqlctpppz366KPTpk2bPn36Lrv42c9+Nn78+IkTJ5bx+GAvmT59+qmnnnrHHXdMmDBhyJAhxxxzzE9/+tNDDz304osv7uaJs7G5TzoxowfccsstS5cuXbVq1fr167/+9a933j537ty77rpr+fLl999//4wZM7rYwt13333UUUctWLBg/vz5u3xr0KBBS5Ysue6663pt+VCy3//+9/fee+8u58g+++wzc+bMPM83b97c/RNnbrOedGJGD/jKV74yZsyYlpaW1tbWZcuWdd4+Z86c8ePHjx49et68eYsWLXrppZfq2PiUKVMmTZrUo+uFvmXlypWVSmXcuHG73D5hwoRt27atWbOm+5ua06wnnZjRA1paWjq+GDp0aHt7e+ftHVczKpXKMccc09bW9vjj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+eWXi6JYt25dpVJZu3Ztx3bmzZt3/PHHF0Vx6qmndvxAnn/++Tvv6H/9r/9Vq9VeffXVjv/8p3/6pyFDhuzYsaOMBw2lec973jN16tSdb9m+ffsJJ5zQceO6bpxW/f6U9M6MHnDLLbcsXbp01apV69ev//rXv955+9y5c++6667ly5fff//9M2bM6GILd99991FHHbVgwYL58+fvfPtJJ53U3t4+cODAjv/csGHDwQcfXK1We+2hQJ/z+9///t57793lDNpnn31mzpyZ5/nmzZu7f1r141NSzOgBX/nKV8aMGdPS0tLa2rps2bLO2+fMmTN+/PjRo0fPmzdv0aJFL730UiN72bJly1VXXXX++ef3xJIhjJUrV1YqlXHjxu1y+4QJE7Zt27ZmzZrub6ofn5JiRg9oaWnp+GLo0KHt7e2dt59wwgkdXxxzzDFtbW2PP/543bt46aWXPvShD40fP/7LX/5yw+uFSDre92zfvn2X21999dU93dQJ/feUFDN6wIABAzq/Loritbd3nIe1Wm2XyxGvPT9f16ZNmyZPnnz44YffcccdtVqt5xYOAXS8J+t4f7azVatW1Wq1sWPHdv+06senpJjRix588MGOL5YvX77//vuPGTOm41J758WNJ598svPOu7vs/tRTT5188smnnHLKD3/4w84r9dA8jjzyyMmTJ1911VU737hjx465c+eeddZZBx10UPdPq358SooZvWjWrFlr165dvXr17NmzL7jggkGDBh1yyCGjRo268cYbX3755SVLltx6662ddx46dOj69etfeOGFnbfw/PPPv/e97z3rrLPmzp3bF37JDKW46aabHn744fPOO++xxx5rb29fuXLl1KlTn3nmmWuuuaZSqXT/tOrPp2TZH6ekP3w0/5FHHum4/YYbbnjb297WefsXvvCFI4888qCDDrrkkkva2to67rN06dJx48YNGjTolFNO6fwccFEU3/3ud/fff/+PfOQjO+/oyiuvfO0P7QsvvLDXHzGUbMOGDZ/5zGeOOOKIQYMGtbS0zJw5c+PGjZ3fXfrnTqt+f0pWd/4Nx55K07TuWfq3tra2xYsXT548ediwYWWvhf4jy7JKNH3kdbItwinZyPFt9Bd3eZ7XN5gkidl+PHvmmWdWKpWlS5fu5f0GnZ0wr85zeMVlaVPNBtUXnueXN29cvPiNR8+69pDR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qR199atf/dCHPnT00Ud38/47dux44YUXfv0fNm3aNGvWrJ5aCQB95Z3ZtddeW/wft99+e6VSWbBgQectixYt6rzn2rVri9dYsmRJx3evvvrqJ554YurUqStWrHjppZeef/75f/3Xfz322GOzLPvpT3+6RzvqWltbW2tra+cbvt3ZsGFDx5Z37Njx4osv/uhHPxo8ePDll1/+6quv9vgzA0A/+Z3ZqlWrarXaokWL3vGOdwwZMmT48OGnn376nXfeWalU7rrrrh7c0Wc/+9lf/epXf//3f9/N+1er1aFDh3784x//2Mc+9qc//emxxx7rwcUsXLiwWq1ee+21PbhNgObUJ2I2YcKEbdu2ZVm2840tLS1FUVx//fU9uKMrrrhi7NixX/3qVx955JE9Gux4T7bvvvv24GIACBazUaNGvfZzEHfffXfHd2fOnHnyySd//OMfHz169PTp02+66aaHH364N5YxZMiQBQsWtLe3d+diY6VS2b59+/r167/zne/cdtttf/EXf3HUUUf14GJaW1uLopgxY0YPbhOgOfWJd2b777//3XffvWjRogkTJuR5fuGFF44fP37UqFG33HJLj+/r5JNPvvjii3/9619/61vf2t19DjvssI7c1mq1kSNHzpw5c/v27VdccYV3ZgBNHbPX/QDIaaed1nmHfffd99xzz82ybOPGjatXr16wYMGb3vSm1tbWb3/72z2+mCuuuOItb3nL1772tZUrV3Z9z3322efggw+ePHlynufnn39+x4212v/7EdD29vZd7txxS8d3AWi6d2a7GDt2bGtr6y9/+ctjjz32m9/8Zo9vf7/99uv6YmPnpxm3b9++adOmJUuWfPjDH+787vDhwyuVyjPPPLPL1B/+8IfO7wLQXDF7+umnq9Xq9OnTd7m9Vqu9/e1vf/7559va2np8p+9+97s/97nPLVu27LV/jfrPGjVq1Ot+zLLjltGjR/fcMgHolvKviY0cOfKd73znzTffPHjw4HPPPXf06NHDhw9/+umn/+f//J+33377cccdN3DgwN7Y7+WXX/7P//zPdXxa8owzzhgwYMDcuXOHDx9+7rnnvvGNb/zjH//44x//+JprrhkyZMh73/ve3lgtAH3004zVavXFF1+sVCo333zzgQceeN1115100kmHHnrofvvtN3bs2M985jO1Wq33/hpWx8XGOv73IiNHjvxv/+2/tbW1XXbZZSNGjBgwYMDhhx9+6aWXbtu27R/+4R/e+MY3dnM7/p4ZQH/7e2YPP/zw5z//+fHjxx9wwAEDBw5saWm54IILfve7302cOLH39vvud7975syZdQx+8YtfzPP8/e9//5ve9KYBAwYcdthhH/rQh5YsWXLhhRf2wjIB+DOqRVH8ufsAQJ/WJ96ZAUAjxAyA8MQMgPDEDIDwxAyA8MQMgPDEDIDwxAyA8MQMgPDEDIDwxAyA8MQMgPDEDIDwxAyA8MQMgPDEDIDwxAyA8MQMgPDEDIDwxAyA8MQMgPDEDIDwxAyA8MQMgPDEDIDwxAyA8MQMgPDEDIDwxAyA8MQMgPDEDIDwxAyA8MQMgPDEDIDwxAyA8MQMgPDEDHrSpk2bVq1a1f/2BX2cmEFl6tSp1dezZMmSPd3UlClT7rvvvtfeniRJa2trD633z+wLmpCYQeWOO+4o/sOCBQuGDh3a8XVRFFOmTNnTTb3yyiu9s8aS9wV9nJjBn7Fhw4apU6fuv//+b37zmy+55JLOhPzjP/7j6NGjhw0bNmnSpDvvvLNSqZx22mmPPvrotGnTpk+fvrutbdy4sVqtXnfddS0tLYMHD37/+9//9NNPd97+ve997/DDDx8+fPj555/fsaOnnnqqWq0+8cQTHePf+ta3TjjhhG7uC5qHmMGf8ZGPfGTYsGFPPPHEL37xi2XLlv2X//JfKpXKgw8+OGvWrDvuuGPjxo2f+9znPvGJT2zevPnuu+8+6qijFixYMH/+/K63ecsttyxdunTVqlXr16//+te/3nn73Llz77rrruXLl99///0zZszoYgvd3xc0AzGDrtxzzz0rVqy48cYbDznkkNGjR3/729/+7ne/u3Xr1t///veVSmXo0KGDBg0677zztm7detBBB3V/s1/5ylfGjBnT0tLS2tq6bNmyztvnzJkzfvz40aNHz5s3b9GiRS+99FLvPCzob8QMurJy5cqXX3550KBBHR8JmTRp0o4dO/793//9jDPOOO6448aNG3fcccd94xvfeOqpp/Zosy0tLR1fDB06tL29vfP2jkuIlUrlmGOOaWtre/zxx3v00UC/JWbQlW3bto0dO7b4v731rW8dPHjwz3/+81/+8peTJ0/+wQ9+cOyxx65evbr7mx0wYEDn10VRvPb27du3VyqVWq1WrVZ3Huy4HdiFmEFXjj766LVr177uG69qtXrSSSddeeWVK1euHDJkyL/8y7903NjI7h588MGOL5YvX77//vuPGTNm4MCBlUql83rjk08+ufMCGtkX9CdiBl1573vf+453vGPatGnr1q17+umnZ86cecQRR7z66qs/+MEPWlpaHnrooba2tnvvvfeZZ5555zvf2XHZcP369S+88EJ9u5s1a9batWtXr149e/bsCy64YNCgQYcccsioUaNuvPHGl19+ecmSJbfeemvnnRvcF/QnYgZd2WefffI8Hzp06Lhx49761rc++uij//Iv/9LxoY9PfvKTZ5555rBhwy644ILrr7/+xBNPrFQqF1100ZVXXjlt2rT6djdlypTTTz/9+OOPP+OMM6666qqOt1/z589fsmTJwQcf/I1vfONLX/pS550b3Bf0J9Wdr9fTtTRNy14C/VZbW9vixYsnT548bNiwstdCX5FlWdlLCKNW9gKCyfO8vsEkSfKxc+qcXTO76WYbeZ4jzy5durSU/Zrtm7N0n8uMAIQnZgCEJ2YAhCdmAIQnZgCEJ2YAhCdmAIQnZgCEJ2YAhCdmAIQnZgCEJ2YAhCdmAIQnZgCEJ2YAhCdmAIQnZgCEJ2YAhFctiqLsNYSRpmnZSwCaSJZlZS8hjFrZCwgmz/P6BpMkycfOqXN2zezSZst6vI3st6zZiMc34s9VM83SfS4zAhCemAEQnpgBEJ6YARCemAEQnpgBEJ6YARCemAEQnpgBEJ6YARCemAEQnpgBEJ6YARCemAEQnpgBEJ6YARCemAEQnpgBEF61KIqy1xBGmqZlLwFoIlmWlb2EMGplLyCYPM/rG0ySJB87p87ZNbObbraR57ms2bIeb7Ptt5lm6T6XGQEIT8wACE/MAAhPzAAIT8wACE/MAAhPzAAIT8wACE/MAAhPzAAIT8wACE/MAAhPzAAIT8wACE/MAAhPzAAIT8wACE/MAAivWhRF2WsII03TspcANJEsy8peQhi1shcQTJ7n9Q0mSZKPnVPn7JrZpe23rNlGHm9ZsxGfZ8e3b8/SfS4zAhCemAEQnpgBEJ6YARCemAEQnpgBEJ6YARCemAEQnpgBEJ6YARCemAEQnpgBEJ6YARCemAEQnpgBEJ6YARCemAEQnpgBEF61KIqy1xBGmqZlLwFoIlmWlb2EMGplLyCYPM/rG0ySJB87p87ZNbObbraR57ms2YjPs+Pbt2fpPpcZAQhPzAAIT8wACE/MAAhPzAAIT8wACE/MAAhPzAAIT8wACE/MAAhPzAAIT8wACE/MAAhPzAAIT8wACE/MAAhPzAAIT8wACK9aFEXZawgjTdOylwA0kSzLyl5CGLWyFxBMnuf1DSZJYrafz46dU+fsmtlNNxvx+JYxS/e5zAhAeGIGQHhiBkB4YgZAeGIGQHhiBkB4YgZAeGIGQHhiBkB4YgZAeGIGQHhiBkB4YgZAeGIGQHhiBkB4YgZAeGIGQHhiBkB41aIoyl5DGGmalr0EoIlkWVb2EuIo6LYkSep+ns2aNWt2T5X9mheJy4wAhCdmAIQnZgCEJ2YAhCdmAIQnZgCEJ2YAhCdmAIQnZgCEJ2YAhCdmAIQnZgCEJ2YAhCdmAIQnZgCEJ2YAhCdmAIQnZgCEVy2Kouw1hJGmadlLAJpIlmVlLyGMWtkLCCYfO6e+wWTN7KabzfM6Z5PEbD+fjfjzXMYs3ecyIwDhiRkA4YkZAOGJGQDhiRkA4YkZAOGJGQDhiRkA4YkZAOGJGQDhiRkA4YkZAOGJGQDhiRkA4YkZAOGJGQDhiRkA4YkZAOFVi6Ioew1hpGla9hKAJpJlWdlLCKNW9gKCycfOqW8wWTM7z/M6Z5Ok6fZrtn/PRvx5LmOW7nOZEYDwxAyA8MQMgPDEDIDwxAyA8MQMgPDEDIDwxAyA8MQMgPDEDIDwxAyA8MQMgPDEDIDwxAyA8MQMgPDEDIDwxAyA8MQMgPCqRVGUvYYw0jQtewlAE8myrOwlhFErewHB5GPn1DeYrJnddLN5XudskjQ0G/G5coz693NV737pPpcZAQhPzAAIT8wACE/MAAhPzAAIT8wACE/MAAhPzAAIT8wACE/MAAhPzAAIT8wACE/MAAhPzAAIT8wACE/MAAhPzAAIT8wACK9aFEXZawgjTdOylwA0kSzLyl5CGLWyFxBMPnZOfYPJmtl5ntc5myRNt9+y1lzWrGPU949RGbN0n8uMAIQnZgCEJ2YAhCdmAIQnZgCEJ2YAhCdmAIQnZgCEJ2YAhCdmAIQnZgCEJ2YAhCdmAIQnZgCEJ2YAhCdmAIQnZgCEJ2YAhFctiqLsNYSRpmnZSwCaSJZlZS8hjFrZCwgmHzunvsFkzeymm83zOmeTpKHZstbsGPXv56qMWbrPZUYAwhMzAMITMwDCEzMAwhMzAMITMwDCEzMAwhMzAMITMwDCEzMAwhMzAMITMwDCEzMAwhMzAMITMwDCEzMAwhMzAMITMwDCqxZFUfYawkjTtOwlAE0ky7KylxBGrewFBJPneX2DSZKY3UuzY+fUObtmdtPNRjy+zTRL97nMCEB4YgZAeGIGQHhiBkB4YgZAeGIGQHhiBkB4YgZAeGIGQHhiBkB4YgZAeGIGQHhiBkB4YgZAeGIGQHhiBkB4YgZAeGIGQHjVoijKXkMYaZqWvQSgiWRZVvYSwqiVvYBg8jyvbzBJErN7aXbsnDpn18xuutmIx7eZZuk+lxkBCE/MAAhPzAAIT8wACE/MAAhPzAAIT8wACE/MAAhPzAAIT8wACE/MAAhPzAAIT8wACE/MAAhPzAAIT8wACE/MAAhPzAAIr1oURdlrCCNN07KXADSRLMvKXkIcBd2WJEndz7NZs2bN7qmyX/MicZkRgPDEDIDwxAyA8MQMgPDEDIDwxAyA8MQMgPDEDIDwxAyA8MQMgPDEDIDwxAyA8MQMgPDEDIDwxAyA8MQMgPDEDIDwxAyA8KpFUZS9hjDSNC17CUATybKs7CXEUdBtSZLU/TybNWvW7J4q+zUvEpcZAQhPzAAIT8wACE/MAAhPzAAIT8wACE/MAAhPzAAIT8wACE/MAAhPzAAIT8wACE/MAAhPzAAIT8wACE/MAAhPzAAIT8wACK9aFEXZawgjTdOylwA0kSzLyl5CHAXdliRJ3c+zWbNmze6psl/zInGZEYDwxAyA8MQMgPDEDIDwxAyA8MQMgPDEDIDwxAyASnT/DyL4qtnfmLw4AAAAAElFTkSuQmCC"
          },
          {
            "type": "input_text",
            "text": "Above is a visual representation of all the training examples and the test input. Each grid cell is colored according to its value (0-9), with clear labels and arrows showing input\u2192output transformations. Use both the textual and visual information to understand the pattern."
          }
        ]
      },
      {
        "type": "message",
        "role": "assistant",
        "content": [
          "Analysis:\n\nFrom the textual training examples and the visuals:\n\n- Each training input is a larger grid with 4 scattered colored squares (color 6,7,8,2 in examples).\n- Each colored square is 6x6 in size visually with several internal black dots.\n- Output for each training example is a 5x5 grid with the same color as the input squares.\n- The 5x5 output seems to be extracted from the top-left 5x5 portion of one of the input squares, or the left 5 columns and top 5 rows of a square, capturing the pattern inside that square.\n- The output pattern shows the black dots inside the square in the output.\n- Usually in training, the output captures the largest compact square block of color in the input, cropping it down to 5x5.\n- It looks like the task is to find one of the color squares, extract a 5x5 section showing the shape/pattern inside that colored square.\n\nFor the test input:\n\n- The input also shows multiple scattered color squares (color is 1).\n- The output is expected to be a 5x5 grid with that color and the pattern inside it.\n- The code should:\n   1. Find the largest connected component of a non-zero color.\n   2. Extract a 5x5 subgrid of that component (perhaps top-left 5x5 or bounding box cropped to 5x5).\n   3. Fill cells with the color or 0 according to original pattern.\n- The pattern of black dots inside the squares are preserved.\n\nImplementation plan:\n\n- Identify all non-zero connected components with the same color.\n- Choose the largest one by area.\n- Extract the bounding box of that component.\n- Crop to a 5x5 grid from the top-left corner of that bounding box in the input grid.\n- Create output 5x5 grid with:\n   - The color of that component in cells belonging to the component inside the crop.\n   - zero elsewhere.\n   - Black dots correspond to zero values inside the square (so keep original 0's as zero).\n- Return this 5x5 grid.\n\nThis aligns well with all training examples as well as the test input pattern.\n\nWe will use BFS or DFS for connected component extraction.\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n    from collections import deque\n    \n    grid = np.array(grid)\n    rows, cols = grid.shape\n    \n    # Find all connected components of nonzero colors\n    visited = np.zeros_like(grid, dtype=bool)\n    \n    def neighbors(r,c):\n        for nr,nc in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\n            if 0 <= nr < rows and 0 <= nc < cols:\n                yield nr,nc\n    \n    components = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            if grid[r,c] != 0 and not visited[r,c]:\n                color = grid[r,c]\n                q = deque([(r,c)])\n                visited[r,c] = True\n                cells = []\n                while q:\n                    rr,cc = q.popleft()\n                    cells.append((rr,cc))\n                    for nr,nc in neighbors(rr,cc):\n                        if not visited[nr,nc] and grid[nr,nc] == color:\n                            visited[nr,nc] = True\n                            q.append((nr,nc))\n                components.append((len(cells), color, cells))\n    \n    if not components:\n        # No nonzero colors, output empty 5x5 zero grid\n        return [[0]*5 for _ in range(5)]\n    \n    # Choose largest component by size\n    components.sort(reverse=True, key=lambda x: x[0])\n    size, color, cells = components[0]\n    \n    # Get bounding box of largest component\n    rows_c = [r for r,c in cells]\n    cols_c = [c for r,c in cells]\n    rmin, rmax = min(rows_c), max(rows_c)\n    cmin, cmax = min(cols_c), max(cols_c)\n    \n    # Extract 5x5 subgrid from top-left corner of bounding box, or as fits\n    # The bounding box can be bigger than 5x5, crop accordingly\n    r_end = min(rmin+5, rows)\n    c_end = min(cmin+5, cols)\n    \n    subgrid = grid[rmin:r_end, cmin:c_end]\n    \n    # Create output 5x5 initially zeros\n    out = np.zeros((5,5), dtype=int)\n    \n    # Place the pattern into output\n    # For each cell in subgrid:\n    # If cell == color => place color\n    # else => 0 (black dot inside square)\n    for rr in range(subgrid.shape[0]):\n        for cc in range(subgrid.shape[1]):\n            if subgrid[rr, cc] == color:\n                out[rr, cc] = color\n            else:\n                out[rr, cc] = 0\n                \n    return out.tolist()\n```\n"
        ]
      },
      {
        "role": "user",
        "content": [
          {
            "type": "input_text",
            "text": "Please analyze the training feedback and programs from all prior turns, and write an improved transformation.\n\n**Important**:\n1. Always start by attempting to find a complete rule that solves all training examples and should generalize to the test input.\n2. If you cannot find a perfect solution, provide your best attempt at a transformation that solves as many training examples as possible - ideally more than in the best previous turn.\n3. Even if your solution doesn't solve all examples perfectly, ensure it demonstrates meaningful pattern recognition and provides reasonable outputs that minimize pixel-level errors.\n\nFinal answer:\n```python\ndef transform(grid):\n    # Your improved transformation logic here (even if partial)\n    return transformed_grid\n```"
          },
          {
            "type": "input_text",
            "text": "Training results: 1/4 examples solved, 87.0% pixel accuracy - Great progress! You're on the right track. Next, try to identify a transformation that solves more than 1 of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[7, 7, 7, 7, 7], [7, 0, 7, 7, 7], [7, 7, 7, 0, 7], [7, 0, 7, 7, 7], [7, 7, 7, 7, 7]]\nYour output: [[7, 7, 7, 7, 7], [7, 7, 7, 0, 7], [7, 0, 7, 7, 7], [7, 7, 7, 7, 7], [7, 7, 7, 7, 7]]\nPixel accuracy: 80.0%\n\nTraining Example 2 \u2717:\nExpected: [[8, 8, 8, 8, 8], [8, 0, 8, 0, 8], [8, 8, 8, 8, 8], [8, 0, 8, 0, 8], [8, 8, 8, 8, 8]]\nYour output: [[8, 8, 8, 8, 8], [8, 0, 8, 8, 8], [8, 8, 8, 0, 8], [8, 0, 8, 8, 8], [8, 8, 8, 8, 8]]\nPixel accuracy: 88.0%\n\nTraining Example 3 \u2717:\nExpected: [[6, 6, 6, 6, 6], [6, 0, 6, 0, 6], [6, 6, 6, 6, 6], [6, 0, 6, 6, 6], [6, 6, 6, 6, 6]]\nYour output: [[6, 6, 6, 6, 6], [6, 6, 6, 6, 6], [6, 0, 6, 0, 6], [6, 6, 6, 6, 6], [6, 6, 6, 6, 6]]\nPixel accuracy: 80.0%\n\nTraining Example 4 \u2713:\nExpected: [[2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 0, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]]\nYour output: [[2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 0, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]]\n\n"
          },
          {
            "type": "input_image",
            "image_url": "data:image/png;base64,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"
          },
          {
            "type": "input_text",
            "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
          }
        ]
      },
      {
        "type": "message",
        "role": "assistant",
        "content": [
          "The main error in the previous attempt is that the positions of the zero pixels inside the colored square (the \"holes\") are misplaced. The output black pixels in training examples 1-3 don't just come from the input zeros inside the bounding box. Instead, the pattern appears to:\n\n- Preserve the shape and color of the biggest colored square\n- Place zeros (black dots) exactly where the input colored square had holes\n- These holes have precise positions relative to the square (like symmetrical holes)\n\nBy examining the training examples in detail:\n\n- The output is always a 5x5 grid\n- The pattern is the internal layout of one colored block reduced (not just cropped), but shifted/scaled down to 5x5.\n- The holes tend to be positioned symmetrically, often in consistent positions in the 5x5.\n- There seem to be two main \"types\" of internal hole patterns seen in the training examples, frequently centered in a 5x5 grid.\n  \nBased on these, my improved approach is:\n\n1. Extract the largest connected colored component as before.\n2. Get its bounding box.\n3. Resize that bounding box to 5x5, preserving the relative hole positions. Use nearest-neighbor downsampling.\n4. In the resized version, replace colored pixels by the component's color, and zeros remain zeros.\n\nThis resizing approach should capture the holes and shape proportionally and recreate the exact layout within a 5x5 frame.\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n    from collections import deque\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n\n    # Find largest connected component of a single color (nonzero)\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def neighbors(r,c):\n        for nr,nc in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\n            if 0 <= nr < rows and 0 <= nc < cols:\n                yield nr,nc\n\n    components = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r,c] != 0 and not visited[r,c]:\n                color = grid[r,c]\n                q = deque([(r,c)])\n                visited[r,c] = True\n                cells = []\n                while q:\n                    rr,cc = q.popleft()\n                    cells.append((rr,cc))\n                    for nr,nc in neighbors(rr,cc):\n                        if not visited[nr,nc] and grid[nr,nc] == color:\n                            visited[nr,nc] = True\n                            q.append((nr,nc))\n                components.append((len(cells), color, cells))\n\n    if not components:\n        # no colored component -> 5x5 zeros\n        return [[0]*5 for _ in range(5)]\n\n    # Largest colored component\n    components.sort(reverse=True, key=lambda x: x[0])\n    size, color, cells = components[0]\n\n    rows_c = [r for r,c in cells]\n    cols_c = [c for r,c in cells]\n    rmin, rmax = min(rows_c), max(rows_c)\n    cmin, cmax = min(cols_c), max(cols_c)\n\n    block = grid[rmin:rmax+1, cmin:cmax+1]\n\n    # Resize block to 5x5 using nearest neighbor sampling\n    # Define a function for nearest-neighbor downsampling to 5x5\n    def resize_to_5x5(arr):\n        h, w = arr.shape\n        result = np.zeros((5,5), dtype=int)\n        for i in range(5):\n            for j in range(5):\n                # Map output i,j to input coordinates\n                x = int(round(i * (h-1) / 4))\n                y = int(round(j * (w-1) / 4))\n                result[i,j] = arr[x,y]\n        return result\n\n    resized = resize_to_5x5(block)\n\n    # Map nonzero pixels to color, zeros remain 0\n    output = np.where(resized != 0, color, 0)\n\n    return output.tolist()\n```"
        ]
      },
      {
        "role": "user",
        "content": [
          {
            "type": "input_text",
            "text": "Please analyze the training feedback and programs from all prior turns, and write an improved transformation.\n\n**Important**:\n1. Always start by attempting to find a complete rule that solves all training examples and should generalize to the test input.\n2. If you cannot find a perfect solution, provide your best attempt at a transformation that solves as many training examples as possible - ideally more than in the best previous turn.\n3. Even if your solution doesn't solve all examples perfectly, ensure it demonstrates meaningful pattern recognition and provides reasonable outputs that minimize pixel-level errors.\n\nFinal answer:\n```python\ndef transform(grid):\n    # Your improved transformation logic here (even if partial)\n    return transformed_grid\n```"
          },
          {
            "type": "input_text",
            "text": "Training results: 1/4 examples solved, 87.0% pixel accuracy - Great progress! You're on the right track. Next, try to identify a transformation that solves more than 1 of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[7, 7, 7, 7, 7], [7, 0, 7, 7, 7], [7, 7, 7, 0, 7], [7, 0, 7, 7, 7], [7, 7, 7, 7, 7]]\nYour output: [[7, 7, 7, 7, 7], [7, 7, 7, 0, 7], [7, 0, 7, 7, 7], [7, 7, 7, 7, 7], [7, 7, 7, 7, 7]]\nPixel accuracy: 80.0%\n\nTraining Example 2 \u2717:\nExpected: [[8, 8, 8, 8, 8], [8, 0, 8, 0, 8], [8, 8, 8, 8, 8], [8, 0, 8, 0, 8], [8, 8, 8, 8, 8]]\nYour output: [[8, 8, 8, 8, 8], [8, 0, 8, 8, 8], [8, 8, 8, 0, 8], [8, 0, 8, 8, 8], [8, 8, 8, 8, 8]]\nPixel accuracy: 88.0%\n\nTraining Example 3 \u2717:\nExpected: [[6, 6, 6, 6, 6], [6, 0, 6, 0, 6], [6, 6, 6, 6, 6], [6, 0, 6, 6, 6], [6, 6, 6, 6, 6]]\nYour output: [[6, 6, 6, 6, 6], [6, 6, 6, 6, 6], [6, 0, 6, 0, 6], [6, 6, 6, 6, 6], [6, 6, 6, 6, 6]]\nPixel accuracy: 80.0%\n\nTraining Example 4 \u2713:\nExpected: [[2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 0, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]]\nYour output: [[2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 0, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]]\n\n"
          },
          {
            "type": "input_image",
            "image_url": "data:image/png;base64,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"
          },
          {
            "type": "input_text",
            "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
          }
        ]
      },
      {
        "type": "message",
        "role": "assistant",
        "content": [
          "The key persistent errors are about the exact positions of the zero (black) pixels inside the 5x5 output square \u2014 they are shifted or misplaced compared to expected outputs.\n\nFrom analyzing the feedback and the visuals:\n\n- The zeros (black pixels) are very specific patterns inside the square, often symmetric and arranged in a pattern.\n- Simply resizing the bounding box with a nearest-neighbor sampling distorts the pattern of holes and shifts them around, causing inaccuracies.\n- The 5x5 output is always the same fixed size regardless of the input square size.\n- The important pattern is the _skeleton_ or shape of holes inside the solid color square.\n- Across examples, the hole pattern resembles _positions of zeros_ inside the colored component itself, arranged in an approximate 5x5 block.\n\n**Improved hypothesis:**\n- Extract the largest colored component.\n- Compute its bounding box.\n- Within that bounding box, locate the shape of the colored block (where pixels are color) and the holes (pixels = 0).\n- From the bounding box, downsample the shape and holes _separately_ into a 5x5 grid by a simple block majority vote, preserving the hole positions more accurately.\n- Then reconstruct the 5x5 grid: colored pixels where majority of original colored points are, holes where majority are zeros.\n- This approach captures spatial info better than nearest neighbor and reduces shifts.\n- Finally, output a 5x5 grid colored by the component color with zeros marking holes.\n\nThis approach should better approximate holes in the output grid.\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n    from collections import deque\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def neighbors(r, c):\n        for nr, nc in ((r-1,c), (r+1,c), (r,c-1), (r,c+1)):\n            if 0 <= nr < rows and 0 <= nc < cols:\n                yield nr, nc\n\n    components = []\n\n    # Find largest connected component of a single nonzero color\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                q = deque([(r, c)])\n                visited[r, c] = True\n                cells = []\n                while q:\n                    rr, cc = q.popleft()\n                    cells.append((rr, cc))\n                    for nr, nc in neighbors(rr, cc):\n                        if not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                components.append((len(cells), color, cells))\n\n    if not components:\n        # no colored component\n        return [[0]*5 for _ in range(5)]\n\n    # Choose largest component\n    components.sort(key=lambda x: x[0], reverse=True)\n    size, color, cells = components[0]\n\n    rmin = min(r for r, c in cells)\n    rmax = max(r for r, c in cells)\n    cmin = min(c for r, c in cells)\n    cmax = max(c for r, c in cells)\n\n    block = grid[rmin:rmax+1, cmin:cmax+1]\n\n    h_in, w_in = block.shape\n\n    # Create two binary masks for colors and holes\n    color_mask = (block == color).astype(int)\n    hole_mask = (block == 0).astype(int)\n\n    # Downsample masks to 5x5 by block majority\n    def downsample_majority(mask):\n        out = np.zeros((5,5), dtype=int)\n        # Compute block sizes (may not divide evenly)\n        h_block_sizes = []\n        acc = 0\n        for i in range(5):\n            start = int(i * h_in / 5)\n            end = int((i+1) * h_in / 5)\n            h_block_sizes.append((start,end))\n        w_block_sizes = []\n        for j in range(5):\n            start = int(j * w_in / 5)\n            end = int((j+1) * w_in / 5)\n            w_block_sizes.append((start,end))\n        for i in range(5):\n            for j in range(5):\n                rstart, rend = h_block_sizes[i]\n                cstart, cend = w_block_sizes[j]\n                block_slice = mask[rstart:rend, cstart:cend]\n                if block_slice.size == 0:\n                    out[i,j] = 0\n                else:\n                    # majority vote\n                    val = 1 if block_slice.sum() >= (block_slice.size / 2) else 0\n                    out[i,j] = val\n        return out\n\n    color_ds = downsample_majority(color_mask)\n    hole_ds = downsample_majority(hole_mask)\n\n    # The final output: where hole_ds is 1 -> 0, else color\n    output = np.where(hole_ds == 1, 0, color_ds * color)\n\n    return output.tolist()\n```\n"
        ]
      },
      {
        "role": "user",
        "content": [
          {
            "type": "input_text",
            "text": "Please analyze the training feedback and programs from all prior turns, and write an improved transformation.\n\n**Important**:\n1. Always start by attempting to find a complete rule that solves all training examples and should generalize to the test input.\n2. If you cannot find a perfect solution, provide your best attempt at a transformation that solves as many training examples as possible - ideally more than in the best previous turn.\n3. Even if your solution doesn't solve all examples perfectly, ensure it demonstrates meaningful pattern recognition and provides reasonable outputs that minimize pixel-level errors.\n\nFinal answer:\n```python\ndef transform(grid):\n    # Your improved transformation logic here (even if partial)\n    return transformed_grid\n```"
          },
          {
            "type": "input_text",
            "text": "Training results: 1/4 examples solved, 87.0% pixel accuracy - Great progress! You're on the right track. Next, try to identify a transformation that solves more than 1 of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[7, 7, 7, 7, 7], [7, 0, 7, 7, 7], [7, 7, 7, 0, 7], [7, 0, 7, 7, 7], [7, 7, 7, 7, 7]]\nYour output: [[7, 7, 7, 7, 7], [7, 7, 7, 0, 7], [7, 0, 7, 7, 7], [7, 7, 7, 7, 7], [7, 7, 7, 7, 7]]\nPixel accuracy: 80.0%\n\nTraining Example 2 \u2717:\nExpected: [[8, 8, 8, 8, 8], [8, 0, 8, 0, 8], [8, 8, 8, 8, 8], [8, 0, 8, 0, 8], [8, 8, 8, 8, 8]]\nYour output: [[8, 8, 8, 8, 8], [8, 0, 8, 8, 8], [8, 8, 8, 0, 8], [8, 0, 8, 8, 8], [8, 8, 8, 8, 8]]\nPixel accuracy: 88.0%\n\nTraining Example 3 \u2717:\nExpected: [[6, 6, 6, 6, 6], [6, 0, 6, 0, 6], [6, 6, 6, 6, 6], [6, 0, 6, 6, 6], [6, 6, 6, 6, 6]]\nYour output: [[6, 6, 6, 6, 6], [6, 6, 6, 6, 6], [6, 0, 6, 0, 6], [6, 6, 6, 6, 6], [6, 6, 6, 6, 6]]\nPixel accuracy: 80.0%\n\nTraining Example 4 \u2713:\nExpected: [[2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 0, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]]\nYour output: [[2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 0, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]]\n\n"
          },
          {
            "type": "input_image",
            "image_url": "data:image/png;base64,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"
          },
          {
            "type": "input_text",
            "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
          }
        ]
      },
      {
        "type": "message",
        "role": "assistant",
        "content": [
          "The main error remains the positions of the black (zero) pixels inside the 5x5 output grid, which are being misplaced by the simplistic downsampling approach. Analyzing the feedback and examples indicates these black pixels often match certain fixed patterns relative to the square, especially related to the internal shape and holes.\n\nTo better capture this, I propose a refined approach where:\n\n- Extract the largest colored connected component and its bounding box.\n- Instead of direct downsampling, split the bounding box into a fixed 5\u00d75 grid of blocks.\n- Within each block, check if that block contains *only* the color pixels or if it contains any holes (zeros).\n- Output cell in 5\u00d75 grid is zero if the corresponding block contains any zero pixels (hole), else the block is colored.\n- This avoids averaging or majority voting which can blur details and cause shifts.\n- This also corresponds well to the visual feedback: holes only appear as zero if there is any hole pixel in that area.\n\nThis solution should be more faithful to the original hole pattern and avoids convolutional smoothing artifacts.\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n    from collections import deque\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def neighbors(r, c):\n        for nr, nc in ((r-1,c), (r+1,c), (r,c-1), (r,c+1)):\n            if 0 <= nr < rows and 0 <= nc < cols:\n                yield nr, nc\n\n    components = []\n\n    # Find largest connected component with a single nonzero color\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                q = deque([(r, c)])\n                visited[r, c] = True\n                cells = []\n                while q:\n                    rr, cc = q.popleft()\n                    cells.append((rr, cc))\n                    for nr, nc in neighbors(rr, cc):\n                        if not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                components.append((len(cells), color, cells))\n\n    if not components:\n        # No colored component found -> return empty 5x5\n        return [[0]*5 for _ in range(5)]\n\n    components.sort(key=lambda x: x[0], reverse=True)\n    size, color, cells = components[0]\n\n    rmin = min(r for r, c in cells)\n    rmax = max(r for r, c in cells)\n    cmin = min(c for r, c in cells)\n    cmax = max(c for r, c in cells)\n\n    block = grid[rmin:rmax+1, cmin:cmax+1]\n    h_in, w_in = block.shape\n\n    output = np.zeros((5, 5), dtype=int)\n\n    # For each cell in output 5x5 grid, map to corresponding block in input\n    for i in range(5):\n        r_start = int(i * h_in / 5)\n        r_end = int((i + 1) * h_in / 5)\n        if r_end == r_start:\n            r_end = min(r_start + 1, h_in)  # Ensure at least one row\n\n        for j in range(5):\n            c_start = int(j * w_in / 5)\n            c_end = int((j + 1) * w_in / 5)\n            if c_end == c_start:\n                c_end = min(c_start + 1, w_in)  # Ensure at least one col\n\n            subblock = block[r_start:r_end, c_start:c_end]\n\n            # If any zero in subblock => hole(0), else color\n            if np.any(subblock == 0):\n                output[i, j] = 0\n            else:\n                # Should be all color pixels or zeros only if holes\n                # If subblock has any color pixels, paint with that color\n                if np.any(subblock == color):\n                    output[i, j] = color\n                else:\n                    output[i, j] = 0  # Default safe fallback\n\n    return output.tolist()\n```"
        ]
      },
      {
        "role": "user",
        "content": [
          {
            "type": "input_text",
            "text": "Please analyze the training feedback and programs from all prior turns, and write an improved transformation.\n\n**Important**:\n1. Always start by attempting to find a complete rule that solves all training examples and should generalize to the test input.\n2. If you cannot find a perfect solution, provide your best attempt at a transformation that solves as many training examples as possible - ideally more than in the best previous turn.\n3. Even if your solution doesn't solve all examples perfectly, ensure it demonstrates meaningful pattern recognition and provides reasonable outputs that minimize pixel-level errors.\n\nFinal answer:\n```python\ndef transform(grid):\n    # Your improved transformation logic here (even if partial)\n    return transformed_grid\n```"
          },
          {
            "type": "input_text",
            "text": "Training results: 1/4 examples solved, 87.0% pixel accuracy - Great progress! You're on the right track. Next, try to identify a transformation that solves more than 1 of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[7, 7, 7, 7, 7], [7, 0, 7, 7, 7], [7, 7, 7, 0, 7], [7, 0, 7, 7, 7], [7, 7, 7, 7, 7]]\nYour output: [[7, 7, 7, 7, 7], [7, 7, 7, 0, 7], [7, 0, 7, 7, 7], [7, 7, 7, 7, 7], [7, 7, 7, 7, 7]]\nPixel accuracy: 80.0%\n\nTraining Example 2 \u2717:\nExpected: [[8, 8, 8, 8, 8], [8, 0, 8, 0, 8], [8, 8, 8, 8, 8], [8, 0, 8, 0, 8], [8, 8, 8, 8, 8]]\nYour output: [[8, 8, 8, 8, 8], [8, 0, 8, 8, 8], [8, 8, 8, 0, 8], [8, 0, 8, 8, 8], [8, 8, 8, 8, 8]]\nPixel accuracy: 88.0%\n\nTraining Example 3 \u2717:\nExpected: [[6, 6, 6, 6, 6], [6, 0, 6, 0, 6], [6, 6, 6, 6, 6], [6, 0, 6, 6, 6], [6, 6, 6, 6, 6]]\nYour output: [[6, 6, 6, 6, 6], [6, 6, 6, 6, 6], [6, 0, 6, 0, 6], [6, 6, 6, 6, 6], [6, 6, 6, 6, 6]]\nPixel accuracy: 80.0%\n\nTraining Example 4 \u2713:\nExpected: [[2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 0, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]]\nYour output: [[2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 0, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]]\n\n"
          },
          {
            "type": "input_image",
            "image_url": "data:image/png;base64,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"
          },
          {
            "type": "input_text",
            "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
          }
        ]
      },
      {
        "type": "message",
        "role": "assistant",
        "content": [
          "The main recurrent error is that some zero pixels (holes) occur in positions like (1,1), (1,3), (3,1) etc inside the 5x5 output but sometimes get \"shifted\" or misplaced by our block check method, especially in the first three examples. The feedback images suggest the hole pixels are consistently arranged in symmetrical fixed locations relative to the 5x5 grid, not simply from the spatial distribution of zeros in the bounding box.\n\nThese holes seem to correspond exactly to certain cells inside the 5x5 outputs that are zero, and these hole positions correspond to zero pixels inside the input colored square.\n\nSo a better heuristic is:\n\n- Identify the largest colored connected component and crop its bounding box.\n- Since the input squares are generally around 6\u00d76, extract a direct 6\u00d76 patch from the bounding box (cropping to exactly 6\u00d76 if possible).\n- Then, convert this 6\u00d76 patch into a 5\u00d75 output by:\n   - Interpreting the 6\u00d76 as a large square with 5 \"cells\" in each dimension by skipping the last row and column or averaging accordingly.\n   - For each output cell, set zero if there is any zero (hole) in the corresponding 2\u00d72 input pixels patch (the 6\u00d76 can be roughly seen as 5\u00d75 of 2\u00d72 areas overlapping), else the output cell gets the input color.\n- This approach mimics how small holes are preserved by a majority or any-zero logic but more precisely respects the input pattern's shape.\n- If bounding box smaller than 6\u00d76, pad it accordingly before downsampling.\n\nThis tries to more exactly capture the hole pattern shown in the examples.\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n    from collections import deque\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def neighbors(r, c):\n        for nr, nc in ((r-1,c), (r+1,c), (r,c-1), (r,c+1)):\n            if 0 <= nr < rows and 0 <= nc < cols:\n                yield nr, nc\n\n    components = []\n\n    # Find largest connected component with single nonzero color\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r,c] != 0 and not visited[r,c]:\n                color = grid[r,c]\n                q = deque([(r,c)])\n                visited[r,c] = True\n                cells = []\n                while q:\n                    rr, cc = q.popleft()\n                    cells.append((rr, cc))\n                    for nr, nc in neighbors(rr, nc):\n                        if not visited[nr,nc] and grid[nr,nc] == color:\n                            visited[nr,nc] = True\n                            q.append((nr,nc))\n                components.append((len(cells), color, cells))\n\n    if not components:\n        return [[0]*5 for _ in range(5)]\n\n    components.sort(key=lambda x: x[0], reverse=True)\n    size, color, cells = components[0]\n\n    rmin = min(r for r,c in cells)\n    rmax = max(r for r,c in cells)\n    cmin = min(c for r,c in cells)\n    cmax = max(c for r,c in cells)\n\n    block = grid[rmin:rmax+1, cmin:cmax+1]\n    h_in, w_in = block.shape\n\n    # Pad to at least 6x6 with color pixels (if smaller)\n    target = 6\n    if h_in < target or w_in < target:\n        padded = np.full((max(h_in,target), max(w_in,target)), fill_value=color, dtype=int)\n        padded[:h_in, :w_in] = block\n        block = padded\n        h_in, w_in = block.shape\n\n    # Now block is at least 6x6; crop if bigger (to 6x6 top-left)\n    block = block[:target, :target]\n    h_in, w_in = block.shape  # now 6,6\n\n    output = np.zeros((5,5), dtype=int)\n\n    # For each output cell, check corresponding 2x2 input cells for holes (0)\n    # If any zero in 2x2 block, output is 0 else color\n    for i in range(5):\n        for j in range(5):\n            # input cells from (i,i+1),(j,j+1)\n            subblock = block[i:i+2, j:j+2]\n            if np.any(subblock == 0):\n                output[i,j] = 0\n            else:\n                output[i,j] = color\n\n    return output.tolist()\n```\n"
        ]
      },
      {
        "role": "user",
        "content": [
          {
            "type": "input_text",
            "text": "Please analyze the training feedback and programs from all prior turns, and write an improved transformation.\n\n**Important**:\n1. Always start by attempting to find a complete rule that solves all training examples and should generalize to the test input.\n2. If you cannot find a perfect solution, provide your best attempt at a transformation that solves as many training examples as possible - ideally more than in the best previous turn.\n3. Even if your solution doesn't solve all examples perfectly, ensure it demonstrates meaningful pattern recognition and provides reasonable outputs that minimize pixel-level errors.\n\nFinal answer:\n```python\ndef transform(grid):\n    # Your improved transformation logic here (even if partial)\n    return transformed_grid\n```"
          },
          {
            "type": "input_text",
            "text": "Training results: 0/4 examples solved, 0.0% pixel accuracy - Keep experimenting! Try a different approach to the transformation.\n\nTraining Example 1 \u2717:\nExpected: [[7, 7, 7, 7, 7], [7, 0, 7, 7, 7], [7, 7, 7, 0, 7], [7, 0, 7, 7, 7], [7, 7, 7, 7, 7]]\nError: Traceback (most recent call last):\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmpqsilh1_c.py\", line 107, in <module>\n    output = transform(test_input)\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmpqsilh1_c.py\", line 56, in transform\n    for nr, nc in neighbors(rr, nc):\n                                ^^\nUnboundLocalError: cannot access local variable 'nc' where it is not associated with a value\n\n\nTraining Example 2 \u2717:\nExpected: [[8, 8, 8, 8, 8], [8, 0, 8, 0, 8], [8, 8, 8, 8, 8], [8, 0, 8, 0, 8], [8, 8, 8, 8, 8]]\nError: Traceback (most recent call last):\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmp7twqaxhw.py\", line 107, in <module>\n    output = transform(test_input)\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmp7twqaxhw.py\", line 56, in transform\n    for nr, nc in neighbors(rr, nc):\n                                ^^\nUnboundLocalError: cannot access local variable 'nc' where it is not associated with a value\n\n\nTraining Example 3 \u2717:\nExpected: [[6, 6, 6, 6, 6], [6, 0, 6, 0, 6], [6, 6, 6, 6, 6], [6, 0, 6, 6, 6], [6, 6, 6, 6, 6]]\nError: Traceback (most recent call last):\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmp5unfk6xk.py\", line 107, in <module>\n    output = transform(test_input)\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmp5unfk6xk.py\", line 56, in transform\n    for nr, nc in neighbors(rr, nc):\n                                ^^\nUnboundLocalError: cannot access local variable 'nc' where it is not associated with a value\n\n\nTraining Example 4 \u2717:\nExpected: [[2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 0, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]]\nError: Traceback (most recent call last):\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmpabwbtifk.py\", line 107, in <module>\n    output = transform(test_input)\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/v5/23nssdts27qd26t6dc53v2g40000gn/T/tmpabwbtifk.py\", line 56, in transform\n    for nr, nc in neighbors(rr, nc):\n                                ^^\nUnboundLocalError: cannot access local variable 'nc' where it is not associated with a value\n\n\n"
          },
          {
            "type": "input_image",
            "image_url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAP8AAAKUCAIAAABExnktAAAxLUlEQVR4nO3de1hTZ4LH8TfcQSAItSi3qiBgn3hBFAWjFeEPhKIg6Nh6GRBHpohF4lq1Zey4jxR3cHFq+9R1VaAMdXB0y0VHXfQRUWtRW5mK4oUBqkCRwWiISLjm3ceep3lYIGnQkNv7+zz+gYdzyTl8z+HkJIfwKKUEgEkmun4AADqD+oFdqB/YhfqBXagf2IX6gV2oH9iF+oFdqB/YhfqBXagf2IX6gV2oH9j1SvUnJyfzlFu1atWQ41hYWIwdO3bx4sU3btwYPM+zZ8/yeDxHR8fOzs4B3zp+/DiPxzt06BD337i4OB6Pl5mZOWC0xsZGHo+Xlpb2KlNxOjs7Dxw4EBwc7OLiYmlp6eLismzZskuXLqnYJmlpaco2yK1bt1RvtNDQ0F/dsIpx1q1b13849/BiYmK+/fbb/o8nKipqwGgTJkx4//33nz59OqyNz3n8+PGuXbv8/Pz4fP6oUaMCAgIOHTrU/23C3OIGTP7999+PGTPGzs6urKyMMH7s7+npaWlpOXHiRHBwcF1d3YDvZmdnE0KePn169OhRdea2Y8eOu3fvDvcxqDPVjz/+GBgY+Pvf//7ChQvNzc3d3d3Nzc3Hjx+fP39+VlYW0TPcw/v666+FQuFXX32lYrQff/zxs88+CwsLk8vlw9r433777bRp0/7whz/84x//kEqlHR0d169f/93vfpeQkKDigZ0/fz44OLivr+/cuXPBwcHEaOr//PPP6S+OHTtGCMnJyVEMyc/PV4xZX1+vGN7Z2Xnnzp13331XKpXu37+//wwlEklRUdGyZcscHR3/67/+S53H0N3dHRcX19fXN6xH/qtT9fT0xMbG/uMf/wgKCiopKXn8+HFPT8/Dhw+/+OILR0fHDz74gDuQK1NZWUkHEQgEQ24QhXPnzvWfiTrjNDc3c8NlMtk///nPbdu2UUrXrl374MGD/qPJZLL+Gz80NPTatWtnz55Vf+P/61//io6O/umnn955552KigqpVPrkyZOioqKJEyfm5OQcOHBgyO1QWFgYHh5uY2Nz4cKF2bNnEz2jg2O/paWlr6/vf/zHfxBCBhz7jxw50tnZmZiYGB8fX1FRcfPmzV+d28aNG69evfqf//mfw3oMvzrVl19++f3334eGhl68eDEyMtLJycnMzMzd3f299977+uuv+/r6/vrXvxJ9YmVl5enpmZGRsWPHju7u7j//+c8qNv6mTZu4PUf9jZ+VldXS0pKamnrkyJHZs2fb2dmNHj16yZIl5eXlo0aNysrKGnyb1OHDh5ctW/b6669funRp6tSpiuG5ubk8Hu/zzz8nDNbf1dV1+/ZtkUhECPH29u7/rZycnMmTJy9cuPC9994zNTVV5/D/ySefeHl57dix486dO+o/hl+d6siRIzwe77//+79NTU0HfOutt96qrq7etWsX0UubN2+2sbH53//93yG/29PTc//+/X379pmZmb311lvqb/y//e1v1tbW//7v/z5ghm5ubpcvX75w4QKPx+s//E9/+tO6desmTpx4+fLlSZMmEb2kpfonTJigeOJlZWUlEAiOHTv22muvpaSkKMa5devWd999t2XLFh6P5+npuWzZsq+++qq9vV31nG1sbHJycnp6eoZ1/vOrU1VWVk6ePHnChAlDTj558uQBP+wB/Pz8BjxbvXz5srINonDhwoXhjjOYnZ3dpEmTBvxStba25ia3sLDw8fH55ptvvvzyy/5rp3rj9/T0/PjjjwEBAba2toOXOH369HHjxvUf8sEHH2zdupUQMm/ePA8PjwHjx8XFUUqTk5MJm1c8XV1d165d+8MPP4wdO1YxMDs729XVdeXKldx/t2/f/uzZM3VOMIRC4fvvv3/t2rU9e/ao/xhUTNXT0yORSJydnfsPHHAdZvz48URfOTk5df1M2Qh9fX0VFRU9PT1qbnyJREIpdXJyUvMBfPbZZ4GBgaGhodnZ2V9//TXRV1qqn3sC193dXVBQwB2cdu/e7eLiohihp6cnPz+/qanJ0tKSy2vatGmUUjWf+37yySeTJk36+OOPq6ur1X9UyqYyNze3s7NrbW0lL2vws16hUPirz2gXLFgw3HGG9PTpU3Nzc0tLy8HPeru7u+vq6jZs2PDZZ5/927/9m5ob39HR0cTERP0NEh8ff+HChby8PEdHx9/97ndNTU1EL2n12G9ubv6b3/zm6NGj5eXlYWFh/a8Knzx5csiNe+PGjevXr//qnK2trV/i/EfFVFOmTKmurn748OGQF7j8/f2Jvmpvb79169bkyZOH/K65ufmECRP27NkjEAhyc3PV3PimpqaTJ0/+7rvvOjo6Bo+WkZGxZs2an376STHkiy++sLCwGDdu3Oeff/7kyZM1a9YMvrqqD3Rw5rNo0aKNGzfeuHFDcezhfvNaWVm1tbX1P85duXKFEKLsatoAc+fOTUlJuX79+uBXsl5iqpUrV8rl8qSkpCH3JX3+MzB79+7t6ekJCwtTPZqJiUl7e3tvb6+aGz8qKkomk/3xj38cMJ8ff/zxT3/608mTJ4c8L3rnnXdiY2PPnz8/rJNSIz/v/+STTzw8PPbv33/16lVCyKNHj86cORMZGWlvb99/tMDAQB8fn7/+9a9tbW3qzDY9PX3SpElffPHFsB7MkFOtW7fO39//73//e0BAwN/+9rdHjx719PRwr3ZFRETcuHHDxES/3iTS1dV17969tLS0nTt32tjYKHtOSSltbGzcsmXLzZs3/fz8zMzM1Nz4qampTk5OmZmZa9as+e6772QyWUtLy5EjRxYsWCCRSLZs2dL/RKu//fv3Ozs7p6Wlff/990TP6OZHOGrUqM8++0wulycmJvb29ubl5fX29iqecvX329/+tqOj4y9/+Yv6ZzKqr8aoOZWFhUVRUVFgYOCNGzd+85vfjBs3zsLCgnunw6lTp3x8fNR8KVqZIa/n8Hi8/te41Bln3Lhxiitpvr6+6enp3Ns63N3dB6wjN5qJiYm7u/uePXtMTEy4i7ZqbnwnJ6ejR4/a2dn95S9/mTVrlo2NzdixY1euXPngwYPo6OgPPvhA2Zq+9tprBw8e7Onpeffdd58/f8769X7O4sWLo6Kifvjhhz//+c+5ubmjR49etGjR4NHWrFljYmKi5skPdybDvZQzLENO5ebmdunSpfz8/PDwcDc3NwsLC2dn5/Dw8C+//PLWrVuzZs0i+sTc3Nzd3X3FihXffPPNO++8o2w0U1PT119/PSIi4uzZs9zZkfobPyQkpLKy8v333/f19bW1tbW2tp49e/ahQ4f+53/+Z/CrIv1FRkbGxcXdv3+//wVufcDT51NYgBGlXyevANqE+oFdqB/YhfqBXagf2IX6gV2oH9iF+oFdqB/YhfqBXagf2IX6gV2oH9iF+oFdqB/YhfqBXagf2IX6gV2oH9iF+oFdqB/YhfqBXagf2IX6gV2oH9iF+oFdqB/YhfqBXagf2IX6gV2oH9iF+oFdqB/YhfqBXagf2IX6gV1GXr9YLL57966uH4XBEDO2ubRXv5ub2+CPns3Pzx/RhYaGhlZUVKg//p49e+bMmaPsuxKJZOLEicOaoT5QrJREIuHxeCr6Dh3m5jJ0Ztpc2N69e1/iw3RfhUwm09SsGhoaoqOj6+vricFycHBQ/QG1Ms1tLoOg+zOfw4cPW1paNjQ0EEJaW1vt7e1zcnIeP37M4/EOHz7s5ubG5/MTEhIUP5jm5ubY2FhbW1t3d3eRSKQY3tTUFB0dbWdnN2bMmKSkpK6urgULFty7dy8+Pn7dunUqJrx9+/a8efOsra2DgoKUxf33v/9dIBD4+/sTQ9N/pfof+5vU2FzE6FFtcXV13bt375DfWrhwYVJSEqU0JSUlODiYUtra2koI8fb2rqqqqq2tnTZt2tq1a7mRAwMD4+LiWltba2trhUJhYmIipbS3t3fKlCnLly9vaWmpqakRCoVbt26llPr4+OTk5KiYUCaTeXh4bNiw4cmTJyUlJdznjw9+hGfPnr127VpPTw8h5Ntvv6WGo/9KPX36lBBy584dNTcXNXZarX/Ajmdqasp9q6amxsHBISsri8/n19TUKOovLCzkRigtLbWwsGhvby8vL7exsenq6uKGX79+3cTERCaTlZeXW1hYiMXiAQtV/DiVTVhUVMTn8zs6Orjh69evH7J+jiHW33+lFPWrubmosdPqmc+AY39vby833MvLa8uWLSKRaPPmzV5eXorxFU9Ap0+f3t3dXVtbW11d3dHRYWlpyT1pnjVrllwur6uru337tpubm6Ojo7JFK5uwurra09PT2tqaG83Pz48YncErpebmIsZO9+f9nFu3bhFCbty40X+gubk590VfX9+LZ+hmZr29vV5eXgP24DfffNPc3JzH46mYv7IJB4ymWKIxGbxSam4uYuz0ov7Tp08fPXo0MzOzuLi4qKhIMfzmzZvcF5WVlba2tp6enr6+vvX19Y2NjQPm4O3t3dDQwP1m70/xM1Y2oUAgqKmpef78OfffqqoqYnQGr5Sam4sYParrZ73Pnj3z8PDYtGkTd4bq6uoqlUq58/6ZM2fW1dXdv39/ypQpIpGIUtrX1+fn5xcaGvrw4cPGxsaUlBR3d/fOzk65XD5jxoyVK1e2trbW19cvXbp0xYoVlFJ/f//09HSpVKpswq6uLm9v74SEBLFYfPbsWTs7OyM77++/UorzfjU3FzV2unzWSwhJTEzcuHHj+PHj29vbKaVtbW3u7u7Jyclc/du2bXvjjTdGjx4tEom6u7u5+Tx48GDJkiWjRo2yt7cPCwu7c+cON7y+vn7RokVWVlZOTk5xcXFtbW2U0oMHD9ra2sbExKiYsLa2NiQkxMrKSiAQiEQiI6u//0op6ldzc1Fjx1P98odq0dHRZGR0d3efOnUqJCTEzs6OGIXCwkJdPwTQ9Gu9hbOuv9yE0ddnqZj2cYd8zCny+ZRbvmPMhjvtqyx35KYF1t/pAEzjKb/K9AonIEZY/2s2JjR9iOcJYHh4vGGMo93dQE/rB1a6H3ISbe0DqB/0o3td7AN68WoXGBUeT7/moxzqB43SbLIjvAOgftDvWEdyB0D9oPeZjticUT8Ywjn6yMwf9YMBPD0doaWgfmAX6gdDOPCPzLJQP7AL9YOBHPhHYImoH9iF+oFdqB8M57RH08vFezxBiyglxcWkt5eYm5PFi3W2//xCT+/rNT5GeF8vb/jtXr1KsrPJgQMkIYGsW0cCA19y0Rp687Mu7+vt/6d7hiUqKgr39RqkhgbS1UXmzCFNTS/+6RrO+0G78vPJ9u3kzBmiB1A/aFd8PMnNJZGRRA+gftAid3dibU0KC198MdRfN9MyXPMBLQoIII8ekfnzX1zzUf4JUVqD+kGLdH2JcwCc+cDL0tGfoNLgclE/sAv1A7tQPxjUyY9Gl4j6gV2oHwzn8K/pZaF+YBfqBwM5/I/AUlC/Ppo+fXrTz2+B5D5Ub9++fX5+fjNmzCgtLSVs7gB0ROaP+vVRbGxsSUkJIaSsrCwsLGzXrl0XL148cuRIfn4+0VuUGtycUb8+WrZsWXFxMSHkxIkTy5cvDw8PX7NmTUNDQ15eHtFnlBrWbxXUr498fHzEYrFUKq2srJw7d25ubm5qaur+/fvj4+OJnqPUgE6o8C43PbVkyZLdu3cHBARIpdLFixefO3fO399/4sSJRP9Rqpl3s438k2nc16un9/Xeu3dv6tSpZWVlQUFBmZmZBQUFcrk8ISEhOTmZGAoeT89fQ3jV+g3u/lpd3U9MPmwkbOINZx/AZzaCUaG/BI3P6wV2UR3dD6AcrvkAu1A/sAv1A7tQP7AL9QO7UD+wC/UDu1A/sAv1A7tQP7AL9QO7UD+wC/UDu1A/sAv1g+a1tbVFRUUJhcKoqKi2tjYVw3fv3i0QCDIzMwkhcrk8IiJCIpEQbUH9oHnp6enz58+/fPnyvHnzMjIyVAz/9NNPr1y5kpWVRQg5dOhQTEyMg4MD0Rbc16slRvh5vcoJBILS0lIXF5empqawsLCqqiplwz08PM6fPx8SElJZWbl69eqTJ0/ytPj5Lvi8Xi1Ny5SWlpaxY8cSQsaNG9fS0qJieHp6+qpVqzIyMtLS0nbu3KnN9HHmAzq2evXqiooKHx8fQkhdXV1ERMTx48e1tnTc1wua5+zs/OjRIxcXl+bmZmdnZ9XDKaU7duzIy8vz9/evqKgICgqKjY0lWoFjP2heeHh4QUEBIaSgoCA8PJwQ0t7ePuRwQkh2dnZkZKSTk5NMJqOUdnR0EG1B/aB5H3300cWLF4VC4aVLlz788ENCyNKlS4ccLpFIjh07tn79ekJIampqaGjo5s2bibbgzAc0j8/nD7ikwf3t9cHDHRwczpw5w3297WdEi3DsB3ahfmAX6gd2oX5gF+oHdqF+YBfqB3ahfmAX6gd2oX5gF+oHdqF+YBfqB3bhvl4tYeq+XkOhy/t6mZoW9BDOfIBdqB/YhfqBXagf2IX6gV2oH9iF+oFdqB/YhfqBXagf2IX6gV2oH9iF+oFdqB/YhfqBXagf2IX6gV2oH9j1Svf1Ahg0HPuBXagf2IX6gV2oH9iF+oFdqB/YhfqBXagf2IX6gV2oH9iF+oFdqB/YhfqBXagf2IX6gV2oH9iF+oFdqB/YhfqBXagf2IX6gV2oH9iF+oFdqB/YhfqBXagf2IX6gV2oH9iF+oFdqB/YhfqBXagf2IX6gV2oH9iF+oFdqB/YhfqBXagf2IX6gV2oH9iF+oFdqB/YhfqBXUZev1gsvnv3rq4fhcEQM7a5tFe/m5sbb5D8/PwRXWhoaGhFRYX64+/Zs2fOnDmDh9fU1Lz99tsODg7jxo1LTEyUSqXEcChWSiKR8Hg8FX2HDnNzGTqtHvv37t1L/79Vq1aN6BJlMtmrz6Snp+ftt98eP358fX39pUuXvv/++9///vfEADk4OFBKfX19R3RzGRKqLa6uroPrp5QeOnTIwsLi4cOHlNJ//etfdnZ22dnZra2thJBDhw65urra29uvXbu2o6ODG/+nn36KiYkZNWqUm5tbamqqYnhjY2NUVJStre1rr7323nvvdXZ2vvXWW9w6JiQkqJjw1q1bQqHQysoqMDAwKSlp9uzZAx7hN998Y2Zm1tXVxf23pKTExsZGLpdTQ9B/pZ4+fUoIuXPnjpqbixo73ddPKV24cGFSUhKlNCUlJTg4mFLK1e/t7V1VVVVbWztt2rS1a9dyIwcGBsbFxbW2ttbW1gqFwsTEREppb2/vlClTli9f3tLSUlNTIxQKt27dSin18fHJyclRMaFMJvPw8NiwYcOTJ09KSkqsra0H1z/AgQMH3NzcqIHov1KK+tXcXNTYabX+Ab92TE1NuW/V1NQ4ODhkZWXx+fyamhpF/YWFhdwIpaWlFhYW7e3t5eXlNjY2isPw9evXTUxMZDJZeXm5hYWFWCwesFDFj1PZhEVFRXw+X/F7YP369arrl0gkEyZM+Pjjj6nhUKyUon41Nxc1dro87+/t7eWGe3l5bdmyRSQSbd682cvLSzG+4gno9OnTu7u7a2trq6urOzo6LC0tuSfNs2bNksvldXV1t2/fdnNzc3R0VLZoZRNWV1d7enpaW1tzo/n5+al4/M+fP4+MjBQIBGlpacRwDF4pNTcXMXb6csXz1q1bhJAbN270H2hubs590dfXRwgxMzPr7e318vIasAe/+eab5ubmPB5PxfyVTThgNMUSBxOLxSEhIW5ubsePHzczMyOGY/BKqbm5iLHTi/pPnz599OjRzMzM4uLioqIixfCbN29yX1RWVtra2np6evr6+tbX1zc2Ng6Yg7e3d0NDA/ebvT/Fz1jZhAKBoKam5vnz59x/q6qqhnyEjY2NQqFw/vz5X331lYWFBTEog1dKzc1FjB7V9bPeZ8+eeXh4bNq0iTtDdXV1lUql3Hn/zJkz6+rq7t+/P2XKFJFIRCnt6+vz8/MLDQ19+PBhY2NjSkqKu7t7Z2enXC6fMWPGypUrW1tb6+vrly5dumLFCkqpv79/enq6VCpVNmFXV5e3t3dCQoJYLD579qydnd3g8/6nT59OmjTpgw8+oAao/0opzvvV3FzU2OnyWS8hJDExcePGjePHj29vb6eUtrW1ubu7Jycnc/Vv27btjTfeGD16tEgk6u7u5ubz4MGDJUuWjBo1yt7ePiwsjLt+Rymtr69ftGiRlZWVk5NTXFxcW1sbpfTgwYO2trYxMTEqJqytrQ0JCbGyshIIBCKRaHD9GRkZgx/5s2fPqCHov1L9r3jWq7G5qLHjvdgDXlZ0dDQZGd3d3adOnQoJCbGzsyNGobCwUNcPAQZ61Wdv0zJf8of6w5ZoFdN2PH186tQY3w8+f22i73CnfZXljty0oIcM6doFGDae8qtMr3ACYoT124x+7eMa3WwR0DCVl1YHjqPd3UBP6wdWuh9yEm3tA6gf9KN7XewDevFqFxgVHk+/5qMc6geN0myyI7wDoH7Q71hHcgdA/aD3mY7YnFE/GMI5+sjMH/WDATw9HaGloH5gF+oHQzjwj8yyUD+wC/WDgRz4R2CJqB/YhfqBXagfDOe0R9PLxXs8QYsoJcXFpLeXmJuTxYt1tv/8Qk/v6zU+RnhfL2/47V69SrKzyYEDJCGBrFtHAgNfctEaevOzLu/r7f+ne4YlKirK4JYLLzQ0kK4uMmcOaWp68U/XcN4P2pWfT7ZvJ2fOED2A+kG74uNJbi6JjCR6APWDFrm7E2trUlj44ouh/rqZluGaD2hRQAB59IjMn//ims9QnxClZagftEjXlzgHwJkPvCwd/QkqDS4X9QO7UD+wC/WDQZ38aHSJqB/YhfrBcA7/ml4W6gd2oX4wkMP/CCwF9euj6dOnN/38FkjuQ/X27dvn5+c3Y8aM0tJSwuYOQEdk/qhfH8XGxpaUlBBCysrKwsLCdu3adfHixSNHjuTn5xO9RanBzRn166Nly5YVFxcTQk6cOLF8+fLw8PA1a9Y0NDTk5eURfUapYf1WQf36yMfHRywWS6XSysrKuXPn5ubmpqam7t+/Pz4+nug5Sg3ohArvctNTS5Ys2b17d0BAgFQqXbx48blz5/z9/SdOnEj0H6WaeTfbyD+Zxn29enpf771796ZOnVpWVhYUFJSZmVlQUCCXyxMSEpKTk4mh4PH0/DWEV63f4D43V1fT/tGLMIo3nH0An9kIRoX+EjQ+rxfYRfXuA5hxzQfYhfqBXagf2IX6gV2oH9iF+oFdqB/YhfqBXagf2IX6gV2oH9iF+oFdqB/YhfqBXagfNK+trS0qKkooFEZFRbW1takYvnv3boFAkJmZSQiRy+URERESiYRoC+oHzUtPT58/f/7ly5fnzZuXkZGhYvinn3565cqVrKwsQsihQ4diYmIcHByItuC+Xi0xws/rVU4gEJSWlrq4uDQ1NYWFhVVVVSkb7uHhcf78+ZCQkMrKytWrV588eZKnxc93wef1amm5TGlpaRk7diwhZNy4cS0tLSqGp6enr1q1KiMjIy0tbefOndpMH2c+oGOrV6+uqKjw8fEhhNTV1UVERBw/flxrS8d9vaB5zs7Ojx49cnFxaW5udnZ2Vj2cUrpjx468vDx/f/+KioqgoKDY2FiiFTj2g+aFh4cXFBQQQgoKCsLDwwkh7e3tQw4nhGRnZ0dGRjo5OclkMkppR0cH0RbUD5r30UcfXbx4USgUXrp06cMPPySELF26dMjhEonk2LFj69evJ4SkpqaGhoZu3ryZaAvOfEDz+Hz+gEsL3N9eHzzcwcHhzJkz3Nfbfka0CMd+YBfqB3ahfmAX6gd2oX5gF+oHdqF+YBfqB3ahfmAX6gd2oX5gF+oHdqF+YBfu69USpu7rNRS6vK+XqWlBD+HMB9iF+oFdqB/YhfqBXagf2IX6gV2oH9iF+oFdqB/YhfqBXagf2IX6gV2oH9iF+oFdqB/YhfqBXagf2IX6gV2vdF8vgEHDsR/YhfqBXagf2IX6gV2oH9iF+oFdqB/YhfqBXagf2IX6gV2oH9iF+oFdqB/YhfqBXagf2IX6gV2oH9iF+oFdqB/YhfqBXagf2IX6gV2oH9iF+oFdqB/YhfqBXagf2IX6gV2oH9iF+oFdqB/YhfqBXagf2IX6gV2oH9iF+oFdqB/YhfqBXagf2IX6gV2oH9iF+oFdqB/YZeT1i8Xiu3fv6vpRGAwxY5tLe/W7ubnxBsnPzx/RhYaGhlZUVKg//p49e+bMmTN4eEtLS2xsrL29vbu7+65du4hBUayURCLh8Xgq+g4d5uYydGbaXNjevXs3bdqkzSXKZDKNzOfdd9/18PBoaGioqalZtGjR2LFj161bRwyNg4MDpVQLm8tQ6P7M5/Dhw5aWlg0NDYSQ1tZWe3v7nJycx48f83i8w4cPu7m58fn8hIQExQ+mubk5NjbW1tbW3d1dJBIphjc1NUVHR9vZ2Y0ZMyYpKamrq2vBggX37t2Lj4/nSlU24e3bt+fNm2dtbR0UFFRfXz/4EdbW1paVle3Zs4fP58+cOTM4OPjKlSvEQPRfqf7H/iY1NhcxelRbXF1d9+7dO+S3Fi5cmJSURClNSUkJDg6mlLa2thJCvL29q6qqamtrp02btnbtWm7kwMDAuLi41tbW2tpaoVCYmJhIKe3t7Z0yZcry5ctbWlpqamqEQuHWrVsppT4+Pjk5OSomlMlkHh4eGzZsePLkSUlJibW19ezZs5WtQk9Pz7lz5xwdHUtKSqiB6L9ST58+JYTcuXNHzc1FjZ1W6x+w45mamnLfqqmpcXBwyMrK4vP5NTU1ivoLCwu5EUpLSy0sLNrb28vLy21sbLq6urjh169fNzExkclk5eXlFhYWYrF4wEIVP05lExYVFfH5/I6ODm74+vXrVdTv4+NjaWm5YMGC1tZWajgUK6WoX83NRY2dVs98Bhz7e3t7ueFeXl5btmwRiUSbN2/28vJSjK94Ajp9+vTu7u7a2trq6uqOjg5LS0vuSfOsWbPkcnldXd3t27fd3NwcHR2VLVrZhNXV1Z6entbW1txofn5+Kh7/3bt3xWKxjY3N22+/TQzH4JVSc3MRY6f7837OrVu3CCE3btzoP9Dc3Jz7oq+v78UzdDOz3t5eLy+vAXvwm2++aW5uzuPxVMxf2YQDRlMsUZlRo0alpaVdvXr1p59+IgZi8EqpubmIsdOL+k+fPn306NHMzMzi4uKioiLF8Js3b3JfVFZW2traenp6+vr61tfXNzY2DpiDt7d3Q0MD95u9P8XPWNmEAoGgpqbm+fPn3H+rqqoGP7wzZ87w+fyuri7uv0+ePDE1NXVwcCAGYvBKqbm5iNGjun7W++zZMw8Pj02bNnFnqK6urlKplDvvnzlzZl1d3f3796dMmSISiSilfX19fn5+oaGhDx8+bGxsTElJcXd37+zslMvlM2bMWLlyZWtra319/dKlS1esWEEp9ff3T09Pl0qlyibs6ury9vZOSEgQi8Vnz561s7MbfN4vk8m8vb2TkpIkEskPP/wwefLkdevWUQPRf6UU5/1qbi5q7HT5rJcQkpiYuHHjxvHjx7e3t1NK29ra3N3dk5OTufq3bdv2xhtvjB49WiQSdXd3c/N58ODBkiVLRo0aZW9vHxYWdufOHW54fX39okWLrKysnJyc4uLi2traKKUHDx60tbWNiYlRMWFtbW1ISIiVlZVAIBCJREM+6/3nP/8ZHh5ub2/v4eGxfft2mUxGDUT/lVLUr+bmosaOp/rlD9Wio6PJyOju7j516lRISIidnR0xCoWFhbp+CKDp13pzL77/chPGzd+nYloxbTtFTmV8t9rb1GO4077KckduWmD9nQ7ANJ7yq0yvcAJihPU78fgSx/O6fhSgCSovrQ4cR7u7gZ7WD6x0P+Qk2toHUD/oR/e62Af04tUuMCo8nn7NRznUDxql2WRHeAdA/aDfsY7kDoD6Qe8zHbE5o34whHP0kZk/6gcDeHo6QktB/cAu1A+GcOAfmWWhfmAX6gcDOfCPwBJRP7AL9QO7UD8YzmmPppeL93iCFlFKiotJby8xNyeLF+ts//mFnt7Xa3yM8L5e3vDbvXqVZGeTAwdIQgJZt44EBr7kojX05mdd3tfb/0/3DEtUVJTBLRdeaGggXV1kzhzS1PTin67hvB+0Kz+fbN9OzpwhegD1g3bFx5PcXBIZSfQA6gctcncn1taksPDFF0P9dTMtwzUf0KKAAPLoEZk//8U1n6E+IUrLUD9oka4vcQ6AMx94WTr6E1QaXC7qB3ahfmAX6geDOvnR6BJRP7AL9YPhHP41vSzUD+xC/WAgh/8RWArq10fTp09v+vktkNyH6u3bt8/Pz2/GjBmlpaWEzR2Ajsj8Ub8+io2NLSkpIYSUlZWFhYXt2rXr4sWLR44cyc/PJ3qLUoObM+rXR8uWLSsuLiaEnDhxYvny5eHh4WvWrGloaMjLyyP6jFLD+q2C+vWRj4+PWCyWSqWVlZVz587Nzc1NTU3dv39/fHw80XOUGtAJFd7lpqeWLFmye/fugIAAqVS6ePHic+fO+fv7T5w4keg/SjXzbraRfzKN+3r19L7ee/fuTZ06taysLCgoKDMzs6CgQC6XJyQkJCcnE0PB4+n5awivWr/BfW6urqbli4MJm3jD2QfwmY1gVOgvQePzeoFdVEf3AyiHaz7ALtQP7EL9wC7UD+xC/cAu1A/sQv3ALtQP7EL9wC7UD+xC/cAu1A/sQv3ALtQP7EL9oHltbW1RUVFCoTAqKqqtrU3F8N27dwsEgszMTEKIXC6PiIiQSCREW1A/aF56evr8+fMvX748b968jIwMFcM//fTTK1euZGVlEUIOHToUExPj4OBAtAX39WqJEX5er3ICgaC0tNTFxaWpqSksLKyqqkrZcA8Pj/Pnz4eEhFRWVq5evfrkyZM8LX6+C4uf16uTaZnS0tIyduxYQsi4ceNaWlpUDE9PT1+1alVGRkZaWtrOnTu1mT7OfEDHVq9eXVFR4ePjQwipq6uLiIg4fvy41paO+3pB85ydnR89euTi4tLc3Ozs7Kx6OKV0x44deXl5/v7+FRUVQUFBsbGxRCtw7AfNCw8PLygoIIQUFBSEh4cTQtrb24ccTgjJzs6OjIx0cnKSyWSU0o6ODqItqB8076OPPrp48aJQKLx06dKHH35ICFm6dOmQwyUSybFjx9avX08ISU1NDQ0N3bx5M9EWnPmA5vH5/AGXNLi/vT54uIODw5kzZ7ivt/2MaBGO/cAu1A/sQv3ALtQP7EL9wC7UD+xC/cAu1A/sQv3ALtQP7EL9wC7UD+xC/cAu3NerJUzd12sodHlfL1PTgh7CmQ+wC/UDu1A/sAv1A7tQP7AL9QO7UD+wC/UDu1A/sAv1A7tQP7AL9QO7UD+wC/UDu1A/sAv1A7tQP7AL9QO7Xum+XgCDhmM/sAv1A7tQP7AL9QO7UD+wC/UDu1A/sAv1A7tQP7AL9QO7UD+wC/UDu1A/sAv1A7tQP7AL9QO7UD+wC/UDu1A/sAv1A7tQP7AL9QO7UD+wC/UDu1A/sAv1A7tQP7AL9QO7UD+wC/UDu1A/sAv1A7tQP7AL9QO7UD+wC/UDu1A/sAv1A7tQP7AL9QO7UD+wC/UDu1A/sMvI6xeLxXfv3tX1ozAYYsY2l/bqd3Nz4w2Sn58/ogsNDQ2tqKhQf/w9e/bMmTNHxQjJyckLFiwgBkWxUhKJhMfjqeg7dJiby9Bp9di/d+9e+v+tWrVqRJcok8k0OLfLly9/8cUXxGA5ODhQSn19fbWzufSf7s98Dh8+bGlp2dDQQAhpbW21t7fPycl5/Pgxj8c7fPiwm5sbn89PSEhQ/GCam5tjY2NtbW3d3d1FIpFieFNTU3R0tJ2d3ZgxY5KSkrq6uhYsWHDv3r34+Ph169apmPD27dvz5s2ztrYOCgqqr69X9jg7OzsTEhJmzpxJDEr/lep/7G9SY3MRo0e1xdXVdfCxn7Nw4cKkpCRKaUpKSnBwMKW0tbWVEOLt7V1VVVVbWztt2rS1a9dyIwcGBsbFxbW2ttbW1gqFwsTEREppb2/vlClTli9f3tLSUlNTIxQKt27dSin18fHJyclRMaFMJvPw8NiwYcOTJ09KSkqsra1nz5495IPcsmVLdHR0RkbGW2+9RQ1H/5V6+vQpIeTOnTtqbi5q7LRa/4Adz9TUlPtWTU2Ng4NDVlYWn8+vqalR1F9YWMiNUFpaamFh0d7eXl5ebmNj09XVxQ2/fv26iYmJTCYrLy+3sLAQi8UDFqr4cSqbsKioiM/nd3R0cMPXr18/ZP3Xrl0bM2ZMc3OzwdXff6UU9au5uaix0+V5f29vLzfcy8try5YtIpFo8+bNXl5eivEVT0CnT5/e3d1dW1tbXV3d0dFhaWnJPWmeNWuWXC6vq6u7ffu2m5ubo6OjskUrm7C6utrT09Pa2pobzc/Pb/C0PT09a9euzczMHDt2LDFAg1dKzc1FjJ3uz/s5t27dIoTcuHGj/0Bzc3Pui76+PkKImZlZb2+vl5fXgD34zTffNDc35/F4KuavbMIBoymW2F96erqbm9tvf/tbYpgGr5Sam4sYO72o//Tp00ePHs3MzCwuLi4qKlIMv3nzJvdFZWWlra2tp6enr69vfX19Y2PjgDl4e3s3NDRwv9n7U/yMlU0oEAhqamqeP3/O/beqqmrwwzt+/PiZM2e4Xxrbt28vLy/n8XiDZ6W3Bq+UmpuLGD2q62e9z5498/Dw2LRpE3eG6urqKpVKufP+mTNn1tXV3b9/f8qUKSKRiFLa19fn5+cXGhr68OHDxsbGlJQUd3f3zs5OuVw+Y8aMlStXtra21tfXL126dMWKFZRSf3//9PR0qVSqbMKuri5vb++EhASxWHz27Fk7Oztlz3o5Bnfe33+lFOf9am4uaux0+ayXEJKYmLhx48bx48e3t7dTStva2tzd3ZOTk7n6t23b9sYbb4wePVokEnV3d3PzefDgwZIlS0aNGmVvbx8WFnbnzh1ueH19/aJFi6ysrJycnOLi4tra2iilBw8etLW1jYmJUTFhbW1tSEiIlZWVQCAQiURGVn//lVLUr+bmosaO92IPeFnR0dFkZHR3d586dSokJMTOzo4YhcLCQl0/BBjIjLyawrafXm7CaL6Limkf9/SOIeTz9lZf+bPhTvsqyx25acEI6wdQl4qrTK9wAmKE9b9mbkaDA3T9KEATVF5aHTiOdncDPa0fWOl+yEm0tQ+gftCP7nWxD+jFq11gVHg8/ZqPcqgfNEqzyY7wDoD6Qb9jHckdAPWD3mc6YnNG/WAI5+gjM3/UDwbw9HSEloL6gV2oHwzhwD8yy0L9wC7UDwZy4B+BJaJ+YBfqB3ahfjCc0x5NLxfv8QQtopQUF5PeXmJuThYv1tn+o6n6o/kumFYduKv3hWvXyOnT5MABkpBAXn+d6Jqe3tdrfNPCCw0NpKuLzJlDmppe/NM1nPeDduXnk+3byZkzRA+gftCu+HiSm0siI4keQP2gRe7uxNqaFBa++GKov26mZbjmA1oUEEAePSLz57+45qPyE6K0A/WDFun6EucAOPOBl6WjP0GlweWifmAX6gd2oX4wqJMfjS4R9QO7UD8YzuFf08tC/cAu1A8GcvgfgaWgfn00ffr0pp/fAsl9qN6+ffv8/PxmzJhRWlpK2NwB6IjMH/Xro9jY2JKSEkJIWVlZWFjYrl27Ll68eOTIkfz8fKK3KDW4OaN+fbRs2bLi4mJCyIkTJ5YvXx4eHr5mzZqGhoa8vDyizyg1rN8qqF8f+fj4iMViqVRaWVk5d+7c3Nzc1NTU/fv3x8fHEz1HqQGdUOFdbnpqyZIlu3fvDggIkEqlixcvPnfunL+//8SJE4n+o1Qz72Yb+SfTuK9XT+/rXbZs2dSpU8vKyvh8/ttvvz1nzhy5XP6HP/yBGAT6c7gvvQ9o6zWEV/206le5R7aoqOjlpo2KijK8+3rPXyVs4g1nH8BnNoJRob8Ejc/rBXZRHd0PoByu+QC7UD+wC/UDu1A/sAv1A7tQP7AL9QO7UD+wC/UDu1A/sAv1A7tQP7AL9QO7UD+wC/WD5rW1tUVFRQmFwqioqLa2NhXDd+/eLRAIMjMzCSFyuTwiIkIikWjtcaJ+0Lz09PT58+dfvnx53rx5GRkZKoZ/+umnV65cycrKIoQcOnQoJibGwcGBaMur3tmo0QdjzAoLGfrEXoFAUFpa6uLi0tTUFBYWVlVVpWy4h4fH+fPnQ0JCKisrV69effLkSZ4WP98Fn9erpWmZ0tLSMnbsWELIuHHjWlpaVAxPT09ftWpVRkZGWlrazp07tZk+znxAx1avXl1RUeHj40MIqauri4iIOH78uNaWjvt6QfOcnZ0fPXrk4uLS3Nzs7OysejildMeOHXl5ef7+/hUVFUFBQbGxsUQrcOwHzQsPDy8oKCCEFBQUhIeHE0La29uHHE4Iyc7OjoyMdHJykslklNKOjg6iLagfNO+jjz66ePGiUCi8dOnShx9+SAhZunTpkMMlEsmxY8fWr19PCElNTQ0NDd28eTPRFl3+NSumpmX3r1npMRz7gV2oH9iF+oFdqB/YhfqBXagf2IX6gV2oH9iF+oFdqB/YhfqBXagf2IX6gV24r1dLmLqv11Dgvl4tTQt6CGc+wC7UD+xC/cAu1A/sQv3ALtQP7EL9wC7UD+xC/cAu1A/sQv3ALtQP7EL9wC7UD+xC/cAu1A/sQv3ALtQP7Hql+3oBDBqO/cAu1A/sQv3ALtQP7EL9wC7UD+xC/cAu1A/sQv3ALtQP7EL9wC7UD+xC/cAu1A/sQv3ALtQP7EL9wC7UD+xC/UCY9X88O1uxlDgGsQAAAABJRU5ErkJggg=="
          },
          {
            "type": "input_text",
            "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
          }
        ]
      },
      {
        "type": "message",
        "role": "assistant",
        "content": [
          "The error traceback shows there is a typo in the `neighbors` iteration inside the BFS loop: the variable name `nc` used in the `neighbors(rr, nc)` call inside a loop is shadowed and incorrectly reused, causing an \"UnboundLocalError\".\n\nSpecifically in the line:\n```python\nfor nr, nc in neighbors(rr, nc):\n```\n`nc` is used as the loop variable and as the argument, which is invalid because `nc` is not defined at that point.\n\nThe correct variable should be `cc` (the current column variable name in the BFS loop) in place of the second argument.\n\nFixing this variable name resolves the error.\n\n---\n\nBesides this bug fix, the previous approach was a solid attempt to capture the exact hole pattern by splitting the largest component bounding box into 5x5 by 2x2 blocks and mapping holes accurately.\n\nI will fix the variable name bug and keep the rest of the logic unchanged.\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n    from collections import deque\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def neighbors(r, c):\n        for nr, nc in ((r-1,c), (r+1,c), (r,c-1), (r,c+1)):\n            if 0 <= nr < rows and 0 <= nc < cols:\n                yield nr, nc\n\n    components = []\n\n    # Find largest connected component with single nonzero color\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                q = deque([(r, c)])\n                visited[r, c] = True\n                cells = []\n                while q:\n                    rr, cc = q.popleft()\n                    cells.append((rr, cc))\n                    for nr, nc in neighbors(rr, cc):\n                        if not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                components.append((len(cells), color, cells))\n\n    if not components:\n        # No colored component found, output empty 5x5 grid\n        return [[0] * 5 for _ in range(5)]\n\n    # Largest component\n    components.sort(key=lambda x: x[0], reverse=True)\n    size, color, cells = components[0]\n\n    rmin = min(r for r, c in cells)\n    rmax = max(r for r, c in cells)\n    cmin = min(c for r, c in cells)\n    cmax = max(c for r, c in cells)\n\n    block = grid[rmin:rmax + 1, cmin:cmax + 1]\n    h_in, w_in = block.shape\n\n    # Pad to at least 6x6 with color pixels if smaller\n    target = 6\n    if h_in < target or w_in < target:\n        padded = np.full((max(h_in, target), max(w_in, target)), fill_value=color, dtype=int)\n        padded[:h_in, :w_in] = block\n        block = padded\n        h_in, w_in = block.shape\n\n    # Crop to 6x6 top-left\n    block = block[:target, :target]\n    h_in, w_in = block.shape  # now 6x6\n\n    output = np.zeros((5, 5), dtype=int)\n\n    # For each output cell corresponding to 2x2 input cells check holes\n    for i in range(5):\n        for j in range(5):\n            subblock = block[i:i + 2, j:j + 2]\n            if np.any(subblock == 0):\n                output[i, j] = 0\n            else:\n                output[i, j] = color\n\n    return output.tolist()\n```"
        ]
      },
      {
        "role": "user",
        "content": [
          {
            "type": "input_text",
            "text": "Please analyze the training feedback and programs from all prior turns, and write an improved transformation.\n\n**Important**:\n1. Always start by attempting to find a complete rule that solves all training examples and should generalize to the test input.\n2. If you cannot find a perfect solution, provide your best attempt at a transformation that solves as many training examples as possible - ideally more than in the best previous turn.\n3. Even if your solution doesn't solve all examples perfectly, ensure it demonstrates meaningful pattern recognition and provides reasonable outputs that minimize pixel-level errors.\n\nFinal answer:\n```python\ndef transform(grid):\n    # Your improved transformation logic here (even if partial)\n    return transformed_grid\n```"
          },
          {
            "type": "input_text",
            "text": "Training results: 0/4 examples solved, 71.0% pixel accuracy - Good partial progress! Your approach is capturing some patterns. Next, try to identify a transformation that solves at least one of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[7, 7, 7, 7, 7], [7, 0, 7, 7, 7], [7, 7, 7, 0, 7], [7, 0, 7, 7, 7], [7, 7, 7, 7, 7]]\nYour output: [[7, 7, 0, 0, 7], [0, 0, 0, 0, 7], [0, 0, 7, 7, 7], [7, 7, 7, 7, 7], [7, 7, 7, 7, 7]]\nPixel accuracy: 64.0%\n\nTraining Example 2 \u2717:\nExpected: [[8, 8, 8, 8, 8], [8, 0, 8, 0, 8], [8, 8, 8, 8, 8], [8, 0, 8, 0, 8], [8, 8, 8, 8, 8]]\nYour output: [[0, 0, 8, 8, 8], [0, 0, 0, 0, 8], [0, 0, 0, 0, 8], [0, 0, 8, 8, 8], [8, 8, 8, 8, 8]]\nPixel accuracy: 60.0%\n\nTraining Example 3 \u2717:\nExpected: [[6, 6, 6, 6, 6], [6, 0, 6, 0, 6], [6, 6, 6, 6, 6], [6, 0, 6, 6, 6], [6, 6, 6, 6, 6]]\nYour output: [[6, 6, 6, 6, 6], [0, 0, 0, 0, 6], [0, 0, 0, 0, 6], [6, 6, 6, 6, 6], [6, 6, 6, 6, 6]]\nPixel accuracy: 72.0%\n\nTraining Example 4 \u2717:\nExpected: [[2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 0, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]]\nYour output: [[2, 2, 2, 2, 2], [0, 0, 2, 2, 2], [0, 0, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]]\nPixel accuracy: 88.0%\n\n"
          },
          {
            "type": "input_image",
            "image_url": "data:image/png;base64,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"
          },
          {
            "type": "input_text",
            "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
          }
        ]
      },
      {
        "type": "message",
        "role": "assistant",
        "content": [
          "After analyzing the prior attempts and the recent pixel accuracy feedback with the accompanying images, I observe these issues:\n\n- The zero pixels (holes) are mostly misrepresented or clustered incorrectly in the output.\n- There is a clear mismatch in spatial layout: the black holes are not in the right positions relative to the colored cells.\n- Previous attempts with direct downsampling or block-wise checking don't preserve the shape properly.\n- The output is consistently 5x5, so the solution should precisely map the original shape inside the bounding box of the biggest colored component to a 5x5 pattern that faithfully represents holes.\n\n**Key insights:**\n\n- The input colored shapes are generally 6x6 blocks with black holes inside.\n- The holes occupy specific pixels, and these pixels correspond well to a known 5x5 pattern.\n- Instead of block majority or nearest neighbor, a _nearest neighbor scaling_ from the cropped bounding box to 5x5 output, while preserving exact pixel values (color or zero), is likely better.\n- That is, rescale input bounding box area of the component to exactly 5x5, mapping each output pixel to exactly one input pixel using nearest neighbor, preserving colors and holes exactly.\n\n**Additional details:**\n\n- Before rescaling, crop the bounding box of the largest connected component of color.\n- Perform nearest neighbor rescaling to 5x5 on this bounding box.\n- For rescaling, use nearest-neighbor sampling indices calculated as round(i * (h_in - 1)/4) and round(j * (w_in - 1)/4).\n- Map resampled pixels to the color or zero as is.\n- Return the 5x5 grid.\n\nThis approach should minimize holes distortion and spatial shifts.\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n    from collections import deque\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def neighbors(r, c):\n        for nr, nc in ((r-1,c), (r+1,c), (r,c-1), (r,c+1)):\n            if 0 <= nr < rows and 0 <= nc < cols:\n                yield nr, nc\n\n    components = []\n    # Identify largest connected component of one color (nonzero)\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                q = deque([(r, c)])\n                visited[r, c] = True\n                cells = []\n                while q:\n                    rr, cc = q.popleft()\n                    cells.append((rr, cc))\n                    for nr, nc in neighbors(rr, cc):\n                        if not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                components.append((len(cells), color, cells))\n\n    if not components:\n        return [[0]*5 for _ in range(5)]\n\n    # Choose largest component\n    components.sort(key=lambda x: x[0], reverse=True)\n    size, color, cells = components[0]\n\n    rmin = min(r for r, c in cells)\n    rmax = max(r for r, c in cells)\n    cmin = min(c for r, c in cells)\n    cmax = max(c for r, c in cells)\n\n    block = grid[rmin:rmax+1, cmin:cmax+1]\n    h_in, w_in = block.shape\n\n    # Nearest neighbor rescale block to 5x5 output\n    output = np.zeros((5, 5), dtype=int)\n    for i in range(5):\n        for j in range(5):\n            ri = int(round(i * (h_in - 1) / 4))\n            cj = int(round(j * (w_in - 1) / 4))\n            val = block[ri, cj]\n            if val == color:\n                output[i, j] = color\n            else:\n                # Zero or any other color (black holes are zeros)\n                output[i, j] = 0\n\n    return output.tolist()\n```"
        ]
      },
      {
        "role": "user",
        "content": [
          {
            "type": "input_text",
            "text": "Please analyze the training feedback and programs from all prior turns, and write an improved transformation.\n\n**Important**:\n1. Always start by attempting to find a complete rule that solves all training examples and should generalize to the test input.\n2. If you cannot find a perfect solution, provide your best attempt at a transformation that solves as many training examples as possible - ideally more than in the best previous turn.\n3. Even if your solution doesn't solve all examples perfectly, ensure it demonstrates meaningful pattern recognition and provides reasonable outputs that minimize pixel-level errors.\n\nFinal answer:\n```python\ndef transform(grid):\n    # Your improved transformation logic here (even if partial)\n    return transformed_grid\n```"
          },
          {
            "type": "input_text",
            "text": "Training results: 1/4 examples solved, 87.0% pixel accuracy - Great progress! You're on the right track. Next, try to identify a transformation that solves more than 1 of the training examples.\n\nTraining Example 1 \u2717:\nExpected: [[7, 7, 7, 7, 7], [7, 0, 7, 7, 7], [7, 7, 7, 0, 7], [7, 0, 7, 7, 7], [7, 7, 7, 7, 7]]\nYour output: [[7, 7, 7, 7, 7], [7, 7, 7, 0, 7], [7, 0, 7, 7, 7], [7, 7, 7, 7, 7], [7, 7, 7, 7, 7]]\nPixel accuracy: 80.0%\n\nTraining Example 2 \u2717:\nExpected: [[8, 8, 8, 8, 8], [8, 0, 8, 0, 8], [8, 8, 8, 8, 8], [8, 0, 8, 0, 8], [8, 8, 8, 8, 8]]\nYour output: [[8, 8, 8, 8, 8], [8, 0, 8, 8, 8], [8, 8, 8, 0, 8], [8, 0, 8, 8, 8], [8, 8, 8, 8, 8]]\nPixel accuracy: 88.0%\n\nTraining Example 3 \u2717:\nExpected: [[6, 6, 6, 6, 6], [6, 0, 6, 0, 6], [6, 6, 6, 6, 6], [6, 0, 6, 6, 6], [6, 6, 6, 6, 6]]\nYour output: [[6, 6, 6, 6, 6], [6, 6, 6, 6, 6], [6, 0, 6, 0, 6], [6, 6, 6, 6, 6], [6, 6, 6, 6, 6]]\nPixel accuracy: 80.0%\n\nTraining Example 4 \u2713:\nExpected: [[2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 0, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]]\nYour output: [[2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 0, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]]\n\n"
          },
          {
            "type": "input_image",
            "image_url": "data:image/png;base64,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"
          },
          {
            "type": "input_text",
            "text": "Above is a visual comparison of expected vs predicted outputs for each training example. Green circles indicate correct solutions, red circles show errors. Use this visual feedback along with the textual analysis to improve your approach."
          }
        ]
      },
      {
        "type": "message",
        "role": "assistant",
        "content": [
          "The main recurring error is the positions of the black pixels (holes) inside the 5x5 output grid\u2014which are often misplaced by the simple nearest neighbor resampling, especially in Training Examples 1, 2, and 3. The hole pattern in outputs is quite specific and symmetrical, not fully captured by nearest neighbor resampling of the input bounding box.\n\n**Hypothesis / Pattern:**\n\n- The output 5x5 grid corresponds exactly to the **shape of the largest colored region** but with holes only in a few very specific fixed cells.\n- The holes correspond to black pixels (zeros) in the input but in fixed relative positions.\n- The position of holes resembles **the largest connected component's mask's contour of disconnected zero cells inside it**.\n- Overall, the output captures a 5x5 shape with:\n  - Border cells all colored (no holes on borders except some specific inside).\n  - Some inner cells are black (holes) following a fixed pattern.\n\n**Improved approach:**\n\n1. Extract the largest colored connected component and its bounding box.\n2. Extract a boolean mask of the largest component inside the bounding box.\n3. Rescale the mask to 5x5 using **max pooling** on 2x2 blocks: \n   - Resulting in a binary 5x5 mask representing where the color is present.\n4. Identify holes: any zero pixels fully enclosed by the component inside bounding box (holes fully surrounded).\n   - Create an internal mask of holes inside the component (zeros surrounded by color).\n   - Rescale holes using **max pooling (or any zero within block means hole)** to 5x5.\n5. The final output 5x5 grid uses:\n   - Color where rescaled mask = 1\n   - Hole (0) where rescaled hole mask = 1\n6. This pooling approach maintains hole shapes and their positions more robustly.\n\nThis will better preserve hole shapes and positions compared to nearest neighbor sampling.\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n    from collections import deque\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def neighbors(r, c):\n        for nr, nc in ((r-1, c), (r+1, c), (r, c-1), (r, c+1)):\n            if 0 <= nr < rows and 0 <= nc < cols:\n                yield nr, nc\n\n    components = []\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                q = deque([(r, c)])\n                visited[r, c] = True\n                cells = []\n                while q:\n                    rr, cc = q.popleft()\n                    cells.append((rr, cc))\n                    for nr, nc in neighbors(rr, cc):\n                        if not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                components.append((len(cells), color, cells))\n\n    if not components:\n        return [[0] * 5 for _ in range(5)]\n\n    components.sort(key=lambda x: x[0], reverse=True)\n    size, color, cells = components[0]\n\n    rmin = min(r for r, c in cells)\n    rmax = max(r for r, c in cells)\n    cmin = min(c for r, c in cells)\n    cmax = max(c for r, c in cells)\n\n    block = grid[rmin:rmax + 1, cmin:cmax + 1]\n    h_in, w_in = block.shape\n\n    # Create mask of component color presence (1) and holes (0)\n    comp_mask = (block == color).astype(int)\n    zero_mask = (block == 0).astype(int)\n\n    # Detect internal holes fully enclosed by component (zero pixels surrounded by color)\n    # We'll use flood fill from border zeros to find external zeros, rest zeros inside are holes\n    external_zeros = np.zeros_like(zero_mask, dtype=bool)\n    from collections import deque\n    queue = deque()\n\n    # Add border zeros positions\n    for i in range(h_in):\n        for j in [0, w_in -1]:\n            if zero_mask[i,j]:\n                queue.append((i,j))\n                external_zeros[i,j] = True\n    for j in range(w_in):\n        for i in [0, h_in -1]:\n            if zero_mask[i,j]:\n                queue.append((i,j))\n                external_zeros[i,j] = True\n\n    # Flood fill external zeros\n    while queue:\n        x, y = queue.popleft()\n        for nx, ny in ((x-1,y), (x+1,y), (x,y-1), (x,y+1)):\n            if 0 <= nx < h_in and 0 <= ny < w_in:\n                if zero_mask[nx, ny] and not external_zeros[nx, ny]:\n                    external_zeros[nx, ny] = True\n                    queue.append((nx, ny))\n\n    # Holes mask are zeros not reachable from outside\n    holes_mask = zero_mask.astype(bool) & (~external_zeros)\n\n    def max_pool_2d(arr, out_h=5, out_w=5):\n        in_h, in_w = arr.shape\n        out_arr = np.zeros((out_h, out_w), dtype=int)\n        for i in range(out_h):\n            r0 = int(i * in_h / out_h)\n            r1 = int((i + 1) * in_h / out_h)\n            if r1 == r0:\n                r1 = min(r0+1, in_h)\n            for j in range(out_w):\n                c0 = int(j * in_w / out_w)\n                c1 = int((j + 1) * in_w / out_w)\n                if c1 == c0:\n                    c1 = min(c0+1, in_w)\n                block_slice = arr[r0:r1, c0:c1]\n                out_arr[i,j] = 1 if np.any(block_slice) else 0\n        return out_arr\n\n    comp_down = max_pool_2d(comp_mask)\n    holes_down = max_pool_2d(holes_mask.astype(int))\n\n    # Compose final output: where holes present \u2192 0, else color if comp_down present\n    output = np.where(holes_down==1, 0, comp_down * color)\n\n    return output.tolist()\n```"
        ]
      }
    ],
    "all_responses": [
      {
        "id": "resp_686fb3664d1c81a0ac42095570b1530a0309873a52022234",
        "model": "gpt-4.1-mini-2025-04-14",
        "usage": {
          "input_tokens": 5509,
          "output_tokens": 1071,
          "total_tokens": 6580
        },
        "output": [
          {
            "type": "message",
            "content": [
              "Analysis:\n\nFrom the textual training examples and the visuals:\n\n- Each training input is a larger grid with 4 scattered colored squares (color 6,7,8,2 in examples).\n- Each colored square is 6x6 in size visually with several internal black dots.\n- Output for each training example is a 5x5 grid with the same color as the input squares.\n- The 5x5 output seems to be extracted from the top-left 5x5 portion of one of the input squares, or the left 5 columns and top 5 rows of a square, capturing the pattern inside that square.\n- The output pattern shows the black dots inside the square in the output.\n- Usually in training, the output captures the largest compact square block of color in the input, cropping it down to 5x5.\n- It looks like the task is to find one of the color squares, extract a 5x5 section showing the shape/pattern inside that colored square.\n\nFor the test input:\n\n- The input also shows multiple scattered color squares (color is 1).\n- The output is expected to be a 5x5 grid with that color and the pattern inside it.\n- The code should:\n   1. Find the largest connected component of a non-zero color.\n   2. Extract a 5x5 subgrid of that component (perhaps top-left 5x5 or bounding box cropped to 5x5).\n   3. Fill cells with the color or 0 according to original pattern.\n- The pattern of black dots inside the squares are preserved.\n\nImplementation plan:\n\n- Identify all non-zero connected components with the same color.\n- Choose the largest one by area.\n- Extract the bounding box of that component.\n- Crop to a 5x5 grid from the top-left corner of that bounding box in the input grid.\n- Create output 5x5 grid with:\n   - The color of that component in cells belonging to the component inside the crop.\n   - zero elsewhere.\n   - Black dots correspond to zero values inside the square (so keep original 0's as zero).\n- Return this 5x5 grid.\n\nThis aligns well with all training examples as well as the test input pattern.\n\nWe will use BFS or DFS for connected component extraction.\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n    from collections import deque\n    \n    grid = np.array(grid)\n    rows, cols = grid.shape\n    \n    # Find all connected components of nonzero colors\n    visited = np.zeros_like(grid, dtype=bool)\n    \n    def neighbors(r,c):\n        for nr,nc in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\n            if 0 <= nr < rows and 0 <= nc < cols:\n                yield nr,nc\n    \n    components = []\n    \n    for r in range(rows):\n        for c in range(cols):\n            if grid[r,c] != 0 and not visited[r,c]:\n                color = grid[r,c]\n                q = deque([(r,c)])\n                visited[r,c] = True\n                cells = []\n                while q:\n                    rr,cc = q.popleft()\n                    cells.append((rr,cc))\n                    for nr,nc in neighbors(rr,cc):\n                        if not visited[nr,nc] and grid[nr,nc] == color:\n                            visited[nr,nc] = True\n                            q.append((nr,nc))\n                components.append((len(cells), color, cells))\n    \n    if not components:\n        # No nonzero colors, output empty 5x5 zero grid\n        return [[0]*5 for _ in range(5)]\n    \n    # Choose largest component by size\n    components.sort(reverse=True, key=lambda x: x[0])\n    size, color, cells = components[0]\n    \n    # Get bounding box of largest component\n    rows_c = [r for r,c in cells]\n    cols_c = [c for r,c in cells]\n    rmin, rmax = min(rows_c), max(rows_c)\n    cmin, cmax = min(cols_c), max(cols_c)\n    \n    # Extract 5x5 subgrid from top-left corner of bounding box, or as fits\n    # The bounding box can be bigger than 5x5, crop accordingly\n    r_end = min(rmin+5, rows)\n    c_end = min(cmin+5, cols)\n    \n    subgrid = grid[rmin:r_end, cmin:c_end]\n    \n    # Create output 5x5 initially zeros\n    out = np.zeros((5,5), dtype=int)\n    \n    # Place the pattern into output\n    # For each cell in subgrid:\n    # If cell == color => place color\n    # else => 0 (black dot inside square)\n    for rr in range(subgrid.shape[0]):\n        for cc in range(subgrid.shape[1]):\n            if subgrid[rr, cc] == color:\n                out[rr, cc] = color\n            else:\n                out[rr, cc] = 0\n                \n    return out.tolist()\n```\n"
            ]
          }
        ]
      },
      {
        "id": "resp_686fb37b131881a08a2a0b5544c9daec0309873a52022234",
        "model": "gpt-4.1-mini-2025-04-14",
        "usage": {
          "input_tokens": 7857,
          "output_tokens": 873,
          "total_tokens": 8730
        },
        "output": [
          {
            "type": "message",
            "content": [
              "The main error in the previous attempt is that the positions of the zero pixels inside the colored square (the \"holes\") are misplaced. The output black pixels in training examples 1-3 don't just come from the input zeros inside the bounding box. Instead, the pattern appears to:\n\n- Preserve the shape and color of the biggest colored square\n- Place zeros (black dots) exactly where the input colored square had holes\n- These holes have precise positions relative to the square (like symmetrical holes)\n\nBy examining the training examples in detail:\n\n- The output is always a 5x5 grid\n- The pattern is the internal layout of one colored block reduced (not just cropped), but shifted/scaled down to 5x5.\n- The holes tend to be positioned symmetrically, often in consistent positions in the 5x5.\n- There seem to be two main \"types\" of internal hole patterns seen in the training examples, frequently centered in a 5x5 grid.\n  \nBased on these, my improved approach is:\n\n1. Extract the largest connected colored component as before.\n2. Get its bounding box.\n3. Resize that bounding box to 5x5, preserving the relative hole positions. Use nearest-neighbor downsampling.\n4. In the resized version, replace colored pixels by the component's color, and zeros remain zeros.\n\nThis resizing approach should capture the holes and shape proportionally and recreate the exact layout within a 5x5 frame.\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n    from collections import deque\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n\n    # Find largest connected component of a single color (nonzero)\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def neighbors(r,c):\n        for nr,nc in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\n            if 0 <= nr < rows and 0 <= nc < cols:\n                yield nr,nc\n\n    components = []\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r,c] != 0 and not visited[r,c]:\n                color = grid[r,c]\n                q = deque([(r,c)])\n                visited[r,c] = True\n                cells = []\n                while q:\n                    rr,cc = q.popleft()\n                    cells.append((rr,cc))\n                    for nr,nc in neighbors(rr,cc):\n                        if not visited[nr,nc] and grid[nr,nc] == color:\n                            visited[nr,nc] = True\n                            q.append((nr,nc))\n                components.append((len(cells), color, cells))\n\n    if not components:\n        # no colored component -> 5x5 zeros\n        return [[0]*5 for _ in range(5)]\n\n    # Largest colored component\n    components.sort(reverse=True, key=lambda x: x[0])\n    size, color, cells = components[0]\n\n    rows_c = [r for r,c in cells]\n    cols_c = [c for r,c in cells]\n    rmin, rmax = min(rows_c), max(rows_c)\n    cmin, cmax = min(cols_c), max(cols_c)\n\n    block = grid[rmin:rmax+1, cmin:cmax+1]\n\n    # Resize block to 5x5 using nearest neighbor sampling\n    # Define a function for nearest-neighbor downsampling to 5x5\n    def resize_to_5x5(arr):\n        h, w = arr.shape\n        result = np.zeros((5,5), dtype=int)\n        for i in range(5):\n            for j in range(5):\n                # Map output i,j to input coordinates\n                x = int(round(i * (h-1) / 4))\n                y = int(round(j * (w-1) / 4))\n                result[i,j] = arr[x,y]\n        return result\n\n    resized = resize_to_5x5(block)\n\n    # Map nonzero pixels to color, zeros remain 0\n    output = np.where(resized != 0, color, 0)\n\n    return output.tolist()\n```"
            ]
          }
        ]
      },
      {
        "id": "resp_686fb389f11081a094e9b48f939ad9020309873a52022234",
        "model": "gpt-4.1-mini-2025-04-14",
        "usage": {
          "input_tokens": 10007,
          "output_tokens": 1095,
          "total_tokens": 11102
        },
        "output": [
          {
            "type": "message",
            "content": [
              "The key persistent errors are about the exact positions of the zero (black) pixels inside the 5x5 output square \u2014 they are shifted or misplaced compared to expected outputs.\n\nFrom analyzing the feedback and the visuals:\n\n- The zeros (black pixels) are very specific patterns inside the square, often symmetric and arranged in a pattern.\n- Simply resizing the bounding box with a nearest-neighbor sampling distorts the pattern of holes and shifts them around, causing inaccuracies.\n- The 5x5 output is always the same fixed size regardless of the input square size.\n- The important pattern is the _skeleton_ or shape of holes inside the solid color square.\n- Across examples, the hole pattern resembles _positions of zeros_ inside the colored component itself, arranged in an approximate 5x5 block.\n\n**Improved hypothesis:**\n- Extract the largest colored component.\n- Compute its bounding box.\n- Within that bounding box, locate the shape of the colored block (where pixels are color) and the holes (pixels = 0).\n- From the bounding box, downsample the shape and holes _separately_ into a 5x5 grid by a simple block majority vote, preserving the hole positions more accurately.\n- Then reconstruct the 5x5 grid: colored pixels where majority of original colored points are, holes where majority are zeros.\n- This approach captures spatial info better than nearest neighbor and reduces shifts.\n- Finally, output a 5x5 grid colored by the component color with zeros marking holes.\n\nThis approach should better approximate holes in the output grid.\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n    from collections import deque\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def neighbors(r, c):\n        for nr, nc in ((r-1,c), (r+1,c), (r,c-1), (r,c+1)):\n            if 0 <= nr < rows and 0 <= nc < cols:\n                yield nr, nc\n\n    components = []\n\n    # Find largest connected component of a single nonzero color\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                q = deque([(r, c)])\n                visited[r, c] = True\n                cells = []\n                while q:\n                    rr, cc = q.popleft()\n                    cells.append((rr, cc))\n                    for nr, nc in neighbors(rr, cc):\n                        if not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                components.append((len(cells), color, cells))\n\n    if not components:\n        # no colored component\n        return [[0]*5 for _ in range(5)]\n\n    # Choose largest component\n    components.sort(key=lambda x: x[0], reverse=True)\n    size, color, cells = components[0]\n\n    rmin = min(r for r, c in cells)\n    rmax = max(r for r, c in cells)\n    cmin = min(c for r, c in cells)\n    cmax = max(c for r, c in cells)\n\n    block = grid[rmin:rmax+1, cmin:cmax+1]\n\n    h_in, w_in = block.shape\n\n    # Create two binary masks for colors and holes\n    color_mask = (block == color).astype(int)\n    hole_mask = (block == 0).astype(int)\n\n    # Downsample masks to 5x5 by block majority\n    def downsample_majority(mask):\n        out = np.zeros((5,5), dtype=int)\n        # Compute block sizes (may not divide evenly)\n        h_block_sizes = []\n        acc = 0\n        for i in range(5):\n            start = int(i * h_in / 5)\n            end = int((i+1) * h_in / 5)\n            h_block_sizes.append((start,end))\n        w_block_sizes = []\n        for j in range(5):\n            start = int(j * w_in / 5)\n            end = int((j+1) * w_in / 5)\n            w_block_sizes.append((start,end))\n        for i in range(5):\n            for j in range(5):\n                rstart, rend = h_block_sizes[i]\n                cstart, cend = w_block_sizes[j]\n                block_slice = mask[rstart:rend, cstart:cend]\n                if block_slice.size == 0:\n                    out[i,j] = 0\n                else:\n                    # majority vote\n                    val = 1 if block_slice.sum() >= (block_slice.size / 2) else 0\n                    out[i,j] = val\n        return out\n\n    color_ds = downsample_majority(color_mask)\n    hole_ds = downsample_majority(hole_mask)\n\n    # The final output: where hole_ds is 1 -> 0, else color\n    output = np.where(hole_ds == 1, 0, color_ds * color)\n\n    return output.tolist()\n```\n"
            ]
          }
        ]
      },
      {
        "id": "resp_686fb39a496881a0a15586218531df840309873a52022234",
        "model": "gpt-4.1-mini-2025-04-14",
        "usage": {
          "input_tokens": 12379,
          "output_tokens": 922,
          "total_tokens": 13301
        },
        "output": [
          {
            "type": "message",
            "content": [
              "The main error remains the positions of the black (zero) pixels inside the 5x5 output grid, which are being misplaced by the simplistic downsampling approach. Analyzing the feedback and examples indicates these black pixels often match certain fixed patterns relative to the square, especially related to the internal shape and holes.\n\nTo better capture this, I propose a refined approach where:\n\n- Extract the largest colored connected component and its bounding box.\n- Instead of direct downsampling, split the bounding box into a fixed 5\u00d75 grid of blocks.\n- Within each block, check if that block contains *only* the color pixels or if it contains any holes (zeros).\n- Output cell in 5\u00d75 grid is zero if the corresponding block contains any zero pixels (hole), else the block is colored.\n- This avoids averaging or majority voting which can blur details and cause shifts.\n- This also corresponds well to the visual feedback: holes only appear as zero if there is any hole pixel in that area.\n\nThis solution should be more faithful to the original hole pattern and avoids convolutional smoothing artifacts.\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n    from collections import deque\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def neighbors(r, c):\n        for nr, nc in ((r-1,c), (r+1,c), (r,c-1), (r,c+1)):\n            if 0 <= nr < rows and 0 <= nc < cols:\n                yield nr, nc\n\n    components = []\n\n    # Find largest connected component with a single nonzero color\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                q = deque([(r, c)])\n                visited[r, c] = True\n                cells = []\n                while q:\n                    rr, cc = q.popleft()\n                    cells.append((rr, cc))\n                    for nr, nc in neighbors(rr, cc):\n                        if not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                components.append((len(cells), color, cells))\n\n    if not components:\n        # No colored component found -> return empty 5x5\n        return [[0]*5 for _ in range(5)]\n\n    components.sort(key=lambda x: x[0], reverse=True)\n    size, color, cells = components[0]\n\n    rmin = min(r for r, c in cells)\n    rmax = max(r for r, c in cells)\n    cmin = min(c for r, c in cells)\n    cmax = max(c for r, c in cells)\n\n    block = grid[rmin:rmax+1, cmin:cmax+1]\n    h_in, w_in = block.shape\n\n    output = np.zeros((5, 5), dtype=int)\n\n    # For each cell in output 5x5 grid, map to corresponding block in input\n    for i in range(5):\n        r_start = int(i * h_in / 5)\n        r_end = int((i + 1) * h_in / 5)\n        if r_end == r_start:\n            r_end = min(r_start + 1, h_in)  # Ensure at least one row\n\n        for j in range(5):\n            c_start = int(j * w_in / 5)\n            c_end = int((j + 1) * w_in / 5)\n            if c_end == c_start:\n                c_end = min(c_start + 1, w_in)  # Ensure at least one col\n\n            subblock = block[r_start:r_end, c_start:c_end]\n\n            # If any zero in subblock => hole(0), else color\n            if np.any(subblock == 0):\n                output[i, j] = 0\n            else:\n                # Should be all color pixels or zeros only if holes\n                # If subblock has any color pixels, paint with that color\n                if np.any(subblock == color):\n                    output[i, j] = color\n                else:\n                    output[i, j] = 0  # Default safe fallback\n\n    return output.tolist()\n```"
            ]
          }
        ]
      },
      {
        "id": "resp_686fb3a9642881a0a56ee4cf89c476810309873a52022234",
        "model": "gpt-4.1-mini-2025-04-14",
        "usage": {
          "input_tokens": 14578,
          "output_tokens": 1013,
          "total_tokens": 15591
        },
        "output": [
          {
            "type": "message",
            "content": [
              "The main recurrent error is that some zero pixels (holes) occur in positions like (1,1), (1,3), (3,1) etc inside the 5x5 output but sometimes get \"shifted\" or misplaced by our block check method, especially in the first three examples. The feedback images suggest the hole pixels are consistently arranged in symmetrical fixed locations relative to the 5x5 grid, not simply from the spatial distribution of zeros in the bounding box.\n\nThese holes seem to correspond exactly to certain cells inside the 5x5 outputs that are zero, and these hole positions correspond to zero pixels inside the input colored square.\n\nSo a better heuristic is:\n\n- Identify the largest colored connected component and crop its bounding box.\n- Since the input squares are generally around 6\u00d76, extract a direct 6\u00d76 patch from the bounding box (cropping to exactly 6\u00d76 if possible).\n- Then, convert this 6\u00d76 patch into a 5\u00d75 output by:\n   - Interpreting the 6\u00d76 as a large square with 5 \"cells\" in each dimension by skipping the last row and column or averaging accordingly.\n   - For each output cell, set zero if there is any zero (hole) in the corresponding 2\u00d72 input pixels patch (the 6\u00d76 can be roughly seen as 5\u00d75 of 2\u00d72 areas overlapping), else the output cell gets the input color.\n- This approach mimics how small holes are preserved by a majority or any-zero logic but more precisely respects the input pattern's shape.\n- If bounding box smaller than 6\u00d76, pad it accordingly before downsampling.\n\nThis tries to more exactly capture the hole pattern shown in the examples.\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n    from collections import deque\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def neighbors(r, c):\n        for nr, nc in ((r-1,c), (r+1,c), (r,c-1), (r,c+1)):\n            if 0 <= nr < rows and 0 <= nc < cols:\n                yield nr, nc\n\n    components = []\n\n    # Find largest connected component with single nonzero color\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r,c] != 0 and not visited[r,c]:\n                color = grid[r,c]\n                q = deque([(r,c)])\n                visited[r,c] = True\n                cells = []\n                while q:\n                    rr, cc = q.popleft()\n                    cells.append((rr, cc))\n                    for nr, nc in neighbors(rr, nc):\n                        if not visited[nr,nc] and grid[nr,nc] == color:\n                            visited[nr,nc] = True\n                            q.append((nr,nc))\n                components.append((len(cells), color, cells))\n\n    if not components:\n        return [[0]*5 for _ in range(5)]\n\n    components.sort(key=lambda x: x[0], reverse=True)\n    size, color, cells = components[0]\n\n    rmin = min(r for r,c in cells)\n    rmax = max(r for r,c in cells)\n    cmin = min(c for r,c in cells)\n    cmax = max(c for r,c in cells)\n\n    block = grid[rmin:rmax+1, cmin:cmax+1]\n    h_in, w_in = block.shape\n\n    # Pad to at least 6x6 with color pixels (if smaller)\n    target = 6\n    if h_in < target or w_in < target:\n        padded = np.full((max(h_in,target), max(w_in,target)), fill_value=color, dtype=int)\n        padded[:h_in, :w_in] = block\n        block = padded\n        h_in, w_in = block.shape\n\n    # Now block is at least 6x6; crop if bigger (to 6x6 top-left)\n    block = block[:target, :target]\n    h_in, w_in = block.shape  # now 6,6\n\n    output = np.zeros((5,5), dtype=int)\n\n    # For each output cell, check corresponding 2x2 input cells for holes (0)\n    # If any zero in 2x2 block, output is 0 else color\n    for i in range(5):\n        for j in range(5):\n            # input cells from (i,i+1),(j,j+1)\n            subblock = block[i:i+2, j:j+2]\n            if np.any(subblock == 0):\n                output[i,j] = 0\n            else:\n                output[i,j] = color\n\n    return output.tolist()\n```\n"
            ]
          }
        ]
      },
      {
        "id": "resp_686fb3bd337081a0ba1c7555b053a2d50309873a52022234",
        "model": "gpt-4.1-mini-2025-04-14",
        "usage": {
          "input_tokens": 16985,
          "output_tokens": 837,
          "total_tokens": 17822
        },
        "output": [
          {
            "type": "message",
            "content": [
              "The error traceback shows there is a typo in the `neighbors` iteration inside the BFS loop: the variable name `nc` used in the `neighbors(rr, nc)` call inside a loop is shadowed and incorrectly reused, causing an \"UnboundLocalError\".\n\nSpecifically in the line:\n```python\nfor nr, nc in neighbors(rr, nc):\n```\n`nc` is used as the loop variable and as the argument, which is invalid because `nc` is not defined at that point.\n\nThe correct variable should be `cc` (the current column variable name in the BFS loop) in place of the second argument.\n\nFixing this variable name resolves the error.\n\n---\n\nBesides this bug fix, the previous approach was a solid attempt to capture the exact hole pattern by splitting the largest component bounding box into 5x5 by 2x2 blocks and mapping holes accurately.\n\nI will fix the variable name bug and keep the rest of the logic unchanged.\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n    from collections import deque\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def neighbors(r, c):\n        for nr, nc in ((r-1,c), (r+1,c), (r,c-1), (r,c+1)):\n            if 0 <= nr < rows and 0 <= nc < cols:\n                yield nr, nc\n\n    components = []\n\n    # Find largest connected component with single nonzero color\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                q = deque([(r, c)])\n                visited[r, c] = True\n                cells = []\n                while q:\n                    rr, cc = q.popleft()\n                    cells.append((rr, cc))\n                    for nr, nc in neighbors(rr, cc):\n                        if not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                components.append((len(cells), color, cells))\n\n    if not components:\n        # No colored component found, output empty 5x5 grid\n        return [[0] * 5 for _ in range(5)]\n\n    # Largest component\n    components.sort(key=lambda x: x[0], reverse=True)\n    size, color, cells = components[0]\n\n    rmin = min(r for r, c in cells)\n    rmax = max(r for r, c in cells)\n    cmin = min(c for r, c in cells)\n    cmax = max(c for r, c in cells)\n\n    block = grid[rmin:rmax + 1, cmin:cmax + 1]\n    h_in, w_in = block.shape\n\n    # Pad to at least 6x6 with color pixels if smaller\n    target = 6\n    if h_in < target or w_in < target:\n        padded = np.full((max(h_in, target), max(w_in, target)), fill_value=color, dtype=int)\n        padded[:h_in, :w_in] = block\n        block = padded\n        h_in, w_in = block.shape\n\n    # Crop to 6x6 top-left\n    block = block[:target, :target]\n    h_in, w_in = block.shape  # now 6x6\n\n    output = np.zeros((5, 5), dtype=int)\n\n    # For each output cell corresponding to 2x2 input cells check holes\n    for i in range(5):\n        for j in range(5):\n            subblock = block[i:i + 2, j:j + 2]\n            if np.any(subblock == 0):\n                output[i, j] = 0\n            else:\n                output[i, j] = color\n\n    return output.tolist()\n```"
            ]
          }
        ]
      },
      {
        "id": "resp_686fb3cb2f3481a0819c2bd6377246fa0309873a52022234",
        "model": "gpt-4.1-mini-2025-04-14",
        "usage": {
          "input_tokens": 19109,
          "output_tokens": 887,
          "total_tokens": 19996
        },
        "output": [
          {
            "type": "message",
            "content": [
              "After analyzing the prior attempts and the recent pixel accuracy feedback with the accompanying images, I observe these issues:\n\n- The zero pixels (holes) are mostly misrepresented or clustered incorrectly in the output.\n- There is a clear mismatch in spatial layout: the black holes are not in the right positions relative to the colored cells.\n- Previous attempts with direct downsampling or block-wise checking don't preserve the shape properly.\n- The output is consistently 5x5, so the solution should precisely map the original shape inside the bounding box of the biggest colored component to a 5x5 pattern that faithfully represents holes.\n\n**Key insights:**\n\n- The input colored shapes are generally 6x6 blocks with black holes inside.\n- The holes occupy specific pixels, and these pixels correspond well to a known 5x5 pattern.\n- Instead of block majority or nearest neighbor, a _nearest neighbor scaling_ from the cropped bounding box to 5x5 output, while preserving exact pixel values (color or zero), is likely better.\n- That is, rescale input bounding box area of the component to exactly 5x5, mapping each output pixel to exactly one input pixel using nearest neighbor, preserving colors and holes exactly.\n\n**Additional details:**\n\n- Before rescaling, crop the bounding box of the largest connected component of color.\n- Perform nearest neighbor rescaling to 5x5 on this bounding box.\n- For rescaling, use nearest-neighbor sampling indices calculated as round(i * (h_in - 1)/4) and round(j * (w_in - 1)/4).\n- Map resampled pixels to the color or zero as is.\n- Return the 5x5 grid.\n\nThis approach should minimize holes distortion and spatial shifts.\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n    from collections import deque\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def neighbors(r, c):\n        for nr, nc in ((r-1,c), (r+1,c), (r,c-1), (r,c+1)):\n            if 0 <= nr < rows and 0 <= nc < cols:\n                yield nr, nc\n\n    components = []\n    # Identify largest connected component of one color (nonzero)\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                q = deque([(r, c)])\n                visited[r, c] = True\n                cells = []\n                while q:\n                    rr, cc = q.popleft()\n                    cells.append((rr, cc))\n                    for nr, nc in neighbors(rr, cc):\n                        if not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                components.append((len(cells), color, cells))\n\n    if not components:\n        return [[0]*5 for _ in range(5)]\n\n    # Choose largest component\n    components.sort(key=lambda x: x[0], reverse=True)\n    size, color, cells = components[0]\n\n    rmin = min(r for r, c in cells)\n    rmax = max(r for r, c in cells)\n    cmin = min(c for r, c in cells)\n    cmax = max(c for r, c in cells)\n\n    block = grid[rmin:rmax+1, cmin:cmax+1]\n    h_in, w_in = block.shape\n\n    # Nearest neighbor rescale block to 5x5 output\n    output = np.zeros((5, 5), dtype=int)\n    for i in range(5):\n        for j in range(5):\n            ri = int(round(i * (h_in - 1) / 4))\n            cj = int(round(j * (w_in - 1) / 4))\n            val = block[ri, cj]\n            if val == color:\n                output[i, j] = color\n            else:\n                # Zero or any other color (black holes are zeros)\n                output[i, j] = 0\n\n    return output.tolist()\n```"
            ]
          }
        ]
      },
      {
        "id": "resp_686fb3da6a4481a0be659969f20021240309873a52022234",
        "model": "gpt-4.1-mini-2025-04-14",
        "usage": {
          "input_tokens": 21273,
          "output_tokens": 1401,
          "total_tokens": 22674
        },
        "output": [
          {
            "type": "message",
            "content": [
              "The main recurring error is the positions of the black pixels (holes) inside the 5x5 output grid\u2014which are often misplaced by the simple nearest neighbor resampling, especially in Training Examples 1, 2, and 3. The hole pattern in outputs is quite specific and symmetrical, not fully captured by nearest neighbor resampling of the input bounding box.\n\n**Hypothesis / Pattern:**\n\n- The output 5x5 grid corresponds exactly to the **shape of the largest colored region** but with holes only in a few very specific fixed cells.\n- The holes correspond to black pixels (zeros) in the input but in fixed relative positions.\n- The position of holes resembles **the largest connected component's mask's contour of disconnected zero cells inside it**.\n- Overall, the output captures a 5x5 shape with:\n  - Border cells all colored (no holes on borders except some specific inside).\n  - Some inner cells are black (holes) following a fixed pattern.\n\n**Improved approach:**\n\n1. Extract the largest colored connected component and its bounding box.\n2. Extract a boolean mask of the largest component inside the bounding box.\n3. Rescale the mask to 5x5 using **max pooling** on 2x2 blocks: \n   - Resulting in a binary 5x5 mask representing where the color is present.\n4. Identify holes: any zero pixels fully enclosed by the component inside bounding box (holes fully surrounded).\n   - Create an internal mask of holes inside the component (zeros surrounded by color).\n   - Rescale holes using **max pooling (or any zero within block means hole)** to 5x5.\n5. The final output 5x5 grid uses:\n   - Color where rescaled mask = 1\n   - Hole (0) where rescaled hole mask = 1\n6. This pooling approach maintains hole shapes and their positions more robustly.\n\nThis will better preserve hole shapes and positions compared to nearest neighbor sampling.\n\n---\n\nFinal answer:\n```python\ndef transform(grid):\n    import numpy as np\n    from collections import deque\n\n    grid = np.array(grid)\n    rows, cols = grid.shape\n\n    visited = np.zeros_like(grid, dtype=bool)\n\n    def neighbors(r, c):\n        for nr, nc in ((r-1, c), (r+1, c), (r, c-1), (r, c+1)):\n            if 0 <= nr < rows and 0 <= nc < cols:\n                yield nr, nc\n\n    components = []\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] != 0 and not visited[r, c]:\n                color = grid[r, c]\n                q = deque([(r, c)])\n                visited[r, c] = True\n                cells = []\n                while q:\n                    rr, cc = q.popleft()\n                    cells.append((rr, cc))\n                    for nr, nc in neighbors(rr, cc):\n                        if not visited[nr, nc] and grid[nr, nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                components.append((len(cells), color, cells))\n\n    if not components:\n        return [[0] * 5 for _ in range(5)]\n\n    components.sort(key=lambda x: x[0], reverse=True)\n    size, color, cells = components[0]\n\n    rmin = min(r for r, c in cells)\n    rmax = max(r for r, c in cells)\n    cmin = min(c for r, c in cells)\n    cmax = max(c for r, c in cells)\n\n    block = grid[rmin:rmax + 1, cmin:cmax + 1]\n    h_in, w_in = block.shape\n\n    # Create mask of component color presence (1) and holes (0)\n    comp_mask = (block == color).astype(int)\n    zero_mask = (block == 0).astype(int)\n\n    # Detect internal holes fully enclosed by component (zero pixels surrounded by color)\n    # We'll use flood fill from border zeros to find external zeros, rest zeros inside are holes\n    external_zeros = np.zeros_like(zero_mask, dtype=bool)\n    from collections import deque\n    queue = deque()\n\n    # Add border zeros positions\n    for i in range(h_in):\n        for j in [0, w_in -1]:\n            if zero_mask[i,j]:\n                queue.append((i,j))\n                external_zeros[i,j] = True\n    for j in range(w_in):\n        for i in [0, h_in -1]:\n            if zero_mask[i,j]:\n                queue.append((i,j))\n                external_zeros[i,j] = True\n\n    # Flood fill external zeros\n    while queue:\n        x, y = queue.popleft()\n        for nx, ny in ((x-1,y), (x+1,y), (x,y-1), (x,y+1)):\n            if 0 <= nx < h_in and 0 <= ny < w_in:\n                if zero_mask[nx, ny] and not external_zeros[nx, ny]:\n                    external_zeros[nx, ny] = True\n                    queue.append((nx, ny))\n\n    # Holes mask are zeros not reachable from outside\n    holes_mask = zero_mask.astype(bool) & (~external_zeros)\n\n    def max_pool_2d(arr, out_h=5, out_w=5):\n        in_h, in_w = arr.shape\n        out_arr = np.zeros((out_h, out_w), dtype=int)\n        for i in range(out_h):\n            r0 = int(i * in_h / out_h)\n            r1 = int((i + 1) * in_h / out_h)\n            if r1 == r0:\n                r1 = min(r0+1, in_h)\n            for j in range(out_w):\n                c0 = int(j * in_w / out_w)\n                c1 = int((j + 1) * in_w / out_w)\n                if c1 == c0:\n                    c1 = min(c0+1, in_w)\n                block_slice = arr[r0:r1, c0:c1]\n                out_arr[i,j] = 1 if np.any(block_slice) else 0\n        return out_arr\n\n    comp_down = max_pool_2d(comp_mask)\n    holes_down = max_pool_2d(holes_mask.astype(int))\n\n    # Compose final output: where holes present \u2192 0, else color if comp_down present\n    output = np.where(holes_down==1, 0, comp_down * color)\n\n    return output.tolist()\n```"
            ]
          }
        ]
      }
    ]
  }
}